quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"utput = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty:; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals. We remind the reader that the types of functions that can be used with this method is limited to:; ['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil'; , 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1'; , 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma'; , 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p'; , 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']. Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; >>> H = [H0, [H1, '9 * exp(-(t / 5.) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:11782,depend,dependent,11782,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"val [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:5615,depend,dependent,5615,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,1,['depend'],['dependent']
Integrability,"value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:22634,message,message,22634,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,4,['message'],['message']
Integrability,"value; return self._isherm. if self.dims[0] != self.dims[1]:; self._isherm = False; else:; data = self.data; h = np.abs((data.transpose().conj() - data).data); self._isherm = False if np.any(h > settings.atol) else True. return self._isherm. @isherm.setter; def isherm(self, isherm):; self._isherm = isherm. @property; def type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:46059,depend,dependent,46059,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['depend'],['dependent']
Integrability,"value[, section]); Add value to count. add_timing(self, key, value[, section]); Add value to timing. add_message(self, key, value[, section, sep]); Add value to message. report:; Output the statistics report to console or file. add_count(self, key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:44176,message,message,44176,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['message'],['message']
Integrability,"ve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object at 0x2b226247fbe0>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorte",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:68550,depend,dependent,68550,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not isinstance(sso.dW_factors, list):; sso.dW_factors = [1] * len(sso.sc_ops); elif len(sso.dW_factors) != len(sso.sc_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). sso.solver_obj = PcSSESolver; sso.solver_name = ""photocurrent_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:31575,depend,depend,31575,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['depend'],['depend']
Integrability,"veloper tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’. Setup Using Macports¶; On the Mac OS, we recommended that you install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via; sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel. Optional, but highly recommended ports include; sudo port install vtk5 +python27 #used for the Bloch3d class; sudo port install py27-mayavi #used for the Bloch3d class. Now, we want to tell OSX which Python and iPython we are going to use; sudo port select python python34; sudo port select ipython ipython34. To install QuTiP from Macports, run; sudo port install py-qutip. Note; The next step is optional, but is necessary if you plan to use the string (Cython) based time-dependent format. See Solving Problems with Time-dependent Hamiltonians. Finally, we want to set the macports compiler to the vanilla GCC version. From the command line type:; port select gcc. which will bring up a list of installed compilers, such as:; Available versions for gcc:; apple-gcc42; gcc42; llvm-gcc42; mp-gcc47; none (active). We want to set the the compiler to the gcc4x compiler, where x is the highest number available, in this case mp-gcc47 (the “mp-” does not matter). To do this type:; sudo port select gcc mp-gcc47. Running port select again should give:; Available versions for gcc:; apple-gcc42; gcc42; llvm-gcc42; mp-gcc47 (active); none. Installing QuTiP via Macports will take a long time as each of the QuTiP dependencies is build from source code. The advantage is that all dependencies are resolved automatically, and the result should be a consistent build. Setup via SciPy Superpack¶; A second option is to install the required Python packages using the SciPy Superpack. Further information on installing the superp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:7154,depend,dependent,7154,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['depend'],['dependent']
Integrability,"vely; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:5801,depend,dependent,5801,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,2,['depend'],['dependent']
Integrability,"ven this decomposition of the initial state in the Floquet states we can easily evaluate the wavefunction that is the solution to (5) at an arbitrary time \(t\) using the function qutip.floquet.floquet_wavefunction_t; In [30]: t = 10 * np.random.rand(). In [31]: psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args). In [32]: psi_t; Out[32]: ; <2x1 sparse matrix of type '<class 'numpy.complex128'>'; 	with 2 stored elements in Compressed Sparse Row format>. The following example illustrates how to use the functions introduced above to calculate and plot the time-evolution of (5).; from qutip import *; from scipy import *. delta = 0.2 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.5 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmaz(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html:12065,depend,dependent,12065,docs/4.4/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"ver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html:1432,integrat,integration,1432,docs/4.5/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html,2,"['depend', 'integrat']","['dependent', 'integration']"
Integrability,"ver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_mesolve""); return photocurrent_mesolve(H, rho0, times, c_ops=c_ops, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:18691,depend,depend,18691,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,4,['depend'],['depend']
Integrability,"vers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used lik",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:23040,depend,dependent,23040,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"w ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 20",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide.html:2526,depend,dependent,2526,docs/3.0.1/guide/guide.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide.html,1,['depend'],['dependent']
Integrability,"w ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 20",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide.html:2464,depend,dependent,2464,docs/3.0.0/guide/guide.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html,1,['depend'],['dependent']
Integrability,"wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to eva",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:74193,depend,dependence,74193,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['depend'],['dependence']
Integrability,"wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:97670,depend,dependence,97670,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['depend'],['dependence']
Integrability,"ways hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11733,depend,dependent,11733,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:11824,depend,dependent,11824,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:20759,depend,dependent,20759,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"which does have to be on the system drive. If this is not feasible, then it is possible to run QuTiP under Python 2.7. Windows and Python 2.7¶. Important; Running QuTiP under Python 2.7 on Windows is not recommended or supported. However, it is currently possible. There are no working conda-forge packages for Python 2.7 on Windows. You will have to install via pip or from source in Python 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” funct",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:7853,depend,depending,7853,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,4,['depend'],['depending']
Integrability,"which does have to be on the system drive. If this is not feasible, then it is possible to run QuTiP under Python 2.7. Windows and Python 2.7¶. Important; Running QuTiP under Python 2.7 on Windows is not recommended or supported. However, it is currently possible. There are no working conda-forge packages for Python 2.7 on Windows. You will have to install via pip or from source in Python 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the pytest testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:7988,depend,depending,7988,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['depend'],['depending']
Integrability,"which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:217120,wrap,wrapper,217120,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['wrap'],['wrapper']
Integrability,"which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved: :; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:109594,depend,dependencies,109594,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['depend'],['dependencies']
Integrability,"width(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:14075,message,message,14075,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['message'],['message']
Integrability,"will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (list / array) – List of times for \(t\). Must be uniformly spaced.; c_ops (list of qutip.Qobj) – Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; kwargs (dictionary) – Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output – An instance of the class qutip.solver.SolverResult. Return type:qutip.solver.SolverResult. Todo; Add checks for commuting jump operators in M",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:76285,depend,depending,76285,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['depending']
Integrability,"wser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINO",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:16085,wrap,wrap,16085,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['wrap'],['wrap']
Integrability,"x : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:70590,depend,dependent,70590,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['depend'],['dependent']
Integrability,"x. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3b90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:34184,depend,dependent,34184,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"x. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b11f65d3a90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:34246,depend,dependent,34246,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"x.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used for the coefficient; at time t.; If the coefficients are to be treated as step function, use the arguments; args = {“_step_func_coeff”: True}; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:“state_vec”:psi0, args[“state_vec”] = state as 1D np.ndarray; “state_mat”:psi0, args[“state_mat”] = state as 2D np.ndarray; “state”:psi0, args[“state”] = state as Qobj; This Qobj is the initial value. expectation values:“expect_op_n”:0, args[“expect_op_n”] = expect(e_ops[int(n)], state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:“collapse”:list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters. QobjEvo(Q_object=[], args={}, tlist=None); Q_objectarray_likeData for vector/matrix representation of the quantum object. argsdictionary that contain the arguments for; tlistarray_likeList of times at which the numpy-array coefficients are applied. Times; must be equidistant and start from 0. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementList of Qobj and the coefficients.; [(Qobj, coefficient as a function, original coefficient,. type, local arguments ), … ]. type :1: function; 2: string; 3: np.array; 4: Cubic_Spline. argsmaparguments of the coefficients. dynamics_argslistarguments that change during evolution. tlistarray_likeList ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:19129,depend,depending,19129,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['depend'],['depending']
Integrability,"x; Input quantum object or csr_matrix. Returns:; degree : array; Array of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format. sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns:; perm : array; Array of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if; necessary. Parameters:; A : sparse matrix; Input matrix. perm_type : str {‘row’, ‘column’}; Type of permutation to generate. Returns:; perm : array; Array of row or column permutations. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_.; References; I. S. Duff, K. Kaya, and B. Uc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:203564,rout,routine,203564,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,2,['rout'],"['routine', 'routines']"
Integrability,"xperimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:4095,depend,depending,4095,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,8,['depend'],['depending']
Integrability,"xponent {k}""; ); return op. def _rhs(self, L):; """""" Make the RHS for the HEOM. """"""; ops = _GatherHEOMRHS(self.ados.idx, block=L.shape[0], nhe=self._n_ados). for he_n in self.ados.labels:; op = self._grad_n(L, he_n); ops.add_op(he_n, he_n, op); for k in range(len(self.ados.dims)):; next_he = self.ados.next(he_n, k); if next_he is not None:; op = self._grad_next(he_n, k); ops.add_op(he_n, next_he, op); prev_he = self.ados.prev(he_n, k); if prev_he is not None:; op = self._grad_prev(he_n, k); ops.add_op(he_n, prev_he, op). return ops.gather(). def _configure_solver(self):; """""" Set up the solver. """"""; RHSmat = self._rhs(self._L0.data); assert isinstance(RHSmat, sp.csr_matrix). if self._is_timedep:; # In the time dependent case, we construct the parameters; # for the ODE gradient function _dsuper_list_td under the; # assumption that RHSmat(t) = RHSmat + time dependent terms; # that only affect the diagonal blocks of the RHS matrix.; # This assumption holds because only _grad_n dependents on; # the system Liovillian (and not _grad_prev or _grad_next). h_identity_mat = sp.identity(self._n_ados, format=""csr""); H_list = self.H_sys.to_list(). solver_params = [[RHSmat]]; for idx in range(1, len(H_list)):; temp_mat = sp.kron(; h_identity_mat, liouvillian(H_list[idx][0]); ); solver_params.append([temp_mat, H_list[idx][1]]). solver = scipy.integrate.ode(self._dsuper_list_td); solver.set_f_params(solver_params); else:; solver = scipy.integrate.ode(cy_ode_rhs); solver.set_f_params(RHSmat.data, RHSmat.indices, RHSmat.indptr). solver.set_integrator(; ""zvode"",; method=self.options.method,; order=self.options.order,; atol=self.options.atol,; rtol=self.options.rtol,; nsteps=self.options.nsteps,; first_step=self.options.first_step,; min_step=self.options.min_step,; max_step=self.options.max_step,; ). self._ode = solver; self.RHSmat = RHSmat. [docs] def steady_state(; self,; use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False; ):; """"""; Compute the steady state of the system.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:19445,depend,dependents,19445,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,1,['depend'],['dependents']
Integrability,"y 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package mana",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:2344,depend,dependent,2344,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['depend'],['dependent']
Integrability,"y Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:14126,depend,dependabot,14126,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['depend'],['dependabot']
Integrability,"y as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, ‘exp(-1j*w1*t)’], [H2, ‘cos(w2*t)’]],args={“w1”:1.,”w2”:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:name+”=vec”:Qobj => args[name] == state as 1D np.ndarray; name+”=mat”:Qobj => args[name] == state as 2D np.ndarray; name+”=Qobj”:Qobj => args[name] == state as Qobj; This Qobj is the initial value. expectation values:name+”=expect”:O (Qobj/QobjEvo) => args[name] == expect(O, state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:name+”=collapse”:list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters. QobjEvo(Q_object=[], args={}, tlist=None); Q_objectarray_likeData for vector/matrix representation of the quantum object. argsdictionary that contain the arguments for; tlistarray_likeList of times at which the numpy-array coefficients are applied. Times; must be equidistant and start from 0. Attributes. cteQobjConstant part of the QobjEvo. opslistList of Qobj and the coefficients.; [(Qobj, coefficient as a function, original coefficient,. type, local arguments ), … ]. type :1: function; 2: string; 3: np.array; 4: Cubic_Spline. argsmaparguments of the coefficients. tlistarray_likeList of times at which the numpy-array coefficients are applied. compil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:18397,depend,depending,18397,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['depend'],['depending']
Integrability,"y be used by advanced users. Returns:; lu (object) – Returns a SuperLU object representing iLU preconditioner.; info (dict, optional) – Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:; H (qobj or list) – Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve).; t (float or array-like) – Time or list of times for which to evaluate the propagator.; c_op_list (list) – List of qobj collapse operators.; args (list/array/dictionary) – Parameters to callback functions for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the ODE solver.; = str ('batch', 'single') (unitary_mode) – Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’).; parallel (bool {False, True}) – Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, optio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:108845,depend,dependent,108845,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"y library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5863,depend,dependent,5863,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"y setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; state_norm_func=None, dims=None):; """"""; Internal function for solving ODEs.; """""". #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y). return output. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:18889,integrat,integration,18889,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,2,['integrat'],"['integrate', 'integration']"
Integrability,"y spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:78960,depend,depending,78960,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['depending']
Integrability,"y, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output: qutip.solver.SolverResult. An instance of the class qutip.solver.SolverResult. ssesolve(H, psi0, times, sc_ops, e_ops, **kwargs)[source]¶; Solve the stochast",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:65028,depend,depending,65028,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['depend'],['depending']
Integrability,"y.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, psi0, tlist, e_ops=[], args={}, options=None,; progress_bar=None,; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (`psi0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : :class:`qutip.qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be empty list operator evolution. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:4074,depend,dependent,4074,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"y/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100, options_modes=None)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. options_modesqutip.solver.Optionsoptions for the ODE solver. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:109416,depend,dependent,109416,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:41719,integrat,integratorstr,41719,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['integrat'],['integratorstr']
Integrability,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem coll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:34724,integrat,integratorstr,34724,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['integrat'],['integratorstr']
Integrability,"ypes; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings. from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None,; progress_bar=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:4505,depend,depending,4505,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['depend'],['depending']
Integrability,"ys that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax : tuple. A tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)¶; Metho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:32237,depend,depending,32237,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['depend'],['depending']
Integrability,"ystem with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavefunction \(\Psi(t=0)\) in the Floquet states and immediately obtain the solution for arbitrary \(t\). (3)\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\hb",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:3462,depend,dependence,3462,docs/3.0.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html,3,['depend'],['dependence']
Integrability,"ystem.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. qobj: qutip.QobjThe Hamiltonian of the ideal pulse. get_ideal_qobjevo(self, dims)[source]¶; Get a QobjEvo representation of the ideal evolution. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. ideal_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution. get_noisy_qobjevo(self, dims)[source]¶; Get the QobjEvo representation of the noisy evolution. The result; can be used directly as input for the qutip solvers. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. noisy_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution and coherent noise. c_ops: list of qutip.QobjEvoA list of (time-dependent) lindbald operators. print_info(self)[source]¶; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise. property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:143155,depend,dependent,143155,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['depend'],['dependent']
Integrability,"ython 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/installation.html:8729,depend,dependencies,8729,docs/4.3/installation.html,https://qutip.org,https://qutip.org/docs/4.3/installation.html,3,"['depend', 'message']","['dependencies', 'message']"
Integrability,"ython setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Installation on MS Windows¶; We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work.; QuTiP uses dynamic compilation of C for some of its time-dependant dynamics solvers. For MS Windows users the additional challenge is the need for a ANSI C99 compliant C compiler. Unlike other platforms, no C compiler is provided with Windows by default.; It is possible to install a Windows SDK that includes a C compiler, but ANSI C99 compliance is not 100%.; The mingw-w64 project looks to help overcome this, and to some extent it is successful.; The conda-forge packages for QuTiP will also install the Mingwpy package, which uses mingw-w64.; Currently we are only able get QuTiP working with Python <= 3.4. Python >= 3.5 is compiled with a ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:6605,depend,dependencies,6605,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['depend'],['dependencies']
Integrability,"ze : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float; The time for which to evaluate the time-dependent Qobj instance. args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:; method : str {‘dense’, ‘sparse’}; Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns:; oper : qobj; Exponentiated quantum operator. Raises:; TypeError; Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:8804,depend,dependent,8804,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['depend'],['dependent']
Integrability,"} \ket{\psi} = -i H(t)\ket{\psi}\]; Note we use units where \(\hbar=1\) throughout. The solutions to Schrödinger’s equation are of the form:. \[\ket{\psi(t)} = U(t)\ket{\psi_0}\]; where \(\psi_0\) is the state of the system at \(t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [NKanej]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:4295,depend,dependent,4295,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['depend'],['dependent']
Integrability,"} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solver : str. choice of solver (me for master-equation and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec : array. An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. reverse : bool {False, True}. If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str {‘me’, ‘mc’, ‘es’}. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc corre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:83515,depend,dependent,83515,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"}, options=<qutip.solver.Options object at 0x1a2041a400>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x1a2041a3c8>)[source]¶; Calc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:100717,depend,dependent,100717,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure. Use A+trans(A); if original matrix is not symmetric or not sure. Parameters. Acsc_matrix, csr_matrixInput graph in CSC or CSR matrix format. startintStaring node for BFS traversal. Returns. orderarrayOrder in which nodes are traversed from starting node. levelsarrayLevel of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters. Aqobj, csr_matrix, csc_matrixInput quantum object or csr_matrix. Returns. degreearrayArray of integers giving the degree for each node (row). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:242160,rout,routines,242160,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['rout'],['routines']
Integrability,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters. Acsc_matrix, csr_matrixInput graph in CSC or CSR matrix format. startintStaring node for BFS traversal. Returns. orderarrayOrder in which nodes are traversed from starting node. levelsarrayLevel of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters. Aqobj, csr_matrix, csc_matrixInput quantum object or csr_matrix. Returns. degreearrayArray of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:199674,rout,routines,199674,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['rout'],['routines']
Integrability,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters:; A : csc_matrix, csr_matrix; Input graph in CSC or CSR matrix format. start : int; Staring node for BFS traversal. Returns:; order : array; Order in which nodes are traversed from starting node. levels : array; Level of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters:; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns:; degree : array; Array of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:201772,rout,routines,201772,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['rout'],['routines']
Integrability,"¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos ac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:17559,depend,dependent,17559,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['depend'],['dependent']
Integrability,"– Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:149561,depend,dependent,149561,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"– Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:158393,depend,dependent,158393,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"– Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:166152,depend,dependent,166152,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html:452,depend,dependent,452,docs/4.1/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:420,depend,dependent,420,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in parti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:420,depend,dependent,420,docs/4.3/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html:489,depend,dependent,489,docs/4.4/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html:473,depend,dependent,473,docs/4.5/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Permutational Invariance — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\dot{\rho} = \mathcal{D}_\text{TLS}(\rho)=-\frac{i}{\hbar}\lbrack H,\rho \rbrack; +\frac{\gamma_\text{CE}}{2}\mathc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html:427,depend,dependent,427,docs/4.3/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html,1,['depend'],['dependent']
Integrability,"﻿. . Permutational Invariance — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\dot{\rho} = \mathcal{D}_\text{TLS}(\rho)=-\fr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-piqs.html:496,depend,dependent,496,docs/4.4/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-piqs.html,1,['depend'],['dependent']
Integrability,"﻿. . Permutational Invariance — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\dot{\rho} = \mathcal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-piqs.html:480,depend,dependent,480,docs/4.5/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-piqs.html,1,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Ham",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of h",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. Bloch-Redfield master equation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:484,depend,dependent,484,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,2,['depend'],['dependent']
Integrability,"﻿. Floquet Formalism — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms sho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:471,depend,dependent,471,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. Lindblad Master Equation Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; wh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:557,depend,dependent,557,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,1,['depend'],['dependent']
Integrability,"﻿. Monte Carlo Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:508,depend,dependent,508,docs/4.6/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html,1,['depend'],['dependent']
Integrability,"﻿. Permutational Invariance — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\do",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html:478,depend,dependent,478,docs/4.6/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html,1,['depend'],['dependent']
Integrability,"﻿. Permutational Invariance — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:507,depend,dependent,507,docs/4.7/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html,1,['depend'],['dependent']
Integrability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Citing QuTiP; QuTiP is developed by several physicists in their spare time.; As with anyone in academics,; their life and death is determined entirely by citations and paper count. ; Therefore, if you find QuTiP useful, please consider citing this project as:. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234 (2013), DOI: 10.1016/j.cpc.2012.11.019. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP: An open-source Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 183, 1760–1772 (2012), DOI: 10.1016/j.cpc.2012.02.021. This will also help us secure future funding supporting the development of this software.; PDF versions of these papers may be found on the ArXiv preprint server; here and here.; If you do use QuTiP in a publication, please take a few minutes and let us know; by posting on the QuTiP message board.; We would love to hear how QuTiP is being used as a research tool. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/citing.html:1211,message,message,1211,citing.html,https://qutip.org,https://qutip.org/citing.html,1,['message'],['message']
Integrability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Virtual Lab. Exploring simple quantum systems with QuTiP can help build intuition for them,; but there are many cases where writing code and Jupyter notebooks can get; in the way:. When teaching, coding can be a big distraction. Quantum mechanics is complex ; enough without your students having to struggle with installing software,; messing up their notebooks or learning QuTiP at the same time. When doing research, coding can be a big detour. You just want to do a quick; check to remind yourself how a simple system works, not spend the afternoon; fiddling in a text editor. You have papers to write and grant reports to fill; in. Time is precious. When at a party or while pitching your cool ideas, you don’t want to take out; your laptop to show people how cool your ideas are. It breaks the flow. You; need to be able to show them on your tablet. For all of these use cases, there is QuTiP Virtual Lab – a tablet and web; optimized graphical interface for building and exploring simple quantum systems.; It runs entirely in your browser, so there’s no server and nothing to install.; Click the button below to get started!; Enter QuTiP Virtual Lab.; There’s a handy tutorial with videos included in the virtual lab itself and some pre-built systems; to get you started. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-virtual-lab.html:1236,interface,interface,1236,qutip-virtual-lab.html,https://qutip.org,https://qutip.org/qutip-virtual-lab.html,1,['interface'],['interface']
Integrability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP is open-source software for simulating the dynamics of open quantum systems. The QuTiP library depends on the excellent Numpy, Scipy, and Cython numerical packages. In addition, graphical output is provided by Matplotlib. QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of Hamiltonians, including those with arbitrary time-dependence, commonly found in a wide range of physics applications such as quantum optics, trapped ions, superconducting circuits, and quantum nanomechanical resonators. QuTiP is freely available for use and/or modification on all major platforms such as Linux, Mac OSX, and Windows*. Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics and dynamics in the classroom. *QuTiP is developed on Unix platforms only, and some features may not be available under Windows. From the classroom to the corporate office, QuTiP is used around the world to advance research in quantum optics, quantum information, quantum open systems, optomechanics, and many related fields. QuTiP is in use at nearly every single research university around the globe, government-funded research labs, and is relied upon by every major corporation focused on developing a quantum computer. QuTiP is already being used at a variety of institutions around the globe, and has been downloaded more than a million times since its initial release. Need; help in simulating a tricky problem? Our large community of users are gracious enough to take a moment of their time and help in tackling even the most esoteric of issues. Distribution of the 39,420 Unique Visitors in 2020. Supporting Organizations; Developers from Nori's lab and Blais' lab have been ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index.html:381,depend,depends,381,index.html,https://qutip.org,https://qutip.org/index.html,2,['depend'],"['dependence', 'depends']"
Integrability,﻿. QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python. css; ; bootstrap.css; gh-fork-ribbon.css; site.css. QuTiP - Quantum Toolbox in Python. docs; . /3.0.0; . /apidoc; ; API documentation — QuTiP 3.0 Documentation; Classes — QuTiP 3.0 Documentation; Functions — QuTiP 3.0 Documentation. Bibliography — QuTiP 3.0 Documentation; Change Log — QuTiP 3.0 Documentation; Developers — QuTiP 3.0 Documentation; Frontmatter — QuTiP 3.0 Documentation; Index — QuTiP 3.0 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 3.0 Documentation; Dynamics Simulation Results — QuTiP 3.0 Documentation; Floquet Formalism — QuTiP 3.0 Documentation; Lindblad Master Equation Solver — QuTiP 3.0 Documentation; Monte Carlo Solver — QuTiP 3.0 Documentation; Setting Options for the Dynamics Solvers — QuTiP 3.0 Documentation; Performance (QuTiP vs. qotoolbox) — QuTiP 3.0 Documentation; Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. /scripts; ; correlation_ex1.pdf; correlation_ex1.py; correlation_ex2.pdf; correlation_ex2.py; correlation_ex3.pdf; correlation_ex3.py; correlation_ex4.pdf; correlation_ex4.py; floquet_ex0.pdf; floquet_ex0.py; floquet_ex1.pdf; floquet_ex1.py; floquet_ex2.pdf; floquet_ex2.py; floquet_ex3.pdf; floquet_ex3.py; spectrum_ex1.pdf; spectrum_ex1.py. Users Guide — QuTiP 3.0 Documentation; Basic Operations on Quantum Objects — QuTiP 3.0 Documentation; Plotting on the Bloch Sphere — QuTiP 3.0 Documentation; Two-time correlation functions — QuTiP 3.0 Documentation; Time Evolution and Quantum System Dynamics — QuTiP 3.0 Documentation; An Overview of the Eseries Class — QuTiP 3.0 Documentation; Guide Overview — QuTiP 3.0 Documentation; Running Problems in Parallel — QuTiP 3.0 Documentation; Generating Random Quantum States & Operators — QuTiP 3.0 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 3.0 Documentation; Modifying Internal QuTiP Settings — QuTiP 3.0 Documentation,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:971,depend,dependent,971,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['depend'],['dependent']
Integrability,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:494,integrat,integration,494,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,1,['integrat'],['integration']
Integrability,"﻿. QuTiP Development Roadmap — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:416,integrat,integration,416,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,1,['integrat'],['integration']
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/3.0.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. Stochastic Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.genera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:532,depend,dependent,532,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,1,['depend'],['dependent']
Integrability,"﻿. Stochastic Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:561,depend,dependent,561,docs/4.7/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html,1,['depend'],['dependent']
Modifiability," """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20076,config,config,20076,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36931,config,config,36931,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12134,config,config,12134,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); ; # Add H object terms to ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; # Add cop object terms to end of ode args string; for k in range(len(me_cops_obj)):; string_list.append(""me_cops_obj[%d]"" % k) ; ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=len(Lcoeff), h_tdterms=Lcoeff, ; c_td_splines=me_cops_coeff, ; c_td_spline_flags=me_cops_obj_flags, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mesolve.html:21916,config,config,21916,docs/4.3/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability," # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3734,config,config,3734,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability," # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9336,config,config,9336,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11533,config,config,11533,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability," # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 2011 to 2021 inclusive, QuT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:36104,config,config,36104,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['config'],['config']
Modifiability," # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20578,config,config,20578,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability," #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. # -----------------------------------------------------------------------------; # Functions for calculating the Bloch-Redfield tensor for a time-independent; # system.; #; [docs]def bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=[], use_secular=True, sec_cutoff=0.1):; """"""; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system's coupling; to its environment. .. note::. This tensor generation requires a time-independent Hamiltonian. Parameters; ----------. H : :class:`qutip.qobj`; System Hamiltonian. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to the environment. spectra_cb : list of callback functions; List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of :class:`qutip.qobj`; List of system collapse operators. use_secular : bool; Flag (True of False) that indicates if the secular approximation should; be used.; ; sec_cutoff : float {0.1}; Threshold for secular approximation. Returns; -------. R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. """"""; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:11434,coupling,coupling,11434,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability," 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/parallel.html:1753,variab,variables,1753,docs/4.7/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html,1,['variab'],['variables']
Modifiability," 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets.; """"""; self.render(self.fig, self.axes); if self.run_from_ipython():; if self._shown:; display(self.fig); else:; self.fig.show(); self._shown = True. [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(self.fig, self.axes); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; complete_path = os.getcwd() + ""/"" + str(dirc) + '/bloch_' \; + str(self.savenum) + '.' + format; else:; complete_path = os.getcwd() + '/bloch_' + \; str(self.savenum) + '.' + format; else:; complete_path = name. if dpin:; self.fig.savefig(complete_path, dpi=dpin); else:; self.fig.savefig(complete_path); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/bloch.html:21009,variab,variable,21009,docs/4.5/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/bloch.html,1,['variab'],['variable']
Modifiability," (Cython.__version__, _cython_requirement))). import pyximport; os.environ['CFLAGS'] = '-O3 -w -ffast-math -march=native -mfpmath=sse'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}). except Exception as e:; print(""QuTiP warning: Cython setup failed: "" + str(e)); else:; del Cython, pyximport. # -----------------------------------------------------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass. # -----------------------------------------------------------------------------; # cpu/process configuration; #; import multiprocessing. # Check if environ flag for qutip processes is set; if 'QUTIP_NUM_PROCESSES' in os.environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number of cores; from qutip.hardware_info import hardware_info; info = hardware_info(); if 'cpus' in info:; qutip.settings.num_cpus = info['cpus']; else:; qutip.settings.num_cpus = multiprocessing.cpu_count(). # -----------------------------------------------------------------------------; # Load configuration from environment variables: override defaults and; # configuration file.; #. # check for fortran mcsolver files; try:; from qutip.fortran import mcsolve_f90; except:; qutip.settings.fortran = False; else:; qutip.settings.fortran = True. # check for scikits.umfpack; try:; import scikits.umfpack as umfpack; exce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:6916,config,configuration,6916,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['config'],['configuration']
Modifiability," (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-parfor.html:2182,variab,variables,2182,docs/3.0.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html,4,['variab'],"['variable', 'variables']"
Modifiability, (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.operations.gates). c,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:5232,config,configure,5232,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,1,['config'],['configure']
Modifiability," (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progres",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12305,config,config,12305,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability," (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # --------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32226,config,config,32226,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:68884,config,configuration,68884,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability," * spre(cdc) \; - 0.5 * spost(cdc); elif c.issuper:; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6126,config,config,6126,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,14,['config'],['config']
Modifiability," * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe.; *Examples*; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; *Examples*; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:; state can be obtained with:; name+""=vec"":Qobj => args[name] == state as 1D np.ndarray; name+""=mat"":Qobj => args[name] == state as 2D np.ndarray; name+""=Qobj"":Qobj => args[name] == state as Qobj. This Qobj is the initial value. expectation values:; name+""=expect"":O (Qobj/QobjEvo) => args[name] == expect(O, state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:; name+""=collapse"":list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters; ----------; QobjEvo(Q_object=[], args={}, tlist=None). Q_object : array_like; Data for vector/matrix representation of the quantum object. args : dictionary that contain the arguments for. tlist : array_like; List of times at which the numpy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:7201,variab,variables,7201,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['variab'],['variables']
Modifiability," + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38094,config,config,38094,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:6402,config,config,6402,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,2,['config'],['config']
Modifiability," + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeErr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6206,config,config,6206,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,5,['config'],['config']
Modifiability," +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26747,config,config,26747,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:35691,evolve,evolve,35691,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['evolve'],['evolve']
Modifiability," +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; self.ntrajs = np.array(self.ntrajs); self.ntrajs = self.ntrajs[np.whe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8420,config,config,8420,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21269,config,config,21269,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,4,['config'],['config']
Modifiability," += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """""". # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T. f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)). else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:5571,variab,variables,5571,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['variab'],['variables']
Modifiability," += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:5645,variab,variables,5645,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,2,['variab'],['variables']
Modifiability," += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; ; initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:17851,config,config,17851,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['config'],['config']
Modifiability," - sigma * 1.0j * mu). return eta_list, gamma_list. [docs]class LorentzianPadeBath(FermionicBath):; """"""; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`LorentzianBath` which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(self, Q, gamma, w, mu, T, Nk, tag=None):; ck_plus, vk_plus = self._corr(gamma, w, mu, T, Nk, sigma=1.0); ck_minus, vk_minus = self._corr(gamma, w, mu, T, Nk, sigma=-1.0). super().__init__(; Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=tag,; ). def _corr(self, gamma, w, mu, T, Nk, sigma):; beta = 1. / T; kappa, epsilon = self._kappa_epsilon(Nk). def f_approx(x):; f = 0.5; for ll in range(1, Nk + 1):; f = f - 2 * kappa[ll] * x / (x**2 + epsilon[ll]**2); return f. eta_list = [0.5 * gamma * w * f_approx(1.0j * beta * w)]; gamma_list",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:23957,coupling,coupling,23957,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:44906,variab,variable,44906,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['variab'],['variable']
Modifiability," -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:33814,config,config,33814,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32805,config,config,32805,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Mon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:10625,variab,variable,10625,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,4,['variab'],['variable']
Modifiability," ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [32]: N = 10 # number of basis states. In [33]: a = destroy(N). In [34]: H = a.dag() * a # simple HO. In [35]: psi0 = basis(N, 9) # initial state. In [36]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [37]: times = np.linspace(0, 10, 100). In [38]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [39]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [40]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [42]: args = {'A': 9, 'sigma': 5}. In [43]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Mon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:11248,variab,variable,11248,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,3,['variab'],['variable']
Modifiability," / array_like. Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:data : instance/array_like. Input Python object to be stored. filename : str. Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1.0, we recommend to use qutip.parallel_map; instead of this function. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:task: a Python function. The function that is to be called for each value in task_vec. values: array / list. The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary. The optional additional argument to the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:157854,variab,variables,157854,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['variab'],['variables']
Modifiability," /; (-(epsilon[ll]**2 / beta**2) + w**2); ); gamma_list.append(epsilon[ll] / beta - sigma * 1.0j * mu). return eta_list, gamma_list. [docs]class LorentzianPadeBath(FermionicBath):; """"""; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`LorentzianBath` which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(self, Q, gamma, w, mu, T, Nk, tag=None):; ck_plus, vk_plus = self._corr(gamma, w, mu, T, Nk, sigma=1.0); ck_minus, vk_minus = self._corr(gamma, w, mu, T, Nk, sigma=-1.0). super().__init__(; Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=tag,; ). def _corr(self, gamma, w, mu, T, Nk, sigma):; beta = 1. / T; kappa, epsilon = self._kappa_epsilon(Nk). def f_approx(x):; f = 0.5; for ll in range(1, Nk + 1):; f = f - 2 * kappa[ll] * x / (x**2 + epsilon[ll]**2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:23904,coupling,coupling,23904,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability," 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14336,config,config,14336,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15328,config,config,15328,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9646,config,config,9646,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18594,config,config,18594,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," 512 (2016). 207. Fischer et al., ""Dynamical modeling of pulsed two-photon interference"", ; New J. Phys. 18, 113053 (2016).; Notebook1; Notebook2. 206. Seifoory et al., ""The properties of squeezed optical states created in lossy cavities"", ; arXiv:1608.05005. 205. Qin et al., ""Heralded quantum controlled-phase gates with dissipative dynamics in macroscopically distant resonators"", ; Phys. Rev. A 96, 012315 (2017). 204. Cruzeiro et al., ""Interactively Applying the Variational Method to the Dihydrogen Molecule: Exploring Bonding and Antibonding"", ; Journal of Chemical Education (2016). 203. Pleinert et al., ""Quantum signatures of collective behavior of a coherently driven two atom system coupled to a single-mode of the electromagnetic field"", ; arXiv:1608.00137. 202. Wang et al., ""Multiple-output microwave single-photon source using superconducting circuits with longitudinal and transverse couplings"", ; Phys. Rev. A 94, 053858 (2016). 201. Marshall et al., ""Continuous-variable quantum computing on encrypted data"", ; Nat. Comm. 7, 13795 (2016). 200. Dajka et al., ""Leggett–Garg inequalities for a quantum top affected by classical noise"", ; J. Quantum Inf. Process. (2016). 199. Rouxinol et al., ""Measurements of nanoresonator-qubit interactions in a hybrid quantum electromechanical system"", ; Nanotechnology 27, 364003 (2016). 198. Hocker et al., ""PEET: a Matlab tool for estimating physical gate errors in quantum information processing systems"", ; Quantum Information Processing (2016). 197. Daskin, ""Quantum eigenvalue estimation for irreducible non-negative matrices"", ; Int. J. Quantum Inform. 14, 1650005 (2016). 196. Dlaska et al., ""Robust quantum state transfer via topologically protected edge channels in dipolar arrays"", ; Quantum Sci. Technol. 2, 015001 (2017). 195. Juliusson et al., ""Manipulating Fock states of a harmonic oscillator while preserving its linearity"", ; Phys. Rev. A 94, 063861 (2016). 194. Banchi et al., ""Quantum gate learning in qubit networks: Toffoli g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:22531,variab,variable,22531,users.html,https://qutip.org,https://qutip.org/users.html,1,['variab'],['variable']
Modifiability," 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8637,variab,variables,8637,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:79180,variab,variables,79180,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['variab'],['variables']
Modifiability," : List of array[drift_dyn_gen.shape]; Eigenvectors of the dynamics generators; Used for calculating the propagators and their gradients; Only used when the PropagatorComputer uses diagonalisation. prop_eigen : List of array[drift_dyn_gen.shape]; Propagator in diagonalised basis of the combined dynamics generator; Used for calculating the propagators and their gradients; Only used when the PropagatorComputer uses diagonalisation. dyn_gen_factormatrix : List of array[drift_dyn_gen.shape]; Matrix of scaling factors calculated duing the decomposition; Used for calculating the propagator gradients; Only used when the PropagatorComputer uses diagonalisation. fact_mat_round_prec : float; Rounding precision used when calculating the factor matrix; to determine if two eigenvalues are equivalent; Only used when the PropagatorComputer uses diagonalisation. def_amps_fname : string; Default name for the output used when save_amps is called. """"""; def __init__(self, optimconfig):; self.config = optimconfig; self.reset(). def reset(self):; # Main functional attributes; self.evo_time = 0; self.num_tslots = 0; self.tau = None; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:10020,config,config,10020,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability," : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType):; output.num_expect = 0; expt_callback = True. elif isinstance(e_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:12892,variab,variables,12892,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['variab'],['variables']
Modifiability," : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, w0, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; w0=w0,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). def _matsubara_params(self, lam, gamma, w0, T, Nk):; """""" Calculate the Matsubara coefficents and frequencies. """"""; beta = 1/T; Om = np.sqrt(w0**2 - (gamma/2)**2); Gamma = gamma/2. ck_real = ([; (lam**2 / (4 * Om)); * (1 / np.tanh(beta * (Om + 1.0j * Gamma) / 2)),; (lam**2 / (4*Om)); * (1 / np.tanh(beta * (Om - 1.0j * Gamma) / 2)),; ]). ck_real.extend([; (-2 * lam**2 * gamma / beta) * (2 * np.pi * k / beta); / (; ((Om + 1.0j * Gamma)**2 + (2 * np.pi * k/beta)**2); * ((Om - 1.0j * Gamma)**2 + (2 * np.pi * k / beta)**2); ); for k in range(1, Nk + 1); ]). vk_real = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]; vk_real.extend([; 2 * np.pi * k * T; for k in range(1, Nk + 1); ]). ck_imag = [; 1.0j * lam**2 / (4 * Om),; -1.0j * lam**2 / (4 * Om),; ]. vk_imag = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class FermionicBath(Bath):; """"""; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the ``+`` and ``-`` modes of; the bath correlation function. There must be the same number of ``+`` and ``-`` modes and their; coefficients must be specified in the same order so that ``ck_plus[i],; vk_plus[i]`` are the plus coefficient and frequency corresponding; to the minus mode ``ck_minus[i], vk_minus[i]``. In the fermionic case the order in which excitations are created or; destr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:17851,extend,extend,17851,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['extend'],['extend']
Modifiability," = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17890,config,config,17890,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). A comparison of this time-dependent damping, with that of a constant decay term is presented below. Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable:; def H1_coeff(t, args):; return args['A'] * exp(-(t/args['sigma'])**2). or equivalently:; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty:; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:10134,variab,variable,10134,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['variab'],['variable']
Modifiability," = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-eseries.html:5643,evolve,evolve,5643,docs/4.2/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-eseries.html,3,['evolve'],['evolve']
Modifiability," = True. return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_H_t_shift(H, args=None):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". if isinstance(H, Qobj):; # constant hamiltonian; return H, args. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""); return H_shifted, _args. if isinstance(H, list):; # string/function-list based time-dependence; H_shifted = []; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. for i in range(len(H)):; if isinstance(H[i], list):; # modify hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.Funct",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:38268,variab,variable,38268,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['variab'],['variable']
Modifiability," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.36s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.64s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.93s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.21s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.48s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.76s. Est. time left: 00:00:00:01; 70.0%. Run time: 2.00s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.23s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.46s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:14264,variab,variables,14264,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.95s. Est. time left: 00:00:00:08; 20.0%. Run time: 1.81s. Est. time left: 00:00:00:07; 30.0%. Run time: 2.67s. Est. time left: 00:00:00:06; 40.0%. Run time: 3.59s. Est. time left: 00:00:00:05; 50.0%. Run time: 4.42s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.27s. Est. time left: 00:00:00:03; 70.0%. Run time: 6.10s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.91s. Est. time left: 00:00:00:01; 90.0%. Run time: 7.74s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:13804,variab,variables,13804,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37178,config,config,37178,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36176,config,config,36176,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," = []; exponents.extend(; BathExponent(""R"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_real, vk_real); ); exponents.extend(; BathExponent(""I"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_imag, vk_imag); ). if combine:; exponents = self.combine(exponents). super().__init__(exponents). [docs] @classmethod; def combine(cls, exponents, rtol=1e-5, atol=1e-7):; """"""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""; groups = []; remaining = exponents[:]. while remaining:; e1 = remaining.pop(0); group = [e1]; for e2 in remaining[:]:; if (; np.isclose(e1.vk, e2.vk, rtol=rtol, atol=atol) and; np.allclose(e1.Q, e2.Q, rtol=rtol, atol=atol); ):; group.append(e2); remaining.remove(e2); groups.append(group). new_exponents = []; for combine in groups:; exp1 = combine[0]; if (exp1.type != exp1.types.RI) and all(; exp2.type == exp1.type for exp2 in combine; ):; # the group is either type I or R; ck = sum(exp.ck for exp in combine); new_exponents.append(BathExponent(; exp1.type, None, exp1.Q, ck, exp1.vk, tag=exp1.tag,; )); else:; # the group includes both type I and R exponents; ck_R = (; sum(exp.ck for exp in combine if exp.type == exp.types.R) +; sum(exp.ck for exp in combine if exp.type == exp.types.RI); ); ck_I = (; sum(exp.ck for exp in combine if exp.type == exp.type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:7904,coupling,coupling,7904,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability," = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25426,config,config,25426,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19451,config,config,19451,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):; # averaged sparse density matrices; for i in range(nstep):; qtf90.qutraj_run.get_rho_sparse(i + 1); val = qtf90.qutraj_run.csr_val; col = qtf90.qutraj_run.csr_col - 1; ptr = qtf90.qutraj_run.csr_ptr - 1; m = qtf90.qutraj_run.csr_nrows; k = qtf90.qutraj_run.csr_ncols; states[i] = Qobj(csr_matrix((val, col, ptr),; (m, k)).toarray(),; dims=self.dm_dims, shape=se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13660,config,config,13660,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # ---------------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13790,config,config,13790,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13883,config,config,13883,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13133,config,config,13133,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # P",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38007,config,config,38007,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings; import qutip.settings as qset; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td, spmvpy_csr; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:2574,config,config,2574,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,2,['config'],['config']
Modifiability," DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings; import qutip.settings as qset; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/mesolve.html:2574,config,config,2574,docs/4.1/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability," Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26340,config,config,26340,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14700,config,config,14700,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15692,config,config,15692,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_lev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:107343,config,configuration,107343,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability," GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:69815,variab,variables,69815,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability," Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinst",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1132,config,config,1132,docs/4.7/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html,1,['config'],['config']
Modifiability," H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # -----------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37006,config,config,37006,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36004,config,config,36004,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:27391,config,configure,27391,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,2,['config'],['configure']
Modifiability," H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]¶; Reset any attributes to default values. run(self, rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:34106,coupling,coupling,34106,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38213,config,config,38213,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html:1308,extend,extend,1308,docs/4.6/development/ideas/heom-gpu.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html,1,['extend'],['extend']
Modifiability," Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:13758,config,configuration,13758,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['config'],['configuration']
Modifiability," It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]¶; clear any temporarily held status data. compute_fid_grad(self)[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]¶; Check configuration and initialise the normalisation. init_normalization(self)[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]¶. normalize_SU(self, A)[source]¶. normalize_gradient_PSU(self, grad)[source]¶; Normalise the gradient matrix pas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:110213,config,config,110213,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['config']
Modifiability," LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approxim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:2707,variab,variables,2707,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,1,['variab'],['variables']
Modifiability," LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian ap",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:2678,variab,variables,2678,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['variab'],['variables']
Modifiability," Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12355,config,config,12355,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability," List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. options : qutip.solver.Options; Options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters:; H : qutip.qobj. System Hamiltonian. a_ops : list; Nested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cb : list; Depreciated. c_ops : list; List of system collapse operators. use_secular : bool {True, False}; Flag that indicates if the secular approximation should; be used. sec_cutoff : float {0.1}; Threshold for secular approximation. atol : float {qutip.settings.atol}; Threshold for removing small parameters. Returns:; R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`; R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_ten",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:67172,coupling,couplingto,67172,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['coupling'],['couplingto']
Modifiability," None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:3865,config,config,3865,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability," None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:3946,config,config,3946,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability," Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics¶; Dynamics (subclass instance) – describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config¶; OptimConfig instance – various configuration options; (see OptimConfig for details). termination_conditions¶; TerminationCondition instance – attributes determine when the optimisation will end. pulse_generator¶; PulseGen (subclass instance) – (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats¶; Stats – attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump¶; dump.OptimDump – Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:62082,config,config,62082,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,2,['config'],"['config', 'configuration']"
Modifiability," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:175131,variab,variable,175131,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variable']
Modifiability," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:183701,variab,variable,183701,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variable']
Modifiability," Note; This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:L : qobj. Liouvillian of the system. rho0 : qobj. Initial state vector or density matrix. Returns:eseries : qutip.eseries. eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:63658,coupling,coupling,63658,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability," ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28831,config,config,28831,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2295,config,config,2295,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability," OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:2889,variab,variables,2889,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,6,"['config', 'variab']","['config', 'variables']"
Modifiability," OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (loc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:82071,config,config,82071,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['config']
Modifiability," OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm; Attributes. max_metric_corr; (integer) The maximum number of variable metric corrections used to define the limited memory matrix. That is the number of previous gradient values that are used to approximate the Hessian see the scipy.optimize.fmin_l_bfgs_b documentation for description of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:65279,config,config,65279,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['config'],['config']
Modifiability," Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state accor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html:1565,evolve,evolve,1565,docs/4.5/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html,1,['evolve'],['evolve']
Modifiability," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:11287,config,configuration,11287,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,7,['config'],['configuration']
Modifiability," Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:8754,config,config,8754,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,2,['config'],['config']
Modifiability," QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require approx 10GB of disk space, much of which does have to be on the system drive. If this is not feasible, then it is possible to run QuTiP under Python 2.7. Windows and Python 2.7¶. Important; Running QuTiP under Python",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:6024,config,configuration,6024,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,5,['config'],['configuration']
Modifiability," Run time: 17.62s. Est. time left: 00:00:00:00; Total run time: 17.63s. we can extract the relevant expectation values using:; In [17]: expt1 = data.expect[0]. In [18]: expt10 = data.expect[1]. In [19]: expt100 = data.expect[2]. In [20]: expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [21]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [22]: times = np.linspace(0.0, 10.0, 200). In [23]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [24]: a = tensor(qeye(2), destroy(10)). In [25]: sm = tensor(destroy(2), qeye(10)). In [26]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [27]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 0.83s. Est. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html:16539,config,configuration,16539,docs/4.4/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html,1,['config'],['configuration']
Modifiability," Run time: 26.46s. Est. time left: 00:00:00:00; Total run time: 26.52s. we can extract the relevant expectation values using:; In [17]: expt1 = data.expect[0]. In [18]: expt10 = data.expect[1]. In [19]: expt100 = data.expect[2]. In [20]: expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [21]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [22]: times = np.linspace(0.0, 10.0, 200). In [23]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [24]: a = tensor(qeye(2), destroy(10)). In [25]: sm = tensor(destroy(2), qeye(10)). In [26]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [27]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.21s. Est. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html:12280,config,configuration,12280,docs/4.5/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html,1,['config'],['configuration']
Modifiability," SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:2248,config,configuration,2248,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,4,['config'],['configuration']
Modifiability," SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will sto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:70543,config,config,70543,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['config']
Modifiability," SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:67548,config,config,67548,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,3,['config'],['config']
Modifiability," Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self.num_tslots):; self.time[t+1] = self.time[t] + self.tau[t]. def _init_lists(self):; """"""; Create the container lists / arrays for the:; dynamics generations, propagators, and evolutions etc; Set the time slices and cumulative time; """""". # Create containers for control Hamiltonian etc; shp = self.drift_dyn_gen.shape; # set H to be just empty float arrays with the shape of H; self.dyn_gen = [np.empty(shp, dtype=complex); for x in range(self.num_tslots)]; # the exponetiation of H. Just empty float arrays with the shape of H; self.prop = [np.empty(shp, dtype=comple",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:12229,config,config,12229,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability," Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1954,coupling,coupling,1954,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,1,['coupling'],['coupling']
Modifiability," Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:1519,evolve,evolves,1519,docs/4.7/guide/dynamics/dynamics-krylov.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html,1,['evolve'],['evolves']
Modifiability," Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:8104,coupling,coupling,8104,docs/4.6/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html,2,['coupling'],['coupling']
Modifiability," TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:3833,coupling,coupling,3833,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,8,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability," TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:76331,variab,variables,76331,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability," These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self._phase_application = 'preop'; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). [docs] def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); if self._num_ctrls is None:; self._num_ctrls = self._get_num_ctrls(); return self._num_ctrls. def _get_onto_evo_target(self):; """"""; Get the adjoint of the target.; Used for calculating the 'backward' evolution; """"""; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); else:; self._onto_evo_target = self._target.T.conj(); return self._onto_evo_target. def _spectral_decomp(self, k):; """"""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:46874,config,configuration,46874,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,5,['config'],['configuration']
Modifiability," This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5564,extend,extending,5564,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,1,['extend'],['extending']
Modifiability," This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:63410,coupling,coupling,63410,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability," TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32280,config,config,32280,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. « Visualization of... Saving QuTiP Obj... ». Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; In [11]: result = p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-parfor.html:2288,variab,variables,2288,docs/3.1.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html,2,['variab'],['variables']
Modifiability," [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'; ; Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header prope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:13446,variab,variables,13446,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['variab'],['variables']
Modifiability," \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q – Values representing the Q-function calculated over the specified range; [xvec,yvec]. Return type:array. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:; state (qobj) – A state vector or density matrix for a spin-j quantum system.; theta (array_like) – theta-coordinates at which to calculate the Q function.; phi (array_like) – phi-coordinates at which to calculate the Q function. Returns:Q, THETA, PHI – Values representing the spin Q fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:110635,config,config,110635,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['config'],['config']
Modifiability," _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27053,config,config,27053,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28056,config,config,28056,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.sof",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html:7381,config,config,7381,docs/4.0.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the DrudeLorentzBath which constructs; a simpler exponential expansion. Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of Padé exponentials terms used to approximate the bath; correlation functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Padé terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Padé terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class UnderDampedBath(Q, lam, gamma, w0, T, Nk, combine=True, tag=None)[source]¶;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:56730,coupling,coupling,56730,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/Ph",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:68978,coupling,coupling,68978,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," a single operator; # if so convert it to a list containing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:9839,config,config,9839,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['config'],['config']
Modifiability," a specific conda environment, or you have installed Miniconda, then you will need to install the required packages for QuTiP.; recommended:; conda install numpy scipy cython matplotlib pytest pytest-cov jupyter notebook spyder. minimum (recommended):; conda install numpy scipy cython pytest pytest-cov matplotlib. absolute mimimum:; conda install numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks). Spyder is an IDE for scientific development with Python. Adding the conda-forge channel¶; If you have conda 4.1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To instal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:4237,config,config,4237,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['config'],['config']
Modifiability," an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:31421,config,config,31421,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:128015,coupling,coupling,128015,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.parallel. Source code for qutip.parallel; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from numpy import array; import multiprocessing; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if sys.platform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/parallel.html:1239,variab,variable,1239,docs/4.7/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html,1,['variab'],['variable']
Modifiability," and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15030,config,config,15030,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16022,config,config,16022,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," and/or lindblad noise. If there are; pulse independent noise, a dummy Pulse can be created by; Pulse(None, None). The modified input pulses should always; be at the begining of the list, followed by the dummy pulses. get_noisy_dynamics(self, pulses, dims)[source]¶; Template method.; It should return a list of pulses with noise. Parameters. pulses: list of :class:`qutip.qip.Pulse`The input pulses, on which the noise object will be applied. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. Returns. noisy_pulses: list of qutip.qip.PulseThe input Pulse object with additional noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label=None)[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:137531,variab,variables,137531,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['variab'],['variables']
Modifiability," and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # ------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13622,config,config,13622,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_bins : int; Number of time bins; the range over which each index can vary. Returns:; temporal_basis_vector : :class: qutip.Qobj; A basis vecto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:111505,config,config,111505,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['config'],['config']
Modifiability," array_like; Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data : instance/array_like; Input Python object to be stored. filename : str; Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func : function_type; A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:; result : list; A list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:; task : a Python function; The function that is to be called for each value in task_vec. values : array / list; The list or array of values for which the task function is to be; evaluated. task_args : list / dictionary; The optional additional argument ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:210102,variab,variables,210102,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability," as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:3862,enhance,enhancement,3862,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['enhance'],['enhancement']
Modifiability," bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:14623,config,config,14623,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,3,['config'],['config']
Modifiability," be checked. Returns. taus: dictA dictionary of key, val as {tau: value} consisting of the valid; taus for this row and column of the Dicke space element. One-Dimensional Lattice¶. class Lattice1d(num_cell=10, boundary='periodic', cell_num_site=1, cell_site_dof=[1], Hamiltonian_of_cell=None, inter_hop=None)[source]¶; A class for representing a 1d crystal.; The Lattice1d class can be defined with any specific unit cells and a; specified number of unit cells in the crystal. It can return dispersion; relationship, position operators, Hamiltonian in the position represention; etc. Parameters. num_cellintThe number of cells in the crystal. boundarystrSpecification of the type of boundary the crystal is defined with. cell_num_siteintThe number of sites in the unit cell. cell_site_doflist of int/ intThe tensor structure of the degrees of freedom at each site of a unit; cell. Hamiltonian_of_cellqutip.QobjThe Hamiltonian of the unit cell. inter_hopqutip.Qobj / list of QobjThe coupling between the unit cell at i and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:60287,coupling,coupling,60287,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,3,['coupling'],['coupling']
Modifiability," boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, pl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:28870,config,config,28870,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['config']
Modifiability," by stacking; them together. get_ops_labels()[source]¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(qc)[source]¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. optimize_circuit(qc)[source]¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. Returns:; qc: QubitCircuit; The optimal circuit representation. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:67158,config,configuration,67158,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability," cached, because it is used in the gradient calculation. init_comp(self)[source]¶; Check configuration and initialise the normalisation. init_normalization(self)[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]¶. normalize_SU(self, A)[source]¶. normalize_gradient_PSU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:111355,config,configuration,111355,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configuration']
Modifiability," can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly installed on OS X using Homebrew and the automated installation shell scripts. Python 2.7 installation script; Python 3.4 installation script. Having downloaded the script corresponding to the version of Python you want to use, the installation script can be run from the terminal using (replacing X with 2 or 3); sh install_qutip_pyX.sh. The script will then install Homebrew and the required QuTiP dependencies before installing QuTiP itself and running the built in test suite. Any errors in the homebrew configuration will be displayed at the end. Using Python 2.7 or 3.4, the python commend-line and IPython interpreter can be run by calling python and ipython or python3 and ipython3, respectively.; If you have installed other packages in the /usr/local/ directory, or have changed the permissions of any of its sub-directories, then this script may fail to install all the necessary tools automatically. Setup Using Macports¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’.; On the Mac OS, you can install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via (Replace ‘34’ with ‘27’ if you want Python 2.7); sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel; sudo port install py34-pip. Now",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:7168,config,configuration,7168,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['config'],['configuration']
Modifiability, cnot() (in module qutip.qip.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Du,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:4273,config,configure,4273,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['config'],['configure']
Modifiability," collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('fro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28235,config,config,28235,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15093,config,config,15093,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16085,config,config,16085,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j *",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34095,config,config,34095,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33086,config,config,33086,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13545,config,config,13545,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23732,config,config,23732,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in rang",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:35143,config,config,35143,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16860,config,config,16860,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TI",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:24545,config,config,24545,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,2,['config'],['config']
Modifiability," config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30250,config,config,30250,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13165,config,config,13165,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability," configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:41101,coupling,coupling,41101,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," contains a single element. If 'e_ops' were provided""; "", return its corresponding expectation values at 'psi0', else ""; ""return 'psi0'.""; ). progress_bar.start(1). res, expt_callback, options, n_expt_op = _e_ops_outputs(; res, e_ops, n_tlist_steps, options; ). if options.store_states:; res.states = [psi0]. e_0 = None; if expt_callback:; # use callback method; e_0 = e_ops(0, psi0); res.expect.append(e_0). e_m_0 = []; for m in range(n_expt_op):; op = e_ops[m]. if not isinstance(op, Qobj) and callable(op):; e_m_0.append(op(0, psi0)); res.expect[m][0] = e_m_0[m]; continue. e_m_0.append(expect(op, psi0)); res.expect[m][0] = e_m_0[m]. if happy_breakdown:; res = _happy_breakdown(; tlist,; options,; res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:13813,evolve,evolves,13813,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['evolve'],['evolves']
Modifiability," ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None impli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:30934,variab,variables,30934,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['variab'],['variables']
Modifiability," decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-steady.html:10431,coupling,coupling,10431,docs/4.6/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html,2,['coupling'],['coupling']
Modifiability," def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16002,config,config,16002,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16994,config,config,16994,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Mo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:10399,variab,variable,10399,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,1,['variab'],['variable']
Modifiability," del top_path. # -----------------------------------------------------------------------------; # setup the cython environment; #; _cython_requirement = ""0.15.0""; try:; import Cython; if _version2int(Cython.__version__) < _version2int(_cython_requirement):; print(""QuTiP warning: old version of cython detected "" +; (""(%s), requiring %s."" %; (Cython.__version__, _cython_requirement))). import pyximport; os.environ['CFLAGS'] = '-O3 -w -ffast-math -march=native -mfpmath=sse'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}). except Exception as e:; print(""QuTiP warning: Cython setup failed: "" + str(e)); else:; del Cython, pyximport. # -----------------------------------------------------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass. # -----------------------------------------------------------------------------; # cpu/process configuration; #; import multiprocessing. # Check if environ flag for qutip processes is set; if 'QUTIP_NUM_PROCESSES' in os.environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number of cores; from qutip.hardware_info import hardware_info; info = hardware_info(); if 'cpus' in info:; qutip.settings.num_cpus = info['cpus']; else:; qutip.settings.num_cpus = multiprocessing.cpu_count(). # ----------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:6528,config,config,6528,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['config'],['config']
Modifiability," deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:9690,variab,variables,9690,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,1,['variab'],['variables']
Modifiability," described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:14810,config,configuration,14810,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,2,['config'],['configuration']
Modifiability," destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17716,coupling,coupling,17716,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability," do explicit loops here in case spectra_cb[k] can not deal with array arguments; for n in range(N):; for m in range(N):; Jw[k, n, m] = a_ops[k][1](W[n, m]). dw_min = np.abs(W[W.nonzero()]).min(). # pre-calculate mapping between global index I and system indices a,b; Iabs = np.empty((N*N,3),dtype=int); for I, Iab in enumerate(Iabs):; # important: use [:] to change array values, instead of creating new variable Iab; Iab[0] = I; Iab[1:] = vec2mat_index(N, I). # unitary part + dissipation from c_ops (if given):; Heb = H.transform(ekets); L = liouvillian(Heb, c_ops=[c_op.transform(ekets) for c_op in c_ops]); ; # dissipative part:; rows = []; cols = []; data = []; for I, a, b in Iabs:; # only check use_secular once per I; if use_secular:; # only loop over those indices J which actually contribute; Jcds = Iabs[np.where(np.abs(W[a, b] - W[Iabs[:,1], Iabs[:,2]]) < dw_min * sec_cutoff)]; else:; Jcds = Iabs; for J, c, d in Jcds:; elem = 0+0j; # summed over k, i.e., each operator coupling the system to the environment; elem += 0.5 * np.sum(A[:, a, c] * A[:, d, b] * (Jw[:, c, a] + Jw[:, d, b])); if b==d:; # sum_{k,n} A[k, a, n] * A[k, n, c] * Jw[k, c, n]); elem -= 0.5 * np.sum(A[:, a, :] * A[:, :, c] * Jw[:, c, :]); if a==c:; # sum_{k,n} A[k, d, n] * A[k, n, b] * Jw[k, d, n]); elem -= 0.5 * np.sum(A[:, d, :] * A[:, :, b] * Jw[:, d, :]); if elem != 0:; rows.append(I); cols.append(J); data.append(elem). R = arr_coo2fast(np.array(data, dtype=complex),; np.array(rows, dtype=np.int32),; np.array(cols, dtype=np.int32), N**2, N**2); ; L.data = L.data + R; ; return L, ekets. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None, ; progress_bar=None,_safe_mode=True):; ; if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]; ; H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:14235,coupling,coupling,14235,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability," documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation wil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:84357,config,config,84357,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['config']
Modifiability," dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38648,config,config,38648,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=<qutip.solver.Options object at 0x2b225f643f98>, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b225f643fd0>, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:54537,evolve,evolved,54537,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['evolve'],['evolved']
Modifiability," energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:74794,variab,variables,74794,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability," entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6372,config,config,6372,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:12433,flexible,flexible,12433,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,1,['flexible'],['flexible']
Modifiability," errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:14716,flexible,flexible,14716,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,1,['flexible'],['flexible']
Modifiability," exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29274,config,config,29274,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:69654,evolve,evolves,69654,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['evolve'],['evolves']
Modifiability," exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:40647,evolve,evolves,40647,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['evolve'],['evolves']
Modifiability," exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Matsubara terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class DrudeLorentzPadeBath(Q, lam, gamma, T, Nk, combine=True, tag=None",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:54687,coupling,coupling,54687,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:92822,variab,variables,92822,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['variab'],['variables']
Modifiability," fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/bloch_redfield.html:17825,config,config,17825,docs/4.5/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability," fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TI",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23542,config,config,23542,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,8,['config'],['config']
Modifiability," fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:222115,config,configuration,222115,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['configuration']
Modifiability," float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29642,config,config,29642,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_ind",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34020,config,config,34020,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33011,config,config,33011,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:13846,extend,extended,13846,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,1,['extend'],['extended']
Modifiability," for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(ins",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11543,config,config,11543,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12549,config,config,12549,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0x2b225f631c18>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_binsintNumber of time bins; the range over which each index can vary. Returns. temporal_basis_vector:class: qutip.QobjA basis vector representing photon ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:111775,config,config,111775,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['config'],['config']
Modifiability," for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/history.html:2714,rewrite,rewrite,2714,docs/4.7/guide/heom/history.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html,1,['rewrite'],['rewrite']
Modifiability," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like. optional list of precomputed tensors \(T_k\). kwargs : dictionary. Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output: qutip.solver.Result. An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:142305,variab,variables,142305,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['variab'],['variables']
Modifiability," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:210507,variab,variables,210507,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['variab'],['variables']
Modifiability," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details). tslot_paramsdictParameters for the Tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:220884,variab,variable,220884,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['variab'],['variable']
Modifiability," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works.; (See TimeslotComputer classes for; details). tslot_paramsdictParameters for the Ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:232997,variab,variable,232997,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['variab'],['variable']
Modifiability," from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.superoperator import liouvillian; from qutip.interpolate import Cubic_Spline; from qutip.cy.spconvert import arr_coo2fast; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:3634,coupling,coupling,3634,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,3,['coupling'],['coupling']
Modifiability," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.12s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.20s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.28s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.36s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.44s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.52s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.60s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.68s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:16854,variab,variables,16854,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.13s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.22s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.31s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.40s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.49s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.58s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.67s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.86s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:16688,variab,variables,16688,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.24s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.44s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.62s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.80s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.00s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.23s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.42s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.62s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16785,variab,variables,16785,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12227,config,config,12227,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHSt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22709,config,config,22709,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:5406,config,configuration,5406,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['config'],['configuration']
Modifiability," i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37801,config,config,37801,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34183,config,config,34183,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.arr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33174,config,config,33174,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup cons",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37576,config,config,37576,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13127,config,config,13127,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability," import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:3740,coupling,coupling,3740,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,2,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability," import _td_format_check, _td_wrap_array_str; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None,; progress_bar=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (*callback format*). Alternatively, `H` and `c_ops` can be a specified in a nested-list format; where each ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:5061,evolve,evolved,5061,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['evolve'],['evolved']
Modifiability," in DrudeLorentzBath. temperaturefloatBath temperature. Referred to as T in DrudeLorentzBath. N_cutintThe maximum depth of the hierarchy. See max_depth in; HEOMSolver for a full description. N_expintNumber of exponential terms used to approximate the bath correlation; functions. The equivalent Nk in DrudeLorentzBath is one; less than N_exp (see note above). cut_freqfloatBath spectral density cutoff frequency. Referred to as gamma in; DrudeLorentzBath. bnd_cut_approxboolUse boundary cut off approximation. If true, the Matsubara; terminator is added to the system Liouvillian (and H_sys is; promoted to a Liouvillian if it was a Hamiltonian). optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_barNone, True or BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the solver. If True, an instance of; TextProgressBar is used instead. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. class BathExponent(type, dim, Q, ck, vk, ck2=None, sigma_bar_k_offset=None, tag=None)[source]¶; Represents a single exponent (naively, an excitation mode) within the; decomposition of the correlation functions of a bath. Parameters. type{“R”, “I”, “RI”, “+”, “-“} or BathExponent.ExponentTypeThe type of bath exponent.; “R” and “I” are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion.; “RI” is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single vk. The ck is the coefficient in the real; expansion and ck2 is the coefficient in the imaginary expansion.; “+” and “-” are fermionic bath exponents. These fermionic bath; exponents must specify sigma_bar_k_offset which specifies; the amount to add to k (the exponent index within the bath of this; exponent) to determ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:49391,coupling,coupling,49391,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:195926,config,config,195926,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['config']
Modifiability," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local min",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:76164,config,config,76164,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['config']
Modifiability," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:68281,config,config,68281,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['config']
Modifiability," in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15331,config,config,15331,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16323,config,config,16323,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of cor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:91524,variab,variables,91524,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['variab'],['variables']
Modifiability," in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23695,config,config,23695,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,10,['config'],['config']
Modifiability," in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:76022,variab,variables,76022,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability," is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); tlist = np.asarray(tlist); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:34731,evolve,evolve,34731,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['evolve'],['evolve']
Modifiability," is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:34359,variab,variable,34359,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['variab'],['variable']
Modifiability," k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and the imaginary part, \(C_{imag}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; And now the same numbers calculated in Python:; # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:; from qutip.nonmarkov.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we’re done!; The BosonicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths¶; The HEOMSolver supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath.; In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the Fenna–Matthews–Olson (FMO); pigment-protein complex which plays an important role in photosynthesis (; for a full FMO example see the note",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:10028,extend,extend,10028,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,1,['extend'],['extend']
Modifiability," last element of `coeff` has no effect. -""cubic"": Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The `QobjEvo` representation of the evolution element.; """"""; try:; return self._get_qobjevo_helper(spline_kind, dims=dims); except Exception as err:; print(; ""The Evolution element went wrong was\n {}"".format(str(self))); raise(err). def __str__(self):; return str({""qobj"": self.qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:4172,variab,variables,4172,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,3,['variab'],['variables']
Modifiability," left: 00:00:00:07; 90.0%. Run time: 33.20s. Est. time left: 00:00:00:03; 100.0%. Run time: 36.90s. Est. time left: 00:00:00:00; Total run time: 37.02s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [30]: kappa = 0.5. In [31]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [32]: N = 10 # number of basis states. In [33]: a = destroy(N). In [34]: H = a.dag() * a # simple HO. In [35]: psi0 = basis(N, 9) # initial state. In [36]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [37]: times = np.linspace(0, 10, 100). In [38]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [39]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [40]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:10128,variab,variable,10128,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,2,['variab'],"['variable', 'variables']"
Modifiability," len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32480,config,config,32480,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters:; N (int) – Square root of the dimension of the superoperator to be returned.; enforce_tp (bool) – If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced.; rank (int or None) – Rank of the sampled superoperator. If None, a full-rank; superoperator is generated.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:rho – A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Return type:Qobj. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states – array of three level atom basis vectors. Return type:array. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops – array of three level operators. Return type:array. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:36755,config,configuration,36755,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['config'],['configuration']
Modifiability," likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:8150,variab,variables,8150,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['variab'],['variables']
Modifiability," list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=comple",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:17472,extend,extends,17472,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,9,['extend'],['extends']
Modifiability," list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32836,config,config,32836,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:6948,config,config,6948,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability," map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7689,config,config,7689,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability," matrices A & B. Parameters:; A (qobj) – Density matrix or state vector.; B (qobj) – Density matrix or state vector with same dimensions as A. Returns:dist – Hilbert-Schmidt distance between density matrices. Return type:float. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters:; A (Qobj) – Quantum object representing a superoperator.; target (Qobj) – Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns:fid – Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. Return type:float. process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. Continous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:; basis (list) – List of operators that defines the basis for the correlation matrix.; rho (Qobj) – Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:corr_mat – A 2-dimensional array of correlation values or operators. Return type:ndarray. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:50331,variab,variable,50331,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variable']
Modifiability," minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm; Attributes. max_metric_corr; (integer) The maximum number of variable metric corrections used to define the limited memory matrix. That is the number of previous gradient values that are used to approximate the Hessian see the scipy.optimize.fmin_l_bfgs_b documentation for description of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:65889,config,configuration,65889,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['config'],['configuration']
Modifiability," named ‘filename.qu’ in current directory. Parameters:; name : str; Name of data file to be loaded. Returns:; qobject : instance / array_like; Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data : instance/array_like; Input Python object to be stored. filename : str; Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func : function_type; A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:; result : list; A list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:; task : a Python function; The function that is to be called for each value in task_vec. values : array / list; The list o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:210042,variab,variables,210042,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability," object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:43356,config,configurations,43356,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['config'],['configurations']
Modifiability," of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/history.html:1787,flexible,flexible,1787,docs/4.7/guide/heom/history.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html,1,['flexible'],['flexible']
Modifiability," of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]¶; Check configuration and initialise the normalisation. init_normalization(self)[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]¶. normalize_SU(self, A)[source]¶. normalize_gradient_PSU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[sourc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:110459,config,configuration,110459,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configuration']
Modifiability," of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of; qutip.parallel.parallel_map. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of va",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:262606,variab,variables,262606,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['variab'],['variables']
Modifiability," operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27884,config,config,27884,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:13450,layers,layers,13450,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['layers'],['layers']
Modifiability," optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:79888,config,configuration,79888,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configuration']
Modifiability," or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of qutip.parallel_map. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:250415,variab,variables,250415,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['variab'],['variables']
Modifiability," otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/correlation.html:37395,config,config,37395,docs/4.4/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/correlation.html,1,['config'],['config']
Modifiability," otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary; def _transform_shift_one_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:37448,config,config,37448,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,1,['config'],['config']
Modifiability," otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary; def _transform_shift_one_c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:38024,config,config,38024,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,1,['config'],['config']
Modifiability," parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:8526,config,config,8526,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,2,['config'],['config']
Modifiability," params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:82232,variab,variable,82232,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['variab'],['variable']
Modifiability," period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floque",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:71302,variab,variables,71302,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['variab'],['variables']
Modifiability," phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:7191,variab,variable,7191,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,7,['variab'],['variable']
Modifiability," possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:8165,config,config,8165,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," precision, for ranks less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters:N : int. Square root of the dimension of the superoperator to be returned. enforce_tp : bool. If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rank : int or None. Rank of the sampled superoperator. If None, a full-rank; superoperator is generated. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:rho : Qobj. A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:35441,config,configuration,35441,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['config'],['configuration']
Modifiability," problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12491,config,config,12491,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:15588,variab,variables,15588,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,3,['variab'],['variables']
Modifiability," qutip.bloch_redfield.bloch_redfield_tensor also returns a list of eigenkets ekets, since they are calculated in the process of calculating the Bloch-Redfield tensor R, and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; >>> tlist = linspace(0, 15.0, 1000); >>> psi0 = rand_ket(2); >>> e_ops = [sigmax(), sigmay(), sigmaz()]; >>> expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops); >>>; >>> sphere = Bloch(); >>> sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]); >>> sphere.vector_color = ['r']; >>> # Hamiltonian axis; >>> sphere.add_vectors(array([delta, 0, eps0]) / sqrt(delta ** 2 + eps0 ** 2)); >>> sphere.make_sphere(); >>> show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; >>> output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.Odedata. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html:13249,evolve,evolve,13249,docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,1,['evolve'],['evolve']
Modifiability," qutip.bloch_redfield.bloch_redfield_tensor also returns a list of eigenkets ekets, since they are calculated in the process of calculating the Bloch-Redfield tensor R, and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; >>> tlist = linspace(0, 15.0, 1000); >>> psi0 = rand_ket(2); >>> e_ops = [sigmax(), sigmay(), sigmaz()]; >>> expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops); >>>; >>> sphere = Bloch(); >>> sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]); >>> sphere.vector_color = ['r']; >>> # Hamiltonian axis; >>> sphere.add_vectors(array([delta, 0, eps0]) / sqrt(delta ** 2 + eps0 ** 2)); >>> sphere.make_sphere(); >>> show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; >>> output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.Odedata. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:13187,evolve,evolve,13187,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,1,['evolve'],['evolve']
Modifiability," raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrod",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:29677,config,config,29677,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,4,['config'],['config']
Modifiability," reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.02s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.02s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.03s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.03s. Est. time left: 00:00:00:00; Total run time: 25.10s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-parfor.html:6193,config,configurations,6193,docs/4.5/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-parfor.html,1,['config'],['configurations']
Modifiability," seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:14302,config,config,14302,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, ke",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11282,config,config,11282,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['config'],['config']
Modifiability," simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:77221,evolve,evolved,77221,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['evolve'],['evolved']
Modifiability," since they are calculated in the process of calculating the Bloch-Redfield tensor R, and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; In [6]: import matplotlib.pyplot as plt. In [7]: tlist = np.linspace(0, 15.0, 1000). In [8]: psi0 = rand_ket(2). In [9]: e_ops = [sigmax(), sigmay(), sigmaz()]. In [10]: expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). In [11]: sphere = Bloch(). In [12]: sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). In [13]: sphere.vector_color = ['r']. In [14]: sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). In [15]: sphere.make_sphere(). In [16]: plt.show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; In [17]: output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.solver.Result. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html:13408,evolve,evolve,13408,docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,1,['evolve'],['evolve']
Modifiability," solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12220,config,config,12220,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots();",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:18595,config,config,18595,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,2,['config'],['config']
Modifiability," spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17136,config,config,17136,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16088,config,config,16088,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:17080,config,config,17080,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initial density matrix or state vect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:75449,variab,variables,75449,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variables']
Modifiability," store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:39880,config,config,39880,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,10,['config'],['config']
Modifiability," temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:100157,variab,variables,100157,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['variab'],['variables']
Modifiability," terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:53960,coupling,coupling,53960,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36545,config,config,36545,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35543,config,config,35543,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," the default Python version, if you want to use Python 3 with MS Windows, then it must be python=3.4); recommended:; conda create -n qutip python=3 mkl numpy scipy cython matplotlib nose multiprocess jupyter notebook spyder. minimum (recommended):; conda create -n qutip numpy scipy cython nose matplotlib. absolute mimimum:; conda create -n qutip numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks).; Spyder is an IDE for scientific development with Python. Adding the conda-forge channel¶; If you have conda 4.1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development versi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:4377,config,config,4377,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['config'],['config']
Modifiability," the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. f_coeff : array. The coefficients for Floquet decomposition of the initial wavefunction. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:73313,variab,variables,73313,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['variab'],['variables']
Modifiability," the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.av",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:6734,config,config,6734,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability," the spinchain model and save them in the; attribute `ctrls`. Parameters; ----------; N: int; The number of qubits in the system.; """"""; self.pulse_dict = {}; index = 0; # sx_ops; for m in range(N):; self.pulses.append(; Pulse(sigmax(), m, spline_kind=self.spline_kind)); self.pulse_dict[""sx"" + str(m)] = index; index += 1; # sz_ops; for m in range(N):; self.pulses.append(; Pulse(sigmaz(), m, spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # sxsy_ops; operator = tensor([sigmax(), sigmax()]) + tensor([sigmay(), sigmay()]); for n in range(N - 1):; self.pulses.append(; Pulse(operator, [n, n+1], spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(self, sx, sz):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", and ""sxsy"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""sxsy"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; sx: float or list; The coefficient of sigmax in the model. sz: flaot or list; The coefficient of sigmaz in the model. Notes; -----; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(sx, self.N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(sz, self.N); self._params[""sz""] = sz_para. @property; def sx_ops(self):; return self.ctrls[: self.N]. @property; def sz_ops(self):; return self.ctrls[self.N: 2*self.N]. @property; def sxsy_ops(self):; return self.ctrls[2*self.N:]. @property; def sx_u(self):; return self.coeffs[: self.N]. @property; def sz_u(self):; return self.coeffs[self.N: 2*self.N]. @property; def sxsy_u(self):; return self.coeffs[2*self.N:]. [docs] def load_circuit(; self, qc, setup, schedule_mode=""ASAP"", compiler=None):; """"""; Decompose a :class:`.QubitCircuit` in to the control; amplitu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:5764,coupling,coupling,5764,docs/4.6/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html,2,['coupling'],['coupling']
Modifiability," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:17370,config,configuration,17370,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['config'],"['configuration', 'configure']"
Modifiability," the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11447,config,config,11447,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability," the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:9185,variab,variable,9185,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['variab'],['variable']
Modifiability," the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:75423,variab,variables,75423,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability," time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3573,variab,variables,3573,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['variab'],['variables']
Modifiability," time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('fro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29255,config,config,29255,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:73438,coupling,coupling,73438,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import quti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:3862,variab,variables,3862,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['variab'],['variables']
Modifiability," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:222174,config,configuration,222174,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['configuration']
Modifiability," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:102888,config,configuration,102888,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:94580,config,configuration,94580,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability," used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed cohere",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:27250,coupling,coupling,27250,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:15325,config,config,15325,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability," w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:8893,config,config,8893,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['config'],['config']
Modifiability," where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32352,config,config,32352,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters. Hqutip.qobj; System Hamiltonian. a_opslistNested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eket",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:66077,coupling,couplingto,66077,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['coupling'],['couplingto']
Modifiability," while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28633,config,config,28633,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26625,config,config,26625,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Return type:qutip.solver. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:56672,evolve,evolved,56672,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['evolve'],['evolved']
Modifiability,""" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37683,config,config,37683,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,""" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36886,config,config,36886,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"""""""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:13993,config,config,13993,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,8,['config'],['config']
Modifiability,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:7033,config,configuration,7033,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,2,['config'],['configuration']
Modifiability,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:7033,config,configuration,7033,docs/4.2/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html,6,['config'],['configuration']
Modifiability,"""""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12194,config,config,12194,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,""","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:38605,config,config,38605,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:7648,config,configuration,7648,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['config'],['configuration']
Modifiability,"""Number of trajectories for each process: "" +; str(self.ntrajs)). for i in range(self.nprocs):; p = Process(target=self.evolve_serial,; args=((resq, self.ntrajs[i], i, self.seed * (i + 1)),)); p.start(); processes.append(p); cnt = 0. while True:; try:; sols.append(resq.get()); resq.task_done(); cnt += 1; if (cnt >= self.nprocs):; break; except KeyboardInterrupt:; break; except:; pass. resq.join(); for proc in processes:; try:; proc.join(); except KeyboardInterrupt:; if debug:; print(""Cancel thread on keyboard interrupt""); proc.terminate(); proc.join(); resq.close(); return sols. def serial(self):. if debug:; print(inspect.stack()[0][3]). self.nprocs = 1; self.ntrajs = [self.ntraj]; if debug:; print(""Running in serial.""); print(""Number of trajectories: "" + str(self.ntraj)); sol = self.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:10691,config,config,10691,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:36071,evolve,evolve,36071,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,2,['evolve'],['evolve']
Modifiability,"# ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operator",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38150,config,config,38150,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"# determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28870,config,config,28870,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"############################################################################. __all__ = ['wigner', 'qfunc', 'QFunc', 'spin_q_function',; 'spin_wigner', 'wigner_transform']. import numpy as np; import warnings; from numpy import (; zeros, array, arange, exp, real, conj, pi, copy, sqrt, meshgrid, cos, sin,; ); import scipy.sparse as sp; import scipy.fftpack as ft; import scipy.linalg as la; import scipy.special; from scipy.special import genlaguerre, binom, sph_harm, factorial. import qutip; from qutip import Qobj, ket2dm, jmat; from qutip.parallel import parfor; from qutip.cy.sparse_utils import _csr_get_diag; from qutip.sparse import eigh. def wigner_transform(psi, j, fullparity, steps, slicearray):; """"""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:2972,variab,variable,2972,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,2,['variab'],"['variable', 'variables']"
Modifiability,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:3033,coupling,coupling,3033,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,7,['coupling'],['coupling']
Modifiability,"#########. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, random_integers; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.solver import Options, Result, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:4201,variab,variables,4201,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['variab'],['variables']
Modifiability,"& at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34246,config,config,34246,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30456,config,config,30456,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"'); Out[12]: <matplotlib.text.Text at 0x10d263f90>. In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from qutip import *; import pylab as plt. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = correlation_ss(H, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-correlation.html:6587,coupling,coupling,6587,docs/3.1.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html,1,['coupling'],['coupling']
Modifiability,"', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30495,config,config,30495,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"', 'atan2', 'atanh', 'ceil'; , 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1'; , 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma'; , 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p'; , 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']. Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; >>> H = [H0, [H1, '9 * exp(-(t / 5.) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)':; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e or pi will mess things up when using the string-based format. Collapse operators are handled in the exact same way. Function Based Hamiltonian¶; In the previous version of QuTiP, the simulation of time-dependent problems required writing the Hamiltonian itself as a Python function. However, this method does not allow for time-dependent collapse operators, and is therefore more restrictive. Furthermore, it is less efficient than the other methods for all but the most basic of Hamiltonians (see the next section for a comparison of times.). In this format, the entire Hamiltonian is written as a Python function:; def Hfunc(t, args):; H0 = args[0]; H1 = args[1]; w = 9 * exp(-(t/5.)**2); return H0 - w * H1. where the args variable must always be given, and is now a list of Hamiltonian terms: args=[H0, H1]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:12879,variab,variable,12879,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,4,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30333,config,config,30333,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"', 'lgamma', 'log', 'log10', 'log1p'; , 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']. Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; >>> H = [H0, [H1, '9 * exp(-(t / 5.) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)':; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e or pi will mess things up when using the string-based format. Collapse operators are handled in the exact same way. Function Based Hamiltonian¶; In the previous version of QuTiP, the simulation of time-dependent problems required writing the Hamiltonian itself as a Python function. However, this method does not allow for time-dependent collapse operators, and is therefore more restrictive. Furthermore, it is less efficient than the other methods for all but the most basic of Hamiltonians (see the next section for a comparison of times.). In this format, the entire Hamiltonian is written as a Python function:; def Hfunc(t, args):; H0 = args[0]; H1 = args[1]; w = 9 * exp(-(t/5.)**2); return H0 - w * H1. where the args variable must always be given, and is now a list of Hamiltonian terms: args=[H0, H1]. In this format, our call to the master equation is now:; >>> output = mesolve(Hfunc, psi0, times, c_ops, [a.dag() * a], args=[H0, H1]). We cannot evaluate time-dependent collapse operators in this f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:13160,variab,variables,13160,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['variab'],['variables']
Modifiability,"("":cell(i+1) >""); llt = ''.join(llt); T_inter_cell_s[ir][jr] = llt. H_cell = np.zeros(np.shape(H_cell_s), dtype=complex); T_inter_cell = np.zeros(np.shape(T_inter_cell_s), dtype=complex); return (H_cell_s, T_inter_cell_s, H_cell, T_inter_cell). [docs]class Lattice1d():; """"""A class for representing a 1d crystal. The Lattice1d class can be defined with any specific unit cells and a; specified number of unit cells in the crystal. It can return dispersion; relationship, position operators, Hamiltonian in the position represention; etc. Parameters; ----------; num_cell : int; The number of cells in the crystal.; boundary : str; Specification of the type of boundary the crystal is defined with.; cell_num_site : int; The number of sites in the unit cell.; cell_site_dof : list of int/ int; The tensor structure of the degrees of freedom at each site of a unit; cell.; Hamiltonian_of_cell : qutip.Qobj; The Hamiltonian of the unit cell.; inter_hop : qutip.Qobj / list of Qobj; The coupling between the unit cell at i and at (i+unit vector). Attributes; ----------; num_cell : int; The number of unit cells in the crystal.; cell_num_site : int; The nuber of sites in a unit cell.; length_for_site : int; The length of the dimension per site of a unit cell.; cell_tensor_config : list of int; The tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]; lattice_tensor_config : list of int; The tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]; length_of_unit_cell : int; The length of the dimension for a unit cell.; period_bnd_cond_x : int; 1 indicates ""periodic"" and 0 indicates ""hardwall"" boundary condition; inter_vec_list : list of list; The list of list of coefficients of inter unitcell vectors' components; along Cartesian uit vectors.; lattice_vectors_list : list of list; The list of list of coefficients of lattice basis vectors' components; along Cartesian unit vectors.; H_intra : qutip.Qobj; The Qobj storing the Hamilton",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/lattice.html:7923,coupling,coupling,7923,docs/4.5/modules/qutip/lattice.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/lattice.html,3,['coupling'],['coupling']
Modifiability,"((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _comple",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18792,config,config,18792,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html:13197,enhance,enhanced,13197,docs/3.0.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html,1,['enhance'],['enhanced']
Modifiability,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:13135,enhance,enhanced,13135,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,1,['enhance'],['enhanced']
Modifiability,"(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) +",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17055,coupling,coupling,17055,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability,"(; Q=Q, lam=lam, gamma=gamma, T=T,; ). [docs] def terminator(self):; """"""; Return the Matsubara terminator for the bath and the calculated; approximation discrepancy. Returns; -------; delta: float. The approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the ``Nk`` exponential terms is approximately ``2 * delta *; dirac(t)``, where ``dirac(t)`` denotes the Dirac delta function. terminator : Qobj. The Matsubara terminator -- i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond ``Nk``. It should be used by adding it to; the system liouvillian (i.e. ``liouvillian(H_sys)``).; """"""; delta, L = self._dl_terminator.terminator(self.exponents); return delta, L. def _matsubara_params(self, lam, gamma, T, Nk):; """""" Calculate the Matsubara coefficents and frequencies. """"""; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class DrudeLorentzPadeBath(BosonicBath):; """"""; A helper class for constructing a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`DrudeLorentzBath` wh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:11173,extend,extend,11173,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['extend'],['extend']
Modifiability,"(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_results, expt_callback, options, n_expt_op = _e_ops_outputs(; krylov_results, e_ops, n_tlist_steps, options; ). # parameters for the lazy iteration evolve tlist; psi_norm = np.linalg.norm(_psi); last_t = t0. for idx, partition in enumerate(partitions):. evolved_states = _evolve_krylov_tlist(; H=_H,; psi0=_psi,; krylov_dim=dim_m,; tlist=partition,; t0=last_t,; psi_norm=psi_norm,; krylov_basis=krylov_basis,; T_m=T_m,; sparse=sparse,; ). if idx == 0:; krylov_basis = None; T_m = None; t_idx = 0. _psi = evolved_states[-1]; psi_norm = np.linalg.norm(_psi); last_t = partition[-1]. # apply qobj to each evolved state, remove repeated tail elements; qobj_evolved_states = [; Qobj(state, dims=psi0.dims) for state in evolved_states[1:-1]; ]. krylov_results = _expectation_values(; e_ops,; n_expt_op,; expt_callback,; krylov_results,; qobj_evolved_states,; partitions,; idx,; t_idx,; options,; ). t_idx += len(partition[1:-1]). pbar.update(idx). pbar.finished(). if e_ops_dict:; krylov_results.expect = {; e: krylov_results.expect[n]; for n, e in enumerate(e_ops_dict.keys()); }. return krylov_results. def _expectation_values(; e_ops,; n_expt_op,; expt_callback,; res,; evolved_states,; partitions,; idx,; t_idx,; options,; ):. if options.store_states:; res.states += evolved_states. for t, state in zip(; range(t_idx, t_idx + len(partitions[idx][1:-1])), evolved_states; ):. if expt_callback:; # use callback method; res.expect.append(e_ops(t, state)). for m in range(n_expt_op):; op = e_ops[m]; if not isinstance(op, Qobj) and callable(op):; res.expect[m][t] = op(t, state); continue. res.expect[m][t] = expect(op, state). if (; idx == len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:5963,evolve,evolved,5963,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['evolve'],['evolved']
Modifiability,"(H, rho0, c_ops, e_ops, args); ; ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check whether c_ops or e_ops is is a single operator; # if so convert it to a list containing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:9645,config,config,9645,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:35596,config,config,35596,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,2,['config'],['config']
Modifiability,"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2841,config,config,2841,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability,"(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:20013,config,config,20013,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38617,config,config,38617,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36919,config,config,36919,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35917,config,config,35917,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29808,config,config,29808,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9841,config,config,9841,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"(config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_z",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:24007,config,config,24007,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"(e2); groups.append(group). new_exponents = []; for combine in groups:; exp1 = combine[0]; if (exp1.type != exp1.types.RI) and all(; exp2.type == exp1.type for exp2 in combine; ):; # the group is either type I or R; ck = sum(exp.ck for exp in combine); new_exponents.append(BathExponent(; exp1.type, None, exp1.Q, ck, exp1.vk, tag=exp1.tag,; )); else:; # the group includes both type I and R exponents; ck_R = (; sum(exp.ck for exp in combine if exp.type == exp.types.R) +; sum(exp.ck for exp in combine if exp.type == exp.types.RI); ); ck_I = (; sum(exp.ck for exp in combine if exp.type == exp.types.I) +; sum(exp.ck2 for exp in combine if exp.type == exp.types.RI); ); new_exponents.append(BathExponent(; ""RI"", None, exp1.Q, ck_R, exp1.vk, ck2=ck_I,; tag=exp1.tag,; )). return new_exponents. [docs]class DrudeLorentzBath(BosonicBath):; """"""; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). self._dl_terminator = _DrudeLorentzTerminator(; Q=Q, lam=lam, gamma=gamma, T=T,; ). [docs] def terminator(self):; """"""; Re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:9280,coupling,coupling,9280,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability,"(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zer",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15946,config,config,15946,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zer",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16938,config,config,16938,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:33095,config,config,33095,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"(out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:30193,config,config,30193,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:7976,coupling,coupling,7976,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,1,['coupling'],['coupling']
Modifiability,") != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:34871,variab,variable,34871,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['variab'],['variable']
Modifiability,") * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). (png, hires.png, pdf). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 and later, P.D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17636,coupling,coupling,17636,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability,") * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.dat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31858,config,config,31858,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,") ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15240,config,config,15240,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,") ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16232,config,config,16232,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,") +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup cons",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:38384,config,config,38384,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,") and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat[t_idx, :] += \; 1/(4*options.ntraj[0]) * (c_tau[0] - c_tau[2] -; 1j*c_tau[1] + 1j*c_tau[3]); if t_idx == 1:; options.rhs_reuse = True. return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.tran",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:36776,evolve,evolve,36776,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['evolve'],['evolve']
Modifiability,"))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # ------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:14884,config,config,14884,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15141,config,config,15141,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['config'],['config']
Modifiability,")),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:9537,extend,extend,9537,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,5,['extend'],['extend']
Modifiability,")); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:31564,config,config,31564,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,")); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30544,config,config,30544,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,")); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8355,config,config,8355,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26841,config,config,26841,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:27844,config,config,27844,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeffs (PulseGenCrab attribute). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). col_times (Result attribute). col_which (Result attribute). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). config (Optimizer attribute). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method), [1]. controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method), [1]. coup_op (HEOMSolver attribute). coup_strength (HEOMSolver attribute). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:3599,config,config,3599,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['config'],['config']
Modifiability,"). def _check_coup_op(self, Q):; if not isinstance(Q, Qobj):; raise ValueError(""The coupling operator Q must be a Qobj.""). def __init__(self, Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=None):; self._check_cks_and_vks(ck_plus, vk_plus, ck_minus, vk_minus); self._check_coup_op(Q). exponents = []; for ckp, vkp, ckm, vkm in zip(ck_plus, vk_plus, ck_minus, vk_minus):; exponents.append(BathExponent(; ""+"", 2, Q, ckp, vkp, sigma_bar_k_offset=1, tag=tag,; )); exponents.append(BathExponent(; ""-"", 2, Q, ckm, vkm, sigma_bar_k_offset=-1, tag=tag,; )); super().__init__(exponents). [docs]class LorentzianBath(FermionicBath):; """"""; A helper class for constructing a Lorentzian fermionic bath from the; bath parameters (see parameters below). .. note::. This Matsubara expansion used in this bath converges very slowly; and ``Nk > 20`` may be required to get good convergence. The; Padé expansion used by :class:`LorentzianPadeBath` converges much; more quickly. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(self, Q, gamma, w, mu, T, Nk, tag=None):; ck_plus, vk_plus = self._corr(gamma, w, mu, T, Nk, sigma=1.0); ck_minus, vk_minus = self._corr(gamma, w, mu, T, Nk, sigma=-1.0). super().__init__(; Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=tag,; ). def _corr(self, gamma, w, mu, T, Nk, sigma):; beta = 1. / T; kappa = [0.]; kappa.extend([1. for _ in range(1, Nk + 1)]); epsilon = [0]; epsilon.extend([(2 * ll - 1) * np.pi for ll in range(1, Nk + 1)]). def f(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:21694,coupling,coupling,21694,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability,"):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:14938,config,config,14938,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wav",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15195,config,config,15195,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['config'],['config']
Modifiability,"); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:7492,config,config,7492,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,4,['config'],['config']
Modifiability,"); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9739,variab,variable,9739,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['variab'],"['variable', 'variables']"
Modifiability,"); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21019,config,config,21019,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class DrudeLorentzPadeBath(BosonicBath):; """"""; A helper class for constructing a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`DrudeLorentzBath` which constructs; a simpler exponential expansion. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of Padé exponentials terms used to approximate the bath; correlation functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, T, Nk, combine=True, tag=None; ):; eta_p, gamma_p = self._corr(lam=lam, gamma=gamma, T=T, Nk=Nk). ck_real = [np.real(eta) for eta in eta_p]; vk_real = [gam for gam in gamma_p]; # There is only one term in the expansion of the imaginary part of the; # Drude-Lorentz correlation function.; ck_imag = [np.imag(eta_p[0])]; vk_imag = [gamma_p[0]].",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:12298,coupling,coupling,12298,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability,")\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = linspace(0, 100, 5000); corr = correlation_ss(H, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum_ss, which internally uses essolve; # to solve for the dynamics; wlist2 = linspace(0.25, 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-correlation.html:6094,coupling,coupling,6094,docs/3.0.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html,2,['coupling'],['coupling']
Modifiability,"*2 / (4 * Om),; -1.0j * lam**2 / (4 * Om),; ]. vk_imag = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class FermionicBath(Bath):; """"""; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the ``+`` and ``-`` modes of; the bath correlation function. There must be the same number of ``+`` and ``-`` modes and their; coefficients must be specified in the same order so that ``ck_plus[i],; vk_plus[i]`` are the plus coefficient and frequency corresponding; to the minus mode ``ck_minus[i], vk_minus[i]``. In the fermionic case the order in which excitations are created or; destroyed is important, resulting in two different correlation functions; labelled ``C_plus(t)`` and ``C_plus(t)``::. C_plus(t) = sum(ck_plus * exp(- vk_plus * t)); C_minus(t) = sum(ck_minus * exp(- vk_minus * t)). where the expansions above define the coeffiients ``ck`` and the; frequencies ``vk``. Parameters; ----------; Q : Qobj; The coupling operator for the bath. ck_plus : list of complex; The coefficients of the expansion terms for the ``+`` part of the; correlation function. The corresponding frequencies are passed as; vk_plus. vk_plus : list of complex; The frequencies (exponents) of the expansion terms for the ``+`` part; of the correlation function. The corresponding ceofficients are passed; as ck_plus. ck_minus : list of complex; The coefficients of the expansion terms for the ``-`` part of the; correlation function. The corresponding frequencies are passed as; vk_minus. vk_minus : list of complex; The frequencies (exponents) of the expansion terms for the ``-`` part; of the correlation function. The corresponding ceofficients are passed; as ck_minus. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """""". def _check_cks_and_vks(self, ck_plus, vk_plus, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:19210,coupling,coupling,19210,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability,"+ str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:38035,config,config,38035,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"+ str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-depende",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37074,config,config,37074,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"+; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20664,config,config,20664,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,", 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27423,config,config,27423,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28426,config,config,28426,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,", 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27363,config,config,27363,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28366,config,config,28366,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,", INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Original Code by Arne Grimsmo (2012): github.com/arnelg/qutipf90mc; ###############################################################################. import numpy as np. from qutip.fortran import qutraj_run as qtf90; from qutip.qobj import Qobj; from qutip.mcsolve import _mc_data_config; from qutip.solver import Options, Result, config; from qutip.settings import debug; import qutip.settings. if debug:; import inspect; import os. # Working precision; wpr = np.dtype(np.float64); wpc = np.dtype(np.complex128). [docs]def mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None,; options=Options(), sparse_dms=True, serial=False,; ptrace_sel=[], calc_entropy=False):; """"""; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters; ----------; H : qobj; System Hamiltonian.; psi0 : qobj; Initial state vector; tlist : array_like; Times at which results are recorded.; ntraj : int; Number of trajectories to run.; c_ops : array_like; ``list`` or ``array`` of collapse operators.; e_ops : array_like; ``list`` or ``array`` of operators for calculating expectation values.; options : Options; Instance of solver options.; sparse_dms : boolean; If averaged density matrices are returned, they will be s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:3587,config,config,3587,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,", Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12701,config,config,12701,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,", \(C_{real}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,real} &= \begin{cases}; \gamma & k = 0\\; {2 \pi k} / {\beta } & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and the imaginary part, \(C_{imag}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; And now the same numbers calculated in Python:; # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:; from qutip.nonmarkov.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we’re done!; The BosonicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths¶; The HEOMSolver supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath.; In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the Fe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:9882,extend,extend,9882,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,1,['extend'],['extend']
Modifiability,", c_ops, a_op, b_op,; solver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadysta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:30708,config,config,30708,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,8,['config'],['config']
Modifiability,", config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # ------------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15471,config,config,15471,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # ------------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16463,config,config,16463,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,", config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15219,config,config,15219,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16211,config,config,16211,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,", config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17158,config,config,17158,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,", dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:196087,variab,variable,196087,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['variab'],['variable']
Modifiability,", globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<strin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28301,config,config,28301,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:73305,coupling,coupling,73305,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,", psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:9739,variab,variable,9739,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['variab'],"['variable', 'variables']"
Modifiability,", self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html:30325,variab,variables,30325,docs/4.4/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html,1,['variab'],['variables']
Modifiability,", tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:32071,config,config,32071,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['config'],['config']
Modifiability,", tlist: numpy.array, krylov_dim: int, e_ops=None, options=None, progress_bar: Optional[bool] = None, sparse: bool = False)[source]¶; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (“psi0”) finding an approximation for the time; evolution operator of Hamiltonian (“H”) by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)).; The output is either the state vector or the expectation values of; supplied operators (“e_ops”) at arbitrary points at (“tlist”).; Additional options; Additional options to krylovsolve can be set with the following:. “store_states”: stores states even though expectation values are; requested via the “e_ops” argument.; “store_final_state”: store final state even though expectation values are; requested via the “e_ops” argument. Parameters. Hqutip.QobjSystem Hamiltonian. psi0:class: qutip.QobjInitial state vector (ket). tlistNone / list / arrayList of times on which to evolve the initial state. If None, nothing; happens but the code won’t break. krylov_dim: intDimension of Krylov approximation subspaces used for the time; evolution approximation. e_opsNone / list of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. optionsOptions; Instance of ODE solver options, as well as krylov parameters.; atol: controls (approximately) the error desired for the finalsolution. (Defaults to 1e-8). nsteps: maximum number of krylov’s internal number of Lanczositerations. (Defaults to 10000). progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. sparsebool (default False)Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array result.expect of expectation values for the times; tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:92004,evolve,evolve,92004,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['evolve'],['evolve']
Modifiability,",; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29455,config,config,29455,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,",; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15858,config,config,15858,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,",; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16850,config,config,16850,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,",; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:13933,config,configurability,13933,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['config'],['configurability']
Modifiability,"-----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19789,config,config,19789,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"---------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23244,config,config,23244,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"----------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19975,config,config,19975,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"---------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22258,config,config,22258,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"---------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23379,config,config,23379,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"---------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22393,config,config,22393,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamilton",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14622,config,config,14622,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamilton",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15614,config,config,15614,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"----------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23268,config,config,23268,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14756,config,config,14756,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15748,config,config,15748,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13051,config,config,13051,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.succ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17422,config,config,17422,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"-----------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19804,config,config,19804,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"----------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22282,config,config,22282,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9165,config,config,9165,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"----------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25954,config,config,25954,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"-------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14777,config,config,14777,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15769,config,config,15769,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.ps",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19823,config,config,19823,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"-----------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14644,config,config,14644,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-----------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15636,config,config,15636,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-----------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; sel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12052,config,config,12052,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-----------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23291,config,config,23291,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"---------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:14356,config,config,14356,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['config'],['config']
Modifiability,"--------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17296,config,config,17296,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"-------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:33976,config,config,33976,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32967,config,config,32967,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-----------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22305,config,config,22305,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"----------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13173,config,config,13173,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32570,config,config,32570,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"---------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38194,config,config,38194,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"---------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12174,config,config,12174,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29653,config,config,29653,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-----------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25976,config,config,25976,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"--------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14665,config,config,14665,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15657,config,config,15657,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17482,config,config,17482,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:29101,config,config,29101,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['config'],['config']
Modifiability,"---; type : {""R"", ""I"", ""RI"", ""+"", ""-""} or BathExponent.ExponentType; The type of bath exponent. ""R"" and ""I"" are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion. ""RI"" is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single ``vk``. The ``ck`` is the coefficient in the real; expansion and ``ck2`` is the coefficient in the imaginary expansion. ""+"" and ""-"" are fermionic bath exponents. These fermionic bath; exponents must specify ``sigma_bar_k_offset`` which specifies; the amount to add to ``k`` (the exponent index within the bath of this; exponent) to determine the ``k`` of the corresponding exponent with; the opposite sign (i.e. ""-"" or ""+""). dim : int or None; The dimension (i.e. maximum number of excitations for this exponent).; Usually ``2`` for fermionic exponents or ``None`` (i.e. unlimited) for; bosonic exponents. Q : Qobj; The coupling operator for this excitation mode. vk : complex; The frequency of the exponent of the excitation term. ck : complex; The coefficient of the excitation term. ck2 : optional, complex; For exponents of type ""RI"" this is the coefficient of the term in the; imaginary expansion (and ``ck`` is the coefficient in the real; expansion). sigma_bar_k_offset : optional, int; For exponents of type ""+"" this gives the offset (within the list of; exponents within the bath) of the corresponding ""-"" bath exponent.; For exponents of type ""-"" it gives the offset of the corresponding; ""+"" exponent. tag : optional, str, tuple or any other object; A label for the exponent (often the name of the bath). It; defaults to None. Attributes; ----------. All of the parameters are available as attributes.; """"""; types = enum.Enum(""ExponentType"", [""R"", ""I"", ""RI"", ""+"", ""-""]). def _check_ck2(self, type, ck2):; if type == self.types[""RI""]:; if ck2 is None:; raise ValueError(""RI bath exponents require ck2""); else:; if ck2 is not",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:2086,coupling,coupling,2086,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability,"-. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14815,config,config,14815,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15807,config,config,15807,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args, options=copy(options)). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None,; options=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:4130,variab,variables,4130,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,1,['variab'],['variables']
Modifiability,"-; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():; As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; In [3]: options = Options(). In [4]: options.num_cpus = 3. In [5]: options.atol = 1e-10. or one can use an inline method,; In [6]: options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [7]: print(options); Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-options.html:2599,variab,variable,2599,docs/4.5/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-options.html,1,['variab'],['variable']
Modifiability,"-; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():; As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; In [3]: options = Options(). In [4]: options.num_cpus = 3. In [5]: options.atol = 1e-10. or one can use an inline method,; In [6]: options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [7]: print(options); Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-options.html:2574,variab,variable,2574,docs/4.4/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-options.html,1,['variab'],['variable']
Modifiability,"-Based Time-Dependent Problems using Parfor. Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:1682,coupling,coupling,1682,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,2,['coupling'],['coupling']
Modifiability,"-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:16222,coupling,coupling,16222,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['coupling'],['coupling']
Modifiability,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-control.html:13564,variab,variable,13564,docs/4.3/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html,1,['variab'],['variable']
Modifiability,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-control.html:13562,variab,variable,13562,docs/4.4/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-control.html,3,['variab'],['variable']
Modifiability,". . qutip.qip.pulse — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; from copy import deepcopy. import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`qutip.qip.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = QobjEvo(ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:719,variab,variables,719,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,1,['variab'],['variables']
Modifiability,". H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); self.H = self.dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; including the -i factor; """"""; return -1j*self.dyn_gen[k]. [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; including the -i factor; """"""; return -1j*self.ctrl_dyn_gen[j]. def get_num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); return Dynamics.get_num_ctrls(self). def get_owd_evo_target(self):; return self.target.conj().T. [docs] def spectral_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:24102,config,configuration,24102,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['configuration']
Modifiability,". Montenegro et al., ""Macroscopic nonclassical-state preparation via postselection"", ; Phys. Rev. A 96, 053851 (2017). 243. Cirio et al., ""Amplified Optomechanical Transduction of Virtual Radiation Pressure"", ; Phys. Rev. Lett. 119, 053601 (2017). 242. Romero et al., ""Quantum autoencoders for efficient compression of quantum data"", ; Quantum Sci. Technol. 2, 045001 (2017). 241. Zhong, ""Controllable and fast quantum-information transfer between distant nodes in two-dimensional networks"", ; Sci. Rep. 6, 8 (2016). 240. Guo et al., ""Giant acoustic atom: A single quantum system with a deterministic time delay"", ; Phys. Rev. A 95, 053821 (2017). 239. Vermersch et al., ""Quantum State Transfer via Noisy Photonic and Phononic Waveguides"", ; Phys. Rev. Lett. 118, 133601 (2017). 238. Gudmundsson et al., ""Time-dependent current into and through multilevel parallel quantum dots in a photon cavity"", ; Phys. Rev. B 95, 195307 (2017). 237. Braumüller et al., ""Analog quantum simulation of the Rabi model in the ultra-strong coupling regime"", ; Nat. Commun. 8, 779 (2017). 236. Lagoudakis et al., ""Ultrafast coherent manipulation of trions in site-controlled nanowire quantum dots"", ; Optica 3, 1430 (2016). 235. Roghani et al., ""Dissipative Preparation of Entangled Many-Body States with Rydberg Atoms"", ; arXiv:1611.09612. 234. Lambert et al., ""Superradiance with an ensemble of superconducting flux qubits"", ; Phys. Rev. B 94, 224510 (2016). 233. Yanay et al., ""Shelving-style QND phonon-number detection in quantum optomechanics"", ; New J. Phys. 19, 033014 (2017). 232. Kirton et al., ""Suppressing and Restoring the Dicke Superradiance Transition by Dephasing and Decay"", ; Phys. Rev. Lett. 118, 123602 (2017). 231. Fischer et al., ""On-Chip Architecture for Self-Homodyned Nonclassical Light"", ; Phys. Rev. Applied 7, 044002 (2017).; Notebook. 230. Combes et al., ""The SLH framework for modeling quantum input-output networks"", ; Advances in Physics: X 2, 784 (2017). 229. Lucarelli, ""Quantum optimal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:17726,coupling,coupling,17726,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,". The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossib",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:6817,variab,variables,6817,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,12,['variab'],"['variable', 'variables']"
Modifiability,". Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:7704,enhance,enhancements,7704,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['enhance'],['enhancements']
Modifiability,". amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fideli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:7447,variab,variable,7447,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,2,['variab'],['variable']
Modifiability,". amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control ampli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:16182,variab,variable,16182,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['variab'],['variable']
Modifiability,". property dumping¶. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:79026,variab,variables,79026,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['variab'],['variables']
Modifiability,". qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestrName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:207747,variab,variables,207747,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:722,config,config,722,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,1,['config'],['config']
Modifiability,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:461,variab,variable,461,docs/4.7/modules/qutip/continuous_variables.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html,1,['variab'],['variable']
Modifiability,". qutip.control.fidcomp — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.fidcomp. Source code for qutip.control.fidcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling wi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html:954,config,configuration,954,docs/4.7/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html,1,['config'],['configuration']
Modifiability,". qutip.control.pulseoptim — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:654,config,configuration,654,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['config'],['configuration']
Modifiability,". qutip.control.stats — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.stats. Source code for qutip.control.stats; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/stats.html:827,config,configurations,827,docs/4.7/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/stats.html,1,['config'],['configurations']
Modifiability,". qutip.matplotlib_utilities — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.matplotlib_utilities. Source code for qutip.matplotlib_utilities; """"""; This module contains utility functions that enhance Matplotlib; in one way or another.; """""". __all__ = ['wigner_cmap', 'MidpointNorm', 'complex_phase_cmap']. import numpy as np. try:; import matplotlib as mpl; from matplotlib import cm; from matplotlib.colors import (Normalize, ColorConverter); except:; class Normalize(object):; def __init__(self, vmin=None, vmax=None, clip=False):; pass. [docs]def wigner_cmap(W, levels=1024, shift=0, max_color='#09224F',; mid_color='#FFFFFF', min_color='#530017',; neg_color='#FF97D4', invert=False):; """"""A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters; ----------; W : array; Wigner function array, or any array.; levels : int; Number of color levels to create.; shift : float; Shifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5).; max_color : str; String for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter.; mid_color : str; Color corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter.; min_color : str; Color corresponding to minimum data values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter.; neg_color : str; Color that starts highlighting negative values. Accepts any string; format compatible with the Matplotlib.colors.ColorConverter.; invert : bool; Invert the color scheme for negative values so that smaller negative; values have darker color. Returns; -------; Returns ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html:434,enhance,enhance,434,docs/4.7/modules/qutip/matplotlib_utilities.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html,1,['enhance'],['enhance']
Modifiability,". qutip.qip.pulse — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = QobjEvo(mat, tlist=self.tl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:712,variab,variables,712,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,1,['variab'],['variables']
Modifiability,". qutip.qip.pulse — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/pulse.html:737,variab,variables,737,docs/4.7/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/pulse.html,1,['variab'],['variables']
Modifiability,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:573,config,config,573,docs/4.7/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,". qutip.scattering — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.scattering. Source code for qutip.scattering; """"""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/scattering.html:542,config,configuration,542,docs/4.7/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html,1,['config'],['configuration']
Modifiability,". qutip.sesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.sesolve. Source code for qutip.sesolve; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/sesolve.html:928,config,config,928,docs/4.7/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,". qutip.three_level_atom — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.three_level_atom. Source code for qutip.three_level_atom; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html:661,config,configuration,661,docs/4.7/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html,2,['config'],"['configuration', 'configurations']"
Modifiability,".'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:13623,coupling,coupling,13623,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,3,['coupling'],['coupling']
Modifiability,".'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:17083,coupling,coupling,17083,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability,"., ""Influence of the asymmetric excited state decay on coherent population trapping: atom × quantum dot"", ; arXiv:1702.07692. 266. Pleinert et al., ""Hyperradiance from collective behavior of coherently driven atoms"", ; Optica 4, 779 (2017). 265. Oviedo-Casado et al., ""Magnetic field enhancement of organic photovoltaic cells performance"", ; Sci. Rep. 7, 4297 (2017). 264. Whalen et al., ""Open quantum systems with delayed coherent feedback"", ; Quantum Sci. Technol. 2, 044008 (2017). 263. Cottet et al., ""Observing a quantum Maxwell demon at work"", ; Proc. Natl. Acad. Sci. U.S.A. 114, 7561 (2017). 262. Mazloom et al., ""Adiabatic state preparation of stripe phases with strongly magnetic atoms"", ; Phys. Rev. A 96, 033602 (2017). 261. Poonia et al., ""Functional window of the avian compass"", ; Phys. Rev. E 95, 052417 (2017). 260. Su et al., ""Generating double NOON states of photons in circuit QED"", ; Phys. Rev. A 95, 022339 (2017). 259. Kiukas et al., ""Remote parameter estimation in a quantum spin chain enhanced by local control"", ; Phys. Rev. A 95, 052132 (2017). 258. Gely et al., ""Convergence of the multimode quantum Rabi model of circuit quantum electrodynamics"", ; Phys. Rev. B 95, 245115 (2017). 257. Radtke et al., ""Photonic Quantum Operations via the Quantum Carburettor Effect"", ; arXiv:1701.04251. 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 54",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:14722,enhance,enhanced,14722,users.html,https://qutip.org,https://qutip.org/users.html,1,['enhance'],['enhanced']
Modifiability,".PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:35218,variab,variable,35218,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['variab'],['variable']
Modifiability,".Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:5014,config,config,5014,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,".X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:4795,adapt,adaptive,4795,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['adapt'],['adaptive']
Modifiability,"._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:16033,config,config,16033,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,5,['config'],['config']
Modifiability,"._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:14786,config,config,14786,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['config'],['config']
Modifiability,"._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.le",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:16001,config,config,16001,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,"._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28679,config,config,28679,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11269,config,config,11269,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,".append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if iske",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:20099,config,config,20099,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,".append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'); ; ; for kk, c in enumerate(c_ops):; if isinstance(c, Qobj):; C_terms.append(c.full('f')); C_td_terms.append('1'); elif isinstance(c, list):; C_terms.append(c[0].full('f')); if isinstance(c[1], Cubic_Spline):; CA_obj.append(c[1].coeffs); spline_count[0] += 1; C_td_terms.append(c[1]); else:; raise Exception('Invalid collape operator specification.'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:16534,coupling,coupling,16534,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability,".append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27998,config,config,27998,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; glo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29001,config,config,29001,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,".array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15775,config,config,15775,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16767,config,config,16767,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,".average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:24065,config,config,24065,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,".dims = op.dims; for i in range(1, l):; h = qt.tensor(I, h); for i in range(l+1, k+1):; h = qt.tensor(h, I); return h. def _genptrace(E, k):; """"""; Perform a gneralized partial trace on a superoperator E, tracing out all; subsystems but one.; """"""; for l in range(k-1):; nsys = len(E.dims[0][0]); E = qt.tensor_contract(E, (0, 2*nsys+1), (nsys, 3*nsys+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:11616,coupling,coupling,11616,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,8,['coupling'],['coupling']
Modifiability,".environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number of cores; from qutip.hardware_info import hardware_info; info = hardware_info(); if 'cpus' in info:; qutip.settings.num_cpus = info['cpus']; else:; qutip.settings.num_cpus = multiprocessing.cpu_count(). # -----------------------------------------------------------------------------; # Load configuration from environment variables: override defaults and; # configuration file.; #. # check for fortran mcsolver files; try:; from qutip.fortran import mcsolve_f90; except:; qutip.settings.fortran = False; else:; qutip.settings.fortran = True. # check for scikits.umfpack; try:; import scikits.umfpack as umfpack; except:; qutip.settings.umfpack = False; else:; qutip.settings.umfpack = True; del umfpack; # -----------------------------------------------------------------------------; # Check that import modules are compatible with requested configuration; #. # Check for Matplotlib; try:; import matplotlib; except:; warnings.warn(""matplotlib not found: Graphics will not work.""); else:; del matplotlib. # -----------------------------------------------------------------------------; # Clean name space; #; del os, sys, numpy, scipy, multiprocessing. # -----------------------------------------------------------------------------; # Load modules; #. # core; from qutip.qobj import *; from qutip.states import *; from qutip.operators import *; from qutip.expect import *; from qutip.tensor import *; from qutip.superoperator import *; from qutip.superop_reps import *; from qutip.subsystem_apply import *; from qutip.graph import *. # graphics; from qutip.bloch import *; from qutip.visualization import *; from qutip.orbital import *; from qutip.bloch3d import *; from qutip.matplotlib_utilities import *. # library functions; from qutip.tomography import *; from ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:8116,config,configuration,8116,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['config'],['configuration']
Modifiability,".evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True. def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:20149,config,config,20149,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,4,['config'],['config']
Modifiability,".evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:18812,config,config,18812,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,3,['config'],['config']
Modifiability,".evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:20163,config,config,20163,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,".expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = vec2mat(r.y). if opt.store_states:; output.states.append(Qobj(rho)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = vec2mat(r.y); output.final_state = Qobj(rho). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:26481,config,config,26481,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,".figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-bloch-redfield.html:18379,coupling,coupling,18379,docs/4.4/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability,".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_va",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15004,config,config,15004,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,6,['config'],['config']
Modifiability,".g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12062,config,config,12062,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,".get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:68951,config,config,68951,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,1,['config'],['config']
Modifiability,".h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in rang",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34141,config,config,34141,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:3098,variab,variables,3098,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['variab'],['variables']
Modifiability,".map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7748,config,config,7748,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,".method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25021,config,config,25021,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,".parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_leve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:29260,variab,variables,29260,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['variab'],['variables']
Modifiability,".qutraj_run.csr_col - 1; ptr = qtf90.qutraj_run.csr_ptr - 1; m = qtf90.qutraj_run.csr_nrows; k = qtf90.qutraj_run.csr_ncols; states[i] = Qobj(csr_matrix((val, col, ptr),; (m, k)).toarray(),; dims=self.dm_dims, shape=self.dm_shape); else:; # averaged dense density matrices; for i in range(nstep):; states[i] = Qobj(qtf90.qutraj_run.sol[0, i, :, :],; dims=self.dm_dims, shape=self.dm_shape); else:; # all trajectories as kets; if (ntraj == 1):; states = np.array([Qobj()] * nstep, dtype=object); for i in range(nstep):; states[i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, 0, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); else:; states = np.array([np.array([Qobj()] * nstep, dtype=object)] *; ntraj); for traj in range(ntraj):; for i in range(nstep):; states[traj][i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, traj, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); return states. def get_expect(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). if (config.options.average_expect):; expect = []; for j in range(config.e_num):; if config.e_ops_isherm[j]:; expect += [np.real(qtf90.qutraj_run.sol[j, 0, :, 0])]; else:; expect += [qtf90.qutraj_run.sol[j, 0, :, 0]]; else:; expect = np.array([[np.array([0. + 0.j] * nstep)] *; config.e_num] * ntraj); for j in range(config.e_num):; expect[:, j, :] = qtf90.qutraj_run.sol[j, :, :, 0]; return expect. def get_entropy(self, nstep):. if debug:; print(inspect.stack()[0][3]). if (not self.calc_entropy):; raise Exception('get_entropy: calc_entropy=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:15438,config,config,15438,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,".shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.meth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23026,config,config,23026,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19561,config,config,19561,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,".steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23586,config,config,23586,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13064,config,configuration,13064,docs/4.3/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html,5,['config'],['configuration']
Modifiability,".use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum ev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12446,config,config,12446,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,"/ val for val in evals[0: Nk - 1]]; return chi. class _DrudeLorentzTerminator:; """""" A class for calculating the terminator of a Drude-Lorentz bath; expansion.; """"""; def __init__(self, Q, lam, gamma, T):; self.Q = Q; self.lam = lam; self.gamma = gamma; self.T = T. def terminator(self, exponents):; """""" Calculate the terminator for a Drude-Lorentz bath. """"""; Q = self.Q; lam = self.lam; gamma = self.gamma; beta = 1 / self.T. delta = 2 * lam / (beta * gamma) - 1j * lam. for exp in exponents:; if exp.type == BathExponent.types[""R""]:; delta -= exp.ck / exp.vk; elif exp.type == BathExponent.types[""RI""]:; delta -= (exp.ck + 1j * exp.ck2) / exp.vk; else:; delta -= 1j * exp.ck / exp.vk. op = -2*spre(Q)*spost(Q.dag()) + spre(Q.dag()*Q) + spost(Q.dag()*Q); L_bnd = -delta * op. return delta, L_bnd. [docs]class UnderDampedBath(BosonicBath):; """"""; A helper class for constructing an under-damped bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. w0 : float; Bath spectral density resonance frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, w0, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; w0=w0,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). def _matsubara_params(self, lam, gamma, w0, T, Nk):; """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:16572,coupling,coupling,16572,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability,"/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 201",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:36066,config,config,36066,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"0)\right>$'); Out[12]: Text(0,0.5,'Correlation $\\left<x(t)x(0)\\right>$'). In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; import pylab as plt; from qutip import *. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-correlation.html:5784,coupling,coupling,5784,docs/4.5/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-correlation.html,1,['coupling'],['coupling']
Modifiability,"0, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_ou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18353,config,config,18353,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:1663,enhance,enhancements,1663,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,1,['enhance'],['enhancements']
Modifiability,"0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [14]: psi0 = basis(2,1). In [15]: H = sigmaz(). In [16]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [18]: es; Out[18]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-eseries.html:6440,evolve,evolved,6440,docs/3.1.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html,1,['evolve'],['evolved']
Modifiability,"0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [16]: psi0 = basis(2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [20]: es; Out[20]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-eseries.html:6343,evolve,evolved,6343,docs/3.0.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html,2,['evolve'],['evolved']
Modifiability,"0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if nece",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7813,config,config,7813,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13030,config,config,13030,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:2201,coupling,coupling,2201,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['coupling'],['coupling']
Modifiability,"1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.meth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:24029,config,config,24029,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19328,config,config,19328,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"1.0"". elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolutio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12152,config,config,12152,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string. Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:173518,variab,variable,173518,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['variab'],['variable']
Modifiability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict. Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string. Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:182149,variab,variable,182149,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['variab'],['variable']
Modifiability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:188319,variab,variable,188319,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variable']
Modifiability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:196954,variab,variable,196954,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variable']
Modifiability,"116, 237203 (2016). 125. Verdon-Akzam et al., ""Asymptotically limitless quantum energy teleportation via qudit probes"", ; Phys. Rev. A 93, 022308 (2016). 124. Overbeck et al., ""Time evolution of open quantum many-body systems"", ; Phys. Rev. A 93, 012106 (2016). 123. Dast et al., ""Purity oscillations in Bose-Einstein condensates with balanced gain and loss"", ; Phys. Rev. A 93, 033617 (2016). 122. Zhao et al., ""Quantum statistics control with a plasmonic nanocavity: Multimode-enhanced interferences"", ; Phys. Rev. A 92, 033836 (2015). 121. Granade et al., ""Practical Bayesian tomography"", ; New J. Phys. 18, 033024 (2016). 120. Wan et al., ""Tolerance in the Ramsey interference of a trapped nanodiamond"", ; Phys. Rev. A 93, 043852 (2016). 119. Cirio et al., ""Ground State Electroluminescence"", ; Phys. Rev. Lett. 116, 113601 (2016). 118. Lee et al., ""Ramsey interference in a multilevel quantum system"", ; Phys. Rev. B 93, 085407 (2016). 117. Huang et al., ""Dark state in a nonlinear optomechanical system with quadratic coupling"", ; Phys. Rev. A 92, 013829 (2015). 116. Friis et al., ""Coherent controlization using superconducting qubits"", ; Sci. Rep. 5, 18036 (2015). 115. Glaser et al., ""Training Schrödinger's cat: quantum optimal control"", ; Eur. Phys. J. D 69, 279 (2015). 114. Łobejko et al., ""Interference of qubits in pure dephasing and almost pure dephasing environments"", ; J. Phys. A: Math. Theor. 48, 275302 (2015). 113. Hua et al., ""Quantum state transfer and controlled-phase gate on one-dimensional superconducting resonators assisted by a quantum bus"", ; Sci. Rep. 6, 22037 (2016). 112. Layden et al., ""Universal scheme for indirect quantum control"", ; Phys. Rev. A 93, 040301(R) (2016). 111. Zhang et al., ""Coherent manipulation of a Majorana qubit by a mechanical resonator"", ; Phys. Rev. B 92, 115303 (2015). 110. Yang et al., ""Entangling superconducting qubits in a multi-cavity system"", ; New. J. Phys. 18, 013025 (2016). 109. Hou et al., ""A multi-model Python wrapper for op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:33783,coupling,coupling,33783,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,"17). 272. Cesa et al., ""Two-qubit entangling gates between distant atomic qubits in a lattice"", ; Phys. Rev. A 95, 052330 (2017). 271. Ren et al., ""Evanescent-Vacuum-Enhanced Photon-Exciton Coupling and Fluorescence Collection"", ; Phys. Rev. Lett. 118, 073604 (2017). 270. Chu et al., ""Quantum acoustics with superconducting qubits"", ; Science 358, 199 (2017). 269. Fischer et al., ""Signatures of two-photon pulses from a quantum two-level system"", ; Nat. Phys. 13, 649 (2017). 268. Marshman et al., ""Investigating and improving student understanding of the probability distributions for measuring physical observables in quantum mechanics"", ; Eur. J. Phys. 38, 025705 (2017). 267. Borges et al., ""Influence of the asymmetric excited state decay on coherent population trapping: atom × quantum dot"", ; arXiv:1702.07692. 266. Pleinert et al., ""Hyperradiance from collective behavior of coherently driven atoms"", ; Optica 4, 779 (2017). 265. Oviedo-Casado et al., ""Magnetic field enhancement of organic photovoltaic cells performance"", ; Sci. Rep. 7, 4297 (2017). 264. Whalen et al., ""Open quantum systems with delayed coherent feedback"", ; Quantum Sci. Technol. 2, 044008 (2017). 263. Cottet et al., ""Observing a quantum Maxwell demon at work"", ; Proc. Natl. Acad. Sci. U.S.A. 114, 7561 (2017). 262. Mazloom et al., ""Adiabatic state preparation of stripe phases with strongly magnetic atoms"", ; Phys. Rev. A 96, 033602 (2017). 261. Poonia et al., ""Functional window of the avian compass"", ; Phys. Rev. E 95, 052417 (2017). 260. Su et al., ""Generating double NOON states of photons in circuit QED"", ; Phys. Rev. A 95, 022339 (2017). 259. Kiukas et al., ""Remote parameter estimation in a quantum spin chain enhanced by local control"", ; Phys. Rev. A 95, 052132 (2017). 258. Gely et al., ""Convergence of the multimode quantum Rabi model of circuit quantum electrodynamics"", ; Phys. Rev. B 95, 245115 (2017). 257. Radtke et al., ""Photonic Quantum Operations via the Quantum Carburettor Effect"", ; arXiv:17",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:13996,enhance,enhancement,13996,users.html,https://qutip.org,https://qutip.org/users.html,1,['enhance'],['enhancement']
Modifiability,"17). 304. Bauckhage et al., ""Adiabatic Quantum Computing for Binary Clustering"", ; arXiv:1706.05528. 303. Nigg, ""Observing quantum synchronization blockade in circuit quantum electrodynamics"", ; Phys. Rev. A 97, 013811 (2018). 302. Liu et al., ""High Purcell factor generation of coherent on-chip single photons"", ; arXiv:1706.04422. 301. Román-Ancheyta et al., ""Dynamical Casimir effect in stochastic systems: Photon harvesting through noise"", ; Phys. Rev. A 96, 032501 (2017). 300. Hong et al., ""Hanbury Brown and Twiss interferometry of single phonons from an optomechanical resonator"", ; Science 358, 203 (2017). 299. Pérez-Ríos et al., ""Ultracold molecule assembly with photonic crystals"", ; New J. Phys. 19, 123035 (2017). 298. Zambrano-Serrano et al., ""Chaos generation in fractional-order switched systems and its digital implementation"", ; International Journal of Electronics and Communications (2017). 297. Yoshihara et al., ""Characteristic spectra of circuit quantum electrodynamics systems from the ultrastrong- to the deep-strong-coupling regime"", ; Phys. Rev. A 95, 053824 (2017). 296. Endo et al., ""Dynamics of an ultra-strongly-coupled system interacting with a driven nonlinear resonator"", ; arXiv:1705.08688. 295. Venkatesh et al., ""Cooperative Effects in Closely Packed Quantum Emitters with Collective Dephasing"", ; Phys. Rev. Lett. 120, 033602 (2018). 294. Snijders et al., ""A fiber coupled cavity QED source of identical single photons"", ; arXiv:1705.05876. 293. Zanker et al., ""Analyzing the spectral density of a perturbed analog quantum simulator using Keldysh formalism"", ; arXiv:1705.02325. 292. Csurgay et al., ""Toward engineering design of quantum circuits"", ; Int. J. Circ. Theor. Appl. (2017). 291. Megyeri et al., ""Why material slow light does not improve cavity-enhanced atom detection"", ; J. Mod. Phys. (2017). 290. Huembeli et al., ""Towards a heralded eigenstate-preserving measurement of multi-qubit parity in circuit QED"", ; Phys. Rev. A 96, 012313 (2017). 289. Sh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:9942,coupling,coupling,9942,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,"1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:21967,variab,variables,21967,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['variab'],['variables']
Modifiability,"1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:14435,config,config,14435,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability,"1], type = oper, isherm = True; Qobj data =; [[ 3.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 4.]]]. In [15]: print(c); ['' 'a' 'aa' 'aaa' 'aaaa']. Note; New in QuTiP 3. One can also define functions with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-parfor.html:4416,config,configurations,4416,docs/3.0.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html,2,['config'],['configurations']
Modifiability,"1d: Spin-Bath model, fitting of spectrum and correlation functions; HEOM 1e: Spin-Bath model (pure dephasing); HEOM 2: Dynamics in Fenna-Mathews-Olsen complex (FMO); HEOM 3: Quantum Heat Transport; HEOM 4: Dynamical decoupling of a non-Markovian environment; HEOM 5a: Fermionic single impurity model; HEOM 5b: Discrete boson coupled to an impurity and fermionic leads; Hierarchical Equation of Motion Examples. Miscellaneous tutorials. Lecture: Single-photon Interference. Quantum mechanics lectures with QuTiP; These lecture-style notebooks focus on particular quantum mechanics; topics and analyze them numerically using QuTiP (some more detailed than others). Lecture 0 - Introduction to QuTiP; Lecture 1 - Vacuum Rabi oscillations in the Jaynes-Cummings model; Lecture 2A - Simulation of a two-qubit gate using a resonator as coupler; Lecture 2B - Single-Atom-Lasing; Lecture 3A - The Dicke model; Lecture 3B - Jaynes-Cummings-like model in the ultrastrong coupling regime; Lecture 4 - Correlation functions; Lecture 5 - Evolution and quantum statistics of a quantum parameter amplifier; Lecture 6 - Quantum Monte-Carlo Trajectories; Lecture 7 - Two-qubit iSWAP gate and process tomography; Lecture 8 - Adiabatic sweep; Lecture 9 - Squeezed states of a quantum harmonic oscillator; Lecture 10 - Cavity-QED in the dispersive regime; Lecture 11 - Superconducting Josephson charge qubits; Lecture 12 - Decay into a squeezed vacuum field; Lecture 13 - Resonance flourescence; Lecture 14 - Kerr nonlinearities; Lecture 15 - Nonclassically driven atoms (cascaded quantum systems); Lecture 16 - Gallery of Wigner functions. Contributing; If you would like to contribute a notebook or report a bug, you may open; an issue or pull request in the; qutip-tutorials; GitHub repository. A few of the notebooks are still maintained in the repository; qutip-notebooks and; a complete archive of older versions of the tutorials is maintained there. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-tutorials/index-v4.html:5212,coupling,coupling,5212,qutip-tutorials/index-v4.html,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html,1,['coupling'],['coupling']
Modifiability,"2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:2234,coupling,coupling,2234,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['coupling'],['coupling']
Modifiability,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:2790,enhance,enhanced,2790,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['enhance'],['enhanced']
Modifiability,"2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26385,config,config,26385,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [2]: tensor([basis(2, 0), basis(2, 0)]); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [3]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[3]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:3191,extend,extended,3191,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,3,['extend'],['extended']
Modifiability,"2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [2]: tensor([basis(2, 0), basis(2, 0)]); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [3]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[3]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-tensor.html:3991,extend,extended,3991,docs/3.1.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html,1,['extend'],['extended']
Modifiability,"2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [3]: tensor([basis(2, 0), basis(2, 0)]); Out[3]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [4]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[4]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-tensor.html:3848,extend,extended,3848,docs/3.0.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html,2,['extend'],['extended']
Modifiability,"2]: es3_expect; Out[12]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = (-0-1j); (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([-1.000000e+00, -6.123234e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [14]: psi0 = basis(2,1). In [15]: H = sigmaz(). In [16]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by pri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-eseries.html:5540,evolve,evolve,5540,docs/4.5/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-eseries.html,1,['evolve'],['evolve']
Modifiability,"2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26560,config,config,26560,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"6). 169. Vermersch et al., ""Implementation of chiral quantum optics with Rydberg and trapped-ion setups"", ; Phys. Rev. A 93, 063830 (2016). 168. Apollaro et al., ""Entanglement entropy in a periodically driven quantum Ising ring"", ; Phys. Rev. B 94, 134304 (2016). 167. Jonas, ""Fortran code for generating random probability vectors, unitaries, and quantum states"", ; Frontiers in ICT 3 (2016). 166. Ong et al., ""The Effect of Spin Squeezing on the Entanglement Entropy of Kicked Tops"", ; Entopy 18, 116 (2016). 165. Yang et al., ""Crosstalk-insensitive method for simultaneously coupling multiple pairs of resonators"", ; Phys. Rev. A 93, 042307 (2016). 164. Mavalankar et al., ""Photon-assisted tunneling and charge dephasing in a carbon nanotube double quantum dot"", ; Phys. Rev. B 93, 235428 (2016). 163. Hush et al., ""Quantum state transfer through time reversal of an optical channel"", ; Phys. Rev. A 94, 062302 (2016). 162. Royer et al., ""Fast and high-fidelity entangling gate through parametrically modulated longitudinal coupling"", ; Quantum 1, 11 (2017). 161. Lörch et al., ""Genuine Quantum Signatures in Synchronization of Anharmonic Self-Oscillators"", ; Phys. Rev. Lett. 117, 073601 (2016). 160. Ejtemaee et al., ""3D Sisyphus Cooling of Trapped Ions"", ; Phys. Rev. Lett. 119, 043001 (2017). 159. Rogers, ""The EPR Paradox Implies A Minimum Achievable Temperature"", ; Phys. Rev. E 95, 012149 (2017). 158. Fischer et al., ""Self-homodyne measurement of a dynamic Mollow triplet in the solid state"", ; Nat. Photonics 10, 163 (2016). 157. Zhao et al., ""Vacuum Rabi Splitting in Nanomechanical QED System with Nonlinear Resonator"", ; arXiv:1603.00215. 156. Türkpençe et al., ""Quantum fuel with multilevel atomic coherence for ultrahigh specific work in a photonic Carnot engine"", ; Phys. Rev. E 93, 012145 (2016). 155. Joo et al., ""Deterministic amplification of Schrödinger cat states in circuit quantum electrodynamics"", ; New J. Phys. 18, 023028 (2016). 154. Hofer et al., ""Quantum heat engine b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:27903,coupling,coupling,27903,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,": :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:9555,config,config,9555,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,12,['config'],['config']
Modifiability,": QobjThe circular spin chain circuit to be resolved. rwa: BooleanSpecify if RWA is used or not. Returns. qc: QubitCircuitReturns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. get_ops_and_u(self)[source]¶; Returns the Hamiltonian operators and corresponding values by stacking; them together. get_ops_labels(self)[source]¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(self, qc)[source]¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. optimize_circuit(self, qc)[source]¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. Returns. qc: QubitCircuitThe optimal circuit representation. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:72808,config,config,72808,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['config'],['config']
Modifiability,": float or array; Frequency of the oscillator. w_th : float; The temperature in units of frequency (or the same units as w). Returns:; n_avg : float or array; Return the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. linspace_with(start, stop, num=50, elems=[])[source]¶; Return an array of numbers sampled over specified interval; with additional elements added.; Returns num spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:; start : int; The starting value of the sequence. stop : int; The stoping values of the sequence. num : int, optional; Number of samples to generate. elems : list/ndarray, optional; Requested elements to include in array. Returns:; samples : ndadrray; Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns:; cg_coeff : float; Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value : float / array; The energy in the old unit. orig : string; The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string; The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to sto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:207419,coupling,coupling,207419,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['coupling'],['coupling']
Modifiability,": float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string. Fidelity error (and fidelity error gradi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:132955,variab,variable,132955,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,2,['variab'],['variable']
Modifiability,": float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. amp_update_mode : string. determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string. type / shape of pulse(s) used to initialise the; the control amplitudes. Options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:139496,variab,variable,139496,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['variab'],['variable']
Modifiability,": int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)[source]¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:25179,config,configuration,25179,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['config'],['configuration']
Modifiability,": return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, nu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17330,config,config,17330,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,":. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3.; quite.cite() is improved.; Added matplotlib as optional dependency and updated numpy and scipy requirements.; Fixed matrix generating coherent spin states in qutip.piqs to include complex coefficients. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEAT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:1917,variab,variable,1917,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,1,['variab'],['variable']
Modifiability,"::-1], kraus_list[0].dims[::-1]],; type='super', superrep='choi'). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:9877,extend,extend,9877,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,1,['extend'],['extend']
Modifiability,":; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:2756,enhance,enhanced,2756,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,1,['enhance'],['enhanced']
Modifiability,":; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18617,config,config,18617,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,":; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20274,config,config,20274,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,":; string_list.append(str(value)); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=len(Lcoeff), h_tdterms=Lcoeff, ; c_td_splines=me_cops_coeff, ; c_td_spline_flags=me_cops_obj_flags, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mesolve.html:22627,config,config,22627,docs/4.3/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,":class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_ste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html:6994,config,config,6994,docs/4.0.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"; """""". def __init__(self, N, reverse_states=True):. # number of qubits in the register; self.N = N; self.reverse_states = reverse_states; self.gates = []; self.U_list = []. [docs] def add_gate(self, gate, targets=None, controls=None, arg_value=None,; arg_label=None):; """"""; Adds a gate with specified parameters to the circuit. Parameters; ----------; gate: String or `Gate`; Gate name. If gate is an instance of `Gate`, parameters are; unpacked and added.; targets: List; Gate targets.; controls: List; Gate controls.; arg_value: Float; Argument value(phi).; arg_label: String; Label for gate representation.; """"""; if isinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label. else:; name = gate; self.gates.append(Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label)). [docs] def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : String; Gate name.; start : Integer; Starting location of qubits.; end : Integer; Last qubit for the gate.; qubits : List; Specific qubits for applying gates.; arg_value : Float; Argument value(phi).; arg_label : String; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for i in range(len(qubits)):; self.gates.append(Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value,; arg_label=arg_label)). else:; if end is None:; end = self.N - 1; for i in range(start, end):; self.gates.append(Gate(name, targets=i, controls=None,; arg_value=arg_value,; arg_label=arg_label)). [docs] def add_circuit(self, qc, start=0):; """"""; Adds a block of a qubit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/circuit.html:6174,variab,variable,6174,docs/4.1/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/circuit.html,2,['variab'],['variable']
Modifiability,"; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12324,config,config,12324,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['config'],['config']
Modifiability,"; # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35276,config,config,35276,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34883,config,config,34883,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12553,config,config,12553,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to od",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36506,config,config,36506,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35504,config,config,35504,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35409,config,config,35409,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:7198,flexible,flexible,7198,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['flexible'],['flexible']
Modifiability,"; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-eseries.html:1983,parameteriz,parameterized,1983,docs/3.0.1/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-eseries.html,1,['parameteriz'],['parameterized']
Modifiability,"; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITI",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:98864,config,configuration,98864,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:88510,variab,variable,88510,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,6,['variab'],"['variable', 'variables']"
Modifiability,"; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:6352,config,config,6352,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,2,['config'],['config']
Modifiability,"; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6156,config,config,6156,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,5,['config'],['config']
Modifiability,"; LorentzianPadeBath.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/fermionic.html:3195,coupling,coupling,3195,docs/4.7/guide/heom/fermionic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html,1,['coupling'],['coupling']
Modifiability,"; Neill Lambert. Author; Eric Giguere. version; 4.4. status; Released (July 18, 2018). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/frontmatter.html:1822,coupling,coupling,1822,docs/4.4/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html,1,['coupling'],['coupling']
Modifiability,"; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=fl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18502,config,config,18502,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:6098,coupling,coupling,6098,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,6,['coupling'],['coupling']
Modifiability,"; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-tensor.html:6898,coupling,coupling,6898,docs/3.1.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html,1,['coupling'],['coupling']
Modifiability,"; _H = H.full().copy() # np.ndarray; _psi = psi0.full().copy(); _psi = _psi / np.linalg.norm(_psi). # create internal variable and output containers; if options is None:; options = Options(nsteps=10000); krylov_results = Result(); krylov_results.solver = ""krylovsolve"". # handle particular cases of an empty tlist or single element; n_tlist_steps = len(tlist); if n_tlist_steps < 1:; return krylov_results. if n_tlist_steps == 1: # if tlist has only one element, return it; krylov_results = particular_tlist_or_happy_breakdown(; tlist, n_tlist_steps, options, psi0, e_ops, krylov_results, pbar; ) # this will also raise a warning; return krylov_results. tf = tlist[-1]; t0 = tlist[0]. # optimization step using Lanczos, then reuse it for the first partition; dim_m = krylov_dim; krylov_basis, T_m = lanczos_algorithm(; _H, _psi, krylov_dim=dim_m, sparse=sparse; ). # check if a happy breakdown occurred; if T_m.shape[0] < krylov_dim + 1:; if T_m.shape[0] == 1:; # this means that the state does not evolve in time, it lies in a; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; options,; psi0,; e_ops,; krylov_results,; pbar,; happy_breakdown=True,; ); return krylov_results; else:; # no optimization is required, convergence is guaranteed.; delta_t = tf - t0; n_timesteps = 1; else:. # calculate optimal number of internal timesteps.; delta_t = _optimize_lanczos_timestep_size(; T_m, krylov_basis=krylov_basis, tlist=tlist, options=options; ); n_timesteps = int(ceil((tf - t0) / delta_t)). if n_timesteps >= options.nsteps:; raise Exception(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_result",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:4366,evolve,evolve,4366,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['evolve'],['evolve']
Modifiability,"; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See :obj:`~TimeslotComp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:45188,variab,variable,45188,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['variab'],['variable']
Modifiability,"; arXiv:1712.09762. 359. Dahlberg et al., ""SimulaQron - A simulator for developing quantum internet software"", ; arXiv:1712.08032. 358. Abdel-Wahab et al., ""Dynamic evolution of double Λ five-level atom interacting with one-mode electromagnetic cavity field"", ; Pramana - J. Phys. 89, 87 (2017). 357. Dai et al., ""Quantum simulation of the general semi-classical Rabi model in regimes of arbitrarily strong driving"", ; Appl. Phys. Lett. 111, 242601 (2017). 356. Zhou et al., ""Simulating the Lipkin-Meshkov-Glick model in a hybrid quantum system"", ; arXiv:1712.06234. 355. Otterbach et al., ""Unsupervised Machine Learning on a Hybrid Quantum Computer"", ; arXiv:1712.05771. 354. Wang et al., ""Parallel quantum operations with chiral spin states in a superconducting circuit"", ; arXiv:1712.05261. 353. Tugen et al., ""A Comparative Study of Coupled High-Q Cavity-Quantum Dot System Regarding Dipole Induced Transparency"", ; arXiv:1712.01944. 352. Chen et al., ""Tuning coupling between superconducting resonators with collective qubits"", ; arXiv:1712.04357. 351. Touzard et al., ""Coherent oscillations inside a quantum manifold stabilized by dissipation"", ; arXiv:1705.02401. 350. Zhao et al., ""Two-photon driven Kerr resonator for quantum annealing with three-dimensional circuit QED"", ; arXiv:1712.03613. 349. Tezak et al., ""Low-dimensional manifolds for exact representation of open quantum systems"", ; Phys. Rev. A 96, 062113 (2017). 348. Lambert et al., ""Amplified and tunable transverse and longitudinal spin-photon coupling in hybrid circuit-QED"", ; arXiv:1712.02077. 347. Mirkin et al., ""In the quest of relations between non-Markovianity and quantum optimal control"", ; arXiv:1711.10551. 346. Gu et al., ""Topological edge states and pumping in a chain of coupled superconducting qubits"", ; arXiv:1711.06829. 345. Jiang et al., ""Quantum algorithms to simulate many-body physics of correlated fermions"", ; arXiv:1711.05395. 344. Brambilla et al., ""Heavy quarkonium suppression in a fireball"", ; arX",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:2782,coupling,coupling,2782,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,"; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, w0, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; w0=w0,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). def _matsubara_params(self, lam, gamma, w0, T, Nk):; """""" Calculate the Matsubara coefficents and frequencies. """"""; beta = 1/T; Om = np.sqrt(w0**2 - (gamma/2)**2); Gamma = gamma/2. ck_real = ([; (lam**2 / (4 * Om)); * (1 / np.tanh(beta * (Om + 1.0j * Gamma) / 2)),; (lam**2 / (4*Om)); * (1 / np.tanh(beta * (Om - 1.0j * Gamma) / 2)),; ]). ck_real.extend([; (-2 * lam**2 * gamma / beta) * (2 * np.pi * k / beta); / (; ((Om + 1.0j * Gamma)**2 + (2 * np.pi * k/beta)**2); * ((Om - 1.0j * Gamma)**2 + (2 * np.pi * k / beta)**2); ); for k in range(1, Nk + 1); ]). vk_real = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]; vk_real.extend([; 2 * np.pi * k * T; for k in range(1, Nk + 1); ]). ck_imag = [; 1.0j * lam**2 / (4 * Om),; -1.0j * lam**2 / (4 * Om),; ]. vk_imag = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class FermionicBath(Bath):; """"""; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the ``+`` and ``-`` modes of; the bath correlation function. There must be the same number of ``+`` and ``-`` modes and their; coefficients must be specified in the same order so that ``ck_plus[i],; vk_plus[i]`` are the plus coefficient and frequency corresponding; to the minus mode ``ck_minus[i], vk_minus[i]``. In the fermionic case the order in which excitations are created or; destroyed is important, resulting in two different correlation functions; labelled ``C_plus(t)`` and ``C_plus(t)``::. C_plus(t) = sum(ck_plus * exp(- vk_plus * t)); C_minus(t) = sum(ck_minus * exp(- vk_minus * t)). where the expansions above define the coeffii",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:18122,extend,extend,18122,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['extend'],['extend']
Modifiability,"; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set init",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23333,config,config,23333,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:14660,config,configuration,14660,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['config'],['configuration']
Modifiability,"; e_ops=None,; options=None,; progress_bar: bool = None,; sparse: bool = False,; ):; """"""; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (""psi0"") finding an approximation for the time; evolution operator of Hamiltonian (""H"") by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)). The output is either the state vector or the expectation values of; supplied operators (""e_ops"") at arbitrary points at (""tlist""). **Additional options**. Additional options to krylovsolve can be set with the following:. * ""store_states"": stores states even though expectation values are; requested via the ""e_ops"" argument. * ""store_final_state"": store final state even though expectation values are; requested via the ""e_ops"" argument. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian.; psi0 : :class: `qutip.Qobj`; Initial state vector (ket).; tlist : None / *list* / *array*; List of times on which to evolve the initial state. If None, nothing; happens but the code won't break.; krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation.; e_ops : None / list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values.; options : Options; Instance of ODE solver options, as well as krylov parameters.; atol: controls (approximately) the error desired for the final; solution. (Defaults to 1e-8); nsteps: maximum number of krylov's internal number of Lanczos; iterations. (Defaults to 10000); progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; sparse : bool (default False); Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns; -------; result: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`, which contains; e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:1907,evolve,evolve,1907,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['evolve'],['evolve']
Modifiability,"; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calcul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:47995,config,configuration,47995,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,3,['config'],['configuration']
Modifiability,"; else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:14790,variab,variables,14790,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,1,['variab'],['variables']
Modifiability,"; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17583,config,config,17583,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27014,config,config,27014,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28017,config,config,28017,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33926,config,config,33926,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20948,config,config,20948,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"; if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12154,config,config,12154,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,"; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if phase is not None:; self._dyn_gen_phase = phase. def _get_dyn_gen_phas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:52850,config,config,52850,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,"; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_ind",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32696,config,config,32696,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if self.compiled:; self.dynamics_args[i][2].compile(); self._d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:22706,variab,variables,22706,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['variab'],['variables']
Modifiability,"; passed as ck_imag. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def _check_cks_and_vks(self, ck_real, vk_real, ck_imag, vk_imag):; if len(ck_real) != len(vk_real) or len(ck_imag) != len(vk_imag):; raise ValueError(; ""The bath exponent lists ck_real and vk_real, and ck_imag and""; "" vk_imag must be the same length.""; ). def _check_coup_op(self, Q):; if not isinstance(Q, Qobj):; raise ValueError(""The coupling operator Q must be a Qobj.""). def __init__(; self, Q, ck_real, vk_real, ck_imag, vk_imag, combine=True,; tag=None,; ):; self._check_cks_and_vks(ck_real, vk_real, ck_imag, vk_imag); self._check_coup_op(Q). exponents = []; exponents.extend(; BathExponent(""R"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_real, vk_real); ); exponents.extend(; BathExponent(""I"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_imag, vk_imag); ). if combine:; exponents = self.combine(exponents). super().__init__(exponents). [docs] @classmethod; def combine(cls, exponents, rtol=1e-5, atol=1e-7):; """"""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; --",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:6883,extend,extend,6883,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['extend'],['extend']
Modifiability,"; qc: Qobj; The circular spin chain circuit to be resolved. rwa: Boolean; Specify if RWA is used or not. Returns:; qc: QubitCircuit; Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. get_ops_and_u()[source]¶; Returns the Hamiltonian operators and corresponding values by stacking; them together. get_ops_labels()[source]¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(qc)[source]¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. optimize_circuit(qc)[source]¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. Returns:; qc: QubitCircuit; The optimal circuit representation. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:66855,config,config,66855,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['config']
Modifiability,"; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:12596,config,configure,12596,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['configure']
Modifiability,"; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if pha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:52795,config,configuration,52795,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,1,['config'],['configuration']
Modifiability,"; self.propagators[t2][t1] = propagator(self.H, [t1, t2],; options=self.options,; unitary_mode='single'); # Something is still broken about batch unitary mode (see #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Returns; -------; partition : iterable; The partitioning of collection into num_sets sets.; """"""; for partitioning in product(range(num_sets), repeat=len(collection)):; partition = [[] for _ in range(num_sets)]; for i, set_index in enumerate(partitioning):; partition[set_index].append(collection[i]); yield tuple(tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:5526,evolve,evolver,5526,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,5,['evolve'],['evolver']
Modifiability,"; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18956,config,config,18956,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"<; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26428,config,config,26428,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data str",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:31770,config,config,31770,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltoni",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30750,config,config,30750,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"= 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28702,config,config,28702,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"= None; compiled_coeffs[i] = None; else:; compiled_tlist[i] = np.concatenate(compiled_tlist[i]); compiled_coeffs[i] = np.concatenate(compiled_coeffs[i]); return compiled_tlist, compiled_coeffs. def _process_gate_pulse(; self, start_time, tlist, coeff):; # compute the gate time, step size and coeffs; # according to different pulse mode; if np.isscalar(tlist):; pulse_mode = ""discrete""; # a single constant rectanglar pulse, where; # tlist and coeff are just float numbers; step_size = tlist; coeff = np.array([coeff]); gate_tlist = np.array([tlist]); elif len(tlist) - 1 == len(coeff):; # discrete pulse; pulse_mode = ""discrete""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff); gate_tlist = np.asarray(tlist)[1:] # first t always 0 by def; elif len(tlist) == len(coeff):; # continuos pulse; pulse_mode = ""continuous""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff)[1:]; gate_tlist = np.asarray(tlist)[1:]; else:; raise ValueError(; ""The shape of the compiled pulse is not correct.""); return gate_tlist, coeff, step_size, pulse_mode. def _process_idling_tlist(; self, pulse_mode, start_time, last_pulse_time, step_size):; idling_tlist = []; if pulse_mode == ""continuous"":; # We add sufficient number of zeros at the begining; # and the end of the idling to prevent wrong cubic spline.; if start_time - last_pulse_time > 3 * step_size:; idling_tlist1 = np.linspace(; last_pulse_time + step_size/5,; last_pulse_time + step_size,; 5; ); idling_tlist2 = np.linspace(; start_time - step_size,; start_time,; 5; ); idling_tlist.extend([idling_tlist1, idling_tlist2]); else:; idling_tlist.append(; np.arange(; last_pulse_time + step_size,; start_time, step_size; ); ); elif pulse_mode == ""discrete"":; # idling until the start time; idling_tlist.append([start_time]); return np.concatenate(idling_tlist). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/gatecompiler.html:8928,extend,extend,8928,docs/4.7/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/gatecompiler.html,1,['extend'],['extend']
Modifiability,"= [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hami",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32530,config,config,32530,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability,"= _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19814,config,config,19814,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"= _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1];",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19790,config,config,19790,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"= basis(3, 2). In [6]: N = 2 # Set where to truncate Fock state for cavity. In [7]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [8]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [9]: a = tensor(destroy(N), qeye(3)). In [10]: ada = tensor(num(N), qeye(3)). In [11]: c_ops = [] # Build collapse operators. In [12]: kappa = 1.5 # Cavity decay rate. In [13]: c_ops.append(np.sqrt(kappa) * a). In [14]: gamma = 6 # Atomic decay rate. In [15]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [16]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:8201,coupling,coupling,8201,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,3,['coupling'],['coupling']
Modifiability,"= c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.dat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32867,config,config,32867,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"= col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30415,config,config,30415,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"= config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11797,config,config,11797,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"= config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12803,config,config,12803,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"= np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38788,config,config,38788,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"= psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8625,config,config,8625,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"=0.01, t1=None, t2=None):; super(DispersiveCavityQED, self).__init__(; N, correct_global_phase=correct_global_phase,; t1=t1, t2=t2); self.correct_global_phase = correct_global_phase; self.spline_kind = ""step_func""; self.num_levels = num_levels; self._params = {}; self.set_up_params(; N=N, num_levels=num_levels, deltamax=deltamax,; epsmax=epsmax, w0=w0, wq=wq, eps=eps,; delta=delta, g=g); self.set_up_ops(N); self.dims = [num_levels] + [2] * N. [docs] def set_up_ops(self, N):; """"""; Generate the Hamiltonians for the spinchain model and save them in the; attribute `ctrls`. Parameters; ----------; N: int; The number of qubits in the system.; """"""; self.pulse_dict = {}; index = 0; # single qubit terms; for m in range(N):; self.pulses.append(; Pulse(sigmax(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sx"" + str(m)] = index; index += 1; for m in range(N):; self.pulses.append(; Pulse(sigmaz(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # coupling terms; a = tensor(; [destroy(self.num_levels)] +; [identity(2) for n in range(N)]); for n in range(N):; sm = tensor([identity(self.num_levels)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.pulses.append(; Pulse(a.dag() * sm + a * sm.dag(),; list(range(N+1)), spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(; self, N, num_levels, deltamax,; epsmax, w0, wq, eps, delta, g):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", ""w0"", ""eps"", ""delta""; and ""g"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""g"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; N: int; The number of qubits in the system. num_levels: int; The number of energy levels in the resonator. deltamax: list; The coefficients of sigma-x for each of the qubits in the system. epsmax: li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:6041,coupling,coupling,6041,docs/4.6/modules/qutip/qip/device/cavityqed.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html,2,['coupling'],['coupling']
Modifiability,"== 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:17741,config,config,17741,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability,"=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8071,coupling,coupling,8071,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['coupling'],['coupling']
Modifiability,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=N",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:39184,config,config,39184,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['config'],['config']
Modifiability,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:72866,config,config,72866,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['config'],['config']
Modifiability,"=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:41259,variab,variables,41259,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['variab'],['variables']
Modifiability,"=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23048,config,config,23048,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); if not r.successful():; raise RuntimeError(; ""HSolverDL ODE integra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html:12824,config,configured,12824,docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,1,['config'],['configured']
Modifiability,"=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); outp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:14522,config,configured,14522,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,7,['config'],['configured']
Modifiability,"ABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve', 'bloch_redfield_tensor']. import numpy as np; import os; import types; import warnings; from functools import partial; import scipy.integrate; import scipy.sparse as sp; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec, vec2mat_index; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.superoperator import liouvillian; from qutip.interpolate import Cubic_Spline; from qutip.cy.spconvert import arr_coo2fast; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Solves for the dynamics of a system using the Bloch-Redfield maste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:2480,config,config,2480,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['config'],['config']
Modifiability,"AL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings. from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None,; progress_bar=None, _safe_mode=True):",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:2543,config,config,2543,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"ARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of thre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html:2485,config,configurations,2485,docs/4.6/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html,1,['config'],['configurations']
Modifiability,"ARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2596,config,config,2596,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability,"A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; ; initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing sta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:18487,config,config,18487,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['config'],['config']
Modifiability,"Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. Se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:104911,config,configuration,104911,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"BILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import warnings; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:2990,config,config,2990,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this ca",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:2160,evolve,evolved,2160,docs/4.7/guide/dynamics/dynamics-krylov.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html,1,['evolve'],['evolved']
Modifiability,"C():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13193,config,config,13193,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"CLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from scipy import array; from multiprocessing import Pool; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/parallel.html:2840,variab,variable,2840,docs/4.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html,6,['variab'],['variable']
Modifiability,"CLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from scipy import array; from multiprocessing import Pool; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1.0, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html:4096,variab,variable,4096,docs/3.1.0/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html,1,['variab'],['variable']
Modifiability,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/stats.html:2517,config,configurations,2517,docs/4.1/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/stats.html,7,['config'],['configurations']
Modifiability,"C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:39758,config,config,39758,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38950,config,config,38950,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:38950,config,config,38950,docs/4.3/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33556,config,config,33556,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:6269,config,configuration,6269,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,8,['config'],['configuration']
Modifiability,"DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9132,config,config,9132,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"DE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20897,config,config,20897,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"DE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:22989,config,config,22989,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"DE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_dat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21997,config,config,21997,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"DING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/three_level_atom.html:2366,config,configuration,2366,docs/4.1/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/three_level_atom.html,7,['config'],['configuration']
Modifiability,"Data, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:40784,variab,variable,40784,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['variab'],['variable']
Modifiability,"Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1171,variab,variables,1171,docs/4.7/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html,2,"['config', 'variab']","['config', 'variables']"
Modifiability,"E solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26770,config,config,26770,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"E solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:27773,config,config,27773,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"Error(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:19835,config,config,19835,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"Evo(H_sys); except Exception as err:; raise ValueError(; ""Hamiltonian (H_sys) of type list cannot be converted to""; "" QObjEvo""; ) from err; else:; raise TypeError(; f""Hamiltonian (H_sys) has unsupported type: {type(H_sys)!r}""); return H_sys. def _combine_bath_exponents(self, bath):; """""" Combine the exponents for the specified baths. """"""; if not isinstance(bath, (list, tuple)):; exponents = bath.exponents; else:; exponents = []; for b in bath:; exponents.extend(b.exponents); all_bosonic = all(; exp.type in (exp.types.R, exp.types.I, exp.types.RI); for exp in exponents; ); all_fermionic = all(; exp.type in (exp.types[""+""], exp.types[""-""]); for exp in exponents; ); if not (all_bosonic or all_fermionic):; raise ValueError(; ""Bath exponents are currently restricted to being either""; "" all bosonic or all fermionic, but a mixture of bath""; "" exponents was given.""; ); if not all(exp.Q.dims == exponents[0].Q.dims for exp in exponents):; raise ValueError(; ""All bath exponents must have system coupling operators""; "" with the same dimensions but a mixture of dimensions""; "" was given.""; ); return exponents. def _dsuper_list_td(self, t, y, L_list):; """""" Auxiliary function for the time-dependent integration. Called every; time step.; """"""; L = L_list[0][0]; for n in range(1, len(L_list)):; L = L + L_list[n][0] * L_list[n][1](t); return L * y. def _grad_n(self, L, he_n):; """""" Get the gradient for the hierarchy ADO at level n. """"""; vk = self.ados.vk; vk_sum = sum(he_n[i] * vk[i] for i in range(len(vk))); op = L - vk_sum * self._sId; return op. def _grad_prev(self, he_n, k):; """""" Get the previous gradient. """"""; if self.ados.exponents[k].type in (; BathExponent.types.R, BathExponent.types.I,; BathExponent.types.RI; ):; return self._grad_prev_bosonic(he_n, k); elif self.ados.exponents[k].type in (; BathExponent.types[""+""], BathExponent.types[""-""]; ):; return self._grad_prev_fermionic(he_n, k); else:; raise ValueError(; f""Mode {k} has unsupported type {self.ados.exponents[k].type}""). def ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:14952,coupling,coupling,14952,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,1,['coupling'],['coupling']
Modifiability,"F SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, random_integers; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.solver import Options, Result, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:3899,config,config,3899,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"F THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from scipy import array; import multiprocessing; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if sys.platform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/parallel.html:2974,variab,variable,2974,docs/4.6/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html,1,['variab'],['variable']
Modifiability,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:2962,variab,variables,2962,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['variab'],['variables']
Modifiability,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2991,variab,variables,2991,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['variab'],['variables']
Modifiability,"FITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, randint; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a stat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:2691,config,config,2691,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"Floquet quasienergies. Necessary if; floquet_basis is False and the transformation should be made; back to the lab frame. Tfloat, optionalThe time period of driving. Necessary if floquet_basis is; False and the transformation should be made back to the lab frame. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. kmaxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:100542,variab,variables,100542,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"GLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:2850,config,config,2850,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"GS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:68436,variab,variable,68436,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['variab'],['variable']
Modifiability,"Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:15188,config,config,15188,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians.; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dep",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:18680,config,config,18680,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-depe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15445,config,config,15445,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,3,['config'],['config']
Modifiability,"HALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.superoperator import vec2mat; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, psi0, tlist, e_ops=[], args={}, options=None,; progress_bar=None,; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (`psi0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:2442,config,config,2442,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"HS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3698,config,config,3698,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability,"Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:13007,variab,variable,13007,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,4,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:13540,variab,variable,13540,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,4,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [49]: t = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:13267,variab,variable,13267,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,2,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:13630,variab,variable,13630,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,4,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"Hilbert space is (output space) x (input space).; choi_dims = [kraus_ops[0].dims] * 2; # transform a list of Qobj matrices list[sum_ij k_ij |i><j|]; # into an array of array vectors sum_ij k_ij |i, j>> = sum_I k_I |I>>; kraus_vectors = np.asarray(; [np.reshape(kraus_op.full(), len_op, ""F"") for kraus_op in kraus_ops]; ); # sum_{I} |k_I|^2 |I>><<I|; choi_array = np.tensordot(kraus_vectors, kraus_vectors.conj(), axes=([0], [0])); return Qobj(choi_array, choi_dims, superrep=""choi"", copy=False). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.prod(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:8487,extend,extend,8487,docs/4.7/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html,1,['extend'],['extend']
Modifiability,"However, if you are not familiar with conda environments and only plan to use if for QuTiP, then you should probably work with a default Anaconda / Miniconda environment.; To create a Conda env for QuTiP called qutip-env:; conda create -n qutip-env python=3. Note the python=3 can be ommited if you want the default Python version for the Anaconda / Miniconda install.; If you have created a specific conda environment, or you have installed Miniconda, then you will need to install the required packages for QuTiP.; recommended:; conda install numpy scipy cython matplotlib nose jupyter notebook spyder. minimum (recommended):; conda install numpy scipy cython nose matplotlib. absolute mimimum:; conda install numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks). Spyder is an IDE for scientific development with Python. Adding the conda-forge channel¶; If you have conda 4.1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Gi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:3870,config,config,3870,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,1,['config'],['config']
Modifiability,"However, if you are not familiar with conda environments and only plan to use if for QuTiP, then you should probably work with a default Anaconda / Miniconda environment.; To create a Conda env for QuTiP called qutip-env:; conda create -n qutip-env python=3. Note the python=3 can be ommited if you want the default Python version for the Anaconda / Miniconda install.; If you have created a specific conda environment, or you have installed Miniconda, then you will need to install the required packages for QuTiP.; recommended:; conda install numpy scipy cython matplotlib nose jupyter notebook spyder. minimum (recommended):; conda install numpy scipy cython nose matplotlib. absolute mimimum:; conda install numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks). Spyder is an IDE for scientific development with Python. Adding the conda-forge channel¶; If you have conda 4.1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Gi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:3774,config,config,3774,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,3,['config'],['config']
Modifiability,"Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Paramet",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:93730,variab,variables,93730,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:70723,variab,variables,70723,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html:2907,variab,variables,2907,docs/4.5/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html,1,['variab'],['variables']
Modifiability,"IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:2927,variab,variables,2927,docs/4.6/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html,1,['variab'],['variables']
Modifiability,"IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=Options(),; progress_bar=True, map_func=parallel_map, map_kwargs={},; _safe_mode=True, _exp=False):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, cons",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html:2894,variab,variables,2894,docs/4.4/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html,1,['variab'],['variables']
Modifiability,"ING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html:2396,config,configuration,2396,docs/4.6/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html,1,['config'],['configuration']
Modifiability,"IRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; from functools import partial; import scipy.integrate; import scipy.sparse as sp; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.operators import qdiags; from qutip.superoperator import spre, spost, vec2mat, mat2vec, vec2mat_index; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.superoperator import liouvillian; from qutip.interpolate import Cubic_Spline; from qutip.cy.spconvert import arr_coo2fast; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:2504,config,config,2504,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,3,['config'],['config']
Modifiability,"ISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:2953,config,config,2953,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html:1463,extend,extended,1463,docs/4.6/development/ideas/heom-gpu.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html,1,['extend'],['extended']
Modifiability,"J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. Earlier development of QuTiP was partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/frontmatter.html:1967,coupling,coupling,1967,docs/4.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html,1,['coupling'],['coupling']
Modifiability,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html:9328,config,config,9328,docs/4.0.2/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/utilities.html,4,['config'],['config']
Modifiability,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/utilities.html:9330,config,config,9330,docs/4.2/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html,4,['config'],['config']
Modifiability,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:9330,config,config,9330,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,4,['config'],['config']
Modifiability,"L = -1j * h; Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of Hamiltonian terms; n_L_terms = len(Ldata). # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k). for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; if oper_evo:; initial_vector = psi0.full().ravel('F'); r = scipy.integrate.ode(_td_ode_rhs_oper); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:14656,config,config,14656,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"L,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings. from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None,; progress_bar=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:3800,config,config,3800,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"LUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:2877,coupling,coupling,2877,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,7,['coupling'],['coupling']
Modifiability,"Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21171,config,config,21171,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,2,['config'],['config']
Modifiability,"Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in gener",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html:1659,variab,variable,1659,docs/3.0.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html,1,['variab'],['variable']
Modifiability,"Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is performed.; The following tables lists some of the solvers QuTiP provides for dynamic quantum systems and indicates the type of object; returned ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:1467,evolve,evolves,1467,docs/4.7/guide/dynamics/dynamics-intro.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html,1,['evolve'],['evolves']
Modifiability,"NG IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2880,variab,variables,2880,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,8,"['config', 'variab']","['config', 'variables']"
Modifiability,"NT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm; import qutip.settings as qset; from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/sesolve.html:2438,config,config,2438,docs/4.1/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"NT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm; import qutip.settings as qset; from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:2438,config,config,2438,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"New J. Phys. 17, 113020 (2015). 90. Černotík et al., ""Adiabatic elimination of Gaussian subsystems from quantum dynamics under continuous measurement"", ; Phys. Rev. A 92, 012124 (2015). 89. Müller et al., ""Ultrafast Polariton-Phonon Dynamics of Strongly Coupled Quantum Dot-Nanocavity Systems"", ; Phys. Rev. X 5, 031006 (2015). 88. Osipovs et al., ""Markov Chains in the Task of Author's Writing Style Profile Construction"", ; Information Technology and Management Science 17, 119 (2014). 87. Armour et al., ""Josephson photonics with a two-mode superconducting circuit"", ; Phys. Rev. B 91, 184508 (2015). 86. Li et al., ""Hybrid Quantum Device Based on NV Centers in Diamond Nanomechanical Resonators Plus Superconducting Waveguide Cavities"", ; Phys. Rev. Applied 4, 044003 (2015). 85. Li et al., ""Enhanced electromechanical coupling of a nanomechanical resonator to coupled superconducting cavities"", ; Sci. Rep. 6, 19065 (2016). 84. del Pino et al., ""Quantum theory of collective strong coupling of molecular vibrations with a microcavity mode"", ; New. J. Phys. 17, 053040 (2015). 83. Rossetti et al., ""Trapped-ion Lissajous trajectories by engineering Rashba- and Dresselhaus-type spin-orbit interactions in a Paul trap"", ; Euro. Phys. Lett. 115, 53001 (2016). 82. Batalhao et al., ""Irreversibility and the Arrow of Time in a Quenched Quantum System"", ; Phys. Rev. Lett. 115, 190601 (2015). 81. Gonzalez-Ballestero et al., ""Harvesting excitons through plasmonic strong coupling"", ; Phys. Rev. B 92, 121402 (2015). 80. Lörch et al., ""Sub-Poissonian phonon lasing in three-mode optomechanics"", ; Phys. Rev. A 91, 061803(R) (2015). 79. Dalmonte et al., ""Cluster Luttinger liquids and emergent supersymmetric conformal critical points in the one-dimensional soft-shoulder Hubbard model"", ; Phys. Rev. B 92, 045106 (2015). 78. Weimer, ""Variational analysis of driven-dissipative Rydberg gases"", ; Phys. Rev. A 91, 063401 (2015). 77. Schulte et al., ""Quantum Algorithmic Readout in Multi-Ion Clocks"", ; Ph",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:38243,coupling,coupling,38243,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,"None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:37812,config,config,37812,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['config'],['config']
Modifiability,"None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:24231,variab,variables,24231,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['variab'],['variables']
Modifiability,"None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:30962,coupling,coupling,30962,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:41581,variab,variables,41581,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['variab'],['variables']
Modifiability,"None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tslots+1, dtype=float); # set the cumulative time by summing the time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11438,config,config,11438,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,"None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tsl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:11383,config,configuration,11383,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['configuration']
Modifiability,"Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:10454,config,config,10454,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,1,['config'],['config']
Modifiability,"Note; This solver does not currently support time-dependent Hamiltonians. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 / psi0: :class:`qutip.Qobj`. Initial density matrix or state vector (ket). tlist : list / array. List of times for \(t\). a_ops : list of qutip.qobj. List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. c_ops : list of qutip.qobj. List of system collapse operators. args : dictionary. Placeholder for future implementation, kept for API consistency. options : qutip.solver.Options. Options for the solver. Returns:result: qutip.solver.Result. An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=[], use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Note; This tensor generation requires a time-independent Hamiltonian. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of qutip.qobj. List of system collapse operators. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: qutip.Qobj, list of qutip.Qobj. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:64466,coupling,coupling,64466,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['coupling'],['coupling']
Modifiability,"Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:186980,config,config,186980,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['config']
Modifiability,"O, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the me",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2654,config,config,2654,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability,"OM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:79220,variab,variable,79220,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['variab'],['variable']
Modifiability,"OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; import warnings; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode, dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.settings import debug; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mesolve.html:2478,config,config,2478,docs/4.5/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; import warnings; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode, dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.settings import debug; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=Options(),; progress_bar=BaseProgressBar(), _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mesolve.html:2465,config,config,2465,docs/4.4/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:2344,config,configuration,2344,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,7,['config'],['configuration']
Modifiability,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ub",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:3590,config,configuration,3590,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['config'],['configuration']
Modifiability,"Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in gener",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:1597,variab,variable,1597,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,1,['variab'],['variable']
Modifiability,"Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:3464,coupling,coupling,3464,docs/4.6/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability,"Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:1762,coupling,coupling,1762,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability,"P Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical sy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:1230,enhance,enhanced,1230,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html,1,['enhance'],['enhanced']
Modifiability,"PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/three_level_atom.html:2455,config,configurations,2455,docs/4.1/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/three_level_atom.html,7,['config'],['configurations']
Modifiability,"PLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:2291,config,config,2291,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of; qutip.parallel.parallel_map. Param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:262546,variab,variables,262546,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:1669,config,configuration,1669,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,1,['config'],['configuration']
Modifiability,"Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may how",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/installation.html:1669,config,configuration,1669,docs/4.2/installation.html,https://qutip.org,https://qutip.org/docs/4.2/installation.html,3,['config'],['configuration']
Modifiability,"Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. pytest; 5.3+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may how",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:1678,config,configuration,1678,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['config'],['configuration']
Modifiability,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:2644,config,configuration,2644,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,5,['config'],['configuration']
Modifiability,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html:2653,config,configuration,2653,docs/4.5/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html,1,['config'],['configuration']
Modifiability,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue depr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:2673,config,configuration,2673,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,1,['config'],['configuration']
Modifiability,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:2605,config,config,2605,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; >>> N = 10; >>> omega_a = 1.0; >>> omega_c = 1.25; >>> g = 0.05; >>> a = tensor(identity(2), destroy(N)); >>> sm = tensor(destroy(2), identity(N)); >>> sz = tensor(sigmaz(), identity(N)); >>> H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-tensor.html:6757,coupling,coupling,6757,docs/3.0.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html,2,['coupling'],['coupling']
Modifiability,"RPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:2424,config,config,2424,docs/4.6/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html,1,['config'],['config']
Modifiability,"RPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:2407,config,config,2407,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"RRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.tensor import tensor; from qutip.operators import qeye; from qutip.rhs_generate import (rhs_generate, rhs_clear, _td_format_check); from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis, projection; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; r""""""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)`; where :math:`\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback function",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/propagator.html:2769,config,config,2769,docs/4.6/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/propagator.html,1,['config'],['config']
Modifiability,"RTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops, args={}, options=None,; progress_bar=BaseProgressBar()):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:3664,config,config,3664,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"RY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2774,config,config,2774,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability,"Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6485,config,config,6485,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"S CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:33579,config,config,33579,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"SE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:2909,config,config,2909,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['config'],['config']
Modifiability,"SS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be au",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:2720,config,config,2720,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"STITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (`psi0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/sesolve.html:2643,config,config,2643,docs/4.5/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"STITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/sesolve.html:2663,config,config,2663,docs/4.6/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"STITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=[], args={}, options=Options(),; progress_bar=BaseProgressBar(), _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (`psi0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cann",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/sesolve.html:2630,config,config,2630,docs/4.4/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"STOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:18540,config,configuration,18540,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,2,['config'],['configuration']
Modifiability,"SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation wil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:198194,config,config,198194,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['config']
Modifiability,"Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:19281,refactor,refactored,19281,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['refactor'],['refactored']
Modifiability,"T OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:2663,config,config,2663,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"T-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38124,config,config,38124,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"TS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2711,config,config,2711,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability,"TURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:4029,enhance,enhancements,4029,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,6,['enhance'],['enhancements']
Modifiability,"TY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:2783,config,config,2783,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"The wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:96493,variab,variables,96493,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/frontmatter.html:2296,coupling,coupling,2296,docs/4.7/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html,1,['coupling'],['coupling']
Modifiability,"This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:262123,variab,variable,262123,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['variab'],['variable']
Modifiability,"This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:249941,variab,variable,249941,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['variab'],['variable']
Modifiability,"TiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1038,enhance,enhanced,1038,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,1,['enhance'],['enhanced']
Modifiability,"TiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-eseries.html:1921,parameteriz,parameterized,1921,docs/3.0.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html,1,['parameteriz'],['parameterized']
Modifiability,"True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems.; serial : boolean; If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial.; ptrace_sel: list; This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set sol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:5666,config,config,5666,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7943,config,config,7943,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"TypeError(""psi0 must be Qobj""); if psi0.isket:; pass; elif psi0.isunitary:; if not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition""; "" psi0 is a unitary operator.""); else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""); _solver_safety_check(H, psi0, c_ops=[], e_ops=e_ops, args=args). if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, psi0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, psi0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, psi0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, Qobj):; res = _sesolve_const(H, psi0, tlist, e_ops, args, options,; progress_bar); else:; raise TypeError(""Invalid Hamiltonian specification""). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:6214,config,config,6214,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,"URE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/changelog.html:2367,enhance,enhancements,2367,docs/4.1/changelog.html,https://qutip.org,https://qutip.org/docs/4.1/changelog.html,1,['enhance'],['enhancements']
Modifiability,"USINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.tensor import tensor; from qutip.operators import qeye; from qutip.rhs_generate import (rhs_generate, rhs_clear, _td_format_check); from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False, ; progress_bar=None, **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-depe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/propagator.html:2728,config,config,2728,docs/4.2/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/propagator.html,3,['config'],['config']
Modifiability,"USINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.tensor import tensor; from qutip.operators import qeye; from qutip.rhs_generate import (rhs_generate, rhs_clear, _td_format_check); from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False, ; progress_bar=None, _safe_mode=True, ; **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/propagator.html:2728,config,config,2728,docs/4.3/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/propagator.html,1,['config'],['config']
Modifiability,"USINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.tensor import tensor; from qutip.operators import qeye; from qutip.rhs_generate import (rhs_generate, rhs_clear, _td_format_check); from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/propagator.html:2724,config,config,2724,docs/4.4/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/propagator.html,2,['config'],['config']
Modifiability,"USTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:17261,config,configuration,17261,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,6,['config'],['configuration']
Modifiability,"U_list.append(controlled_gate(ry(gate.arg_value))); elif gate.name == ""CRZ"":; self.U_list.append(controlled_gate(rz(gate.arg_value))); elif gate.name == ""CPHASE"":; self.U_list.append(cphase(gate.arg_value)); elif gate.name == ""CNOT"":; self.U_list.append(cnot()); elif gate.name == ""CSIGN"":; self.U_list.append(csign()); elif gate.name == ""BERKELEY"":; self.U_list.append(berkeley()); elif gate.name == ""SWAPalpha"":; self.U_list.append(swapalpha(gate.arg_value)); elif gate.name == ""SWAP"":; self.U_list.append(swap()); elif gate.name == ""ISWAP"":; self.U_list.append(iswap()); elif gate.name == ""SQRTSWAP"":; self.U_list.append(sqrtswap()); elif gate.name == ""SQRTISWAP"":; self.U_list.append(sqrtiswap()); elif gate.name == ""FREDKIN"":; self.U_list.append(fredkin()); elif gate.name == ""TOFFOLI"":; self.U_list.append(toffoli()); elif gate.name == ""GLOBALPHASE"":; self.U_list.append(globalphase(gate.arg_value)); elif gate.name in self.user_gates:; if gate.controls is not None:; raise ValueError(""A user defined gate {} takes only ""; ""`targets` variable."".format(gate.name)); func_or_oper = self.user_gates[gate.name]; if inspect.isfunction(func_or_oper):; func = func_or_oper; para_num = len(inspect.getfullargspec(func)[0]); if para_num == 0:; oper = func(); elif para_num == 1:; oper = func(gate.arg_value); else:; raise ValueError(; ""gate function takes at most one parameters.""); elif isinstance(func_or_oper, Qobj):; oper = func_or_oper; else:; raise ValueError(""gate is neither function nor operator""); self.U_list.append(oper); else:; raise NotImplementedError(; ""{} gate is an unknown gate."".format(gate.name)). return self.U_list. def latex_code(self):; rows = []. ops = self.gates; col = []; for op in ops:; if isinstance(op, Gate):; gate = op; col = []; _swap_processing = False; for n in range(self.N+self.num_cbits):. if gate.targets and n in gate.targets:. if len(gate.targets) > 1:; if gate.name == ""SWAP"":; if _swap_processing:; col.append(r"" \qswap \qw""); continue; distance = abs(; gate",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html:46978,variab,variable,46978,docs/4.7/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html,1,['variab'],['variable']
Modifiability,"Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-eseries.html:2023,parameteriz,parameterized,2023,docs/3.1.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html,1,['parameteriz'],['parameterized']
Modifiability,"X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-control.html:6151,variab,variables,6151,docs/4.6/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html,2,['variab'],"['variable', 'variables']"
Modifiability,"[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); ; # Add H object terms to ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; # Add cop object terms to end of ode args string; for k in range(len(me_cops_obj)):; string_list.append(""me_cops_obj[%d]"" % k) ; ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=len(Lcoeff), h_tdterms=Lcoeff, ; c_td_splines=me_cops_coeff, ; c_td_spline_flags=me_cops_obj_flags, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mesolve.html:22257,config,config,22257,docs/4.3/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"[-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:15393,config,config,15393,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"[-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians.; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state or oper; #; if psi0.isket:; initial_vector = psi0.full().ravel(); oper_evo = False; elif psi0.isunitary:; initial_vector = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:18885,config,config,18885,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"[-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15650,config,config,15650,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,3,['config'],['config']
Modifiability,"[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36706,config,config,36706,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35704,config,config,35704,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"[0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not share same structure.'). #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:29394,config,config,29394,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['config'],['config']
Modifiability,"[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17586,config,config,17586,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.inte",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:14551,config,config,14551,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,3,['config'],['config']
Modifiability,"[config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29700,config,config,29700,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"[ii]; elif isinstance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state); ; if isinstance(e_ops, list): ; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not share same structure.'). ; #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:27229,config,config,27229,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,1,['config'],['config']
Modifiability,"[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18241,config,config,18241,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37346,config,config,37346,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36344,config,config,36344,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32616,config,config,32616,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability,"[np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15197,config,config,15197,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"[np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16189,config,config,16189,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"\left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html:3368,evolve,evolves,3368,docs/4.5/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html,1,['evolve'],['evolves']
Modifiability,"] = list(range(self.num_cbits,; self.num_cbits + num_regs)); self.num_cbits += num_regs; else:; raise SyntaxError(""QASM: incorrect bracket formatting""); elif command[0] == ""reset"":; raise NotImplementedError((""QASM: reset functionality ""; ""is not supported."")); elif command[0] in [""barrier"", ""include""]:; continue; else:; unprocessed.append(num); continue. if open_bracket_mode:; raise SyntaxError(""QASM: incorrect bracket formatting""). self.commands = [self.commands[i] for i in unprocessed]. def _custom_gate(self, qc_temp, gate_call):; '''; Recursively process a custom-defined gate with specified arguments; to produce a dummy circuit with all the gates in the custom-defined; gate. Parameters; ----------. qc_temp: :class:`.QubitCircuit`; temporary circuit to process custom gate; gate_call: list of str; tokens corresponding to gate signature/call; '''. gate_name, args, regs = gate_call; gate = self.qasm_gates[gate_name]; args_map = {}; regs_map = {}. # maps variables to supplied arguments, registers; for i, arg in enumerate(gate.gate_args):; args_map[arg] = eval(str(args[i])); for i, reg in enumerate(gate.gate_regs):; regs_map[reg] = regs[i]; # process all the constituent gates with supplied arguments, registers; for call in gate.gates_inside:. # create function call for the constituent gate; name, com_args, com_regs = call. for arg, real_arg in args_map.items():; com_args = [command.replace(arg.strip(), str(real_arg)); for command in com_args]; for reg, real_reg in regs_map.items():; com_regs = [command.replace(reg.strip(), str(real_reg)); for command in com_regs]; com_args = [eval(arg) for arg in com_args]. if name in self.predefined_gates:; qc_temp.user_gates = _get_qiskit_gates(); com_regs = [int(reg) for reg in com_regs]; self._add_predefined_gates(qc_temp, name, com_regs, com_args); else:; self._custom_gate(qc_temp, [name, com_args, com_regs]). def _regs_processor(self, regs, reg_type):; '''; Process register tokens: map them to the :class:`.QubitCircuit` indices; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html:8923,variab,variables,8923,docs/4.6/modules/qutip/qip/qasm.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html,2,['variab'],['variables']
Modifiability,"]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; ; initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:18437,config,config,18437,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['config'],['config']
Modifiability,"](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16156,config,config,16156,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:17148,config,config,17148,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"].col_times; sol.col_which[0:sols[0].ntraj] = sols[0].col_which; sol.states = np.array(sols[0].states, dtype=object); sol.expect = np.array(sols[0].expect); if (hasattr(sols[0], 'entropy')):; sol.entropy = np.array(sols[0].entropy); sofar = 0; for j in range(1, len(sols)):; sofar = sofar + sols[j - 1].ntraj; sol.col_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17552,config,config,17552,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33948,config,config,33948,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"]: es3_expect; Out[12]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = -1j; (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [14]: psi0 = basis(2,1). In [15]: H = sigmaz(). In [16]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by pri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-eseries.html:6311,evolve,evolve,6311,docs/3.1.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html,1,['evolve'],['evolve']
Modifiability,"]: es3_expect; Out[14]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = -1j; (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [16]: psi0 = basis(2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by pri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-eseries.html:6214,evolve,evolve,6214,docs/3.0.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html,2,['evolve'],['evolve']
Modifiability,"]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:18304,coupling,coupling,18304,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability,"]; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13446,config,config,13446,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; glo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27977,config,config,27977,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestrName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestrName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:207687,variab,variables,207687,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters. AQobjQuantum object representing a superoperator. targetQobjQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \langle a_n\rangle\]. Parameter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:47776,variab,variable,47776,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variable']
Modifiability,"_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then loo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:6215,variab,variables,6215,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['variab'],"['variable', 'variables']"
Modifiability,"_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.catch_warnings():; warni",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:30896,config,config,30896,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23425,config,config,23425,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29888,config,config,29888,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15078,config,config,15078,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16070,config,config,16070,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36773,config,config,36773,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36633,config,config,36633,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11397,config,config,11397,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHSt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23712,config,config,23712,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17113,config,config,17113,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"_correlation_mc_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); tlist = np.asarray(tlist); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:34314,config,config,34314,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['config'],['config']
Modifiability,"_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33844,config,config,33844,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29982,config,config,29982,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:51179,config,configuration,51179,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,4,['config'],['configuration']
Modifiability,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:51384,config,configuration,51384,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['config'],['configuration']
Modifiability,"_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22728,config,config,22728,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; prin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18288,config,config,18288,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15979,config,config,15979,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16971,config,config,16971,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:54068,coupling,coupling,54068,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32408,config,config,32408,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31388,config,config,31388,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28088,config,config,28088,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] +",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29091,config,config,29091,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_index, mat2vec, vec2mat; from qutip.mesolve import mesolve; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:3699,variab,variables,3699,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,4,['variab'],['variables']
Modifiability,"_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-depen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34207,config,config,34207,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33198,config,config,33198,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_map']. from scipy import array; from multiprocessing import Pool; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1.0, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html:4543,variab,variables,4543,docs/3.1.0/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html,1,['variab'],['variables']
Modifiability,"_mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:31929,config,config,31929,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30909,config,config,30909,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~Qobj`, :class:`~QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~Qobj , list of :obj:`Qobj` and; coefficient, :obj:`~QObjEvo`, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo's; description. psi0 : :class:`~Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; List of times for :math:`t`. e_ops : list of :class:`~Qobj` or callback function, optional; Single operator or list of o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/sesolve.html:3259,evolve,evolve,3259,docs/4.6/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html,1,['evolve'],['evolve']
Modifiability,"_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~qutip.Qobj`, :class:`~qutip.QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~qutip.Qobj` , list of; :obj:`~qutip.Qobj` and coefficient, :obj:`~qutip.QobjEvo`,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo's description. psi0 : :class:`~qutip.Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; List of times for :math:`t`. e_ops : None / list / callback function, optional; A ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/sesolve.html:1524,evolve,evolve,1524,docs/4.7/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html,1,['evolve'],['evolve']
Modifiability,"_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29699,config,config,29699,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:9085,config,configure,9085,docs/4.3/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html,10,['config'],['configure']
Modifiability,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; sup_di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:9085,config,configure,9085,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,6,['config'],['configure']
Modifiability,"_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31893,config,config,31893,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32265,config,config,32265,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31245,config,config,31245,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7555,config,config,7555,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.25s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.48s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.75s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.97s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.21s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.46s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.70s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.95s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.21s. Est. time left: 00:00:00:00; 100.0%. Run time: 2.46s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:8721,variab,variables,8721,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.28s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.53s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.78s. Est. time left: 00:00:00:01; 40.0%. Run time: 1.03s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.28s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.53s. Est. time left: 00:00:00:01; 70.0%. Run time: 1.79s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.03s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.28s. Est. time left: 00:00:00:00; 100.0%. Run time: 2.57s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:8188,variab,variables,8188,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.44s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.88s. Est. time left: 00:00:00:03; 30.0%. Run time: 1.55s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.28s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.84s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.54s. Est. time left: 00:00:00:02; 70.0%. Run time: 4.23s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.94s. Est. time left: 00:00:00:01; 90.0%. Run time: 6.06s. Est. time left: 00:00:00:00; 100.0%. Run time: 6.80s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:8746,variab,variables,8746,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.60s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.13s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.69s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.24s. Est. time left: 00:00:00:02; 70.0%. Run time: 3.79s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.38s. Est. time left: 00:00:00:01; 90.0%. Run time: 4.93s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.46s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:8214,variab,variables,8214,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.30s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.54s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.79s. Est. time left: 00:00:00:01; 40.0%. Run time: 1.05s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.30s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.57s. Est. time left: 00:00:00:01; 70.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.09s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.35s. Est. time left: 00:00:00:00; 100.0%. Run time: 2.60s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:8448,variab,variables,8448,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.56s. Est. time left: 00:00:00:05; 20.0%. Run time: 1.08s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.64s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.31s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.90s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.49s. Est. time left: 00:00:00:02; 70.0%. Run time: 4.10s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.65s. Est. time left: 00:00:00:01; 90.0%. Run time: 5.22s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.80s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:8811,variab,variables,8811,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 3.78s. Est. time left: 00:00:00:33; 20.0%. Run time: 7.55s. Est. time left: 00:00:00:30; 30.0%. Run time: 11.12s. Est. time left: 00:00:00:25; 40.0%. Run time: 14.82s. Est. time left: 00:00:00:22; 50.0%. Run time: 18.42s. Est. time left: 00:00:00:18; 60.0%. Run time: 22.19s. Est. time left: 00:00:00:14; 70.0%. Run time: 25.87s. Est. time left: 00:00:00:11; 80.0%. Run time: 29.56s. Est. time left: 00:00:00:07; 90.0%. Run time: 33.20s. Est. time left: 00:00:00:03; 100.0%. Run time: 36.90s. Est. time ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:8342,variab,variables,8342,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability,"_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31790,config,config,31790,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; glo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20688,config,config,20688,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:18106,config,config,18106,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['config'],['config']
Modifiability,"_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # ------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13720,config,config,13720,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14569,config,config,14569,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15561,config,config,15561,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to mo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11851,config,config,11851,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12857,config,config,12857,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html:69333,config,config,69333,docs/4.0.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/pulseoptim.html,1,['config'],['config']
Modifiability,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:68937,config,config,68937,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,1,['config'],['config']
Modifiability,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:69333,config,config,69333,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,1,['config'],['config']
Modifiability,"_radius = (self.positions_of_sites[; j]-self.positions_of_sites[i])/2. circle1 = plt.Circle((c_cen, 0), c_radius, color='g',; fill=False); ax.add_artist(circle1); if label_on is True:; x_b = c_cen; y_b = c_radius - 0.025; plt.text(x=x_b, y=y_b, s='H'+str(i)+str(j),; horizontalalignment='center',; verticalalignment='center'); x2 = (1+self.positions_of_sites[CNS-1])/2; x1 = x2-1; h = (self.positions_of_sites[; CNS-1]-self.positions_of_sites[0])*8/15; ax.plot([x1, x1], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7); ax.plot([x2, x2], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7); ax.plot([x1, x2], [h, h], ""-"", c=""k"", lw=1.5, zorder=7); ax.plot([x1, x2], [-h, -h], ""-"", c=""k"", lw=1.5, zorder=7); plt.axis('off'); plt.show(); plt.close(); return Hcell. [docs] def display_lattice(self):; """"""; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns; -------; inter_T : Qobj; The coefficient of $\psi_{i,N}^{\dagger}\psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1.; """"""; dim_I = [self.cell_tensor_config, self.cell_tensor_config]; H_inter = Qobj(np.zeros((self._length_of_unit_cell,; self._length_of_unit_cell)), dims=dim_I); for no, inter_hop_no in enumerate(self._H_inter_list):; H_inter = H_inter + inter_hop_no. H_inter = np.array(H_inter); csn = self.cell_num_site; Hcell = [[{} for i in range(csn)] for j in range(csn)]. for i0 in range(csn):; for j0 in range(csn):; Qin = np.zeros((self._length_for_site, self._length_for_site),; dtype=complex); for i in range(self._length_for_site):; for j in range(self._length_for_site):; Qin[i, j] = self._H_intra[; i0*self._length_for_site+i,; j0*self._length_for_site+j]; dim_site = list(np.delete(self.cell_tensor_config, [0], None)); dims_site = [dim_site, dim_site]; Hcell[i0][j0] = Qobj(Qin, dims=dims_site). j0 = 0; i0 = csn-1; Qin = np.zeros((self._length_for_site, self._length_for_site),; dtype=complex); for i in range(self._length_for_site):; for j in range(self._leng",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/lattice.html:38736,coupling,coupling,38736,docs/4.5/modules/qutip/lattice.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/lattice.html,1,['coupling'],['coupling']
Modifiability,"_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9227,config,config,9227,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not '; 'share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not '; 'share same structure.'). #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/solver.html:29451,config,config,29451,docs/4.5/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/solver.html,1,['config'],['config']
Modifiability,"_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:31973,config,config,31973,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENC",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30953,config,config,30953,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; sup_dim = H_sys.dims[0][0]**2; unit_sys = qeye(H_sys.dims[0]). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(Q)*spost(Q.dag()) + spre(Q.dag()*Q) + spost(Q.dag()*Q). approx_factr = ((2*lam0 / (beta*gam*hbar)) - 1j*lam0) / hbar; for k in range(N_m):; approx_factr -= (c[k] / nu[k]); L_bnd = -approx_factr*op.data; L_helems = zcsr_kron(unit_helems, L_bnd); else:; L_helems = fast_csr_matrix(shape=(N_he*sup_dim, N_he*sup_dim)). # Build the hierarchy element interaction matrix; if stats: start_helem_constr = timeit.default_timer(). unit_sup = spre(unit_sys).data; spreQ = spre(Q).da",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:10467,coupling,coupling,10467,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,3,['coupling'],['coupling']
Modifiability,"_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37663,config,config,37663,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14278,config,config,14278,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15270,config,config,15270,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"_times[sofar:sofar + sols[j].ntraj] = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17853,config,config,17853,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"a = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'. Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:15733,variab,variables,15733,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,2,['variab'],['variables']
Modifiability,"a = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats:; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'. Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the sec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/solver.html:16031,variab,variables,16031,docs/4.6/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html,2,['variab'],['variables']
Modifiability,"a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:3485,evolve,evolves,3485,docs/4.7/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html,1,['evolve'],['evolves']
Modifiability,"a). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12560,config,config,12560,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"a); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32389,config,config,32389,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"a); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of cons",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31369,config,config,31369,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"a.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:19709,config,config,19709,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"a.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20498,config,config,20498,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,2,['config'],['config']
Modifiability,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:70504,config,configuration,70504,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:67509,config,configuration,67509,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,3,['config'],['configuration']
Modifiability,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:198155,config,configuration,198155,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"ack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12328,config,config,12328,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"afe_mode:; if not isinstance(psi0, Qobj):; raise TypeError(""psi0 must be Qobj""); if psi0.isket:; pass; elif psi0.isunitary:; if not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition""; "" psi0 is a unitary operator.""); else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""); _solver_safety_check(H, psi0, c_ops=[], e_ops=e_ops, args=args). if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, psi0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, psi0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, psi0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, Qobj):; res = _sesolve_const(H, psi0, tlist, e_ops, args, options,; progress_bar); else:; raise TypeError(""Invalid Hamiltonian specification""). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:6189,config,config,6189,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"aj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13216,config,config,13216,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"ajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22354,config,config,22354,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"al Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state accor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:1671,evolve,evolve,1671,docs/4.7/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html,1,['evolve'],['evolve']
Modifiability,"al codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:12398,variab,variable,12398,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['variab'],['variable']
Modifiability,"al_map']. from scipy import array; from multiprocessing import Pool; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html:3285,variab,variables,3285,docs/4.0.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html,1,['variab'],['variables']
Modifiability,"al_map']. from scipy import array; from multiprocessing import Pool; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/parallel.html:3285,variab,variables,3285,docs/4.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html,5,['variab'],['variables']
Modifiability,"algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:30551,config,config,30551,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['config'],['config']
Modifiability,"all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html:7037,config,config,7037,docs/4.0.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"all_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; N",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:191613,variab,variables,191613,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"all_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or Non",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:193534,variab,variables,193534,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"all_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:H_d : Qobj or list of Qobj. Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]. a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:178731,variab,variables,178731,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"ally traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix.; calc_entropy : boolean; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag())",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6007,config,config,6007,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:17710,coupling,coupling,17710,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,1,['coupling'],['coupling']
Modifiability,"als); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<strin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29321,config,config,29321,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"alse, alpha=None, beta=None, phase_sensitive=False, overlap_terminate=1.0, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x107be58d0>)[source]¶; Calculate control pulses for the Hamiltonian operators in H_ops so that; the unitary U is realized.; Experimental: Work in progress. Parameters:U : Qobj. Target unitary evolution operator. H0 : Qobj. Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj. A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int. Number of GRAPE iterations. time : array / list. Array of time coordinates for control pulse evalutation. u_start : array. Optional array with initial control pulse values. Returns:Instance of GRAPEResult, which contains the control pulses calculated. with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator. Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, dyn_type='GEN_MAT', prop_type='DEF', fid_type='DEF', phase_option=None, fid_err_scale_factor=None, amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:129672,config,configuration,129672,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['config'],['configuration']
Modifiability,"alue, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; if oper_evo:; initial_vector = psi0.full().ravel('F'); r = scipy.integrate.ode(_td_ode_rhs_oper); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # TODO cythonize this?; def _td_ode_rhs_oper(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:15445,config,config,15445,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"alueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19714,config,config,19714,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"alues. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html:6458,config,config,6458,docs/4.0.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ame.qu’ in current directory. Parameters:name (str) – Name of data file to be loaded. Returns:qobject – Object retrieved from requested file. Return type:instance / array_like. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data (instance/array_like) – Input Python object to be stored.; filename (str) – Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func (function_type) – A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function.; following keyword argument is reserved (The) – ; num_cpus (int) – Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result – A list with length equal to number of input parameters; containing the output from func. Return type:list. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array /",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:196967,variab,variables,196967,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variables']
Modifiability,"amics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_hamList of QobjThese are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. HList of QobjThe combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity()[source]¶; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(amplitudes, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:216255,config,configuration,216255,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"amics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-eseries.html:1264,parameteriz,parameterized,1264,docs/4.5/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-eseries.html,1,['parameteriz'],['parameterized']
Modifiability,"ams,; optim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params,; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]). if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:17640,config,configuration,17640,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,3,['config'],['configuration']
Modifiability,"ams=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:41191,variab,variables,41191,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['variab'],['variables']
Modifiability,"an be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:16987,coupling,coupling,16987,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,2,['coupling'],['coupling']
Modifiability,"an be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); Out[30]: [<matplotlib.lines.Line2D at 0x1a251955c0>]. In [31]: plt.plot(tlist, actual_answer); Out[31]: [<matplotlib.lines.Line2D at 0x1a254cc860>]. In [32]: plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; In [33]: a_ops = [ [ (a, a.dag()), ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html:17081,coupling,coupling,17081,docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability,"an be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <matplotlib.figure.Figure at 0x2b4e7dd74b38>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:17045,coupling,coupling,17045,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability,"an(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, m, k. Back to top. © Copy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19839,config,config,19839,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"an; If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6193,config,config,6193,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list of coupling terms between unit cells of the lattice. is_realboolIndicates if the Hamiltonian is real or not. Hamiltonian()[source]¶; Returns the lattice Hamiltonian for the instance of Lattice1d. Returns. Qobj(Hamil)qutip.Qobjoper type Quantum object representing the lattice Hamiltonian. basis(cell, site, dof_ind)[source]¶; Returns a single particle wavefunction ket with the particle localized; at a specified dof at a specified site of a specified cell. Parameters. cell (int) – The cell at which the particle is to be localized.; site (int) – The site of the cell at which the particle is to be localized.; dof_ind (int/ list of int) – The index of the degrees of freedom with which the sigle particle; is to be localized. Returns. vec_iqutip.Qobjket type Quantum object representing the localized particle. bloch_wave_functions()[source]¶; Returns eigenvectors ($psi_n(k)$) of the Hamiltonian in a; numpy.ndarray for translationally symmetric lattices with periodic; boundary condition. \begin{eqnarray}; |\psi_n(k",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:66810,coupling,coupling,66810,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability,"and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list of coupling terms between unit cells of the lattice. is_realboolIndicates if the Hamiltonian is real or not. Methods. Hamiltonian(); Hamiltonian of the crystal. basis(); basis with the particle localized at a certain cell, site with specified degree of freedom. distribute_operator(); Distributes an input operator over all the cells. x(); Position operator for the crystal. k(); Crystal momentum operator for the crystal. operator_at_cells(); Distributes an input operator over user specified cells . operator_between_cells(); A function that returns an operator matrix that applies an operator between a two specified cells. plot_dispersion(); Plots dispersion relation of the crystal. get_dispersion(); Returns the dispersion relation of the crystal. bloch_wave_functions(); Returns the eigenstates of the Hamiltonian (which are Bloch wavefunctions) for a translationally symmetric periodic lattice. array_of_unk(); Returns eigenvectors of the bulk Hamiltonian, i.e. the cell periodic part of the Bloch wavefunctios i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:61307,coupling,coupling,61307,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; In [6]: import matplotlib.pyplot as plt. In [7]: tlist = np.linspace(0, 15.0, 1000). In [8]: psi0 = rand_ket(2). In [9]: e_ops = [sigmax(), sigmay(), sigmaz()]. In [10]: expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). In [11]: sphere = Bloch(). In [12]: sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). In [13]: sphere.vector_color = ['r']. In [14]: sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). In [15]: sphere.make_sphere(). In [16]: plt.show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; In [17]: output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.solver.Result. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html:12888,evolve,evolve,12888,docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html,1,['evolve'],['evolve']
Modifiability,"and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; In [6]: import matplotlib.pyplot as plt. In [7]: tlist = np.linspace(0, 15.0, 1000). In [8]: psi0 = rand_ket(2). In [9]: e_ops = [sigmax(), sigmay(), sigmaz()]. In [10]: expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). In [11]: sphere = Bloch(). In [12]: sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). In [13]: sphere.vector_color = ['r']. In [14]: sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). In [15]: sphere.make_sphere(). In [16]: plt.show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; In [17]: output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.solver.Result. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-bloch-redfield.html:12888,evolve,evolve,12888,docs/4.1/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-bloch-redfield.html,1,['evolve'],['evolve']
Modifiability,"and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. options : qutip.solver.Options; Options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters:; H : qutip.qobj. System Hamiltonian. a_ops : list; Nested list of system operators that cou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:66333,coupling,coupling,66333,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['coupling'],['coupling']
Modifiability,"ange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34868,config,config,34868,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"antum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3740,variab,variables,3740,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['variab'],['variables']
Modifiability,"any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34058,config,config,34058,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33049,config,config,33049,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"any(self):; """"""True if any of the calculation objects are to be dumped""""""; if (self.dump_amps or; self.dump_dyn_gen or; self.dump_prop or; self.dump_prop_grad or; self.dump_fwd_evo or; self.dump_onwd_evo or; self.dump_onto_evo):; return True; else:; return False. @property; def dump_all(self):; """"""True if all of the calculation objects are to be dumped""""""; dyn = self.parent; if (self.dump_amps and; self.dump_dyn_gen and; self.dump_prop and; self.dump_prop_grad and; self.dump_fwd_evo and; (self.dump_onwd_evo) or; (self.dump_onwd_evo == dyn.fid_computer.uses_onwd_evo) and; (self.dump_onto_evo or; (self.dump_onto_evo == dyn.fid_computer.uses_onto_evo))):; return True; else:; return False. def _apply_level(self, level=None):; dyn = self.parent; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_amps = False; self.dump_dyn_gen = False; self.dump_prop = False; self.dump_prop_grad = False; self.dump_fwd_evo = False; self.dump_onwd_evo = False; self.dump_onto_evo = False; elif level == 'FULL':; self.dump_summary = True; self.dump_amps = True; self.dump_dyn_gen = True; self.dump_prop = True; self.dump_prop_grad = True; self.dump_fwd_evo = True; self.dump_onwd_evo = dyn.fid_computer.uses_onwd_evo; self.dump_onto_evo = dyn.fid_computer.uses_onto_evo; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_evo_dump(self):; """"""Add dump of current time evolution generating objects""""""; dyn = self.parent; item = EvoCompDumpItem(self); item.idx = len(self.evo_dumps); self.evo_dumps.append(item); if self.dump_amps:; item.ctrl_amps = copy.deepcopy(dyn.ctrl_amps); if self.dump_dyn_gen:; item.dyn_gen = copy.deepcopy(dyn._",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:16295,config,config,16295,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,8,['config'],['config']
Modifiability,"appa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) +",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17135,coupling,coupling,17135,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability,"append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34000,config,config,34000,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.od",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:14493,config,config,14493,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability,"append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'); ; ; for kk, c in enumerate(c_ops):; if isinstance(c, Qobj):; C_terms.append(c.full('f')); C_td_terms.append('1'); elif isinstance(c, list):; C_terms.append(c[0].full('f')); if isinstance(c[1], Cubic_Spline):; CA_obj.append(c[1].coeffs); spline_count[0] += 1; C_td_terms.append(c[1]); else:; raise Exception('Invalid collapse operator specification.'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:13074,coupling,coupling,13074,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,3,['coupling'],['coupling']
Modifiability,"applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:75134,config,config,75134,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['config'],['config']
Modifiability,"applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2b11f5a5c950>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:75194,config,config,75194,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['config'],['config']
Modifiability,"ar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:1957,coupling,coupling,1957,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,2,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability,"ar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:6664,config,config,6664,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:7382,config,config,7382,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,12,['config'],['config']
Modifiability,"ar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {‘propagator’, ‘mesolve’}; Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:28551,coupling,coupling,28551,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"arams = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11528,config,config,11528,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['config'],['config']
Modifiability,"arams = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:10575,config,config,10575,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['config'],['config']
Modifiability,"arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(na",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36864,config,config,36864,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid())",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35862,config,config,35862,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"are passed as; vk_minus. vk_minus : list of complex; The frequencies (exponents) of the expansion terms for the ``-`` part; of the correlation function. The corresponding ceofficients are passed; as ck_minus. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """""". def _check_cks_and_vks(self, ck_plus, vk_plus, ck_minus, vk_minus):; if len(ck_plus) != len(vk_plus) or len(ck_minus) != len(vk_minus):; raise ValueError(; ""The bath exponent lists ck_plus and vk_plus, and ck_minus and""; "" vk_minus must be the same length.""; ); if len(ck_plus) != len(ck_minus):; raise ValueError(; ""The must be the same number of plus and minus exponents""; "" in the bath, and elements of plus and minus arrays""; "" should be arranged so that ck_plus[i] is the plus mode""; "" corresponding to ck_minus[i].""; ). def _check_coup_op(self, Q):; if not isinstance(Q, Qobj):; raise ValueError(""The coupling operator Q must be a Qobj.""). def __init__(self, Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=None):; self._check_cks_and_vks(ck_plus, vk_plus, ck_minus, vk_minus); self._check_coup_op(Q). exponents = []; for ckp, vkp, ckm, vkm in zip(ck_plus, vk_plus, ck_minus, vk_minus):; exponents.append(BathExponent(; ""+"", 2, Q, ckp, vkp, sigma_bar_k_offset=1, tag=tag,; )); exponents.append(BathExponent(; ""-"", 2, Q, ckm, vkm, sigma_bar_k_offset=-1, tag=tag,; )); super().__init__(exponents). [docs]class LorentzianBath(FermionicBath):; """"""; A helper class for constructing a Lorentzian fermionic bath from the; bath parameters (see parameters below). .. note::. This Matsubara expansion used in this bath converges very slowly; and ``Nk > 20`` may be required to get good convergence. The; Padé expansion used by :class:`LorentzianPadeBath` converges much; more quickly. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:20765,coupling,coupling,20765,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['coupling'],['coupling']
Modifiability,"are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:4778,plugin,plugin,4778,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,4,"['coupling', 'plugin']","['coupling', 'plugin']"
Modifiability,"arg[-1] = self.get_owd_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14723,config,config,14723,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,"arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,’+’, “A”, “Y”. Only used for latex. Examples; >>> def user_gate():; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); >>> qc.QubitCircuit(2, user_gates={""T"":user_gate}); >>> qc.add_gate(""T"", targets=[0]). add_1q_gate(self, name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters. namestringGate name. startintStarting location of qubits. endintLast qubit for the gate. qubitslistSpecific qubits for applying gates. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. add_circuit(self, qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters. qcQubitCircuitThe circuit block to be added to the main circuit. startintThe qubit on which the first gate is applied. add_gate(self, gate, targets=None, controls=None, arg_value=None, arg_label=None, index=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters. gate: string or `Gate`Gate name. If gate is an instance of Gate, parameters are; unpacked and added. targets: listGate targets. controls: listGate controls. arg_value: fl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:63029,variab,variable,63029,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['variab'],['variable']
Modifiability,"args = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13893,config,config,13893,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,10,['config'],['config']
Modifiability,"args). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14196,config,config,14196,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"args). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15188,config,config,15188,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ariant matrix; # ============================================================================; [docs]def tau_column(tau, k, j):; """"""; Determine the column index for the non-zero elements of the matrix for a; particular row `k` and the value of `j` from the Dicke space. Parameters; ----------; tau: str; The tau function to check for this `k` and `j`. k: int; The row of the matrix M for which the non zero elements have; to be calculated. j: float; The value of `j` for this row.; """"""; # In the notes, we indexed from k = 1, here we do it from k = 0; k = k + 1; mapping = {; ""tau3"": k - (2 * j + 3),; ""tau2"": k - 1,; ""tau4"": k + (2 * j - 1),; ""tau5"": k - (2 * j + 2),; ""tau1"": k,; ""tau6"": k + (2 * j),; ""tau7"": k - (2 * j + 1),; ""tau8"": k + 1,; ""tau9"": k + (2 * j + 1),; }; # we need to decrement k again as indexing is from 0; return int(mapping[tau] - 1). [docs]class Pim(object):; """"""; The Permutation Invariant Matrix class. Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state `p` as:. dp/dt = Mp. Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Attributes; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:37997,evolve,evolves,37997,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,3,['evolve'],['evolves']
Modifiability,"arlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32070,config,config,32070,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"arlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31050,config,config,31050,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). Back to top. © Copyright 2011 a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:39675,config,config,39675,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). © Copyright 2011 and later, P.D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38867,config,config,38867,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"array)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8832,config,config,8832,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32177,config,config,32177,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"ase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option). @property; def phase_option(self):; return self._phase_option. @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)). [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; self.dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:11286,config,configuration,11286,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['config'],['configuration']
Modifiability,"ased_dg. def _apply_phase_postop(self, dg):; """"""; Apply phasing operator to dynamics generator.; This called during the propagator calculation.; In this case it will be applied as dg*phase; """"""; if hasattr(self.dyn_gen_phase, 'dot'):; phased_dg = dg.dot(self._dyn_gen_phase); else:; phased_dg = dg*self._dyn_gen_phase; return phased_dg. def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:30391,config,configuration,30391,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,4,['config'],['configuration']
Modifiability,"ass for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13219,config,config,13219,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"at \(t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [2]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of meri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-control.html:4414,evolve,evolve,4414,docs/4.6/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html,1,['evolve'],['evolve']
Modifiability,"at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1954,config,configure,1954,docs/4.7/development/ideas/qutip-interactive.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html,1,['config'],['configure']
Modifiability,"ata * psi_t) ** 2 for c in c_ops]); p = np.cumsum(p / np.sum(p)); n = np.where(p >= r_op)[0][0]. # apply jump; psi_t = c_ops[n].data * psi_t; psi_t /= norm(psi_t); phi_t = np.copy(psi_t). # store info about jump; jump_times.append(times[t_idx] + dt * j); jump_op_idx.append(n). # get new random numbers for next jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dphi_t = (-1.0j * dt) * (Heff.data * phi_t). # deterministic evolution with correction for norm decay; dpsi_t = (-1.0j * dt) * (Heff.data * psi_t); A = 0.5 * np.sum([norm(c.data * psi_t) ** 2 for c in c_ops]); dpsi_t += dt * A * psi_t. # increment wavefunctions; phi_t += dphi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progres",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:33711,parameteriz,parameterized,33711,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['parameteriz'],['parameterized']
Modifiability,"ata to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestrName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestrName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. parallel_map(task",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:207273,variab,variable,207273,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variable']
Modifiability,"ata, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes:¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012):¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gate",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:9029,variab,variable,9029,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,7,['variab'],['variable']
Modifiability,"ata,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15139,config,config,15139,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"ata,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16131,config,config,16131,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ata[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_ishe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23090,config,config,23090,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ata_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:38327,config,config,38327,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ate for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0xd1fd3bdd8>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_binsintNumber of time bins; the range over which each index can vary. Returns. temporal_basis_vector:class: qutip.QobjA basis vector representing photon ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:129723,config,config,129723,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['config'],['config']
Modifiability,"ate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. parent¶; some control object (Dynamics or Optimizer) – aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir¶; str – directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level¶; string – level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file¶; bool – When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext¶; str – Default file extension for any file names that are auto generated. fname_base¶; str – First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary¶; bool – If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep¶; str – delimiter for the summary file.; default is a space. data_sep¶; str – delimiter for the data files (arrays saved to file).; default is a space. summary_file¶; str – File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:115305,config,configured,115305,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configured']
Modifiability,"ate) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=, []T=None, args={}, Tsteps=100)¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains experimental functions for solving stochastic schrodinger; and master equations. The API should not be considered stable, and is subject; to change when we work more on optimizing this module for performance and; features.; Todo:. parallelize. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / arr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:54037,variab,variables,54037,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:226714,config,configuration,226714,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decrea",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:107450,config,configuration,107450,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"ates = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19543,config,config,19543,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"ates whether the computer class instance is capable of computing propagator gradients. It is used to determine whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on; Attributes. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:87037,config,configuration,87037,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"atform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/parallel.html:3479,variab,variables,3479,docs/4.6/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html,1,['variab'],['variables']
Modifiability,"ath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to retain within the expansion of the; bath. System and bath dynamics¶; Now we are ready to construct a solver:; from qutip.nonmarkov.heom import HEOMSolver; from qutip import Options. max_depth = 5 # maximum hierarchy depth to retain; options = Options(nsteps=15_000). solver = HEOMSolver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:3092,coupling,coupling,3092,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,1,['coupling'],['coupling']
Modifiability,"ation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos; Attributes. freqs; (float array[num_coeffs]) Frequencies for the basis functions. randomize_freqs; (bool) If True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters:coeffs : float array[num_coeffs, num_basis_funcs]. The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds; Attributes. dyn_gen_name; (string) Text used in some report functions. Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics Default is simply ‘dynamics generator’. num_iter; (integer) Number of iterations of the optimisation algorithm. wall_time_optim_start; (float) Start time for the optimisation. wall_time_optim_end; (float) End time for the optimisation. wall_time_optim; (float) Time elasped during the optimisation. wall_time_dyn_gen_compute; (float) Total wall (elasped) time computing combined dynamics generator (for example combining drift and control Hamiltonians). wall_time_prop_compute; (float) Total wall (elasped) time computing propagators, that is the time evolution from one timeslot to the next Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute; (f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:107162,config,configurations,107162,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['config'],['configurations']
Modifiability,"ation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23550,config,config,23550,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ation; Attributes. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip_utils.logging, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. grad_exact; (boolean) indicates whether the computer class instance is capable of computing propagator gradients. It is used to determine whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:86568,config,configuration,86568,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"ation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; In [11]: result = p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-parfor.html:1529,variab,variables,1529,docs/4.5/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-parfor.html,2,['variab'],['variables']
Modifiability,"ations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Ham",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1983,coupling,coupling,1983,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['coupling'],['coupling']
Modifiability,"ators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38352,config,config,38352,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"atrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by using the to_super,; to_kraus and to_choi functions. The superrep; attribute keeps track of what reprsentation is a Qobj is currently using.; In [104]: J = to_choi(S). In [105]: J; Out[105]: ; Quantum object:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:20737,extend,extended,20737,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['extend'],['extended']
Modifiability,"atrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by using the to_super,; to_kraus and to_choi functions. The superrep; attribute keeps track of what reprsentation is a Qobj is currently using.; In [105]: J = to_choi(S). In [106]: J; Out[106]: ; Quantum object",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:20517,extend,extended,20517,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,2,['extend'],['extended']
Modifiability,"ats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:8068,coupling,coupling,8068,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,6,['coupling'],['coupling']
Modifiability,"ault is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=, []data_only=False)¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvill",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:20055,config,configurations,20055,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['config'],['configurations']
Modifiability,"aus_list)); op_len = len(kraus_mat_list[0]); op_rng = range(op_len); choi_blocks = array([[sum([op[:, c_ix] * array([op.H[r_ix, :]]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = len(q_oper.dims[0][0]); B = _pauli_basis(nq); B.superrep = 'choi'; return Qobj(B * q_oper * B.dag(), superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = len(q_oper.dims[0][0]); B = _pauli_basis(nq). # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B.dag() * q_oper * B) / q_oper.shape[0], superrep='choi'). # PUBLIC CONVERSION FUNCTIONS -------------------------------------------------; # These functions handle superoperator conversions in a way that preserves the; # correctness of Qobj.type, and in a way that automatically branches based on; # the input Qobj.type. [docs]def to_choi(q_oper):; """"""; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the returned operator is equal to the dimension; of the system. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Choi representation. Returns; -------; choi : Qobj; A quantum object representing the same map as ``q_oper``, such that; ``choi.superrep == ""choi""``. Raises; ------; TypeError: if the given quantum object is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:9147,extend,extend,9147,docs/3.1.0/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html,1,['extend'],['extend']
Modifiability,"ays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12578,config,config,12578,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"back on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8251,config,config,8251,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,10,['config'],['config']
Modifiability,"bal _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE sol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20222,config,config,20222,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"bi rotations for high-fidelity hole spin initialization"", ; Phys. Rev. B 92, 115306 (2015). 91. Wallman et al., ""Estimating the coherence of noise"", ; New J. Phys. 17, 113020 (2015). 90. Černotík et al., ""Adiabatic elimination of Gaussian subsystems from quantum dynamics under continuous measurement"", ; Phys. Rev. A 92, 012124 (2015). 89. Müller et al., ""Ultrafast Polariton-Phonon Dynamics of Strongly Coupled Quantum Dot-Nanocavity Systems"", ; Phys. Rev. X 5, 031006 (2015). 88. Osipovs et al., ""Markov Chains in the Task of Author's Writing Style Profile Construction"", ; Information Technology and Management Science 17, 119 (2014). 87. Armour et al., ""Josephson photonics with a two-mode superconducting circuit"", ; Phys. Rev. B 91, 184508 (2015). 86. Li et al., ""Hybrid Quantum Device Based on NV Centers in Diamond Nanomechanical Resonators Plus Superconducting Waveguide Cavities"", ; Phys. Rev. Applied 4, 044003 (2015). 85. Li et al., ""Enhanced electromechanical coupling of a nanomechanical resonator to coupled superconducting cavities"", ; Sci. Rep. 6, 19065 (2016). 84. del Pino et al., ""Quantum theory of collective strong coupling of molecular vibrations with a microcavity mode"", ; New. J. Phys. 17, 053040 (2015). 83. Rossetti et al., ""Trapped-ion Lissajous trajectories by engineering Rashba- and Dresselhaus-type spin-orbit interactions in a Paul trap"", ; Euro. Phys. Lett. 115, 53001 (2016). 82. Batalhao et al., ""Irreversibility and the Arrow of Time in a Quenched Quantum System"", ; Phys. Rev. Lett. 115, 190601 (2015). 81. Gonzalez-Ballestero et al., ""Harvesting excitons through plasmonic strong coupling"", ; Phys. Rev. B 92, 121402 (2015). 80. Lörch et al., ""Sub-Poissonian phonon lasing in three-mode optomechanics"", ; Phys. Rev. A 91, 061803(R) (2015). 79. Dalmonte et al., ""Cluster Luttinger liquids and emergent supersymmetric conformal critical points in the one-dimensional soft-shoulder Hubbard model"", ; Phys. Rev. B 92, 045106 (2015). 78. Weimer, ""Variational analys",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:38079,coupling,coupling,38079,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,"bitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:113234,config,configuration,113234,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"bj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType):; output.num_expect = 0; expt_callback = True. elif isinstance(e_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/floquet.html:13054,variab,variables,13054,docs/4.5/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/floquet.html,1,['variab'],['variables']
Modifiability,"bject seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # ----------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html:7183,config,config,7183,docs/4.0.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"ble metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:29163,config,config,29163,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['config'],['config']
Modifiability,"ble; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergenc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:6372,config,configuration,6372,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['config'],['configuration']
Modifiability,"box in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1065,config,config,1065,docs/4.7/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html,1,['config'],['config']
Modifiability,"bstantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:13847,variab,variables,13847,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,2,['variab'],['variables']
Modifiability,"by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes:; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity()[source]¶; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(amplitudes, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes:; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the prop",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:96913,config,configuration,96913,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"c(cov_es, wlist). return spectrum. # Monte Carlo solvers. def _correlation_mc_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:35178,config,config,35178,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['config'],['config']
Modifiability,"c_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:35216,config,config,35216,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['config'],['config']
Modifiability,"c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11776,config,config,11776,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12782,config,config,12782,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state); ; if isinstance(e_ops, list): ; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not share same structure.'). ; #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/solver.html:27257,config,config,27257,docs/4.3/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/solver.html,1,['config'],['config']
Modifiability,"c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); els",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:6488,config,config,6488,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,2,['config'],['config']
Modifiability,"c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specifica",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6292,config,config,6292,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,5,['config'],['config']
Modifiability,"cally by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; or one can use an inline method,; Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [3]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-options.html:3986,variab,variable,3986,docs/3.1.0/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-options.html,1,['variab'],['variable']
Modifiability,"can be set to help identify which; bath an exponent is from. class LorentzianPadeBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the LorentzianBath which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters. QQobjOperator describing the coupling between system and bath. gammafloatThe coupling strength between the system and the bath. wfloatThe width of the environment. mufloatThe chemical potential of the bath. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class HierarchyADOs(exponents, max_depth)[source]¶; A description of ADOs (auxilliary density operators) with the; hierarchical equations of motion.; The list of ADOs is constructed from a list of bath exponents; (corresponding to one or more baths). Each ADO is referred to by a label; that lists the number of “excitations” of each bath exponent. The; level of a label within the hierarchy is the sum of the “excitations”; within the label.; For example the label (0, 0, ..., 0) represents the density matrix; of the system being solved and is the only 0th level label.; The labe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:62035,coupling,coupling,62035,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability,"cate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13570,config,config,13570,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"cation. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:218520,config,configuration,218520,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['config'],['configuration']
Modifiability,"cation. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:90916,config,configuration,90916,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"ce / array_like. Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:data : instance/array_like. Input Python object to be stored. filename : str. Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:task : a Python function. The function that is to be called for each value in task_vec. values : array / list. The list or array of values for which the task function is to be; evaluated. task_args : list / dictionary. The optional additional argument to t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:195246,variab,variables,195246,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['variab'],['variables']
Modifiability,"ce_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; self.ntrajs = np.array(self.ntrajs); self.ntrajs = self.ntrajs[np.where(self.ntrajs > 0)]; self.nprocs = len(self.ntrajs); sols = []; processes = []; resq = JoinableQueue(); resq.join(). if debug:; print(""Number of cpus: "" + str(self.cpus)); print(""Trying to start "" + str(self.nprocs) + "" process(es).""); print(""Number of trajectories for each process: "" +; str(self.ntrajs)).",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8728,config,config,8728,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"ce_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8321,config,config,8321,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"cessive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str. Name of generated RHS. cleanup: bool. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:state : qobj. A state vector or density matrix for a spin-j quantum system. theta : array_like. theta-coordinates at which to calculate the Q function. phi : array_like. phi-coordinates at which to calculate the Q function. Returns:Q, THETA, PHI : 2d-array. Values representing the spin Q function at the values",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:109736,config,config,109736,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['config'],['config']
Modifiability,"ch depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 (Qobj) – Initial state (density matrix) of the system.; tlist (list) – Time over which system evolves. Returns:results – Object storing all results from the simulation. Return type:qutip.solver.Result. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:30353,evolve,evolves,30353,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['evolve'],['evolves']
Modifiability,"ch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:H : Qobj / list. System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj. Initial density matrix or state vector (ket). tlist : array_like. List of times for evaluating evolution. a_ops : list. Ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:64059,variab,variable,64059,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['variab'],"['variable', 'variables']"
Modifiability,"check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeffs (PulseGenCrab attribute). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). col_times (Result attribute). col_which (Result attribute). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). config (Optimizer attribute). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method), [1]. controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method), [1]. coup_op (HEOMSolver attribute). coup_strength (HEOMSolver attribute). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:3629,config,configure,3629,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['config'],['configure']
Modifiability,"cies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36521,config,config,36521,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"cies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args strin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35519,config,config,35519,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"cified by the index. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None, dims=None, num_cbits=0)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,’+’, “A”, “Y”. Only used for latex. dimslistA list of integer for the dimension of each composite system.; e.g [2,2,2,2,2] for 5 qubits system. If None, qubits system; will be the default option. num_cbitsintNumber of classical bits in the system. Examples; >>> def user_gate():; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); >>> qubit_circuit = QubitCircuit(2, user_gates={""T"":user_gate}); >>> qubit_circuit.add_gate(""T"", targets=[0]). add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None, classical_controls=None, control_value=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters. namestringGate name. startintStarting location of qubits. endintLast qubit for the gate. qubitslistSpecific qubits for applying gates. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters. qcQubitCircuitThe circuit block to be added to the main circuit. startintThe qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None, index=None, classical_controls=None, control_value=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters. gate: string or :class:`.Gate`Gate name. If gate is an instance of Gate, parameters are; unpacked and added. targets:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:78948,variab,variable,78948,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['variab'],['variable']
Modifiability,"cified by the index. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None, dims=None, num_cbits=0)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,’+’, “A”, “Y”. Only used for latex. dimslistA list of integer for the dimension of each composite system.; e.g [2,2,2,2,2] for 5 qubits system. If None, qubits system; will be the default option. num_cbitsintNumber of classical bits in the system. Examples; >>> def user_gate():; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); >>> qubit_circuit = QubitCircuit(2, user_gates={""T"":user_gate}); >>> qubit_circuit.add_gate(""T"", targets=[0]). add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None, classical_controls=None, control_value=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters. namestringGate name. startintStarting location of qubits. endintLast qubit for the gate. qubitslistSpecific qubits for applying gates. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. add_circuit(qc, start=0, overwrite_user_gates=False)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters. qcQubitCircuitThe circuit block to be added to the main circuit. startintThe qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None, index=None, classical_controls=None, control_value=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters. gate: string or :class:`.Gate`Gate name. If gate is an instance of Gate, parameters are; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:111153,variab,variable,111153,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['variab'],['variable']
Modifiability,"cision, for ranks less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters:; N : int; Square root of the dimension of the superoperator to be returned. enforce_tp : bool; If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rank : int or None; Rank of the sampled superoperator. If None, a full-rank; superoperator is generated. dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . [R0be8dcf25d86-1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:; states : array; array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:; ops : array; array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix represent",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:35680,config,configuration,35680,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['config'],['configuration']
Modifiability,"cking; them together. get_ops_labels(self)[source]¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(self, qc)[source]¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. optimize_circuit(self, qc)[source]¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. Returns. qc: QubitCircuitThe optimal circuit representation. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:73111,config,configuration,73111,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:3993,config,config,3993,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and col",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:31689,config,config,31689,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30669,config,config,30669,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37588,config,config,37588,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
