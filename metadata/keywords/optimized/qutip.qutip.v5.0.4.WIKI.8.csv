quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"self, x):; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). def add_control_noise(self, qobj, targets, tlist=None, coeff=None):; self.add_coherent_noise(qobj, targets, tlist=tlist, coeff=coeff). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element short",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:8351,depend,dependent,8351,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,4,['depend'],['dependent']
Integrability,"self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~QobjEvo`, :class:`~Qobj`, scalars.; - ``*``: :class:`~Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~Qobj` instances,; each of which *may* have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is :math:`Q(t)`, then it is constructed from a set of constant; :obj:`~Qobj` :math:`\\{Q_k\\}` and time-dependent scalars :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~Qobj`, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:7320,depend,dependence,7320,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['depend'],['dependence']
Integrability,"senting time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is constructed from a set; of constant:obj:`~qutip.Qobj` :math:`\\{Q_k\\}` and time-dependent scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:5705,depend,dependent,5705,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['depend'],['dependent']
Integrability,"set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters:; H : qutip.qobj; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : qutip.qobj; initial state vector (ket); or initial unitary operator psi0 = U. tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be empty list operator evolution. args : dictionary; dictionary of parameters for time-dependent Hamiltonians. options : qutip.Qdeoptions; with options for the ODE solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; output: :class:`qutip.solver`; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:54301,depend,dependent,54301,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"set_f_params(L.data); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = ket2dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:23658,depend,dependence,23658,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['depend'],['dependence']
Integrability,"sform(f_states_t, True); elif f_modes_0 is not None:; # Interaction picture, computational basis.; def transform(rho, t):; return rho.transform(f_modes_0, False); else:; raise ValueError(; ""cannot transform out of the Floquet basis without some knowledge ""; ""of the Floquet modes. Pass `f_modes_0`, or all of `f_modes_t`, ""; ""`f_energies` and `T`.""; ). # Setup integrator.; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). # Main evolution loop.; for t_idx, t in enumerate(tlist):; if not r.successful():; break; rho = transform(Qobj(vec2mat(r.y), rho0.dims, rho0.shape), t); if expt_callback:; e_ops(t, rho); else:; for m, e_op in enumerate(e_ops):; output.expect[m][t_idx] = expect(e_op, rho); if store_states:; output.states.append(rho); r.integrate(r.t + dt); return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a functio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:24301,integrat,integrate,24301,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['integrat'],['integrate']
Integrability,"shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:169403,depend,dependent,169403,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependent']
Integrability,"si(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/scattering.html:11622,integrat,integrate,11622,docs/4.7/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html,2,['integrat'],['integrate']
Integrability,"sign2) * self._s_pre_minus_post_Qdag[k]; else:; op = (-1j * sign2) * self._s_pre_plus_post_Qdag[k]; else:; raise ValueError(; f""Unsupported type {self.ados.exponents[k].type}""; f"" for exponent {k}""; ); return op. def _rhs(self, L):; """""" Make the RHS for the HEOM. """"""; ops = _GatherHEOMRHS(self.ados.idx, block=L.shape[0], nhe=self._n_ados). for he_n in self.ados.labels:; op = self._grad_n(L, he_n); ops.add_op(he_n, he_n, op); for k in range(len(self.ados.dims)):; next_he = self.ados.next(he_n, k); if next_he is not None:; op = self._grad_next(he_n, k); ops.add_op(he_n, next_he, op); prev_he = self.ados.prev(he_n, k); if prev_he is not None:; op = self._grad_prev(he_n, k); ops.add_op(he_n, prev_he, op). return ops.gather(). def _configure_solver(self):; """""" Set up the solver. """"""; RHSmat = self._rhs(self._L0.data); assert isinstance(RHSmat, sp.csr_matrix). if self._is_timedep:; # In the time dependent case, we construct the parameters; # for the ODE gradient function _dsuper_list_td under the; # assumption that RHSmat(t) = RHSmat + time dependent terms; # that only affect the diagonal blocks of the RHS matrix.; # This assumption holds because only _grad_n dependents on; # the system Liovillian (and not _grad_prev or _grad_next). h_identity_mat = sp.identity(self._n_ados, format=""csr""); H_list = self.H_sys.to_list(). solver_params = [[RHSmat]]; for idx in range(1, len(H_list)):; temp_mat = sp.kron(; h_identity_mat, liouvillian(H_list[idx][0]); ); solver_params.append([temp_mat, H_list[idx][1]]). solver = scipy.integrate.ode(self._dsuper_list_td); solver.set_f_params(solver_params); else:; solver = scipy.integrate.ode(cy_ode_rhs); solver.set_f_params(RHSmat.data, RHSmat.indices, RHSmat.indptr). solver.set_integrator(; ""zvode"",; method=self.options.method,; order=self.options.order,; atol=self.options.atol,; rtol=self.options.rtol,; nsteps=self.options.nsteps,; first_step=self.options.first_step,; min_step=self.options.min_step,; max_step=self.options.max_step,; ). self.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:19176,depend,dependent,19176,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,4,['depend'],['dependent']
Integrability,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2291,integrat,integrate,2291,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,2,['integrat'],['integrate']
Integrability,"sin', 'arcsinh', 'arctan', 'arctan2', 'arctanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'tau', 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pai",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:4701,depend,dependence,4701,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependence']
Integrability,"sing Parfor. Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:1706,depend,dependence,1706,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['depend'],"['depend', 'dependence']"
Integrability,"sing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:8342,depend,depending,8342,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['depend'],['depending']
Integrability,"sing the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:5770,depend,dependent,5770,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"sing the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any ord",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:5727,depend,dependent,5727,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist). # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:5956,depend,dependent,5956,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"sity matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; ``c_ops``. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of :class:`qutip.Qobj`; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict; Dictionary of parameters for time dependent systems. tol : float; Tolerance of the solver for implicit methods. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. dW_factors : array; Array of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:. - order 1/2 algorithms: 'euler-maruyama', 'pc-euler', 'pc-euler-imp'; - order 1 algorithms: 'milstein', 'platen', 'milstein-imp', 'rouchon'; - order 3/2 algorithms: 'taylor1.5', 'taylor1.5-imp', 'explicit1.5'; - order 2 algorithms: 'taylor2.0'. See the documentation of :func:`~qutip.stochastic.stochastic_solvers`; for a description of the solvers. Implicit methods can adjust; tolerance via the kw 'tol'. Default is {'tol': 1e-6}. method : string ('homodyne', 'heterodyne'); The name of the type of measurement process that give rise to the; stochastic equation to so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:10033,depend,dependent,10033,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['depend'],['dependent']
Integrability,"sk function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:109273,depend,dependencies,109273,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['depend'],['dependencies']
Integrability,"sket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:3350,integrat,integrating,3350,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,1,['integrat'],['integrating']
Integrability,"slist of ints, optionalSpecifies a list of targets “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. eigenvalues: list of floatThe list of eigenvalues of the measurement operator. eigenstates_or_projectors: list of QobjIf the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates. probabilities: list of floatThe probability of measuring the state as being in the corresponding; eigenstate (and the measurement result being the corresponding; eigenvalue). Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:74821,integrat,integrating,74821,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['integrat'],['integrating']
Integrability,"slist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.solver.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamilt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:151094,depend,dependent,151094,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"slot. onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. prop¶; List of propagators (Qobj) for each timeslot. prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters:file_name : string. Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string). List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]. Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean. If True then an info message will be logged. unitarity_check()[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header); Attributes. drift_ham; (Qobj) This is the drift Hamiltonian fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:83081,message,message,83081,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['message'],['message']
Integrability,"solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # pre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:2368,depend,dependent,2368,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['depend'],['dependent']
Integrability,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by qutip.expect. For callable functions, they are; called as f(t, state) and return the expectation value.; A single callback’s expectation value can be any type, but a callback; part of a list must return a number as the expectation value. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:85023,integrat,integrator,85023,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['integrat'],['integrator']
Integrability,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:80399,integrat,integrator,80399,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['integrat'],['integrator']
Integrability,"solver_name = ""photocurrent_mesolve""; sso.LH = liouvillian(sso.H, c_ops=sso.c_ops) * sso.dt. def _prespostdag(op):; return spre(op) * spost(op.dag()). sso.sops = [[spre(op._cdc()) + spost(op._cdc()),; spre(op._cdc()),; op.apply(_prespostdag)._f_norm2()] for op in sso.sc_ops]; sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:31322,depend,dependent,31322,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,5,['depend'],['dependent']
Integrability,"solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj.Qobj`; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : *list* / *array*; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. :math:`t \rightarrow \infty`; here tlist is; automatically set, ignoring user input. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. (does not accept time dependence). a_op : :class:`qutip.qobj.Qobj`; operator A. b_op : :class:`qutip.qobj.Qobj`; operator B. c_op : :class:`qutip.qobj.Qobj`; operator C. d_op : :class:`qutip.qobj.Qobj`; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : :class:`qutip.solver.Options`; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat: *array*; An 2-dimensional *array* (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional *array* of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:27046,depend,dependence,27046,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['depend'],['dependence']
Integrability,"something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals. We remind the reader that the types of functions that can be used with this method is limited to:; ['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil'; , 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1'; , 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma'; , 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p'; , 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']. Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; >>> H = [H0, [H1, '9 * exp(-(t / 5.) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)':; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e or pi will mess things up when using the string-based format. Collapse operators are handled in the exact same way. Function Based Hamiltonian¶; In the previous version of QuTiP, the simulation of time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:12428,depend,dependent,12428,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:168938,depend,dependent,168938,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:197734,Wrap,Wrapper,197734,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['Wrap'],['Wrapper']
Integrability,"specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. iter_num¶; int – Iteration number ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:71118,wrap,wrapper,71118,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['wrap'],['wrapper']
Integrability,"ss; coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key is not ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(CQobjCteOmp); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd.__new__(CQobjEvoTd); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp.__new__(CQobjEvoTdOmp); self.compiled_qobjevo.set_threads(self.omp); self.compiled_qobjevo.__setstate__(state[1]). elif mat_type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:39861,depend,dependence,39861,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['depend'],['dependence']
Integrability,"sses; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; IPython Notebook Tools; Miscellaneous. « Classes. Change Log ». Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)¶; Generates the vector representation of a Fock state. Parameters:N : int. Number of Fock states in Hilbert space. n : int. Integer corresponding to desired number state, defaults; to 0 if omitted. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the state. Returns:state : qobj. Qobj representing the requested number state |n>. Notes; A subtle incompatibility ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:2165,depend,dependent,2165,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ssing issue with NumPy compiled against OPENBLAS; if 'OPENBLAS_MAIN_FREE' not in os.environ:; os.environ['OPENBLAS_MAIN_FREE'] = '1'; # automatically set number of threads used by MKL and openblas to 1; # prevents errors when running things in parallel. Should be set; # by user directly in a script or notebook if >1 is needed.; # Must be set BEFORE importing NumPy; if 'MKL_NUM_THREADS' not in os.environ:; os.environ['MKL_NUM_THREADS'] = '1'. if 'OPENBLAS_NUM_THREADS' not in os.environ:; os.environ['OPENBLAS_NUM_THREADS'] = '1'. import sys; import warnings. import qutip.settings; import qutip.version; from qutip.version import version as __version__; from qutip.utilities import _version2int. # -----------------------------------------------------------------------------; # Check if we're in IPython.; try:; __IPYTHON__; qutip.settings.ipython = True; except:; qutip.settings.ipython = False. # -----------------------------------------------------------------------------; # Check for minimum requirements of dependencies, give the user a warning; # if the requirements aren't fulfilled; #. numpy_requirement = ""1.6.0""; try:; import numpy; if _version2int(numpy.__version__) < _version2int(numpy_requirement):; print(""QuTiP warning: old version of numpy detected "" +; (""(%s), requiring %s."" %; (numpy.__version__, numpy_requirement))); except:; warnings.warn(""numpy not found.""). scipy_requirement = ""0.11.0""; try:; import scipy; if _version2int(scipy.__version__) < _version2int(scipy_requirement):; print(""QuTiP warning: old version of scipy detected "" +; (""(%s), requiring %s."" %; (scipy.__version__, scipy_requirement))); except:; warnings.warn(""scipy not found.""). # -----------------------------------------------------------------------------; # check to see if running from install directory for released versions.; #; top_path = os.path.dirname(os.path.dirname(__file__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:4409,depend,dependencies,4409,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['depend'],['dependencies']
Integrability,"ssion.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve', 'bloch_redfield_tensor']. import numpy as np; import scipy.integrate; import scipy.sparse as sp; from qutip.qobj import Qobj, isket; from qutip.superoperator import spre, spost, vec2mat, mat2vec, vec2mat_index; from qutip.expect import expect; from qutip.solver import Options, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.solver import Result; from qutip.superoperator import liouvillian; from qutip.cy.spconvert import arr_coo2fast. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops, e_ops=[], spectra_cb=[], c_ops=[],; args={}, options=Options(),; _safe_mode=True):; """"""; Solve the dynamics for a system using the Bloch-Redfield master equation. .. note::. This solver does not currently support time-dependent Hamiltonians. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 / psi0: :class:`qutip.Qobj`; Initial density matrix or state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html:2180,integrat,integrate,2180,docs/4.0.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html,2,['integrat'],['integrate']
Integrability,"st : list of qutip.qobj. list of qutip.qobj collapse operators. e_ops : list of qutip.qobj. list of qutip.qobj operators for which to evaluate; expectation values. Returns:expt_array : array. Expectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:L : qobj. Liouvillian of the system. rho0 : qobj. Initial state vector or density matrix. Returns:eseries : qutip.eseries. eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops, e_ops=[], spectra_cb=[], c_ops=None, args={}, options=<qutip.solver.Options instance at 0x105963320>)[source]¶; Solve the dynamics for a system using the Bloch-Redfield master equation. Note; This solver does not currently support time-dependent Hamiltonians. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 / psi0: :class:`qutip.Qobj`. Initial density matrix or state vector (ket). tlist : list / array. List of times for \(t\). a_ops : list of qutip.qobj. List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. c_ops : list of qutip.qobj. List of system collapse operators. args : dictionary. Placeholder for future implementation, kept for API consistency. options : qutip.solver.Options. Options for the solver. Returns:result: qutip.solver.Result. An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=None, use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:54441,depend,dependent,54441,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"st Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # ------------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20706,integrat,integrator,20706,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['integrat'],['integrator']
Integrability,"st have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (12.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the te",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:4094,depend,dependencies,4094,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['depend'],['dependencies']
Integrability,"st have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management sy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:4313,depend,dependencies,4313,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['depend'],['dependencies']
Integrability,"st of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:74462,depend,depending,74462,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['depending']
Integrability,"st version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, suc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:8505,integrat,integration,8505,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['integrat'],['integration']
Integrability,"st)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/sesolve.html:8860,integrat,integrator,8860,docs/4.1/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Integrability,"st)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:8563,integrat,integrator,8563,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Integrability,"st)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, norm, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:9656,integrat,integrator,9656,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Integrability,"st, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eketsarray of qutip.qobjArray of kets that make up a basis tranformation for the eigenbasis. rho0qutip.qobjIni",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:85397,depend,dependent,85397,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"st, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolve will be removed in QuTiP 5. Please use; sesolve or mesolve for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; qutip.Qobj.eigenstates to get the eigenstates and -values,; and use QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Krylov Subspace Solver¶. krylovsolve(H: qutip.qobj.Qobj, psi0: qutip.qobj.Qobj, tlist: numpy.array, krylov_dim: int, e_ops=None, options=None, progress_bar: Optional[bool] = None, sparse: bool = False)[source]¶; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (“psi0”) finding an approximation for the time; evolution operator of Hamiltonian (“H”) by obtaining the projection of; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:90346,depend,dependent,90346,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"st/array/dictionary) – Parameters to callback functions for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the ODE solver.; = str ('batch', 'single') (unitary_mode) – Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’).; parallel (bool {False, True}) – Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:109773,depend,dependent,109773,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"st` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (*callback format*). Alternatively, `H` and `c_ops` can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (:class:`qutip.qobj`) at the first element and where the; second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:5406,depend,dependent,5406,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,7,['depend'],['dependent']
Integrability,"stant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H=[H0,[H1,H1_coeff]]. c_op_list=[C0,[C1,C1_coeff]]. args={'a':A,'w':W}. or in String (Cython) format we could write:; H=[H0,[H1,'sin(w*t)']]. c_op_list=[C0,[C1,'exp(-a*t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : array_like. single operator or list or array of operators for calculating; expectation values. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. Returns:results : Result. Object storing all results from simulation. mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None, options=<qutip.solver.Options instance at 0x2ac685b5cd88>, sparse_dms=True, serial=False, ptrace_sel=, []calc_entropy=False)¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. list or array of collapse operators. e_ops : array_like. list or array of operators for calculating expectation values. options : Options. Instance of solver options. sparse_dms : boolean. If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:41025,depend,dependent,41025,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"stant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H=[H0,[H1,H1_coeff]]. c_op_list=[C0,[C1,C1_coeff]]. args={'a':A,'w':W}. or in String (Cython) format we could write:; H=[H0,[H1,'sin(w*t)']]. c_op_list=[C0,[C1,'exp(-a*t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : array_like. single operator or list or array of operators for calculating; expectation values. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. Returns:results : Result. Object storing all results from simulation. mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None, options=<qutip.solver.Options instance at 0x2b11f5a5cd40>, sparse_dms=True, serial=False, ptrace_sel=, []calc_entropy=False)¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. list or array of collapse operators. e_ops : array_like. list or array of operators for calculating expectation values. options : Options. Instance of solver options. sparse_dms : boolean. If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:41087,depend,dependent,41087,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:14688,depend,dependent,14688,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['depend'],['dependent']
Integrability,"state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/solver.html:14729,depend,dependent,14729,docs/4.5/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/solver.html,5,['depend'],['dependent']
Integrability,"state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1698,Depend,Dependent,1698,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['Depend'],['Dependent']
Integrability,"state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coeffic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1669,Depend,Dependent,1669,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,1,['Depend'],['Dependent']
Integrability,"state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:3219,depend,dependent,3219,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,8,['depend'],['dependent']
Integrability,"state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * _qfunc_iterative_single(vectors[0], alpha_grid, g); for value, vector in zip(values[1:], vectors[1:]):; out += value * _qfunc_iterative_single(vector, alpha_grid, g); out /= np.pi; return out. # -----------------------------------------------------------------------------; # PSEUDO DISTRIBUTION FUNCTIONS FOR SPINS; #; [docs]def spin_q_function(rho, theta, phi):; r""""""The Husimi Q function for spins is defined as ``Q(theta, phi) =; SCS.dag() * rho * SCS`` for the spin coherent state ``SCS = spin_coherent(; j, theta, phi)`` where j is the spin length.; The implementation here is more efficient as it doesn't; generate all of the SCS at theta and phi (see references). The spin Q function is normal when integrated over the surface of the; sphere. .. math:: \frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; Polar (colatitude) angle at which to calculate the Husimi-Q function.; phi : array_like; Azimuthal angle at which to calculate the Husimi-Q function. Returns; -------; Q, THETA, PHI : 2d-array; Values representing the spin Husimi Q function at the values specified; by THETA and PHI. References; ----------; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in arange(-j, j + 1):; Q += binom(2 * j, j + m1) * cos(THETA / 2) ** (2 * (j + m1)) * \; sin(THETA / 2) ** (2 * (j - m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:28228,integrat,integrated,28228,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['integrat'],['integrated']
Integrability,"stem (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/scattering.html:13316,integrat,integrate,13316,docs/4.4/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/scattering.html,1,['integrat'],['integrate']
Integrability,"stem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Correlation Functions¶. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624eab00>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options cla",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:82069,depend,dependent,82069,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"stem with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavefunction \(\Psi(t=0)\) in the Floquet states and immediately obtain the solution for arbitrary \(t\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:3141,depend,dependence,3141,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependence']
Integrability,"stem with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavefunction \(\Psi(t=0)\) in the Floquet states and immediately obtain the solution for arbitrary \(t\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:2916,depend,dependence,2916,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,8,['depend'],['dependence']
Integrability,"stems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g. propagators[t2][t1] returns U[t2,t1].; """"""; def __init__(self, H, tlist, options=None):; self.H = H; self.tlist = tlist; if options is None:; self.options = Options(nsteps=10000, normalize_output=False); else:; self.options = options; # Make a blank nested dictionary to store propagators; self.propagators = dict.fromkeys(tlist); for t in tlist:; self.propagators[t] = dict.fromkeys(tlist). def prop(self, tf, ti):; """"""Compute U[t2,t1] where t2 > t1 or return the cached operator. Parameters; ----------; tf : float; Final time to compute the propagator U[tf, ti].; ti : float; Initial time to compute the propagator U[tf,ti]. Returns; -------; propagator : :class: qutip.Qobj; The propagation operator.; """"""; left, right = np.searchsorted(self.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:3478,depend,dependent,3478,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,7,['depend'],['dependent']
Integrability,"ster-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa20>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursive",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:90458,depend,dependent,90458,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"str; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops, args={}, options=None,; progress_bar=BaseProgressBar()):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:4754,depend,dependent,4754,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3])",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:21507,integrat,integrator,21507,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['integrat'],['integrator']
Integrability,"strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:15119,depend,dependent,15119,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,6,['depend'],['dependent']
Integrability,"such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15875,depend,dependent,15875,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,4,['depend'],['dependent']
Integrability,"sultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 function",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:102636,depend,depend,102636,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['depend']
Integrability,"sultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional k",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:92881,depend,depend,92881,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['depend']
Integrability,"super(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_strin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:18628,depend,dependent,18628,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability,"systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {‘propagator’, ‘mesolve’}; Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:29229,integrat,integrator,29229,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['integrat'],['integrator']
Integrability,"t : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time `t` in the supplied table of Floquet modes.; """""". # find t_wrap in [0,T] such that t = t_wrap + n * T for integer n; t_wrap = t - int(t / T) * T. # find the index in the table that corresponds to t_wrap (= tlist[t_idx]); t_idx = int(t_wrap / T * len(f_modes_table_t)). # XXX: might want to give a warning if the cast of t_idx to int discard; # a significant fraction in t_idx, which would happen if the list of time; # values isn't perfect matching the driving period; # if debug: print ""t = %f -> t_wrap = %f @ %d of %d"" % (t, t_wrap, t_idx,; # N). return f_modes_table_t[t_idx]. [docs]def floquet_states(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:7862,depend,dependence,7862,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,4,['depend'],['dependence']
Integrability,"t = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:12241,depend,dependent,12241,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"t = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Depen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:12551,depend,dependent,12551,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"t = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:13084,depend,dependent,13084,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"t = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Depen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:12811,depend,dependent,12811,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"t = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:13174,depend,dependent,13174,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"t Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:1550,depend,dependent,1550,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"t Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1648,depend,dependent,1648,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"t Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1619,depend,dependent,1619,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"t a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_func > 0:; # constant hamiltonian but time-dependent collapse; # operators in list function format; res = _mesolve_list_func_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; # function-callback style time-dependence: must have constant; # collapse operators; if n_str > 0: # or n_func > 0:; raise TypeError(""Incorrect format: function-format "" +; ""Hamiltonian cannot be mixed with "" +; ""time-dependent collapse operators.""); else:; res = _mesolve_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, list):; # determine if we are dealing with list of [Qobj, string] or; # [Qobj, function] style time-dependencies (for pure python and; # cython, respectively); if n_func > 0:; res = _mesolve_list_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); else:; res = _mesolve_list_str_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). else:; raise TypeError(""Incorrect specification of Hamiltonian "" +; ""or collapse operators.""). else:; #; # no collapse operators: unitary dynamics; #; if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif isinstance(H, (types.FunctionTy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:11195,depend,dependence,11195,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,8,['depend'],"['dependence', 'dependent']"
Integrability,"t be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise Ty",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3989,message,message,3989,docs/4.6/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html,4,['message'],['message']
Integrability,"t coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:4763,depend,dependent,4763,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,4,['depend'],['dependent']
Integrability,"t collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34518,depend,dependent,34518,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['depend'],['dependent']
Integrability,"t for faster usage. code: return the code generated for compilation of the strings. matched: the compiled object use sparse matrix with matching indices. (experimental, no real advantage) dense: the compiled object use dense matrix. omp: (int) number of thread: the compiled object use spmvpy_openmp. __call__(t, data=False, state=None, args={}):; Return the Qobj at time t. *Faster after compilation. mul_mat(t, mat):; Product of this at t time with the dense matrix mat. *Faster after compilation. mul_vec(t, psi):; Apply the quantum object (if operator, no check) to psi. More generaly, return the product of the object at t with psi. *Faster after compilation. expect(t, psi, herm=False):; Calculates the expectation value for the quantum object (if operator, no check) and state psi. Return only the real part if herm. *Faster after compilation. to_list():; Return the time-dependent quantum object as a list. eseries¶. class eseries(q=None, s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(self, wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(self, *args)[source]¶; Returns a tidier version of exponential series. value(self, tlist)[source]¶; Evaluates an exponential series at the times listed in tlist. Parameters. tlistndarrayTimes at which to evaluate expone",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:22505,depend,dependent,22505,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"t hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:8451,depend,dependence,8451,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,10,['depend'],['dependence']
Integrability,"t happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/solver.html:12104,depend,dependent,12104,docs/3.1.0/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html,1,['depend'],['dependent']
Integrability,"t happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/solver.html:11137,depend,dependent,11137,docs/4.0.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html,2,['depend'],['dependent']
Integrability,"t in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [4]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [5]: es2; Out[5]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum obj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-eseries.html:2048,depend,dependent,2048,docs/4.2/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-eseries.html,3,['depend'],['dependent']
Integrability,"t in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [4]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [5]: es2; Out[5]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.5]; [0.5 0. ]]; Exponent #1 = 1j; Quantum objec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-eseries.html:2048,depend,dependent,2048,docs/4.3/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html,3,['depend'],['dependent']
Integrability,"t in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [4]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [5]: es2; Out[5]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum obj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-eseries.html:2848,depend,dependent,2848,docs/3.1.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html,1,['depend'],['dependent']
Integrability,"t in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [6]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [7]: es2; Out[7]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum obj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-eseries.html:2746,depend,dependent,2746,docs/3.0.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability,"t in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj; instances, each of which may have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. Th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:17911,depend,dependence,17911,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,4,['depend'],"['dependence', 'dependent']"
Integrability,"t is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:56011,depend,dependent,56011,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,7,['depend'],['dependent']
Integrability,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Dev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:12201,interface,interface,12201,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['interface'],['interface']
Integrability,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:14484,interface,interface,14484,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['interface'],['interface']
Integrability,"t of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. Examples; >>> qeye(3); Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. identity(dims)[source]¶; Identity operator. Alternative name to qeye. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. momentum(N, offset=0)[source]¶; Momentum operator p=-1j/sqrt(2)*(a-a.dag()). Parameters. NintNumber of Fock states in Hilbert space. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Returns. operqobjMomentum operator as Qobj. phase(N, phi0=0)[source]¶; Single-mode Pegg-Barnett phase operator. Parameters. NintNumber of basis states in Hilbert space. phi0floatReference phase. Returns. operqobjPhase operator with respect to reference phase. Notes; The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space. position(N, offset=0)[source]¶; Position operator x=1/sqrt(2)*(a+a.dag()). Parameters. NintNumber of Fock states in Hilbert space. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Returns. operqobjPosition operator as Qobj. qdiags(diagonals, offsets, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:26101,depend,depending,26101,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['depending']
Integrability,"t parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:5526,wrap,wraps,5526,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['wrap'],['wraps']
Integrability,"t shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0); >>> Pulse(sigmaz(), 0, None, None). Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]); >>> coeff = np.array([0.5, 1.2, 0.8]); >>> spline_kind = ""step_func""; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func""). Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True). Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True). Create an dummy Pulse (H=0); >>> Pulse(None, None). Attributes. ideal_pulse: :class:`qutip.qip.pulse._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`qutip.qip.pulse._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`qutip.qip.pulse._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(self, qob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:138989,depend,dependent,138989,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['depend'],['dependent']
Integrability,"t space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created usi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/frontmatter.html:5524,depend,dependent,5524,docs/3.1.0/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html,1,['depend'],['dependent']
Integrability,"t spaces on which each vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:58078,contract,contracted,58078,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['contract'],['contracted']
Integrability,"t state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:21101,depend,dependence,21101,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependence']
Integrability,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:3890,wrap,wrapper,3890,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,5,['wrap'],['wrapper']
Integrability,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.contr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:3899,wrap,wrapper,3899,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,1,['wrap'],['wrapper']
Integrability,"t this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mesolve.html:6882,integrat,integrator,6882,docs/4.5/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mesolve.html,1,['integrat'],['integrator']
Integrability,"t this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:7389,integrat,integrator,7389,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['integrat'],['integrator']
Integrability,"t this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------. result: :class:`qutip.Result`. An in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:8305,integrat,integrator,8305,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,3,['integrat'],['integrator']
Integrability,"t time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:3158,depend,dependence,3158,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependence']
Integrability,"t time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:3191,depend,dependence,3191,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependence']
Integrability,"t(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:16922,integrat,integration,16922,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,3,['integrat'],['integration']
Integrability,"t(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts); 10.0%. Run time: 2.35s. Est. time left: 00:00:00:21; 20.0%. Run time: 4.75s. Est. time left: 00:00:00:18; 30.0%. Run time: 7.11s. Est. time left: 00:00:00:16; 40.0%. Run time: 9.34s. Est. time left: 00:00:00:14; 50.0%. Run time: 11.66s. Est. time left: 00:00:00:11; 60.0%. Run time: 15.27s. Est. time left: 00:00:00:10; 70.0%. Run time: 17.38s. Est. time left: 00:00:00:07; 80.0%. Run time: 19.55s. Est. time left: 00:00:00:04; 90.0%. Run time: 24.72s. Est. time left: 00:00:00:02; 100.0%. Run time: 30.86s. Est. time left: 00:00:00:00; Total run time: 30.92s. In [31]: figure(); Out[31]: <Figure size 640x480 with 0 Axes>. In [32]: plot(times, data1.expect[0], times, data1.expect[1], lw=2); Out[32]: ; [<matplotlib.lines.Line2D at 0x1a25b90080>,; <matplotlib.lines.Line2D at 0x1a25b905c0>]. In [33]: plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); Out[33]: ; [<matplotlib.lines.Line2D at 0x1a25c97d30>,; <matplotlib.lines.Line2D at 0x1a25c97128>]. In [34]: title('Monte Carlo time evolution'); Out[34]: Text(0.5,1,'Monte Carlo time evolution'). In [35]: xlabel('Time', fontsize=14); Out[35]: Text(0.5,0,'Time'). In [36]: ylabel('Expectation values', fontsize=14); Out[36]: Text(0,0.5,'Expectation values'). In [37]: legend((""cavity photon number"", ""atom excitation probability"")); Out[37]: <matplotlib.legend.Legend at 0x1a25cc3b70>. In [38]: show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html:15602,depend,dependent,15602,docs/4.5/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html,2,['depend'],['dependent']
Integrability,"t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : array_like. single operator or list or array of operators for calculating; expectation values. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. Returns:results : Result. Object storing all results from simulation. mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None, options=<qutip.solver.Options instance at 0x2ac685b5cd88>, sparse_dms=True, serial=False, ptrace_sel=, []calc_entropy=False)¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. list or array of collapse operators. e_ops : array_like. list or array of operators for calculating expectation values. options : Options. Instance of solver options. sparse_dms : boolean. If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) matrices during computation if; sparse_dms = True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems. serial : boolean. If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial. ptrace_sel: list :. This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory beco",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:41510,depend,dependence,41510,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['depend'],['dependence']
Integrability,"t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : array_like. single operator or list or array of operators for calculating; expectation values. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. Returns:results : Result. Object storing all results from simulation. mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None, options=<qutip.solver.Options instance at 0x2b11f5a5cd40>, sparse_dms=True, serial=False, ptrace_sel=, []calc_entropy=False)¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. list or array of collapse operators. e_ops : array_like. list or array of operators for calculating expectation values. options : Options. Instance of solver options. sparse_dms : boolean. If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) matrices during computation if; sparse_dms = True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems. serial : boolean. If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial. ptrace_sel: list :. This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory beco",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:41572,depend,dependence,41572,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['depend'],['dependence']
Integrability,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15804,integrat,integrate,15804,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,2,['integrat'],['integrate']
Integrability,"t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:119041,depend,dependent,119041,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability,"t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj. Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like. list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. c_op : Qobj. operator C. d_op : Qobj. operator D. solver : str. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat : array. An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e.,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:93182,depend,dependent,93182,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:14724,depend,dependence,14724,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability,"t, y, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, y, args). return _ode_super_func(t, y, L). # -----------------------------------------------------------------------------; # A time-dependent dissipative master equation on the list-string format for; # cython compilation; #; def _mesolve_list_str_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density matrix; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian; #; Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec. if isoper(h):; Lconst += -1j * (spre(h) - spost(h)); elif issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:18408,depend,dependent,18408,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['depend'],['dependent']
Integrability,"t,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:10239,depend,dependent,10239,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,6,['depend'],['dependent']
Integrability,"t. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:71242,depend,dependent,71242,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['depend'],['dependent']
Integrability,"t. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:20677,integrat,integrate,20677,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['integrat'],['integrate']
Integrability,"t. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:23595,depend,dependent,23595,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependent']
Integrability,"t.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args). In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:37765,integrat,integrator,37765,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['integrat'],['integrator']
Integrability,"t.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:29545,integrat,integrate,29545,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,4,['integrat'],['integrate']
Integrability,"t.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H : qutip.Qobj; System Hamiltonian. psi0 : qutip.Qobj; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or list or array of co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:60626,depend,dependent,60626,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,3,['depend'],['dependent']
Integrability,"t.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qutip.Qobj. System Hamiltonian. psi0 : qutip.Qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of coll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:59890,depend,dependent,59890,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,6,['depend'],['dependent']
Integrability,"t; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the config",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:7729,depend,depend,7729,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,6,['depend'],['depend']
Integrability,"t>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624ea9b0>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:86844,depend,dependent,86844,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"t[n][0] * (L_list[n][1](t, rho, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, rho, args). return L * rho. # -----------------------------------------------------------------------------; # A time-dependent dissipative master equation on the list-string format for; # cython compilation; #; def _mesolve_list_str_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density matrix; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian; #; Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec. if isoper(h):; Lconst += -1j * (spre(h) - spost(h)); elif issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:17403,depend,dependent,17403,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability,"t_idx,; # N). return f_modes_table_t[t_idx]. def floquet_states(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:9471,depend,dependent,9471,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['depend'],['dependent']
Integrability,"t_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:13525,depend,dependent,13525,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,2,['depend'],['dependent']
Integrability,"t_mesolve'""). else:; raise Exception(""The method must be one of None, homodyne, heterodyne""). sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: ph",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:22355,depend,depend,22355,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,6,['depend'],['depend']
Integrability,"t_thresh : float, optional, default=None. ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default=’smilu_2’. Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:dm : qobj. Steady state density matrix. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list, args=None, options=None, sparse=False)¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:73613,depend,dependent,73613,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"t_thresh : float, optional, default=None. ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default=’smilu_2’. Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:dm : qobj. Steady state density matrix. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list, args=None, options=None, sparse=False)¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2b11f5a5c950>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:73673,depend,dependent,73673,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ta =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we can evaluate it at time t by using the qutip.eseries.esval function:; In [6]: esval(es2, 0.0) # equivalent to es2.value(0.0); Out[6]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. or for a list of times [0.0, 1.0 * pi, 2.0 * pi]:; In [7]: times = [0.0, 1.0 * pi, 2.0 * pi]. In [8]: esval(es2, times) # equivalent to es2.value(times); Out[8]: ; array([ Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. -1.]; [-1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]], dtype=object). To calculate the expectation value of an time-dependent operator represented by an qutip.eseries, we use the qutip.expect function. For example, consider the operator \(\sigma_x \cos(\omega t) + \sigma_z\sin(\omega t)\), and say we would like to know the expectation value of this operator for a spin in its excited state (rho = fock_dm(2,1) produce this state):; In [9]: es3 = (eseries([0.5*sigmaz(), 0.5*sigmaz()], [1j, -1j]) +; ...: eseries([-0.5j*sigmax(), 0.5j*sigmax()], [1j, -1j])); ...: . In [10]: rho = fock_dm(2, 1). In [11]: es3_expect = expect(rho, es3). In [12]: es3_expect; Out[12]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = (-0-1j); (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-eseries.html:3986,depend,dependent,3986,docs/4.2/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-eseries.html,3,['depend'],['dependent']
Integrability,"ta =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we can evaluate it at time t by using the qutip.eseries.esval function:; In [6]: esval(es2, 0.0) # equivalent to es2.value(0.0); Out[6]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. or for a list of times [0.0, 1.0 * pi, 2.0 * pi]:; In [7]: times = [0.0, 1.0 * pi, 2.0 * pi]. In [8]: esval(es2, times) # equivalent to es2.value(times); Out[8]: ; array([ Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. -1.]; [-1. 0.]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]], dtype=object). To calculate the expectation value of an time-dependent operator represented by an qutip.eseries, we use the qutip.expect function. For example, consider the operator \(\sigma_x \cos(\omega t) + \sigma_z\sin(\omega t)\), and say we would like to know the expectation value of this operator for a spin in its excited state (rho = fock_dm(2,1) produce this state):; In [9]: es3 = (eseries([0.5*sigmaz(), 0.5*sigmaz()], [1j, -1j]) +; ...: eseries([-0.5j*sigmax(), 0.5j*sigmax()], [1j, -1j])); ...: . In [10]: rho = fock_dm(2, 1). In [11]: es3_expect = expect(rho, es3). In [12]: es3_expect; Out[12]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = -1j; (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-eseries.html:4786,depend,dependent,4786,docs/3.1.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html,1,['depend'],['dependent']
Integrability,"ta for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td = L_list[n][1]; if L_list[n][2]:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args)**2, out); else:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); return out. def drho_list_td_with_state(t, rho, L_list, args):. out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, rho, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td = L_list[n][1]; if L_list[n][2]:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, rho, args)**2, out); else:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, rho, args), out). return out. #; # evaluate dE(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API, where E is a superoperator; #; def dsuper_list_td(t, y, L_list, args):. L = L_list[0][0] * L_list[0][1](t, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, args). return _ode_super_func(t, y, L). def dsuper_list_td_with_state(t, y, L_list, args):. L = L_list[0][0] * L_list[0][1](t, y, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, y, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, y, args). return _ode_super_func(t, y, L). # -----------------------------------------------------------------------------; # A time-dependent dissipative mast",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:16603,depend,dependence,16603,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,2,['depend'],['dependence']
Integrability,"ta). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:20213,integrat,integrate,20213,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability,ta-Bold.ttf; Inconsolata-Regular.ttf; Lato-Bold.ttf; Lato-Regular.ttf; RobotoSlab-Bold.ttf; RobotoSlab-Regular.ttf. /js; ; modernizr.min.js; theme.js. doctools.js; favicon.ico; jquery.js; searchtools.js; underscore.js. /4.3; . /apidoc; ; API documentation — QuTiP 4.3 Documentation; Classes — QuTiP 4.3 Documentation; Functions — QuTiP 4.3 Documentation. Bibliography — QuTiP 4.3 Documentation; Change Log — QuTiP 4.3 Documentation; Developers — QuTiP 4.3 Documentation. /downloads; ; qutip_tree.pdf. Frontmatter — QuTiP 4.3 Documentation; Index — QuTiP 4.3 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 4.3 Documentation; Dynamics Simulation Results — QuTiP 4.3 Documentation; Floquet Formalism — QuTiP 4.3 Documentation; Lindblad Master Equation Solver — QuTiP 4.3 Documentation; Monte Carlo Solver — QuTiP 4.3 Documentation; Setting Options for the Dynamics Solvers — QuTiP 4.3 Documentation; Permutational Invariance — QuTiP 4.3 Documentation; Solving Problems with Time-dependent Hamiltonians — QuTiP 4.3 Documentation. /scripts; ; correlation_ex2.pdf; correlation_ex2.py; correlation_ex3.pdf; correlation_ex3.py; correlation_ex4.pdf; correlation_ex4.py; ex_steady.pdf; ex_steady.py; floquet_ex1.pdf; floquet_ex1.py; floquet_ex2.pdf; floquet_ex2.py; floquet_ex3.pdf; floquet_ex3.py; spectrum_ex1.pdf; spectrum_ex1.py. Users Guide — QuTiP 4.3 Documentation; Basic Operations on Quantum Objects — QuTiP 4.3 Documentation; Plotting on the Bloch Sphere — QuTiP 4.3 Documentation; Quantum Optimal Control — QuTiP 4.3 Documentation; Two-time correlation functions — QuTiP 4.3 Documentation; Time Evolution and Quantum System Dynamics — QuTiP 4.3 Documentation; An Overview of the Eseries Class — QuTiP 4.3 Documentation; Guide Overview — QuTiP 4.3 Documentation; Parallel computation — QuTiP 4.3 Documentation; Generating Random Quantum States & Operators — QuTiP 4.3 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.3 Documentation; Modifying Internal QuTiP S,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:28005,depend,dependent,28005,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['depend'],['dependent']
Integrability,"table of simulation times for the single-photon example using the different time-dependent formats and both the master equation and Monte Carlo solver. Format; Master Equation; Monte Carlo. Python Function; 2.1 sec; 27 sec. Cython String; 1.4 sec; 9 sec. Hamiltonian Function; 1.0 sec; 238 sec. For the current example, the table indicates that the Hamiltonian function method is in fact the fastest when using the master equation solver. This is because the simulation is quite small. In contrast, the Hamiltonian function is over 26x slower than the compiled string version when using the Monte Carlo solver. In this case, the 500 trajectories needed in the simulation highlights the inefficient nature of the Python function calls. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do:; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). In this case, the second call to qutip.mcsolve takes 3 seconds less than the first. Of course our parameters are different, but this also shows how much time one can save by not reorganizing the data, and in the case of the string format, not recompiling the code. If you need to call the solvers many times for different parameters, this savings will obviously start to add",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:15239,depend,dependent,15239,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"tage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. ('QuTiP Version: ', '3.0.1'); ('Numpy Version: ', '1.8.0'); ('Scipy Version: ', '0.13.3'); ('Cython Version: ', '0.20.1post0'); ('Matplotlib Version: ', '1.3.1'); ('Fortran mcsolver: ', 'True'); ('scikits.umfpack: ', 'False'); ('Python Version: ', '2.7.6'); ('Platform Info: ', 'Linux', '(x86_64)'); (). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:12003,depend,dependencies,12003,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,3,"['depend', 'message']","['dependencies', 'message']"
Integrability,"tall all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:6396,depend,dependencies,6396,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['depend'],['dependencies']
Integrability,"tallation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:2486,depend,dependent,2486,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['depend'],['dependent']
Integrability,"target pulse in the list of pulses. kwargs:Key word arguments for the random number generator. Examples; >>> gaussnoise = RandomNoise(; dt=0.1, rand_gen=np.random.normal, loc=mean, scale=std). Attributes. dt: float, optionalThe time interval between two random amplitude. The coefficients; of the noise are the same within this time range. rand_gen: numpy.random, optionalA random generator in numpy.random, it has to take a size; parameter. indices: list of intThe indices of target pulse in the list of pulses. kwargs:Key word arguments for the random number generator. get_noisy_dynamics(self, pulses)[source]¶; Return a list of pulses containing the input pulse with additional; coherent noise. Parameters. pulses: list of :class:`qutip.qip.Pulse`The input pulses, on which the noise object will be applied. Returns. noisy_pulses: list of qutip.qip.PulseThe input Pulse object with additional coherent noise. class UserNoise[source]¶; Template class for user defined noise. It is classified as a pulse; dependent noise. By calling the method get_noisy_dynamics,; it should return the input pulses with additional; coherent and/or lindblad noise. If there are; pulse independent noise, a dummy Pulse can be created by; Pulse(None, None). The modified input pulses should always; be at the begining of the list, followed by the dummy pulses. get_noisy_dynamics(self, pulses, dims)[source]¶; Template method.; It should return a list of pulses with noise. Parameters. pulses: list of :class:`qutip.qip.Pulse`The input pulses, on which the noise object will be applied. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. Returns. noisy_pulses: list of qutip.qip.PulseThe input Pulse object with additional noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label=None)[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:136409,depend,dependent,136409,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['depend'],['dependent']
Integrability,"tate or oper; #; if psi0.isket:; initial_vector = psi0.full().ravel(); oper_evo = False; elif psi0.isunitary:; initial_vector = psi0.full().ravel('F'); oper_evo = True; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L = -1j * h; L_list.append([L.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; if oper_evo:; initial_vector = psi0.full().ravel('F'); if opt.rhs_with_state:; r = scipy.integrate.ode(oper_list_td_with_state); else:; r = scipy.integrate.ode(oper_list_td); else:; initial_vector = psi0.full().ravel(); if opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td_with_state); else:; r = scipy.integrate.ode(psi_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, L_List_and_args):. L_List = L_List_and_args[0]; args = L_List_and_args[1]. L = L_List[0][0]; tdfunc = L_List[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(L.data, L.indices, L.indptr, psi, tdfunc(t, args), out); f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:8339,integrat,integrate,8339,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"tate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q – Values representing the Q-function calculated over the specified range; [xvec,yvec]. Return type:array. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:; state (qobj) – A state vector or density matrix for a spin-j quantum system.; theta (array_like) – theta-coordinates at which to calculate the Q function.; phi (array_like) – phi-coordinates at which",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:110539,depend,dependent,110539,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"tates and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-dynamics.html:2102,depend,dependent,2102,docs/3.1.0/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability,"tates.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:30209,depend,dependent,30209,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,4,['depend'],['dependent']
Integrability,"tateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None, options=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:105713,depend,dependent,105713,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"tational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:1860,depend,dependence,1860,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,2,['depend'],"['depend', 'dependence']"
Integrability,"tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \lef",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:93761,depend,dependent,93761,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,tawesome-webfont.svg; fontawesome-webfont.ttf; fontawesome-webfont.woff; Inconsolata-Bold.ttf; Inconsolata-Regular.ttf; Lato-Bold.ttf; Lato-Regular.ttf; RobotoSlab-Bold.ttf; RobotoSlab-Regular.ttf. /js; ; modernizr.min.js; theme.js. doctools.js; favicon.ico; jquery.js; searchtools.js; underscore.js. /4.1; . /apidoc; ; API documentation — QuTiP 4.1 Documentation; Classes — QuTiP 4.1 Documentation; Functions — QuTiP 4.1 Documentation. Bibliography — QuTiP 4.1 Documentation; Change Log — QuTiP 4.1 Documentation; Developers — QuTiP 4.1 Documentation; Frontmatter — QuTiP 4.1 Documentation; Index — QuTiP 4.1 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 4.1 Documentation; Dynamics Simulation Results — QuTiP 4.1 Documentation; Floquet Formalism — QuTiP 4.1 Documentation; Lindblad Master Equation Solver — QuTiP 4.1 Documentation; Monte Carlo Solver — QuTiP 4.1 Documentation; Setting Options for the Dynamics Solvers — QuTiP 4.1 Documentation; Solving Problems with Time-dependent Hamiltonians — QuTiP 4.1 Documentation. /scripts; ; correlation_ex2.pdf; correlation_ex2.py; correlation_ex3.pdf; correlation_ex3.py; correlation_ex4.pdf; correlation_ex4.py; ex_steady.pdf; ex_steady.py; floquet_ex1.pdf; floquet_ex1.py; floquet_ex2.pdf; floquet_ex2.py; floquet_ex3.pdf; floquet_ex3.py; spectrum_ex1.pdf; spectrum_ex1.py. Users Guide — QuTiP 4.1 Documentation; Basic Operations on Quantum Objects — QuTiP 4.1 Documentation; Plotting on the Bloch Sphere — QuTiP 4.1 Documentation; Quantum Optimal Control — QuTiP 4.1 Documentation; Two-time correlation functions — QuTiP 4.1 Documentation; Time Evolution and Quantum System Dynamics — QuTiP 4.1 Documentation; An Overview of the Eseries Class — QuTiP 4.1 Documentation; Guide Overview — QuTiP 4.1 Documentation; Parallel computation — QuTiP 4.1 Documentation; Generating Random Quantum States & Operators — QuTiP 4.1 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.1 Documentation; Modifying Internal QuTiP S,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:16789,depend,dependent,16789,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['depend'],['dependent']
Integrability,tawesome-webfont.svg; fontawesome-webfont.ttf; fontawesome-webfont.woff; Inconsolata-Bold.ttf; Inconsolata-Regular.ttf; Lato-Bold.ttf; Lato-Regular.ttf; RobotoSlab-Bold.ttf; RobotoSlab-Regular.ttf. /js; ; modernizr.min.js; theme.js. doctools.js; favicon.ico; jquery.js; searchtools.js; underscore.js. /4.2; . /apidoc; ; API documentation — QuTiP 4.2 Documentation; Classes — QuTiP 4.2 Documentation; Functions — QuTiP 4.2 Documentation. Bibliography — QuTiP 4.2 Documentation; Change Log — QuTiP 4.2 Documentation; Developers — QuTiP 4.2 Documentation; Frontmatter — QuTiP 4.2 Documentation; Index — QuTiP 4.2 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 4.2 Documentation; Dynamics Simulation Results — QuTiP 4.2 Documentation; Floquet Formalism — QuTiP 4.2 Documentation; Lindblad Master Equation Solver — QuTiP 4.2 Documentation; Monte Carlo Solver — QuTiP 4.2 Documentation; Setting Options for the Dynamics Solvers — QuTiP 4.2 Documentation; Solving Problems with Time-dependent Hamiltonians — QuTiP 4.2 Documentation. /scripts; ; correlation_ex2.pdf; correlation_ex2.py; correlation_ex3.pdf; correlation_ex3.py; correlation_ex4.pdf; correlation_ex4.py; ex_steady.pdf; ex_steady.py; floquet_ex1.pdf; floquet_ex1.py; floquet_ex2.pdf; floquet_ex2.py; floquet_ex3.pdf; floquet_ex3.py; spectrum_ex1.pdf; spectrum_ex1.py. Users Guide — QuTiP 4.2 Documentation; Basic Operations on Quantum Objects — QuTiP 4.2 Documentation; Plotting on the Bloch Sphere — QuTiP 4.2 Documentation; Quantum Optimal Control — QuTiP 4.2 Documentation; Two-time correlation functions — QuTiP 4.2 Documentation; Time Evolution and Quantum System Dynamics — QuTiP 4.2 Documentation; An Overview of the Eseries Class — QuTiP 4.2 Documentation; Guide Overview — QuTiP 4.2 Documentation; Parallel computation — QuTiP 4.2 Documentation; Generating Random Quantum States & Operators — QuTiP 4.2 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.2 Documentation; Modifying Internal QuTiP S,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:22356,depend,dependent,22356,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['depend'],['dependent']
Integrability,"tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:24652,integrat,integrate,24652,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['integrat'],['integrate']
Integrability,"te Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:3798,depend,dependent,3798,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['depend'],['dependent']
Integrability,"te Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Set",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/index.html:1974,depend,dependent,1974,docs/4.4/index.html,https://qutip.org,https://qutip.org/docs/4.4/index.html,2,['depend'],['dependent']
Integrability,"te dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:12399,depend,dependent,12399,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['depend'],['dependent']
Integrability,"te expectation values. options : :class:`qutip.Qdeoptions`; Options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); for t_idx, _ in enumerate(tlist):. if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). return result_list. # -----------------------------------------------------------------------------; # Functions for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html:6214,integrat,integrate,6214,docs/4.0.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html,2,['integrat'],['integrate']
Integrability,"te import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:3745,depend,dependent,3745,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,6,['depend'],['dependent']
Integrability,"te import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:2193,depend,dependence,2193,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability,"te the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-correlation.html:4834,depend,dependent,4834,docs/4.7/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html,2,['depend'],['dependent']
Integrability,"te the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:10055,rout,routines,10055,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['rout'],['routines']
Integrability,"te the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:21915,depend,dependent,21915,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['depend'],['dependent']
Integrability,"te(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:17699,depend,dependency,17699,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['depend'],['dependency']
Integrability,"te(sso.sc_ops)]. elif sso.method == 'photocurrent':; sso.d1 = d1_psi_photocurrent; sso.d2 = d2_psi_photocurrent; sso.d2_len = 1; sso.homogeneous = False; sso.distribution = 'poisson'. if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([1]); if ""m_ops"" not in kwargs:; sso.m_ops = [[None] for c in sso.sc_ops]. else:; raise Exception(""Unrecognized method '%s'."" % sso.method). if sso.distribution == 'poisson':; sso.homogeneous = False. if sso.solver == 'euler-maruyama' or sso.solver is None:; sso.rhs = _rhs_psi_euler_maruyama. elif sso.solver == 'platen':; sso.rhs = _rhs_psi_platen. else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _ssesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True ,**kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:12596,depend,depending,12596,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['depend'],['depending']
Integrability,"te::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An instance of the class :class:`qutip.Result`, which contains; either an *array* `result.expect` of expectation values for the times; specif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mesolve.html:7050,depend,dependent,7050,docs/4.5/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability,"te::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An instance of the class :class:`qutip.Result`, which contains; either an *array* `result.expect` of expectation values for the times; specified by `tlist`, or an *array* `resu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:7557,depend,dependent,7557,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['depend'],['dependent']
Integrability,"te::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------. result: :class:`qutip.Result`. An instance of the class :class:`qutip.Result`, which contains; either an *array* `result.expect` of expectation values for the times; specified by `tlist`, or an *array* `resul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:8473,depend,dependent,8473,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,3,['depend'],['dependent']
Integrability,"tead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624ea9e8>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa20>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:89321,depend,dependent,89321,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Gri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/frontmatter.html:4027,depend,dependent,4027,docs/4.4/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html,2,['depend'],['dependent']
Integrability,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/frontmatter.html:4172,depend,dependent,4172,docs/4.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html,2,['depend'],['dependent']
Integrability,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:4108,depend,dependent,4108,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,2,['depend'],['dependent']
Integrability,"ted as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:5029,depend,dependence,5029,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,4,['depend'],['dependence']
Integrability,"ted by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/frontmatter.html:4072,depend,dependence,4072,docs/4.0.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html,2,['depend'],['dependence']
Integrability,"teger. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:147800,depend,dependent,147800,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"teger. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict. Parameters for the PropagatorComputer object; The key",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:156684,depend,dependent,156684,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"teger. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:164496,depend,dependent,164496,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"teger; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:162589,depend,dependent,162589,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"teger; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:171477,depend,dependent,171477,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"teger; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:179293,depend,dependent,179293,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"tems. Returns; -------; nds: int; The number of Dicke states.; """"""; return _num_dicke_states(N). [docs]def num_dicke_ladders(N):; """"""Calculate the total number of ladders in the Dicke space. For a collection of N two-level systems it counts how many different; ""j"" exist or the number of blocks in the block-diagonal matrix. Parameters; ----------; N: int; The number of two-level systems. Returns; -------; Nj: int; The number of Dicke ladders.; """"""; return _num_dicke_ladders(N). [docs]def num_tls(nds):; """"""Calculate the number of two-level systems. Parameters; ----------; nds: int; The number of Dicke states. Returns; -------; N: int; The number of two-level systems.; """"""; if np.sqrt(nds).is_integer():; # N is even; N = 2 * (np.sqrt(nds) - 1); else:; # N is odd; N = 2 * (np.sqrt(nds + 1 / 4) - 1); return int(N). [docs]def isdiagonal(mat):; """"""; Check if the input matrix is diagonal. Parameters; ==========; mat: ndarray/Qobj; A 2D numpy array. Returns; =======; diag: bool; True/False depending on whether the input matrix is diagonal.; """"""; if isinstance(mat, Qobj):; mat = mat.full(). return np.all(mat == np.diag(np.diagonal(mat))). # nonlinear functions of the density matrix; [docs]def dicke_blocks(rho):; """"""Create the list of blocks for block-diagonal density matrix in the Dicke basis. Parameters; ----------; rho : :class:`qutip.Qobj`; A 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns; -------; square_blocks: list of np.array; Give back the blocks list. """"""; shape_dimension = rho.shape[0]; N = num_tls(shape_dimension); ladders = num_dicke_ladders(N); # create a list with the sizes of the blocks, in order; blocks_dimensions = int(N / 2 + 1 - 0.5 * (N % 2)); blocks_list = [; (2 * (i + 1 * (N % 2)) + 1 * ((N + 1) % 2)); for i in range(blocks_dimensions); ]; blocks_list = np.flip(blocks_list, 0); # create a list with each block matrix as element; square_blocks = []; block_position = 0; f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:4869,depend,depending,4869,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,5,['depend'],['depending']
Integrability,"ten', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18757,depend,depending,18757,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['depend'],['depending']
Integrability,"tep=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13782,depend,dependent,13782,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['depend'],['dependent']
Integrability,"ter Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:63927,depend,dependence,63927,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['depend'],['dependence']
Integrability,"ter Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:64947,depend,dependence,64947,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependence']
Integrability,"ternal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:2048,depend,dependent,2048,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability,"tes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:83183,wrap,wrapper,83183,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['wrap'],['wrapper']
Integrability,"test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:10035,depend,dependencies,10035,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['depend'],['dependencies']
Integrability,"tform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/index.html:1532,depend,dependent,1532,docs/4.1/index.html,https://qutip.org,https://qutip.org/docs/4.1/index.html,1,['depend'],['dependent']
Integrability,"tform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/index.html:1500,depend,dependent,1500,docs/4.2/index.html,https://qutip.org,https://qutip.org/docs/4.2/index.html,1,['depend'],['dependent']
Integrability,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17828,depend,dependent,17828,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"th this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/solver.html:24845,message,message,24845,docs/4.5/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/solver.html,5,['message'],['message']
Integrability,"th this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:24804,message,message,24804,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['message'],['message']
Integrability,"th(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:12581,message,message,12581,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['message'],['message']
Integrability,"th:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; output = _mesolve_const(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; if isinstance(H, list):; output = _sesolve_list_td(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _sesolve_func_td(H, rho0, tlis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:35434,integrat,integrator,35434,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['integrat'],['integrator']
Integrability,"that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:35065,integrat,integrator,35065,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['integrat'],['integrator']
Integrability,"the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time \(t\). Return type:qutip.qobj. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:74998,depend,dependent,74998,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:70296,depend,dependent,70296,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['depend'],['dependent']
Integrability,"the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; Time-dependent operators; For problems with time-dependent problems H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a numpy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args). In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using meso",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:36546,depend,dependent,36546,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object at 0x1a2035b7b8>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:78475,depend,dependence,78475,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependence']
Integrability,"the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; """"""self.qobj = list_[0]; self.get_coeff = list_[1]; self.coeff = list_[2]; self.type = list_[3]""""""; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""A class for representing time-dependent quantum objects,; such as quantum operators and states. The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :; +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number; and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array. For function format, the function signature must be f(t, args).; *Examples*; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe.; *Examples*; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:5974,depend,dependent,5974,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['depend'],['dependent']
Integrability,"the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15350,depend,dependent,15350,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,4,['depend'],['dependent']
Integrability,"the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`qutip.qobj`, :class:`qutip.qobjevo`, *list*, *callable*; system Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians.; list format and options can be found in QobjEvo's description. psi0 : :class:`qutip.qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; single operator or list of operators for which to evaluate; expectation values.; For list operator evolution, the overlapse is computed:; tr(e_ops[i].dag()*op(t)). args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]; elif isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if progress_bar is True:; progress_bar = TextProgressBar(). if not (psi0.isket or psi0.isunitary):; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/sesolve.html:4423,depend,dependent,4423,docs/4.4/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,the gradient is computed (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates; (integer) Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter; (float) Mean number of control amplitude updates per iteration. num_timeslot_changes; (integer) Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update; (float) Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes; (integer) Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update; (float) Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class; Attributes. level. parent; (some control object (Dynamics or Optimizer)) aka the host. Object that generates the data that is dumped and is host to this dump object. dump_dir; (str) directory where files (if any) will be written out the path and be relative or absolute use ~/ to specify user home directory Note: files are only written when write_to_file is True of writeout is called explicitly Defaults to ~/.qtrl_dump. write_to_file; (bool) When set True data and summaries (as configured) will be written interactively to file during the processing Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext; (str) Default file extension for any file names that are auto generated. fname_base; (str) First part of any auto generated file names. This is usually overridden in the subclass. dump_summary; (bool) If True a summary is recorded each time a new item is added to the the dump. Default is True. summary_sep; (str) delimiter for t,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:110268,depend,depends,110268,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['depend'],['depends']
Integrability,"the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100])); dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # inefficient... make a and b outer loops and use the mesolve; # instead of the propagator. f_modes_t = np.hstack([f.full() for f in floquet_modes_t_lookup(; f_modes_table_t, t, T)]); FF = f_modes_t.T.conj() @ c_op.full() @ f_modes_t; phi = exp(-1j * np.arange(-kmax, kmax+1) * omega * t); X += (dT / T) * np.einsum(""ij,k->ijk"", FF, phi). Heaviside = lambda x: ((np.sign(x) + 1) / 2.0); for a in range(N):; for b in range(N):; k_idx = 0; for k in range(-kmax, kmax + 1, 1):; Delta[a, b, k_idx] = f_energies[a] - f_energies[b] + k * omega; Gamma[a, b, k_idx] = 2 * pi * Heaviside(Delta[a, b, k_idx]) * \; J_cb(Delta[a, b, k_idx]) * abs(X[a, b, k_idx]) ** 2; k_idx += 1. for a in range(N):; fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:15724,integrat,integration,15724,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['integrat'],['integration']
Integrability,"the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:5174,depend,dependencies,5174,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,2,['depend'],['dependencies']
Integrability,"the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:5078,depend,dependencies,5078,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,3,['depend'],['dependencies']
Integrability,"the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:4853,depend,dependent,4853,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0xd1fd3bdd8>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_binsintNumber of time bins; the range over which each index can vary. Ret",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:129640,depend,dependent,129640,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"the task function. task_kwargs: list / dictionary. The optional additional keyword argument to the task function. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False. Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result : list. The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops : list/array. list or array of qobjs representing commuting Hermitian; operators. Returns:eigs : tuple. Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:201132,depend,dependencies,201132,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependencies']
Integrability,"the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:79423,integrat,integration,79423,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['integrat'],['integration']
Integrability,"the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; t (float) – The time at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; args (dictionary) – dictionary with variables required to evaluate H; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – The Floquet modes as kets at time \(t\). Return type:list of kets. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 (list of qutip.qobj (kets)) – Floquet modes at \(t\); f_energies (list) – Floquet energies.; tlist (array) – The list of times at which to evaluate the floquet modes.; H (qutip.qobj) – system Hamiltonian, time-dependent with period T; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – dictionary with variables required to evaluate H. Returns:output – A nested list of Floquet modes as kets for each time in tlist. Return type:nested list. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t (nested list of qutip.qobj (kets)) – A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table.; t (float) – The time for which to evaluate the Floquet modes.; T (float) – The period of the time-dependence of the hamiltonian. Returns:output – A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. Return type:nested list. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:71970,depend,dependent,71970,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['depend'],"['dependence', 'dependent']"
Integrability,"these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ---",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:8826,depend,dependent,8826,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['depend'],['dependent']
Integrability,"this example, the a_ops list would be:; In [33]: a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; In [34]: N = 10. In [35]: w0 = 1.0 * 2 * np.pi. In [36]: g = 0.05 * w0. In [37]: kappa = 0.15. In [38]: times = np.linspace(0, 25, 1000). In [39]: a = destroy(N). In [40]: H = w0 * a.dag() * a + g * (a + a.dag()). In [41]: psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). In [42]: a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. In [43]: e_ops = [a.dag() * a, a + a.dag()]. In [44]: res_brme = brmesolve(H, psi0, times, a_ops, e_ops). In [45]: plt.figure(); Out[45]: <Figure size 640x480 with 0 Axes>. In [46]: plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:19771,depend,dependent,19771,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,1,['depend'],['dependent']
Integrability,"this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functions (can be mixed); or a single callable function. For operators, the result's expect will; be computed by :func:`qutip.expect`. For callable functions, they are; called as ``f(t, state)`` and return the expectation value.; A single callback's expectation value can be any type, but a callback; part of a list must return a number as the expectation value. args : None / *dictionary*; dictio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/mesolve.html:5117,integrat,integrator,5117,docs/4.7/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html,2,['integrat'],['integrator']
Integrability,"this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:6852,integrat,integrator,6852,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,2,['integrat'],['integrator']
Integrability,"thm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:197026,wrap,wrapper,197026,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['wrap'],['wrapper']
Integrability,"thods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If yo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:2937,depend,dependent,2937,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"thods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:2970,depend,dependent,2970,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"thon 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/installation.html:8729,depend,dependencies,8729,docs/4.2/installation.html,https://qutip.org,https://qutip.org/docs/4.2/installation.html,3,"['depend', 'message']","['dependencies', 'message']"
Integrability,"thon 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:8629,depend,dependencies,8629,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,3,"['depend', 'message']","['dependencies', 'message']"
Integrability,"thon setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.6+)¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Dow",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:5484,depend,dependencies,5484,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['depend'],['dependencies']
Integrability,"thon setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython3 python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:5573,depend,dependencies,5573,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,2,['depend'],['dependencies']
Integrability,"thon; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Relea",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/development.html:1033,integrat,integration,1033,docs/4.7/development/development.html,https://qutip.org,https://qutip.org/docs/4.7/development/development.html,2,['integrat'],['integration']
Integrability,"though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H (qutip.Qobj) – System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian.; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.Qobj) – single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the solver.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:result – An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:59949,depend,dependent,59949,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.Qobj; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.Result`; An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:58788,depend,dependent,58788,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"tial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:13764,depend,dependent,13764,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"tially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for sim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:5186,interface,interfaces,5186,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,1,['interface'],['interfaces']
Integrability,"tially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/frontmatter.html:5441,interface,interfaces,5441,docs/4.7/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html,1,['interface'],['interfaces']
Integrability,"ties import _blas_info; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation', ; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation', ; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", qutip.hardware_info.hardware_info()['cpus']),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Addition",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:3269,depend,dependencies,3269,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,3,['depend'],['dependencies']
Integrability,"time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:76270,depend,dependence,76270,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['depend'],['dependence']
Integrability,"time left: 00:00:00:00; 30.0%. Run time: 0.31s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.40s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.49s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.57s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.67s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.86s. Est. time left: 00:00:00:00; 100.0%. Run time: 0.95s. Est. time left: 00:00:00:00; Total run time: 1.03s. The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:19080,depend,dependent,19080,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"time left: 00:00:00:01; 30.0%. Run time: 0.57s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.67s. Est. time left: 00:00:00:01; 50.0%. Run time: 0.77s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.88s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.98s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.07s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.18s. Est. time left: 00:00:00:00; 100.0%. Run time: 1.28s. Est. time left: 00:00:00:00; Total run time: 1.38s. The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:19246,depend,dependent,19246,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"time left: 00:00:00:01; 30.0%. Run time: 0.57s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.75s. Est. time left: 00:00:00:01; 50.0%. Run time: 0.91s. Est. time left: 00:00:00:00; 60.0%. Run time: 1.08s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.22s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.40s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.57s. Est. time left: 00:00:00:00; 100.0%. Run time: 1.71s. Est. time left: 00:00:00:00; Total run time: 1.73s. The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:20299,depend,dependent,20299,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"time left: 00:00:00:01; 30.0%. Run time: 0.61s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.78s. Est. time left: 00:00:00:01; 50.0%. Run time: 0.98s. Est. time left: 00:00:00:00; 60.0%. Run time: 1.15s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.33s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.51s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.67s. Est. time left: 00:00:00:00; 100.0%. Run time: 1.84s. Est. time left: 00:00:00:00; Total run time: 1.85s. The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:19177,depend,dependent,19177,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"time left: 00:00:00:02; 30.0%. Run time: 0.78s. Est. time left: 00:00:00:01; 40.0%. Run time: 1.09s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.37s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.67s. Est. time left: 00:00:00:01; 70.0%. Run time: 1.96s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.35s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.72s. Est. time left: 00:00:00:00; 100.0%. Run time: 2.99s. Est. time left: 00:00:00:00; Total run time: 3.03s. The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:16656,depend,dependent,16656,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"time left: 00:00:00:02; 30.0%. Run time: 1.09s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.33s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.56s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.80s. Est. time left: 00:00:00:01; 70.0%. Run time: 2.03s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.25s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.48s. Est. time left: 00:00:00:00; 100.0%. Run time: 2.75s. Est. time left: 00:00:00:00; Total run time: 2.83s. The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:19879,depend,dependent,19879,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"time left: 00:00:00:08; 30.0%. Run time: 3.01s. Est. time left: 00:00:00:07; 40.0%. Run time: 3.83s. Est. time left: 00:00:00:05; 50.0%. Run time: 4.60s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.43s. Est. time left: 00:00:00:03; 70.0%. Run time: 6.31s. Est. time left: 00:00:00:02; 80.0%. Run time: 7.20s. Est. time left: 00:00:00:01; 90.0%. Run time: 8.05s. Est. time left: 00:00:00:00; 100.0%. Run time: 8.96s. Est. time left: 00:00:00:00; Total run time: 9.08s. The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:16196,depend,dependent,16196,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"time left: 00:00:00:22; 50.0%. Run time: 18.42s. Est. time left: 00:00:00:18; 60.0%. Run time: 22.19s. Est. time left: 00:00:00:14; 70.0%. Run time: 25.87s. Est. time left: 00:00:00:11; 80.0%. Run time: 29.56s. Est. time left: 00:00:00:07; 90.0%. Run time: 33.20s. Est. time left: 00:00:00:03; 100.0%. Run time: 36.90s. Est. time left: 00:00:00:00; Total run time: 37.02s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [30]: kappa = 0.5. In [31]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [32]: N = 10 # number of basis states. In [33]: a = destroy(N). In [34]: H = a.dag() * a # simple HO. In [35]: psi0 = basis(N, 9) # initial state. In [36]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [37]: times = np.linspace(0, 10, 100). In [38]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [39]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [40]: def H1_coeff(t, args):; ....: A = args['A']; ....:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:9981,depend,dependent,9981,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:13513,integrat,integrated,13513,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['integrat'],['integrated']
Integrability,time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes:; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; The level of data dumping that will occur - SUMMARY : A summary will be recorded - FULL : All possible dumping - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; Fir,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:123404,depend,depends,123404,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['depend'],['depends']
Integrability,"ting States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-dynamics.html:1528,depend,dependent,1528,docs/4.1/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability,"tings.atol); ). else:; return False. @property; def isunitary(self):; if self._isunitary is not None:; # used previously computed value; return self._isunitary. self._isunitary = self.check_isunitary(). return self._isunitary. @isunitary.setter; def isunitary(self, isunitary):; self._isunitary = isunitary. @property; def type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isins",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:50028,depend,dependent,50028,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['depend'],['dependent']
Integrability,"tings.atol); ). else:; return False. @property; def isunitary(self):; if self._isunitary is not None:; # used previously computed value; return self._isunitary. self._isunitary = self.check_isunitary(). return self._isunitary. @isunitary.setter; def isunitary(self, isunitary):; self._isunitary = isunitary. @property; def type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:48947,depend,dependent,48947,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['depend'],['dependent']
Integrability,"tion class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). (png, hires.png, pdf). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:15834,depend,dependent,15834,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"tion of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-eseries.html:1758,depend,dependent,1758,docs/3.0.1/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability,"tion on Mac OS X (10.6+)¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’. Setup Using Macports¶; On the Mac OS, we recommended that you install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via; sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel. Optional, but highly recommended ports include; sudo port install vtk5 +python27 #used for the Bloch3d class; sudo port install py27-mayavi #used for the Bloch3d class. Now, we want to tell OSX which Python and iPython we are going to use; sudo port select python python34; sudo port select ipython ipython34. To install QuTiP from Macports, run; sudo port install py-qutip. Note; The next step is optional, but is necessary if you plan to use the string (Cython) based time-dependent format. See Solving Problems with Time-dependent Hamiltonians. Finally, we want to set the macports compiler to the vanilla GCC version. From the command line type:; port select gcc. which will bring up a list of installed compilers, such as:; Available versions for gcc:; apple-gcc42; gcc42; llvm-gcc42; mp-gcc47; none (active). We want to set the the compiler to the gcc4x compiler, where x is the highest number available, in this case mp-gcc47 (the “mp-” does not matter). To do this type:; sudo port select gcc mp-gcc47. Running port select again should give:; Available versions for gcc:; apple-gcc42; gcc42; llvm-gcc42; mp-gcc47 (active); none. Installing QuTiP via Macports will take a long time as each of the QuTiP dependencies is build from source code. The advantage is that all dependencies are resolved automatically, and the result should be a consistent build. Setup via SciPy Superpack¶; A second option is to install the required ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:7105,depend,dependent,7105,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['depend'],['dependent']
Integrability,"tion singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:91390,depend,dependent,91390,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"tion singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:105743,depend,dependent,105743,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability,"tion subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:7056,depend,dependency,7056,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['depend'],['dependency']
Integrability,"tion values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not wo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:3230,depend,dependent,3230,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,3,['depend'],['dependent']
Integrability,"tion values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:25706,depend,dependent,25706,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['depend'],['dependent']
Integrability,"tion values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`qutip.qobj`, :class:`qutip.qobjevo`, *list*, *callable*; system Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians.; list format and options can be found in QobjEvo's description. psi0 : :class:`qutip.qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : None / list of :class:`qutip.qobj` / callback function; single operator or list of operators for which to evaluate; expectation values.; For list operator evolution, the overlapse is computed:; tr(e_ops[i].dag()*op(t)). args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians. options : None / :class:`qutip.Qdeoptions`; with options for the ODE solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if e_ops is None:; e_ops = []; if isinstance(e_ops, Qobj):; e_ops = [e_ops]; elif isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if progress_bar is None:; progress_bar = BaseProgressBar(); if progress_bar is True:; progress_bar = TextProgressBar(). if not (psi0.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/sesolve.html:4436,depend,dependent,4436,docs/4.5/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"tion with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmesolve solver]. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this me",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:3498,depend,dependent,3498,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,tion. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/index.html:3090,depend,dependent,3090,docs/3.0.0/index.html,https://qutip.org,https://qutip.org/docs/3.0.0/index.html,2,['depend'],['dependent']
Integrability,"tion. add_count()¶; Add some stat that is an integer count. add_timing()¶; Add some timing statistics. add_message()¶; Add some text type for output in the report. report:; Output the statistics report to console or file. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key (string) – key for the section.counts dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the count, or added to an existing count; section (string or class : _StatsSection) – Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key (string) – key for the section.messages dictionary; reusing a key will result in concatenation of value; value (int) – Initial value of the message, or added to an existing message; sep (string) – Message will be prefixed with this string when concatenating; section (string or class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – ke",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:40930,message,message,40930,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['message'],['message']
Integrability,"tion; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:2223,depend,dependent,2223,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"tion=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:drift : Qobj or list of Qobj. the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj. a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:143165,depend,dependent,143165,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"tion=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:7003,depend,dependent,7003,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,4,['depend'],['dependent']
Integrability,"tionType; from qutip.qobj import Qobj, isket; from qutip.superoperator import vec2mat_index, mat2vec, vec2mat; from qutip.mesolve import mesolve; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs +",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html:4872,depend,dependent,4872,docs/3.1.0/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html,1,['depend'],['dependent']
Integrability,"tions that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/operators.html:21782,depend,dependencies,21782,docs/4.3/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/operators.html,1,['depend'],['dependencies']
Integrability,"tions(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver.Options`; options for the ODE solver. For solving the master equation. floquet_basis : bool; Will return results in Floquet basis or computational basis; (optional). k_max : int; The truncation of the number of sidebands (default 5). options_modes : :class:`qutip.solver.Options`; options for the ODE solver. For computing Floquet modes. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:25572,depend,dependent,25572,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['depend'],['dependent']
Integrability,"tions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the sec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:77089,integrat,integrating,77089,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['integrat'],['integrating']
Integrability,"tions.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8358,depend,dependence,8358,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['depend'],['dependence']
Integrability,"tions; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. dumping. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value Note: attributes are created if they do not exist already, and are overwritten if they do. alg; (string) Algorithm to use in pulse optimisation. Options are: ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering ‘CRAB’ - Chopped RAndom Basis. alg_params; (Dictionary) options that are specific to the pulse optim algorithm that is GRAPE or CRAB. disp_conv_msg; (bool) Set true to display a convergence message (for scipy.optimize.minimize methods anyway). optim_method; (string) a scipy.optimize.minimize method that will be used to optimise the pulse for minimum fidelity error. method_params; (Dictionary) Options for the optim_method. Note that where there is an equivalent attribute of this instance or the termination_conditions (for example maxiter) it will override an value in these options. approx_grad; (bool) If set True then the method will approximate the gradient itself (if it has requirement and facility for this) This will mean that the fid_err_grad_wrapper will not get called Note it should be left False when using the Dynamics to calculate approximate gradients Note it is set True automatically when the alg is CRAB. amp_lbound; (float or list of floats) lower boundaries for the control amplitudes Can be a scalar value applied to all controls or a list of bounds for each control. amp_ubound; (float or list of floats) upper boundaries for the control amplit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:57681,message,message,57681,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['message'],['message']
Integrability,"tions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter ter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:198350,wrap,wrapper,198350,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['wrap'],['wrapper']
Integrability,"tionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object at 0x1a2041a470>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:112037,depend,dependent,112037,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"tion¶. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:78462,depend,depend,78462,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['depend']
Integrability,"tip.Qobj. Initial state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output: qutip.solver.SolverResult. An instance of the class qutip.solver.SolverResult. Correlation Functions¶. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like. list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. reverse : bool. If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential ser",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:80253,depend,dependent,80253,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"tip.Qobj`.; """"""; cythonized_dicke = _Dicke(; int(self.N),; float(self.emission),; float(self.dephasing),; float(self.pumping),; float(self.collective_emission),; float(self.collective_dephasing),; float(self.collective_pumping),; ); return cythonized_dicke.lindbladian(). [docs] def liouvillian(self):; """"""Build the total Liouvillian using the Dicke basis. Returns; -------; liouv : :class:`qutip.Qobj`; The Liouvillian matrix for the system.; """"""; lindblad = self.lindbladian(); if self.hamiltonian is None:; liouv = lindblad. else:; hamiltonian = self.hamiltonian; hamiltonian_superoperator = -1j * spre(hamiltonian) + 1j * spost(; hamiltonian; ); liouv = lindblad + hamiltonian_superoperator; return liouv. [docs] def pisolve(self, initial_state, tlist, options=None):; """"""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`qutip.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options : :class:`qutip.solver.Options`; The options for the solver. Returns; =======; result: list; A dictionary of the type `qutip.solver.Result` which holds the; results of the evolution.; """"""; if isdiagonal(initial_state) == False:; msg = ""`pisolve` requires a diagonal initial density matrix. ""; msg += ""In general construct the Liouvillian using ""; msg += ""`piqs.liouvillian` and use qutip.mesolve.""; raise ValueError(msg). if self.hamiltonian and isdiagonal(self.hamiltonian) == False:; msg = ""`pisolve` should only be used for diagonal Hamiltonians. ""; msg += ""Construct the Liouvillian using `piqs.liouvillian` and""; msg += "" use `qutip.mesolve`.""; raise ValueError(msg). if initial_state.full().shape != self.dshape:; msg = ""Initial density matrix should be diagonal.""; raise ValueError(msg). pim = Pim(; self.N,; self.emission,; self.dephasing,; self.pumping,; self.collective_emission,; self.collective_pumping,; self.collective_dephasing,; ); result = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:13787,integrat,integrate,13787,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,5,['integrat'],['integrate']
Integrability,"tip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ---",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:4055,depend,dependent,4055,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,10,['depend'],['dependent']
Integrability,"tip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. # ------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:10020,integrat,integrate,10020,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['integrat'],['integrate']
Integrability,"tip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmeso",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:10341,integrat,integrate,10341,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,4,['integrat'],['integrate']
Integrability,"tlist()[-1], num_steps); dt = tlist[1] - tlist[0]. # make sure coeffs start and end with zero, for ax.fill; tlist = np.hstack(([-dt*1.e-20], tlist, [tlist[-1] + dt*1.e-20])); coeffs = []; for pulse in self.pulses:; coeffs.append(_pulse_interpolate(pulse, tlist)). pulse_ind = 0; axis = []; for i, label_group in enumerate(self.get_operators_labels()):; for j, label in enumerate(label_group):; grid = grids[pulse_ind]; ax = plt.subplot(grid); axis.append(ax); ax.fill(tlist, coeffs[pulse_ind], color_list[i], alpha=0.7); ax.plot(tlist, coeffs[pulse_ind], color_list[i]); if rescale_pulse_coeffs:; ymax = np.max(np.abs(coeffs[pulse_ind])) * 1.1; else:; ymax = np.max(np.abs(coeffs)) * 1.1; if ymax != 0.:; ax.set_ylim((-ymax, ymax)). # disable frame and ticks; if not show_axis:; ax.set_xticks([]); ax.spines['bottom'].set_visible(False); ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['left'].set_visible(False); ax.set_yticks([]); ax.set_ylabel(label, rotation=0); pulse_ind += 1; if i == 0 and j == 0 and title is not None:; ax.set_title(title); fig.tight_layout(); return fig, axis. def _pulse_interpolate(pulse, tlist):; """"""; A function that calls Scipy interpolation routine. Used for plotting.; """"""; if pulse.tlist is None and pulse.coeff is None:; coeff = np.zeros(len(tlist)); return coeff; if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeff = np.ones(len(tlist)); else:; coeff = np.zeros(len(tlist)); return coeff; coeff = pulse.coeff; if len(coeff) == len(pulse.tlist)-1: # for discrete pulse; coeff = np.concatenate([coeff, [0]]). from scipy import interpolate; if pulse.spline_kind == ""step_func"":; kind = ""previous""; else:; kind = ""cubic""; inter = interpolate.interp1d(; pulse.tlist, coeff, kind=kind,; bounds_error=False, fill_value=0.0); return inter(tlist). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/processor.html:23497,rout,routine,23497,docs/4.7/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/processor.html,2,['rout'],['routine']
Integrability,"tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). (png, hires.png, pdf). Note that the parameters and the Hamiltonian used in this example is not the same as in the previous section, and hence the different appearance of the resulting figure.; For convenience, all the steps described above for calculating the evolution of a quantum system using the Floquet formalisms are encapsulated in the function qutip.floquet.fsesolve. Using this function, we could have achieved the same results as in the examples above using; output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. Floquet theory for dissipative evolution¶; A driven system that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:15004,depend,dependent,15004,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability,"to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]¶; Reset any attributes to default values. run(self, rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:32643,depend,depend,32643,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['depend'],['depend']
Integrability,"to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the strin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:17366,depend,dependence,17366,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['dependence']
Integrability,"to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj; instances, each of which may have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffient",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:17390,depend,dependence,17390,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['depend'],['dependence']
Integrability,"to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; appli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:218042,depend,dependent,218042,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability,"to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming language, and the performance of compiled code, all for free. What can be better than that?; . Can't express your time-dependence analytically, or need to construct a function from a data set? No problem. QuTiP allows for passing interpolating functions as time-dependent arguments to the evolution solvers. Even better, these interpolating functions can be runtime compiled into C++, and support both real and complex data.; . From Bloch spheres to nonlinear colormaps for Wigner functions, QuTiP includes a host of built-in visualization routines that help bring your data to life. Our plotting utilities have been used by Fortune 500 companies, government research labs, and countless research groups around the globe. If you don't look good, we don't look good. ; . QuTiP is thoroughly tested, both by its thousands of users, and by the large collection of built in test scripts. QuTiP includes over a thousand such tests, covering nearly all of the builtin functions. These tests are run over and over again during development to make sure that the results you get from QuTiP are in fact the correct answers. No other quantum simulation software is as well tested as QuTiP.; . No software should be a black box to the user, especially in science. QuTiP is not only completely open-source, but also includes hundreds of pages of documentation, a multitude of tutorial Jupyter notebooks, and a friendly community of users who kindly donate their time to help answer questions.; . © 2011 to 2024 inclusi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/features.html:2537,rout,routines,2537,features.html,https://qutip.org,https://qutip.org/features.html,1,['rout'],['routines']
Integrability,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/frontmatter.html:4124,depend,dependence,4124,docs/4.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html,4,['depend'],['dependence']
Integrability,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum informat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:4060,depend,dependence,4060,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,2,['depend'],['dependence']
Integrability,"tor and spin components, excited by a small number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Ba",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/frontmatter.html:5339,depend,dependence,5339,docs/3.0.0/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html,2,['depend'],['dependence']
Integrability,"tor or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be unifo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:102405,depend,dependent,102405,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability,"tor; acts. Parameters:args (array_like) – list or array of quantum objects with type=""super"". Returns:obj – A composite quantum object. Return type:qobj. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:pairs (tuple) – One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:cqobj – The original Qobj with all named index pairs contracted; away. Return type:Qobj. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters:; oper (qobj/array-like) – A single or a list or operators for expectation value.; state (qobj/array-like) – A single or a list of quantum states or density matrices. Returns:expt – Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Retur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:43450,contract,contracted,43450,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['contract'],['contracted']
Integrability,"tor; acts. Parameters:args : array_like. list or array of quantum objects with type=""super"". Returns:obj : qobj. A composite quantum object. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:pairs : tuple. One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:cqobj : Qobj. The original Qobj with all named index pairs contracted; away. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters:oper : qobj/array-like. A single or a list or operators for expectation value. state : qobj/array-like. A single or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:31335,contract,contracted,31335,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,2,['contract'],['contracted']
Integrability,"tor; acts. Parameters:args : array_like. list or array of quantum objects with type=""super"". Returns:obj : qobj. A composite quantum object. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:pairs : tuple. One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:cqobj : Qobj. The original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected sub",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:42779,contract,contracted,42779,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['contract'],['contracted']
Integrability,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe ep",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:159605,depend,dependent,159605,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:127547,depend,dependent,127547,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor base",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:137979,depend,dependent,137979,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:148421,depend,dependent,148421,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_ph",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:116717,depend,dependent,116717,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"tors. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:103453,depend,dependent,103453,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability,"tors. options : qutip.Options. with options for the ODE solver. progress_bar: BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x10569e200>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str. Name of generated RHS. cleanup: bool. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the spe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:97235,depend,dependent,97235,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"tors; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:2315,depend,dependent,2315,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"tors; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:2252,depend,dependent,2252,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"točnik et al., ""Studying Light-Harvesting Models with Superconducting Circuits"", ; arXiv:1710.07466. 337. Banchi et al., ""Driven Quantum Dynamics: Will It Blend?"", ; Phys. Rev. X 7, 041015 (2017). 336. Dhand et al., ""Quantum simulation via all-optically generated tensor network states"", ; arXiv:1710.06103. 335. Poonia et al., ""Quantum Biomimetic Modeling of Diamond NV- Center Spin Dynamics"", ; arXiv:1709.07632. 334. Nimmrichter et al., ""Quantum and classical dynamics of a three-mode absorption refrigerator"", ; Quantum 1, 37 (2017). 333. Qin et al., ""Exponentially-Enhanced Light-Matter Interaction, Cooperativities, and Steady-State Entanglement Using Parametric Amplification"", ; arXiv:1709.09555. 332. Ishibashi et al., ""Oscillation collapse in coupled quantum van der Pol oscillators"", ; Phys. Rev. E 96, 052210 (2017). 331. Elbin et al., ""Rényi Entropies from Random Quenches in Atomic Hubbard and Spin Models"", ; arXiv:1709.05060. 330. Li et al., ""Quantum microwave-optical interface with nitrogen-vacancy centers in diamond"", ; Phys. Rev. A 96, 032342 (2017). 329. Diguna et al., ""The coupling of single-photon exciton–biexciton quantum dot and cavity"", ; J. Nonlinear Optic. Phys. Mat. 1750029, (2017). 328. Lee et al., ""Effective formalism for open-quantum-system dynamics: Time-coarse-graining approach"", ; Phys. Rev. A 97, 012102 (2018). 327. de Moraes Neto et al., ""Steady many-body entanglements in dissipative systems"", ; Phys. Rev. A 96, 062313 (2017). 326. Zhang et al., ""Efficient numerical solution of excitation number conserving quantum systems"", ; AIP Advances 7, 085225 (2017). 325. Heuck et al., ""Temporally and frequency multiplexed single photon source using quantum feedback control for scalable photonic quantum technologies"", ; arXiv:1708.08875. 324. Kurian et al., ""Oxidative species-induced excitonic transport in tubulin aromatic networks: Potential implications for neurodegenerative disease"", ; J. Photochem. Photobiol. B: Biology (2017). 323. Hwang et al., ""Diss",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:5502,interface,interface,5502,users.html,https://qutip.org,https://qutip.org/users.html,1,['interface'],['interface']
Integrability,"traj=0,; args={}, options=Options(),; progress_bar=True, map_func=parallel_map, map_kwargs={},; _safe_mode=True, _exp=False):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : :class:`qutip.Qobj`, ``list``; single collapse operator or a ``list`` of collapse operators. e_ops : :class:`qutip.Qobj`, ``list``; single operator as Qobj or ``list`` or equivalent of Qobj operators; for calculating expectation values. args : dict; Argum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html:4240,depend,dependent,4240,docs/4.4/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html,1,['depend'],['dependent']
Integrability,"tributes. H_S; (qutip.Qobj) System Hamiltonian (can also be a Liouvillian). L1; (qutip.Qobj / list of qutip.Qobj) System operators coupling into the feedback loop. Can be a single operator or a list of operators. L2; (qutip.Qobj / list of qutip.Qobj) System operators coupling out of the feedback loop. Can be a single operator or a list of operators. L2 must have the same length as L1. S_matrix: array; S matrix describing which operators in L1 are coupled to which operators in L2 by the feedback channel. Defaults to an n by n identity matrix where n is the number of elements in L1/L2. c_ops_markov; (qutip.Qobj / list of qutip.Qobj) Decay operators describing conventional Markovian decay channels. Can be a single operator or a list of operators. integrator; (str {‘propagator’, ‘mesolve’}) Integrator method to use. Defaults to ‘propagator’ which tends to be faster for long times (i.e., large Hilbert space). parallel; (bool) Run integrator in parallel if True. Only implemented for ‘propagator’ as the integrator method. options; (qutip.solver.Options) Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:rho0 : qutip.Qobj. initial density matrix or state vector (ket). blist : array_like. List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like. list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float. time-delay. c1 : qutip.Qobj. system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj. system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns:: complex. expectation value of field ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:28525,integrat,integrator,28525,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['integrat'],['integrator']
Integrability,"tributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]¶; Reset any attributes to default values. run(self, rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:33811,integrat,integrator,33811,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['integrat'],['integrator']
Integrability,"tring_list.append(""me_cops_obj[%d]"" % k) ; ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=len(Lcoeff), h_tdterms=Lcoeff, ; c_td_splines=me_cops_coeff, ; c_td_spline_flags=me_cops_obj_flags, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mesolve.html:22479,integrat,integrate,22479,docs/4.3/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability,"trix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underlying matrices into a new; format. See also. Qobj.permutethe same operation on constant quantum objects. tidyup(atol=None)[source]¶; Removes small elements from this quantum object inplace. to_list()[source]¶; Return this operator in the list-like form used to initialised it, like; can be passed to mesolve. trans()[source]¶; Return the matrix transpose. eseries¶. class eseries(q=None, s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Deprecated since version 4.6.0: eseries will be removed in QuTiP 5.; Please use QobjEvo for general time-dependence. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponential series at the times listed in tlist. Parameters. tlistndarrayTimes at which to evaluate exponential series. Returns. val_listndarrayValues of exponential at times i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:27395,depend,dependence,27395,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['depend'],['dependence']
Integrability,"trix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {‘propagator’, ‘mesolve’}; Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:29043,integrat,integrator,29043,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['integrat'],['integrator']
Integrability,"trol pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it.; ``None`` implies that timeslot durations will be equal and calculated; as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:31605,depend,dependent,31605,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['depend'],['dependent']
Integrability,"trol pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:31225,depend,dependent,31225,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,4,['depend'],['dependent']
Integrability,"trs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/solver.html:12656,depend,dependent,12656,docs/4.0.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html,2,['depend'],['dependent']
Integrability,"trs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:12830,depend,dependent,12830,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['depend'],['dependent']
Integrability,"tructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest distance to the start node determines; # the start time of each pulse.; instructions_graph.add_constraint_dependency(constraint_dependency); instructions_graph.compute_distance(cycles_list=cycles_list). # Output pulse schedule result.; instruction_start_time = []; if self.method == ""ASAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instruction.distance_to_start - instruction.duration); elif self.method == ""ALAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instructions_graph.longest_distance -; instruction.distance_to_start); return instruction_start_time. [docs] def commutation_rules(self, ind1, ind2, instructions):; """"""; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:. If the two gates do not have the same n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:18858,depend,dependency,18858,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['depend'],['dependency']
Integrability,"ts of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.lindblad_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def get_ideal_qobj(self, dims):; """"""; Get the Hamiltonian of the ideal pulse. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The Hamiltonian of the ideal pulse.; """"""; return self.ideal_pulse.get_qobj(dims). [docs] def get_ideal_qobjevo(self, dims):; """"""; Get a `QobjEvo` representation of the ideal evolution. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:9291,depend,dependent,9291,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,1,['depend'],['dependent']
Integrability,"ts to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=<qutip.solver.Options object at 0x2b2261d09978>, progress_bar=True, map_func=<function parallel_map at 0x2b225f61c620>, map_kwargs={}, _safe_mode=True, _exp=False)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:58273,depend,dependent,58273,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ts with zero Hamiltonian; by non-trivial noise.; """"""; device_noise = []; if (t1 is not None) or (t2 is not None):; device_noise += [RelaxationNoise(t1, t2).get_noisy_dynamics(dims)]. for noise in noise_list:; if isinstance(noise, (DecoherenceNoise, RelaxationNoise)):; device_noise += [noise.get_noisy_dynamics(dims)]. return device_noise. def process_pulse_noise(pulses, noise_list, dims):; """"""; Apply pulse dependent noise to the input list of pulses.; It does not modify the input; pulse, but return a new one containing the noise.; Device noise noise will be ignored. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied.; noise_list: list of :class:`qutip.qip.noise`; A list of noise objects.; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. noisy_pulses: list of :class:`qutip.qip.Pulse`; The list of pulses with pulse dependent noise.; """"""; noisy_pulses = deepcopy(pulses); for noise in noise_list:; if isinstance(noise, ControlAmpNoise):; noisy_pulses = noise.get_noisy_dynamics(noisy_pulses); elif isinstance(noise, UserNoise):; noisy_pulses = noise.get_noisy_dynamics(pulses, dims); return noisy_pulses. class Noise(object):; """"""; The base class representing noise in a processor.; The noise object can be added to :class:`qutip.qip.device.Processor` and; contributes to evolution.; """"""; def __init__(self):; pass. def _check_coeff_num(self, coeffs, ops_num):; if len(coeffs) != ops_num:; raise ValueError(; ""The length of coeffs is not {}"".format(ops_num)). [docs]class DecoherenceNoise(Noise):; """"""; The decoherence noise in a processor. It generates lindblad noise; according to the given collapse operator `c_ops`. Parameters; ----------; c_ops: :class:`qutip.Qobj` or list; The Hamiltonian representing the dynamics of the noise.; targets: int or list, optional; The indices of qubits that are acted",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:3990,depend,dependent,3990,docs/4.5/modules/qutip/qip/noise.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html,1,['depend'],['dependent']
Integrability,"ts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/solver.html:25095,message,messages,25095,docs/4.5/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/solver.html,5,['message'],['messages']
Integrability,"ts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:25054,message,messages,25054,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['message'],['messages']
Integrability,"ts; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-dynamics.html:1433,depend,dependent,1433,docs/4.3/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-dynamics.html,2,['depend'],['dependent']
Integrability,"tting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:1745,depend,dependent,1745,docs/3.0.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"ttribute). HEOMSolver (class in qutip.nonmarkov.heom). hilbert_dist() (in module qutip.metrics). hinton() (in module qutip.visualization). homogeneous (StochasticSolverOptions attribute). HSolverDL (class in qutip.nonmarkov.heom). I. identity() (in module qutip.operators). init_coeffs() (PulseGenCrab method). init_comp() (FidCompTraceDiff method). (FidCompUnitary method). (FidelityComputer method). init_freqs() (PulseGenCrabFourier method). init_normalization() (FidCompUnitary method). init_optim() (Optimizer method). (OptimizerCrab method). (OptimizerLBFGSB method). init_pulse() (PulseGen method). (PulseGenCrab method). (PulseGenCrabFourier method). (PulseGenLinear method). (PulseGenPeriodic method). init_timeslots() (Dynamics method). initial (Dynamics attribute). initial_amps (OptimResult attribute). initial_ctrl_offset (Dynamics attribute). initial_ctrl_scaling (Dynamics attribute). initial_fid_err (OptimResult attribute). initialize_controls() (Dynamics method). integrator (MemoryCascade attribute). isbra (Qobj attribute). iscp (Qobj attribute). iscptp (Qobj attribute). isherm (Qobj attribute). ishp (Qobj attribute). isket (Qobj attribute). isoper (Qobj attribute). isoperbra (Qobj attribute). isoperket (Qobj attribute). issuper (Qobj attribute). istp (Qobj attribute). iswap() (in module qutip.qip.gates). iter_num (OptimIterSummary attribute). iter_step_callback_func() (Optimizer method). iter_summary (OptimDump attribute). (Optimizer attribute). J. jmat() (in module qutip.operators). K. ket() (in module qutip.states). ket2dm() (in module qutip.states). L. L1 (MemoryCascade attribute). L2 (MemoryCascade attribute). lbound (PulseGen attribute). learningtimes (TTMSolverOptions attribute). level (Dump attribute), [1]. lindblad_dissipator() (in module qutip.superoperator). LinearSpinChain (class in qutip.qip.models.spinchain). linspace_with() (in module qutip.utilities). liouvillian() (in module qutip.superoperator). load_circuit() (CircuitProcessor method). log_lev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:14149,integrat,integrator,14149,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['integrat'],['integrator']
Integrability,"ttributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly sc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:183944,depend,dependency,183944,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependency']
Integrability,"ttributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:77270,wrap,wrapper,77270,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['wrap'],['wrapper']
Integrability,"tum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/frontmatter.html:4120,depend,dependent,4120,docs/4.0.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html,2,['depend'],['dependent']
Integrability,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-eseries.html:998,depend,dependent,998,docs/4.0.2/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability,"tum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-eseries.html:998,depend,dependent,998,docs/4.1/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability,"tum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-eseries.html:998,depend,dependent,998,docs/4.2/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability,"tum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-eseries.html:998,depend,dependent,998,docs/4.3/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability,"tum object and coeff type. compile(code=False, matched=False, dense=False, omp=0):; Create the associated cython object for faster usage. code: return the code generated for compilation of the strings. matched: the compiled object use sparse matrix with matching indices. (experimental, no real advantage) dense: the compiled object use dense matrix. omp: (int) number of thread: the compiled object use spmvpy_openmp. __call__(t, data=False, state=None, args={}):; Return the Qobj at time t. *Faster after compilation. mul_mat(t, mat):; Product of this at t time with the dense matrix mat. *Faster after compilation. mul_vec(t, psi):; Apply the quantum object (if operator, no check) to psi. More generaly, return the product of the object at t with psi. *Faster after compilation. expect(t, psi, herm=False):; Calculates the expectation value for the quantum object (if operator, no check) and state psi. Return only the real part if herm. *Faster after compilation. to_list():; Return the time-dependent quantum object as a list. eseries¶. class eseries(q=None, s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(self, wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(self, *args)[source]¶; Returns a tidier version of exponential series. value(self, tlist)[source]¶; E",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:22334,depend,dependent,22334,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be swapped. Returns; -------. sqobj : Qobj; The original Qobj with all named index pairs swapped with each other; """"""; dims = q_oper.dims; tensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted index",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/tensor.html:10033,Contract,Contracts,10033,docs/4.6/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html,2,['Contract'],['Contracts']
Integrability,"turn sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100,; options_modes=None):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. options_modes : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:11435,depend,dependent,11435,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['depend'],['dependent']
Integrability,"turns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:43339,depend,dependent,43339,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['depend'],['dependent']
Integrability,"turns:corr_vec – An array of correlation values for the times specified by tlist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool {False, True}) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str {'me', 'mc', 'es'}) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by tlist. Return type:ndarray. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:84368,depend,dependent,84368,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"turns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:5051,depend,dependence,5051,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['depend'],['dependence']
Integrability,"tween two random amplitude. The coefficients; of the noise are the same within this time range. rand_gen: numpy.random, optionalA random generator in numpy.random, it has to take a size; parameter. indices: list of intThe indices of target pulse in the list of pulses. **kwargs:Key word arguments for the random number generator. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:167725,depend,dependent,167725,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependent']
Integrability,"two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use corr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:21594,depend,dependent,21594,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,6,['depend'],['dependent']
Integrability,"type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is constructed from a set; of constant:obj:`~qutip.Qobj` :math:`\\{Q_k\\}` and time-dependent scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:5631,depend,dependence,5631,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['depend'],['dependence']
Integrability,"tzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:26460,integrat,integrate,26460,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['integrat'],['integrate']
Integrability,"uTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html:1931,depend,dependent,1931,docs/3.0.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"uTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.6+)¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’. Setup Using Macports¶; On the Mac OS, we recommended that you install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via; sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel. Optional, but highly recommended ports include; sudo port install vtk5 +python27 #used for the Bloch3d class; sudo port install py27-mayavi #used for the Bloch3d class. Now, we want to tell OSX which Python and iPython we are going to use; sudo port select p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:5751,depend,dependencies,5751,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,2,['depend'],['dependencies']
Integrability,"uantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has mor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:31643,integrat,integrator,31643,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['integrat'],['integrator']
Integrability,"uate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=None)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:43953,integrat,integrating,43953,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['integrat'],['integrating']
Integrability,"uation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of; Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo’s description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For callable functions, they are called; as f(t, state) and return the expectation value. A single; callback’s expectation value can be any type, but a callback part of a; list must return a number as the expectation value. For operators, the; result’s expect will be computed by qutip.expect when the state; is a ket. For operator evolution, the overlap is computed by:; (e_ops[i].dag() * op(t)).tr(). argsdict, optionalDictionary of scope parameters for time-dependent Hamiltonians. optionsOptions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional ins",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:79824,depend,dependent,79824,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"ubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind1). # Find start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5834,depend,dependent,5834,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,8,['depend'],['dependent']
Integrability,"ue(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:12850,depend,dependent,12850,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"ue; Qobj data =; [[0. 0.5]; [0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.5]; [0.5 0. ]]. and we can evaluate it at time t by using the qutip.eseries.esval function:; In [6]: esval(es2, 0.0) # equivalent to es2.value(0.0); Out[6]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 1.]; [1. 0.]]. or for a list of times [0.0, 1.0 * pi, 2.0 * pi]:; In [7]: times = [0.0, 1.0 * pi, 2.0 * pi]. In [8]: esval(es2, times) # equivalent to es2.value(times); Out[8]: ; array([Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 1.]; [1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. -1.]; [-1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 1.]; [1. 0.]]], dtype=object). To calculate the expectation value of an time-dependent operator represented by an qutip.eseries, we use the qutip.expect function. For example, consider the operator \(\sigma_x \cos(\omega t) + \sigma_z\sin(\omega t)\), and say we would like to know the expectation value of this operator for a spin in its excited state (rho = fock_dm(2,1) produce this state):; In [9]: es3 = (eseries([0.5*sigmaz(), 0.5*sigmaz()], [1j, -1j]) +; ...: eseries([-0.5j*sigmax(), 0.5j*sigmax()], [1j, -1j])); ...: . In [10]: rho = fock_dm(2, 1). In [11]: es3_expect = expect(rho, es3). In [12]: es3_expect; Out[12]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = (-0-1j); (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-eseries.html:3975,depend,dependent,3975,docs/4.3/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability,"ue; Qobj data =; [[0. 0.5]; [0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.5]; [0.5 0. ]]. and we can evaluate it at time t by using the qutip.eseries.esval function:; In [6]: esval(es2, 0.0) # equivalent to es2.value(0.0); Out[6]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 1.]; [1. 0.]]. or for a list of times [0.0, 1.0 * pi, 2.0 * pi]:; In [7]: times = [0.0, 1.0 * pi, 2.0 * pi]. In [8]: esval(es2, times) # equivalent to es2.value(times); Out[8]: ; array([Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 1.]; [1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. -1.]; [-1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 1.]; [1. 0.]]], dtype=object). To calculate the expectation value of an time-dependent operator represented by an qutip.eseries, we use the qutip.expect function. For example, consider the operator \(\sigma_x \cos(\omega t) + \sigma_z\sin(\omega t)\), and say we would like to know the expectation value of this operator for a spin in its excited state (rho = fock_dm(2,1) produce this state):; In [9]: es3 = (eseries([0.5*sigmaz(), 0.5*sigmaz()], [1j, -1j]) +; ...: eseries([-0.5j*sigmax(), 0.5j*sigmax()], [1j, -1j])); ...: . In [10]: rho = fock_dm(2, 1). In [11]: es3_expect = expect(rho, es3). In [12]: es3_expect; Out[12]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = (-0-1j); (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([-1.000000e+00, -6.123234e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-eseries.html:4016,depend,dependent,4016,docs/4.5/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-eseries.html,1,['depend'],['dependent']
Integrability,"ue; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L = -1j * h; L_list.append([L.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; if oper_evo:; initial_vector = psi0.full().ravel('F'); if opt.rhs_with_state:; r = scipy.integrate.ode(oper_list_td_with_state); else:; r = scipy.integrate.ode(oper_list_td); else:; initial_vector = psi0.full().ravel(); if opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td_with_state); else:; r = scipy.integrate.ode(psi_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, L_List_and_args):. L_List = L_List_and_args[0]; args = L_List_and_args[1]. L = L_List[0][0]; tdfunc = L_List[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(L.data, L.indices, L.indptr, psi, tdfunc(t, args), out); for n in range(1, len(L_List)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; L = L_List",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:8504,integrat,integrate,8504,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"ues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters:method : str. Algorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:oper : qobj. A valid density operator. unit(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:norm : str. Requested norm for states / operators. sparse : bool. Use sparse eigensolver for trace norm. Does not affect other norms. tol : float. Tolerance used by sparse eigensolver. maxiter : int. Number of maximum iterations performed by sparse eigensolver. Returns:oper : qobj. Normalized quantum object. eseries¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects.; Attributes. ampl; (ndarray) Array of amplitudes for exponential series. rates; (ndarray) Array of rates for exponential series. dims; (list) Dimensions of exponential series components. shape; (list) Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:wlist : array_like. Array/list of frequenies. Returns:val_list : ndarray. Values of exponential series at frequencies in wlist. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponential series at the times listed in tlist. Parameters:tlist : ndarray. Times at ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:15800,depend,dependent,15800,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"uet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/floquet.html:11328,depend,dependence,11328,docs/4.5/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/floquet.html,1,['depend'],['dependence']
Integrability,"uet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1,:1][0, 0]; fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:11315,depend,dependence,11315,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,1,['depend'],['dependence']
Integrability,"uet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:11220,depend,dependence,11220,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['depend'],['dependence']
Integrability,"uet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:11347,depend,dependence,11347,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability,"uet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. f_coeff : array. The coefficients for Floquet decomposition of the initial wavefunction. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:73188,depend,dependent,73188,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['depend'],['dependent']
Integrability,"uirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.8+); Setup Using Homebrew; Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.14+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms. Platform-independent instal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:2548,depend,dependent,2548,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['depend'],['dependent']
Integrability,"uires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters; ----------; A : csc_matrix, csr_matrix; Input graph in CSC or CSR matrix format; start : int; Staring node for BFS traversal. Returns; -------; order : array; Order in which nodes are traversed from starting node.; levels : array; Level of the nodes in the order that they are traversed. """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'). num_rows = A.shape[0]; start = int(start); order, levels = _breadth_first_search(A.indices, A.indptr, num_rows, start); # since maybe not all nodes are in search, check for unused entires in; # arrays; return order[order != -1], levels[levels != -1]. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise Typ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/graph.html:5483,rout,routine,5483,docs/3.1.0/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/graph.html,1,['rout'],['routine']
Integrability,"ulate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:50716,depend,dependent,50716,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"ulate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:6530,depend,dependent,6530,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['depend'],['dependent']
Integrability,"ulations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3813,message,message,3813,docs/4.6/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html,8,['message'],['message']
Integrability,"ulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:194028,depend,dependent,194028,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:172283,depend,dependent,172283,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Example",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:168289,depend,dependent,168289,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependent']
Integrability,"ult, config, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode, dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.settings import debug; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Ham",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mesolve.html:3506,integrat,integrating,3506,docs/4.5/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mesolve.html,1,['integrat'],['integrating']
Integrability,"ult,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:10297,depend,dependent,10297,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['depend'],['dependent']
Integrability,"ults¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:46494,Integrat,Integration,46494,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['Integrat'],['Integration']
Integrability,"um states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . QuTiP: Quantum Toolbox in Python (3.1.0); Indices and tables. Frontmatter ». QuTiP: Quantum Toolbox in Python (3.1.0)¶. Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.8+); Setup Using Homebrew; Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/index.html:1958,depend,dependencies,1958,docs/3.1.0/index.html,https://qutip.org,https://qutip.org/docs/3.1.0/index.html,1,['depend'],['dependencies']
Integrability,"umber basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:23522,depend,dependencies,23522,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,2,['depend'],['dependencies']
Integrability,"ument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters:; ops : list/array; list or array of qobjs representing commuting Hermitian; operators. Returns:; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:216327,depend,dependencies,216327,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependencies']
Integrability,"umentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). def add_control_noise(self, qobj, targets, tlist=None, coeff=None):; self.add_coherent_noise(qobj, targets, tlist=tlist, coeff=coeff). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.lindblad_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def get_ideal_qobj(self, dims):; """"""; Get the Hamiltonian of the ideal pulse. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The Hamiltonian of the ideal pulse.; """"""; return self.ideal_pulse.get_qobj(dims). [docs] def get_ideal_qobjevo(self, dims):; """"""; Get a `QobjEvo` representation of the ideal evolution. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the compon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:9489,depend,dependent,9489,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,4,['depend'],['dependent']
Integrability,"uments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14206,depend,dependent,14206,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,4,['depend'],['dependent']
Integrability,"umpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5. Please use :obj:`~QobjEvo`; for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl = np.empty((num,), dtype=object); self.ampl[:] = q; self.rates = np.zeros((num,)); self.dims = self.ampl[0].dims; self.shape = self.ampl[0].shape; elif isinstance(q, Qobj):; qo = Qobj(q); self.ampl = np.empty((1,), dtype=object); self.ampl[0] = qo; self.rates = np.array([0]); self.dims = qo.dims; self.shape = qo.shape; else:; self.ampl = np.array([q]); self.rates = np.array([0]); self.dims = [[1, 1]]; self.sh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/eseries.html:3162,depend,dependence,3162,docs/4.6/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html,2,['depend'],['dependence']
Integrability,"un; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Parameters:; H (qobj/function_type) – System Hamiltonian.; rho0 (qutip.qobj) – Initial state density matrix.; tlist (list/array) – list of times for \(t\).; c_op_list (list of qutip.qobj) – list of qutip.qobj collapse operators.; e_ops (list of qutip.qobj) – list of qutip.qobj operators for which to evaluate; expectation values. Returns:expt_array – Expectation values of wavefunctions/density matrices for the; times specified in tlist. Return type:array. Note; This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:; L (qobj) – Liouvillian of the system.; rho0 (qobj) – Initial state vector or density matrix. Returns:eseries – eseries represention of the system dynamics. Return type:qutip.eseries. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops, e_ops=[], spectra_cb=[], c_ops=[], args={}, options=<qutip.solver.Options object>, _safe_mode=True)[source]¶; Solve the dynamics for a system using the Bloch-Redfield master equation. Note; This solver does not currently support time-dependent Hamiltonians. Parameters:; H (qutip.Qobj) – System Hamiltonian.; / psi0 (rho0) – Initial density matrix or state vector (ket).; tlist (list / array) – List of times for \(t\).; a_ops (list of qutip.qobj) – List of system operators that couple to bath degrees of freedom.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:64699,depend,dependent,64699,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"unction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler metho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:107412,depend,depend,107412,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['depend']
Integrability,"und * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this exa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:8184,depend,dependent,8184,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:183400,depend,dependency,183400,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependency']
Integrability,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:5402,depend,dependencies,5402,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,4,['depend'],['dependencies']
Integrability,"upleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x1a2041a390>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:118996,depend,dependent,118996,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"urce]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:75956,depend,dependence,75956,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependence']
Integrability,"urce]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:64166,depend,dependence,64166,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['depend'],['dependence']
Integrability,"urce]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:75226,depend,dependence,75226,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependence']
Integrability,"urce]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:209791,depend,dependent,209791,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability,"urce]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:183859,depend,dependent,183859,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"urce]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Stochastic Schrödinger Equation and Master Equation¶. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:88079,depend,dependent,88079,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ure when parsingthe version number of the Cython package. Version 3.0.0 (July 17, 2014):¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API for working with; distribution functions.; New format for defining time-dependent Hamiltonians and collapse operators,; using a pre-calculated numpy array that specifies the values of the; Qobj-coefficients for each time step.; New functions for working with different superoperator representations,; including Kraus and Chi representation.; New functions for visualizing quantum states using Qubism and Schimdt plots:; plot_qubism and plot_schmidt.; Dynamics solver now support taking argument e_ops (expectation value; operators) in dictionary form.; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:10870,depend,dependent,10870,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,6,['depend'],['dependent']
Integrability,"urn y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for pyth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:22636,integrat,integrate,22636,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability,"urns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012):¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:9023,depend,dependent,9023,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,9,['depend'],['dependent']
Integrability,"use the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:19129,Depend,Dependent,19129,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,1,['Depend'],['Dependent']
Integrability,"use the following code:; tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, H_ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:13792,depend,dependent,13792,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,2,['depend'],['dependent']
Integrability,"use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:5918,depend,depend,5918,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['depend'],['depend']
Integrability,"use; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:91610,depend,dependent,91610,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind1). # Find start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5691,depend,dependent,5691,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['depend'],['dependent']
Integrability,"using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:4944,depend,dependent,4944,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:26270,depend,dependent,26270,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,6,['depend'],['dependent']
Integrability,"using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math: tau<0. Parameters:H : qutip.qobj.Qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj.Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : list / array; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. :math:`t. ightarrow infty`; here tlist is. automatically set, ignoring user input. taulist : list / array; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list of qutip.qobj.Qobj; list of collapse operators. (does not accept time dependence). a_op : qutip.qobj.Qobj; operator A. b_op : qutip.qobj.Qobj; operator B. c_op : qutip.qobj.Qobj; operator C. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : qutip.solver.Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat: array. An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x105963ab8>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:78360,depend,dependence,78360,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['depend'],['dependence']
Integrability,"ut is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. Hqutip.qobj, qutip.qobjevo, list, callablesystem Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians.; list format and options can be found in QobjEvo’s description. psi0qutip.qobjinitial state vector (ket); or initial unitary operator psi0 = U. tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values.; For list operator evolution, the overlapse is computed:. tr(e_ops[i].dag()*op(t)). argsdictionarydictionary of parameters for time-dependent Hamiltonians. optionsqutip.Qdeoptionswith options for the ODE solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=<qutip.solver.Options object at 0x2b225f643f98>, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b225f643fd0>, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of coll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:53246,depend,dependent,53246,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ut(). return fig, axes. def _overlap(A, B):; return (A.dag() * B).tr() / A.shape[0]; # return cy_overlap(A.data, B.data). [docs]def grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamiltonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Caution: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_start is not None:; for idx, u0 in enumerate(u_start):; u[0, idx, :] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[r, j, -1]); for j in range",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:6416,depend,dependent,6416,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['depend'],['dependent']
Integrability,"utational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Stochastic Schrödinger Equation and Master Equation¶. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:78231,depend,dependent,78231,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:4163,depend,dependent,4163,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,4,['depend'],['dependent']
Integrability,"utip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opsl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:103684,depend,depend,103684,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['depend']
Integrability,"utip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by qutip.expect. For callable functions, they are; called as f(t, state) and return the expectation value.; A single callback’s expectation value can be any type, but a callback; part of a list must return a number as the expectation value. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.solver.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and po",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:85955,depend,dependent,85955,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"utip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16013,depend,dependent,16013,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"utip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.superoperator import vec2mat; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, psi0, tlist, e_ops=[], args={}, options=None,; progress_bar=None,; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (`psi0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : :class:`qutip.qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be emp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:3402,integrat,integrating,3402,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrating']
Integrability,"utip.solver.Options object at 0x2b2261d09978>, progress_bar=True, map_func=<function parallel_map at 0x2b225f61c620>, map_kwargs={}, _safe_mode=True, _exp=False)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:59989,depend,dependent,59989,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"utip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like. list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. reverse : bool. If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat : array. An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[sourc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:80952,depend,dependent,80952,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"utip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.args",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:3767,depend,dependence,3767,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,8,['depend'],['dependence']
Integrability,"utip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False, ; progress_bar=None, _safe_mode=True, ; **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually ; ('single').; ; parallel : bool {False, True}; Run the propagator in parallel mode. This will override the ; unitary_mode settings if set to True.; ; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/propagator.html:3455,depend,dependent,3455,docs/4.3/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/propagator.html,1,['depend'],['dependent']
Integrability,"utput = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty:; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals. We remind the reader that the types of functions that can be used with this method is limited to:; ['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil'; , 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1'; , 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma'; , 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p'; , 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']. Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; >>> H = [H0, [H1, '9 * exp(-(t / 5.) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:11782,depend,dependent,11782,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"val [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:5615,depend,dependent,5615,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['depend'],['dependent']
Integrability,"value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:22634,message,message,22634,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,4,['message'],['message']
Integrability,"value; return self._isherm. if self.dims[0] != self.dims[1]:; self._isherm = False; else:; data = self.data; h = np.abs((data.transpose().conj() - data).data); self._isherm = False if np.any(h > settings.atol) else True. return self._isherm. @isherm.setter; def isherm(self, isherm):; self._isherm = isherm. @property; def type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:46059,depend,dependent,46059,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['depend'],['dependent']
Integrability,"value[, section]); Add value to count. add_timing(self, key, value[, section]); Add value to timing. add_message(self, key, value[, section, sep]); Add value to message. report:; Output the statistics report to console or file. add_count(self, key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:44176,message,message,44176,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['message'],['message']
Integrability,"ve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object at 0x2b226247fbe0>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorte",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:68550,depend,dependent,68550,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"ve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not isinstance(sso.dW_factors, list):; sso.dW_factors = [1] * len(sso.sc_ops); elif len(sso.dW_factors) != len(sso.sc_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). sso.solver_obj = PcSSESolver; sso.solver_name = ""photocurrent_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:31575,depend,depend,31575,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['depend'],['depend']
Integrability,"veloper tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’. Setup Using Macports¶; On the Mac OS, we recommended that you install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via; sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel. Optional, but highly recommended ports include; sudo port install vtk5 +python27 #used for the Bloch3d class; sudo port install py27-mayavi #used for the Bloch3d class. Now, we want to tell OSX which Python and iPython we are going to use; sudo port select python python34; sudo port select ipython ipython34. To install QuTiP from Macports, run; sudo port install py-qutip. Note; The next step is optional, but is necessary if you plan to use the string (Cython) based time-dependent format. See Solving Problems with Time-dependent Hamiltonians. Finally, we want to set the macports compiler to the vanilla GCC version. From the command line type:; port select gcc. which will bring up a list of installed compilers, such as:; Available versions for gcc:; apple-gcc42; gcc42; llvm-gcc42; mp-gcc47; none (active). We want to set the the compiler to the gcc4x compiler, where x is the highest number available, in this case mp-gcc47 (the “mp-” does not matter). To do this type:; sudo port select gcc mp-gcc47. Running port select again should give:; Available versions for gcc:; apple-gcc42; gcc42; llvm-gcc42; mp-gcc47 (active); none. Installing QuTiP via Macports will take a long time as each of the QuTiP dependencies is build from source code. The advantage is that all dependencies are resolved automatically, and the result should be a consistent build. Setup via SciPy Superpack¶; A second option is to install the required Python packages using the SciPy Superpack. Further information on installing the superp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:7154,depend,dependent,7154,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['depend'],['dependent']
Integrability,"vely; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:5801,depend,dependent,5801,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['depend'],['dependent']
Integrability,"ven this decomposition of the initial state in the Floquet states we can easily evaluate the wavefunction that is the solution to (5) at an arbitrary time \(t\) using the function qutip.floquet.floquet_wavefunction_t; In [30]: t = 10 * np.random.rand(). In [31]: psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args). In [32]: psi_t; Out[32]: ; <2x1 sparse matrix of type '<class 'numpy.complex128'>'; 	with 2 stored elements in Compressed Sparse Row format>. The following example illustrates how to use the functions introduced above to calculate and plot the time-evolution of (5).; from qutip import *; from scipy import *. delta = 0.2 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.5 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmaz(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html:12065,depend,dependent,12065,docs/4.4/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"ver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html:1432,integrat,integration,1432,docs/4.5/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html,2,"['depend', 'integrat']","['dependent', 'integration']"
Integrability,"ver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_mesolve""); return photocurrent_mesolve(H, rho0, times, c_ops=c_ops, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:18691,depend,depend,18691,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,6,['depend'],['depend']
Integrability,"vers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used lik",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:23040,depend,dependent,23040,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependent']
Integrability,"w ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 20",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide.html:2526,depend,dependent,2526,docs/3.0.1/guide/guide.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide.html,1,['depend'],['dependent']
Integrability,"w ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 20",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide.html:2464,depend,dependent,2464,docs/3.0.0/guide/guide.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html,1,['depend'],['dependent']
Integrability,"wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to eva",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:74193,depend,dependence,74193,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['depend'],['dependence']
Integrability,"wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:97670,depend,dependence,97670,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['depend'],['dependence']
Integrability,"ways hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11733,depend,dependent,11733,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:11824,depend,dependent,11824,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:20759,depend,dependent,20759,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependent']
Integrability,"which does have to be on the system drive. If this is not feasible, then it is possible to run QuTiP under Python 2.7. Windows and Python 2.7¶. Important; Running QuTiP under Python 2.7 on Windows is not recommended or supported. However, it is currently possible. There are no working conda-forge packages for Python 2.7 on Windows. You will have to install via pip or from source in Python 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” funct",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:7853,depend,depending,7853,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,4,['depend'],['depending']
Integrability,"which does have to be on the system drive. If this is not feasible, then it is possible to run QuTiP under Python 2.7. Windows and Python 2.7¶. Important; Running QuTiP under Python 2.7 on Windows is not recommended or supported. However, it is currently possible. There are no working conda-forge packages for Python 2.7 on Windows. You will have to install via pip or from source in Python 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the pytest testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:7988,depend,depending,7988,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['depend'],['depending']
Integrability,"which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:217120,wrap,wrapper,217120,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['wrap'],['wrapper']
Integrability,"which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved: :; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:109594,depend,dependencies,109594,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['depend'],['dependencies']
Integrability,"width(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:14075,message,message,14075,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['message'],['message']
Integrability,"will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initial density matrix or state vector (ket).; times (list / array) – List of times for \(t\). Must be uniformly spaced.; c_ops (list of qutip.Qobj) – Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; kwargs (dictionary) – Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output – An instance of the class qutip.solver.SolverResult. Return type:qutip.solver.SolverResult. Todo; Add checks for commuting jump operators in M",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:76285,depend,depending,76285,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['depending']
Integrability,"wser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINO",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:16085,wrap,wrap,16085,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['wrap'],['wrap']
Integrability,"x : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:70590,depend,dependent,70590,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['depend'],['dependent']
Integrability,"x. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3b90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:34184,depend,dependent,34184,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"x. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b11f65d3a90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:34246,depend,dependent,34246,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"x.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used for the coefficient; at time t.; If the coefficients are to be treated as step function, use the arguments; args = {“_step_func_coeff”: True}; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:“state_vec”:psi0, args[“state_vec”] = state as 1D np.ndarray; “state_mat”:psi0, args[“state_mat”] = state as 2D np.ndarray; “state”:psi0, args[“state”] = state as Qobj; This Qobj is the initial value. expectation values:“expect_op_n”:0, args[“expect_op_n”] = expect(e_ops[int(n)], state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:“collapse”:list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters. QobjEvo(Q_object=[], args={}, tlist=None); Q_objectarray_likeData for vector/matrix representation of the quantum object. argsdictionary that contain the arguments for; tlistarray_likeList of times at which the numpy-array coefficients are applied. Times; must be equidistant and start from 0. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementList of Qobj and the coefficients.; [(Qobj, coefficient as a function, original coefficient,. type, local arguments ), … ]. type :1: function; 2: string; 3: np.array; 4: Cubic_Spline. argsmaparguments of the coefficients. dynamics_argslistarguments that change during evolution. tlistarray_likeList ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:19129,depend,depending,19129,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['depend'],['depending']
Integrability,"x; Input quantum object or csr_matrix. Returns:; degree : array; Array of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format. sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns:; perm : array; Array of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if; necessary. Parameters:; A : sparse matrix; Input matrix. perm_type : str {‘row’, ‘column’}; Type of permutation to generate. Returns:; perm : array; Array of row or column permutations. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_.; References; I. S. Duff, K. Kaya, and B. Uc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:203564,rout,routine,203564,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,2,['rout'],"['routine', 'routines']"
Integrability,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:43191,Depend,Depending,43191,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['Depend'],['Depending']
Integrability,"xperimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:4095,depend,depending,4095,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,8,['depend'],['depending']
Integrability,"xponent {k}""; ); return op. def _rhs(self, L):; """""" Make the RHS for the HEOM. """"""; ops = _GatherHEOMRHS(self.ados.idx, block=L.shape[0], nhe=self._n_ados). for he_n in self.ados.labels:; op = self._grad_n(L, he_n); ops.add_op(he_n, he_n, op); for k in range(len(self.ados.dims)):; next_he = self.ados.next(he_n, k); if next_he is not None:; op = self._grad_next(he_n, k); ops.add_op(he_n, next_he, op); prev_he = self.ados.prev(he_n, k); if prev_he is not None:; op = self._grad_prev(he_n, k); ops.add_op(he_n, prev_he, op). return ops.gather(). def _configure_solver(self):; """""" Set up the solver. """"""; RHSmat = self._rhs(self._L0.data); assert isinstance(RHSmat, sp.csr_matrix). if self._is_timedep:; # In the time dependent case, we construct the parameters; # for the ODE gradient function _dsuper_list_td under the; # assumption that RHSmat(t) = RHSmat + time dependent terms; # that only affect the diagonal blocks of the RHS matrix.; # This assumption holds because only _grad_n dependents on; # the system Liovillian (and not _grad_prev or _grad_next). h_identity_mat = sp.identity(self._n_ados, format=""csr""); H_list = self.H_sys.to_list(). solver_params = [[RHSmat]]; for idx in range(1, len(H_list)):; temp_mat = sp.kron(; h_identity_mat, liouvillian(H_list[idx][0]); ); solver_params.append([temp_mat, H_list[idx][1]]). solver = scipy.integrate.ode(self._dsuper_list_td); solver.set_f_params(solver_params); else:; solver = scipy.integrate.ode(cy_ode_rhs); solver.set_f_params(RHSmat.data, RHSmat.indices, RHSmat.indptr). solver.set_integrator(; ""zvode"",; method=self.options.method,; order=self.options.order,; atol=self.options.atol,; rtol=self.options.rtol,; nsteps=self.options.nsteps,; first_step=self.options.first_step,; min_step=self.options.min_step,; max_step=self.options.max_step,; ). self._ode = solver; self.RHSmat = RHSmat. [docs] def steady_state(; self,; use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False; ):; """"""; Compute the steady state of the system.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:19445,depend,dependents,19445,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['depend'],['dependents']
Integrability,"y 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package mana",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:2344,depend,dependent,2344,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['depend'],['dependent']
Integrability,"y Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:14126,depend,dependabot,14126,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['depend'],['dependabot']
Integrability,"y as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, ‘exp(-1j*w1*t)’], [H2, ‘cos(w2*t)’]],args={“w1”:1.,”w2”:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:name+”=vec”:Qobj => args[name] == state as 1D np.ndarray; name+”=mat”:Qobj => args[name] == state as 2D np.ndarray; name+”=Qobj”:Qobj => args[name] == state as Qobj; This Qobj is the initial value. expectation values:name+”=expect”:O (Qobj/QobjEvo) => args[name] == expect(O, state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:name+”=collapse”:list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters. QobjEvo(Q_object=[], args={}, tlist=None); Q_objectarray_likeData for vector/matrix representation of the quantum object. argsdictionary that contain the arguments for; tlistarray_likeList of times at which the numpy-array coefficients are applied. Times; must be equidistant and start from 0. Attributes. cteQobjConstant part of the QobjEvo. opslistList of Qobj and the coefficients.; [(Qobj, coefficient as a function, original coefficient,. type, local arguments ), … ]. type :1: function; 2: string; 3: np.array; 4: Cubic_Spline. argsmaparguments of the coefficients. tlistarray_likeList of times at which the numpy-array coefficients are applied. compil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:18397,depend,depending,18397,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['depend'],['depending']
Integrability,"y be used by advanced users. Returns:; lu (object) – Returns a SuperLU object representing iLU preconditioner.; info (dict, optional) – Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:; H (qobj or list) – Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve).; t (float or array-like) – Time or list of times for which to evaluate the propagator.; c_op_list (list) – List of qobj collapse operators.; args (list/array/dictionary) – Parameters to callback functions for time-dependent Hamiltonians and; collapse operators.; options (qutip.Options) – with options for the ODE solver.; = str ('batch', 'single') (unitary_mode) – Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’).; parallel (bool {False, True}) – Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True.; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, optio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:108845,depend,dependent,108845,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"y library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5863,depend,dependent,5863,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"y setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; state_norm_func=None, dims=None):; """"""; Internal function for solving ODEs.; """""". #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y). return output. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:18889,integrat,integration,18889,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,2,['integrat'],"['integrate', 'integration']"
Integrability,"y spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:78960,depend,depending,78960,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['depending']
Integrability,"y, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output: qutip.solver.SolverResult. An instance of the class qutip.solver.SolverResult. ssesolve(H, psi0, times, sc_ops, e_ops, **kwargs)[source]¶; Solve the stochast",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:65028,depend,depending,65028,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['depend'],['depending']
Integrability,"y.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, psi0, tlist, e_ops=[], args={}, options=None,; progress_bar=None,; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (`psi0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : :class:`qutip.qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be empty list operator evolution. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:4074,depend,dependent,4074,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"y/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100, options_modes=None)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. options_modesqutip.solver.Optionsoptions for the ODE solver. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:109416,depend,dependent,109416,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:41719,integrat,integratorstr,41719,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,6,"['Integrat', 'integrat']","['Integrator', 'integratorstr']"
Integrability,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem coll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:34724,integrat,integratorstr,34724,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['integrat'],['integratorstr']
Integrability,"ypes; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings. from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None,; progress_bar=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:4505,depend,depending,4505,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['depend'],['depending']
Integrability,"ys that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax : tuple. A tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)¶; Metho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:32237,depend,depending,32237,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['depend'],['depending']
Integrability,"ystem with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavefunction \(\Psi(t=0)\) in the Floquet states and immediately obtain the solution for arbitrary \(t\). (3)\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\hb",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:3462,depend,dependence,3462,docs/3.0.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html,3,['depend'],['dependence']
Integrability,"ystem.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. qobj: qutip.QobjThe Hamiltonian of the ideal pulse. get_ideal_qobjevo(self, dims)[source]¶; Get a QobjEvo representation of the ideal evolution. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. ideal_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution. get_noisy_qobjevo(self, dims)[source]¶; Get the QobjEvo representation of the noisy evolution. The result; can be used directly as input for the qutip solvers. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. noisy_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution and coherent noise. c_ops: list of qutip.QobjEvoA list of (time-dependent) lindbald operators. print_info(self)[source]¶; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise. property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:143155,depend,dependent,143155,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['depend'],['dependent']
Integrability,"ython 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/installation.html:8729,depend,dependencies,8729,docs/4.3/installation.html,https://qutip.org,https://qutip.org/docs/4.3/installation.html,3,"['depend', 'message']","['dependencies', 'message']"
Integrability,"ython setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Installation on MS Windows¶; We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work.; QuTiP uses dynamic compilation of C for some of its time-dependant dynamics solvers. For MS Windows users the additional challenge is the need for a ANSI C99 compliant C compiler. Unlike other platforms, no C compiler is provided with Windows by default.; It is possible to install a Windows SDK that includes a C compiler, but ANSI C99 compliance is not 100%.; The mingw-w64 project looks to help overcome this, and to some extent it is successful.; The conda-forge packages for QuTiP will also install the Mingwpy package, which uses mingw-w64.; Currently we are only able get QuTiP working with Python <= 3.4. Python >= 3.5 is compiled with a ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:6605,depend,dependencies,6605,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['depend'],['dependencies']
Integrability,"ze : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float; The time for which to evaluate the time-dependent Qobj instance. args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:; method : str {‘dense’, ‘sparse’}; Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns:; oper : qobj; Exponentiated quantum operator. Raises:; TypeError; Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:8804,depend,dependent,8804,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['depend'],['dependent']
Integrability,"} \ket{\psi} = -i H(t)\ket{\psi}\]; Note we use units where \(\hbar=1\) throughout. The solutions to Schrödinger’s equation are of the form:. \[\ket{\psi(t)} = U(t)\ket{\psi_0}\]; where \(\psi_0\) is the state of the system at \(t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [NKanej]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:4295,depend,dependent,4295,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['depend'],['dependent']
Integrability,"} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solver : str. choice of solver (me for master-equation and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec : array. An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. reverse : bool {False, True}. If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str {‘me’, ‘mc’, ‘es’}. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc corre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:83515,depend,dependent,83515,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"}, options=<qutip.solver.Options object at 0x1a2041a400>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x1a2041a3c8>)[source]¶; Calc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:100717,depend,dependent,100717,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure. Use A+trans(A); if original matrix is not symmetric or not sure. Parameters. Acsc_matrix, csr_matrixInput graph in CSC or CSR matrix format. startintStaring node for BFS traversal. Returns. orderarrayOrder in which nodes are traversed from starting node. levelsarrayLevel of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters. Aqobj, csr_matrix, csc_matrixInput quantum object or csr_matrix. Returns. degreearrayArray of integers giving the degree for each node (row). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:242160,rout,routines,242160,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,6,"['Rout', 'rout']","['Routines', 'routines']"
Integrability,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters. Acsc_matrix, csr_matrixInput graph in CSC or CSR matrix format. startintStaring node for BFS traversal. Returns. orderarrayOrder in which nodes are traversed from starting node. levelsarrayLevel of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters. Aqobj, csr_matrix, csc_matrixInput quantum object or csr_matrix. Returns. degreearrayArray of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:199674,rout,routines,199674,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['rout'],['routines']
Integrability,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters:; A : csc_matrix, csr_matrix; Input graph in CSC or CSR matrix format. start : int; Staring node for BFS traversal. Returns:; order : array; Order in which nodes are traversed from starting node. levels : array; Level of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters:; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns:; degree : array; Array of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:201772,rout,routines,201772,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['rout'],['routines']
Integrability,"¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos ac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:17559,depend,dependent,17559,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['dependent']
Integrability,"– Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:149561,depend,dependent,149561,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"– Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:158393,depend,dependent,158393,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"– Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; optim_method (string) – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; optim_alg (string) – Deprecated. Use optim_method.; max_metric_corr (integer) – Deprecated. Use method_params instead; accuracy_factor (float) – Deprecated. Use method_params instead; dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:166152,depend,dependent,166152,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html:452,depend,dependent,452,docs/4.1/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:420,depend,dependent,420,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in parti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:420,depend,dependent,420,docs/4.3/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html:489,depend,dependent,489,docs/4.4/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Floquet Formalism — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html:473,depend,dependent,473,docs/4.5/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"﻿. . Permutational Invariance — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\dot{\rho} = \mathcal{D}_\text{TLS}(\rho)=-\frac{i}{\hbar}\lbrack H,\rho \rbrack; +\frac{\gamma_\text{CE}}{2}\mathc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html:427,depend,dependent,427,docs/4.3/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html,1,['depend'],['dependent']
Integrability,"﻿. . Permutational Invariance — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\dot{\rho} = \mathcal{D}_\text{TLS}(\rho)=-\fr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-piqs.html:496,depend,dependent,496,docs/4.4/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-piqs.html,1,['depend'],['dependent']
Integrability,"﻿. . Permutational Invariance — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\dot{\rho} = \mathcal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-piqs.html:480,depend,dependent,480,docs/4.5/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-piqs.html,1,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Ham",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of h",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:32,depend,dependent,32,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"﻿. Bloch-Redfield master equation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:484,depend,dependent,484,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,4,['depend'],['dependent']
Integrability,"﻿. Floquet Formalism — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms sho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:471,depend,dependent,471,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability,"﻿. Lindblad Master Equation Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; wh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:557,depend,dependent,557,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,2,['depend'],['dependent']
Integrability,"﻿. Monte Carlo Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:508,depend,dependent,508,docs/4.6/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html,2,['depend'],['dependent']
Integrability,"﻿. Permutational Invariance — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\do",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html:478,depend,dependent,478,docs/4.6/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html,2,['depend'],['dependent']
Integrability,"﻿. Permutational Invariance — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:507,depend,dependent,507,docs/4.7/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html,2,['depend'],['dependent']
Integrability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Citing QuTiP; QuTiP is developed by several physicists in their spare time.; As with anyone in academics,; their life and death is determined entirely by citations and paper count. ; Therefore, if you find QuTiP useful, please consider citing this project as:. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234 (2013), DOI: 10.1016/j.cpc.2012.11.019. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP: An open-source Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 183, 1760–1772 (2012), DOI: 10.1016/j.cpc.2012.02.021. This will also help us secure future funding supporting the development of this software.; PDF versions of these papers may be found on the ArXiv preprint server; here and here.; If you do use QuTiP in a publication, please take a few minutes and let us know; by posting on the QuTiP message board.; We would love to hear how QuTiP is being used as a research tool. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/citing.html:1211,message,message,1211,citing.html,https://qutip.org,https://qutip.org/citing.html,1,['message'],['message']
Integrability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Virtual Lab. Exploring simple quantum systems with QuTiP can help build intuition for them,; but there are many cases where writing code and Jupyter notebooks can get; in the way:. When teaching, coding can be a big distraction. Quantum mechanics is complex ; enough without your students having to struggle with installing software,; messing up their notebooks or learning QuTiP at the same time. When doing research, coding can be a big detour. You just want to do a quick; check to remind yourself how a simple system works, not spend the afternoon; fiddling in a text editor. You have papers to write and grant reports to fill; in. Time is precious. When at a party or while pitching your cool ideas, you don’t want to take out; your laptop to show people how cool your ideas are. It breaks the flow. You; need to be able to show them on your tablet. For all of these use cases, there is QuTiP Virtual Lab – a tablet and web; optimized graphical interface for building and exploring simple quantum systems.; It runs entirely in your browser, so there’s no server and nothing to install.; Click the button below to get started!; Enter QuTiP Virtual Lab.; There’s a handy tutorial with videos included in the virtual lab itself and some pre-built systems; to get you started. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-virtual-lab.html:1236,interface,interface,1236,qutip-virtual-lab.html,https://qutip.org,https://qutip.org/qutip-virtual-lab.html,1,['interface'],['interface']
Integrability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP is open-source software for simulating the dynamics of open quantum systems. The QuTiP library depends on the excellent Numpy, Scipy, and Cython numerical packages. In addition, graphical output is provided by Matplotlib. QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of Hamiltonians, including those with arbitrary time-dependence, commonly found in a wide range of physics applications such as quantum optics, trapped ions, superconducting circuits, and quantum nanomechanical resonators. QuTiP is freely available for use and/or modification on all major platforms such as Linux, Mac OSX, and Windows*. Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics and dynamics in the classroom. *QuTiP is developed on Unix platforms only, and some features may not be available under Windows. From the classroom to the corporate office, QuTiP is used around the world to advance research in quantum optics, quantum information, quantum open systems, optomechanics, and many related fields. QuTiP is in use at nearly every single research university around the globe, government-funded research labs, and is relied upon by every major corporation focused on developing a quantum computer. QuTiP is already being used at a variety of institutions around the globe, and has been downloaded more than a million times since its initial release. Need; help in simulating a tricky problem? Our large community of users are gracious enough to take a moment of their time and help in tackling even the most esoteric of issues. Distribution of the 39,420 Unique Visitors in 2020. Supporting Organizations; Developers from Nori's lab and Blais' lab have been ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index.html:381,depend,depends,381,index.html,https://qutip.org,https://qutip.org/index.html,2,['depend'],"['dependence', 'depends']"
Integrability,﻿. QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python. css; ; bootstrap.css; gh-fork-ribbon.css; site.css. QuTiP - Quantum Toolbox in Python. docs; . /3.0.0; . /apidoc; ; API documentation — QuTiP 3.0 Documentation; Classes — QuTiP 3.0 Documentation; Functions — QuTiP 3.0 Documentation. Bibliography — QuTiP 3.0 Documentation; Change Log — QuTiP 3.0 Documentation; Developers — QuTiP 3.0 Documentation; Frontmatter — QuTiP 3.0 Documentation; Index — QuTiP 3.0 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 3.0 Documentation; Dynamics Simulation Results — QuTiP 3.0 Documentation; Floquet Formalism — QuTiP 3.0 Documentation; Lindblad Master Equation Solver — QuTiP 3.0 Documentation; Monte Carlo Solver — QuTiP 3.0 Documentation; Setting Options for the Dynamics Solvers — QuTiP 3.0 Documentation; Performance (QuTiP vs. qotoolbox) — QuTiP 3.0 Documentation; Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. /scripts; ; correlation_ex1.pdf; correlation_ex1.py; correlation_ex2.pdf; correlation_ex2.py; correlation_ex3.pdf; correlation_ex3.py; correlation_ex4.pdf; correlation_ex4.py; floquet_ex0.pdf; floquet_ex0.py; floquet_ex1.pdf; floquet_ex1.py; floquet_ex2.pdf; floquet_ex2.py; floquet_ex3.pdf; floquet_ex3.py; spectrum_ex1.pdf; spectrum_ex1.py. Users Guide — QuTiP 3.0 Documentation; Basic Operations on Quantum Objects — QuTiP 3.0 Documentation; Plotting on the Bloch Sphere — QuTiP 3.0 Documentation; Two-time correlation functions — QuTiP 3.0 Documentation; Time Evolution and Quantum System Dynamics — QuTiP 3.0 Documentation; An Overview of the Eseries Class — QuTiP 3.0 Documentation; Guide Overview — QuTiP 3.0 Documentation; Running Problems in Parallel — QuTiP 3.0 Documentation; Generating Random Quantum States & Operators — QuTiP 3.0 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 3.0 Documentation; Modifying Internal QuTiP Settings — QuTiP 3.0 Documentation,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:971,depend,dependent,971,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['depend'],['dependent']
Integrability,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:494,integrat,integration,494,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['integrat'],['integration']
Integrability,"﻿. QuTiP Development Roadmap — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:416,integrat,integration,416,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['integrat'],['integration']
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/3.0.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,9,"['Depend', 'depend']","['Dependence', 'Dependent', 'dependent']"
Integrability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:30,depend,dependent,30,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,8,"['Depend', 'depend']","['Dependence', 'Dependent', 'dependent']"
Integrability,"﻿. Stochastic Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.genera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:532,depend,dependent,532,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,2,['depend'],['dependent']
Integrability,"﻿. Stochastic Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:561,depend,dependent,561,docs/4.7/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html,2,['depend'],['dependent']
Modifiability," """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20076,config,config,20076,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36931,config,config,36931,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12134,config,config,12134,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); ; # Add H object terms to ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; # Add cop object terms to end of ode args string; for k in range(len(me_cops_obj)):; string_list.append(""me_cops_obj[%d]"" % k) ; ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=len(Lcoeff), h_tdterms=Lcoeff, ; c_td_splines=me_cops_coeff, ; c_td_spline_flags=me_cops_obj_flags, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mesolve.html:21916,config,config,21916,docs/4.3/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability," # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3734,config,config,3734,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability," # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9336,config,config,9336,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11533,config,config,11533,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability," # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 2011 to 2021 inclusive, QuT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:36104,config,config,36104,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,2,['config'],['config']
Modifiability," # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20578,config,config,20578,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability," #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. # -----------------------------------------------------------------------------; # Functions for calculating the Bloch-Redfield tensor for a time-independent; # system.; #; [docs]def bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=[], use_secular=True, sec_cutoff=0.1):; """"""; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system's coupling; to its environment. .. note::. This tensor generation requires a time-independent Hamiltonian. Parameters; ----------. H : :class:`qutip.qobj`; System Hamiltonian. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to the environment. spectra_cb : list of callback functions; List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of :class:`qutip.qobj`; List of system collapse operators. use_secular : bool; Flag (True of False) that indicates if the secular approximation should; be used.; ; sec_cutoff : float {0.1}; Threshold for secular approximation. Returns; -------. R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. """"""; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:11434,coupling,coupling,11434,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability," 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/parallel.html:1753,variab,variables,1753,docs/4.7/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html,2,['variab'],['variables']
Modifiability," 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets.; """"""; self.render(self.fig, self.axes); if self.run_from_ipython():; if self._shown:; display(self.fig); else:; self.fig.show(); self._shown = True. [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(self.fig, self.axes); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; complete_path = os.getcwd() + ""/"" + str(dirc) + '/bloch_' \; + str(self.savenum) + '.' + format; else:; complete_path = os.getcwd() + '/bloch_' + \; str(self.savenum) + '.' + format; else:; complete_path = name. if dpin:; self.fig.savefig(complete_path, dpi=dpin); else:; self.fig.savefig(complete_path); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/bloch.html:21009,variab,variable,21009,docs/4.5/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/bloch.html,1,['variab'],['variable']
Modifiability," (Cython.__version__, _cython_requirement))). import pyximport; os.environ['CFLAGS'] = '-O3 -w -ffast-math -march=native -mfpmath=sse'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}). except Exception as e:; print(""QuTiP warning: Cython setup failed: "" + str(e)); else:; del Cython, pyximport. # -----------------------------------------------------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass. # -----------------------------------------------------------------------------; # cpu/process configuration; #; import multiprocessing. # Check if environ flag for qutip processes is set; if 'QUTIP_NUM_PROCESSES' in os.environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number of cores; from qutip.hardware_info import hardware_info; info = hardware_info(); if 'cpus' in info:; qutip.settings.num_cpus = info['cpus']; else:; qutip.settings.num_cpus = multiprocessing.cpu_count(). # -----------------------------------------------------------------------------; # Load configuration from environment variables: override defaults and; # configuration file.; #. # check for fortran mcsolver files; try:; from qutip.fortran import mcsolve_f90; except:; qutip.settings.fortran = False; else:; qutip.settings.fortran = True. # check for scikits.umfpack; try:; import scikits.umfpack as umfpack; exce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:6916,config,configuration,6916,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['config'],['configuration']
Modifiability," (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-parfor.html:2182,variab,variables,2182,docs/3.0.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html,4,['variab'],"['variable', 'variables']"
Modifiability, (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.operations.gates). c,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:5232,config,configure,5232,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,1,['config'],['configure']
Modifiability," (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progres",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12305,config,config,12305,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability," (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # --------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32226,config,config,32226,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:68884,config,configuration,68884,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability," * spre(cdc) \; - 0.5 * spost(cdc); elif c.issuper:; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6126,config,config,6126,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,16,['config'],['config']
Modifiability," * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe.; *Examples*; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; *Examples*; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:; state can be obtained with:; name+""=vec"":Qobj => args[name] == state as 1D np.ndarray; name+""=mat"":Qobj => args[name] == state as 2D np.ndarray; name+""=Qobj"":Qobj => args[name] == state as Qobj. This Qobj is the initial value. expectation values:; name+""=expect"":O (Qobj/QobjEvo) => args[name] == expect(O, state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:; name+""=collapse"":list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters; ----------; QobjEvo(Q_object=[], args={}, tlist=None). Q_object : array_like; Data for vector/matrix representation of the quantum object. args : dictionary that contain the arguments for. tlist : array_like; List of times at which the numpy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:7201,variab,variables,7201,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['variab'],['variables']
Modifiability," + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38094,config,config,38094,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:6402,config,config,6402,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability," + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeErr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6206,config,config,6206,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,5,['config'],['config']
Modifiability," +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26747,config,config,26747,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:35691,evolve,evolve,35691,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['evolve'],['evolve']
Modifiability," +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; self.ntrajs = np.array(self.ntrajs); self.ntrajs = self.ntrajs[np.whe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8420,config,config,8420,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21269,config,config,21269,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,4,['config'],['config']
Modifiability," += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """""". # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T. f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)). else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:5571,variab,variables,5571,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['variab'],['variables']
Modifiability," += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:5645,variab,variables,5645,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,2,['variab'],['variables']
Modifiability," += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; ; initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:17851,config,config,17851,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['config'],['config']
Modifiability," - sigma * 1.0j * mu). return eta_list, gamma_list. [docs]class LorentzianPadeBath(FermionicBath):; """"""; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`LorentzianBath` which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(self, Q, gamma, w, mu, T, Nk, tag=None):; ck_plus, vk_plus = self._corr(gamma, w, mu, T, Nk, sigma=1.0); ck_minus, vk_minus = self._corr(gamma, w, mu, T, Nk, sigma=-1.0). super().__init__(; Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=tag,; ). def _corr(self, gamma, w, mu, T, Nk, sigma):; beta = 1. / T; kappa, epsilon = self._kappa_epsilon(Nk). def f_approx(x):; f = 0.5; for ll in range(1, Nk + 1):; f = f - 2 * kappa[ll] * x / (x**2 + epsilon[ll]**2); return f. eta_list = [0.5 * gamma * w * f_approx(1.0j * beta * w)]; gamma_list",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:23957,coupling,coupling,23957,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['coupling'],['coupling']
Modifiability," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:44906,variab,variable,44906,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['variab'],['variable']
Modifiability," -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:33814,config,config,33814,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32805,config,config,32805,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Mon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:10625,variab,variable,10625,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,4,['variab'],['variable']
Modifiability," ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [32]: N = 10 # number of basis states. In [33]: a = destroy(N). In [34]: H = a.dag() * a # simple HO. In [35]: psi0 = basis(N, 9) # initial state. In [36]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [37]: times = np.linspace(0, 10, 100). In [38]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [39]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [40]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [42]: args = {'A': 9, 'sigma': 5}. In [43]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Mon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:11248,variab,variable,11248,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,3,['variab'],['variable']
Modifiability," / array_like. Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:data : instance/array_like. Input Python object to be stored. filename : str. Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1.0, we recommend to use qutip.parallel_map; instead of this function. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:task: a Python function. The function that is to be called for each value in task_vec. values: array / list. The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary. The optional additional argument to the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:157854,variab,variables,157854,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['variab'],['variables']
Modifiability," /; (-(epsilon[ll]**2 / beta**2) + w**2); ); gamma_list.append(epsilon[ll] / beta - sigma * 1.0j * mu). return eta_list, gamma_list. [docs]class LorentzianPadeBath(FermionicBath):; """"""; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`LorentzianBath` which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(self, Q, gamma, w, mu, T, Nk, tag=None):; ck_plus, vk_plus = self._corr(gamma, w, mu, T, Nk, sigma=1.0); ck_minus, vk_minus = self._corr(gamma, w, mu, T, Nk, sigma=-1.0). super().__init__(; Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=tag,; ). def _corr(self, gamma, w, mu, T, Nk, sigma):; beta = 1. / T; kappa, epsilon = self._kappa_epsilon(Nk). def f_approx(x):; f = 0.5; for ll in range(1, Nk + 1):; f = f - 2 * kappa[ll] * x / (x**2 + epsilon[ll]**2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:23904,coupling,coupling,23904,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['coupling'],['coupling']
Modifiability," 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14336,config,config,14336,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15328,config,config,15328,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9646,config,config,9646,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18594,config,config,18594,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," 512 (2016). 207. Fischer et al., ""Dynamical modeling of pulsed two-photon interference"", ; New J. Phys. 18, 113053 (2016).; Notebook1; Notebook2. 206. Seifoory et al., ""The properties of squeezed optical states created in lossy cavities"", ; arXiv:1608.05005. 205. Qin et al., ""Heralded quantum controlled-phase gates with dissipative dynamics in macroscopically distant resonators"", ; Phys. Rev. A 96, 012315 (2017). 204. Cruzeiro et al., ""Interactively Applying the Variational Method to the Dihydrogen Molecule: Exploring Bonding and Antibonding"", ; Journal of Chemical Education (2016). 203. Pleinert et al., ""Quantum signatures of collective behavior of a coherently driven two atom system coupled to a single-mode of the electromagnetic field"", ; arXiv:1608.00137. 202. Wang et al., ""Multiple-output microwave single-photon source using superconducting circuits with longitudinal and transverse couplings"", ; Phys. Rev. A 94, 053858 (2016). 201. Marshall et al., ""Continuous-variable quantum computing on encrypted data"", ; Nat. Comm. 7, 13795 (2016). 200. Dajka et al., ""Leggett–Garg inequalities for a quantum top affected by classical noise"", ; J. Quantum Inf. Process. (2016). 199. Rouxinol et al., ""Measurements of nanoresonator-qubit interactions in a hybrid quantum electromechanical system"", ; Nanotechnology 27, 364003 (2016). 198. Hocker et al., ""PEET: a Matlab tool for estimating physical gate errors in quantum information processing systems"", ; Quantum Information Processing (2016). 197. Daskin, ""Quantum eigenvalue estimation for irreducible non-negative matrices"", ; Int. J. Quantum Inform. 14, 1650005 (2016). 196. Dlaska et al., ""Robust quantum state transfer via topologically protected edge channels in dipolar arrays"", ; Quantum Sci. Technol. 2, 015001 (2017). 195. Juliusson et al., ""Manipulating Fock states of a harmonic oscillator while preserving its linearity"", ; Phys. Rev. A 94, 063861 (2016). 194. Banchi et al., ""Quantum gate learning in qubit networks: Toffoli g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:22531,variab,variable,22531,users.html,https://qutip.org,https://qutip.org/users.html,1,['variab'],['variable']
Modifiability," 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8637,variab,variables,8637,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['variab'],['variables']
Modifiability," : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:79180,variab,variables,79180,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['variab'],['variables']
Modifiability," : List of array[drift_dyn_gen.shape]; Eigenvectors of the dynamics generators; Used for calculating the propagators and their gradients; Only used when the PropagatorComputer uses diagonalisation. prop_eigen : List of array[drift_dyn_gen.shape]; Propagator in diagonalised basis of the combined dynamics generator; Used for calculating the propagators and their gradients; Only used when the PropagatorComputer uses diagonalisation. dyn_gen_factormatrix : List of array[drift_dyn_gen.shape]; Matrix of scaling factors calculated duing the decomposition; Used for calculating the propagator gradients; Only used when the PropagatorComputer uses diagonalisation. fact_mat_round_prec : float; Rounding precision used when calculating the factor matrix; to determine if two eigenvalues are equivalent; Only used when the PropagatorComputer uses diagonalisation. def_amps_fname : string; Default name for the output used when save_amps is called. """"""; def __init__(self, optimconfig):; self.config = optimconfig; self.reset(). def reset(self):; # Main functional attributes; self.evo_time = 0; self.num_tslots = 0; self.tau = None; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.evo_init2t = None; self.evo_t2end = None; self.evo_t2targ = None; # Atrributes used in diagonalisation; self.decomp_curr = None; self.prop_eigen = None; self.dyn_gen_eigenvectors = None; self.dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.set_log_level(self.config.log_level); # Internal flags; self._dyn_gen_mapped = False; self._ctrls_initialized = False. # Create the computing objects; self._create_computers(). self.clear(). [docs] def set_log_level(self, lvl):;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:10020,config,config,10020,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability," : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType):; output.num_expect = 0; expt_callback = True. elif isinstance(e_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:12892,variab,variables,12892,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['variab'],['variables']
Modifiability," : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, w0, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; w0=w0,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). def _matsubara_params(self, lam, gamma, w0, T, Nk):; """""" Calculate the Matsubara coefficents and frequencies. """"""; beta = 1/T; Om = np.sqrt(w0**2 - (gamma/2)**2); Gamma = gamma/2. ck_real = ([; (lam**2 / (4 * Om)); * (1 / np.tanh(beta * (Om + 1.0j * Gamma) / 2)),; (lam**2 / (4*Om)); * (1 / np.tanh(beta * (Om - 1.0j * Gamma) / 2)),; ]). ck_real.extend([; (-2 * lam**2 * gamma / beta) * (2 * np.pi * k / beta); / (; ((Om + 1.0j * Gamma)**2 + (2 * np.pi * k/beta)**2); * ((Om - 1.0j * Gamma)**2 + (2 * np.pi * k / beta)**2); ); for k in range(1, Nk + 1); ]). vk_real = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]; vk_real.extend([; 2 * np.pi * k * T; for k in range(1, Nk + 1); ]). ck_imag = [; 1.0j * lam**2 / (4 * Om),; -1.0j * lam**2 / (4 * Om),; ]. vk_imag = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class FermionicBath(Bath):; """"""; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the ``+`` and ``-`` modes of; the bath correlation function. There must be the same number of ``+`` and ``-`` modes and their; coefficients must be specified in the same order so that ``ck_plus[i],; vk_plus[i]`` are the plus coefficient and frequency corresponding; to the minus mode ``ck_minus[i], vk_minus[i]``. In the fermionic case the order in which excitations are created or; destr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:17851,extend,extend,17851,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['extend'],['extend']
Modifiability," = (; sols[j].col_times); sol.col_which[sofar:sofar + sols[j].ntraj] = (; sols[j].col_which); if (config.e_num == 0):; if (config.options.average_states):; # collect states, averaged over trajectories; sol.states += np.array(sols[j].states); else:; # collect states, all trajectories; sol.states = np.vstack((sol.states,; np.array(sols[j].states))); else:; if (config.options.average_expect):; # collect expectation values, averaged; for i in range(config.e_num):; sol.expect[i] += np.array(sols[j].expect[i]); else:; # collect expectation values, all trajectories; sol.expect = np.vstack((sol.expect,; np.array(sols[j].expect))); if (hasattr(sols[j], 'entropy')):; if (config.options.average_states or; config.options.average_expect):; # collect entropy values, averaged; sol.entropy += np.array(sols[j].entropy); else:; # collect entropy values, all trajectories; sol.entropy = np.vstack((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:17890,config,config,17890,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). A comparison of this time-dependent damping, with that of a constant decay term is presented below. Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable:; def H1_coeff(t, args):; return args['A'] * exp(-(t/args['sigma'])**2). or equivalently:; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty:; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:10134,variab,variable,10134,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['variab'],['variable']
Modifiability," = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-eseries.html:5643,evolve,evolve,5643,docs/4.2/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-eseries.html,3,['evolve'],['evolve']
Modifiability," = True. return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_H_t_shift(H, args=None):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". if isinstance(H, Qobj):; # constant hamiltonian; return H, args. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""); return H_shifted, _args. if isinstance(H, list):; # string/function-list based time-dependence; H_shifted = []; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. for i in range(len(H)):; if isinstance(H[i], list):; # modify hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.Funct",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:38268,variab,variable,38268,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['variab'],['variable']
Modifiability," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.36s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.64s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.93s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.21s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.48s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.76s. Est. time left: 00:00:00:01; 70.0%. Run time: 2.00s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.23s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.46s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:14264,variab,variables,14264,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.95s. Est. time left: 00:00:00:08; 20.0%. Run time: 1.81s. Est. time left: 00:00:00:07; 30.0%. Run time: 2.67s. Est. time left: 00:00:00:06; 40.0%. Run time: 3.59s. Est. time left: 00:00:00:05; 50.0%. Run time: 4.42s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.27s. Est. time left: 00:00:00:03; 70.0%. Run time: 6.10s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.91s. Est. time left: 00:00:00:01; 90.0%. Run time: 7.74s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:13804,variab,variables,13804,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37178,config,config,37178,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36176,config,config,36176,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," = []; exponents.extend(; BathExponent(""R"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_real, vk_real); ); exponents.extend(; BathExponent(""I"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_imag, vk_imag); ). if combine:; exponents = self.combine(exponents). super().__init__(exponents). [docs] @classmethod; def combine(cls, exponents, rtol=1e-5, atol=1e-7):; """"""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""; groups = []; remaining = exponents[:]. while remaining:; e1 = remaining.pop(0); group = [e1]; for e2 in remaining[:]:; if (; np.isclose(e1.vk, e2.vk, rtol=rtol, atol=atol) and; np.allclose(e1.Q, e2.Q, rtol=rtol, atol=atol); ):; group.append(e2); remaining.remove(e2); groups.append(group). new_exponents = []; for combine in groups:; exp1 = combine[0]; if (exp1.type != exp1.types.RI) and all(; exp2.type == exp1.type for exp2 in combine; ):; # the group is either type I or R; ck = sum(exp.ck for exp in combine); new_exponents.append(BathExponent(; exp1.type, None, exp1.Q, ck, exp1.vk, tag=exp1.tag,; )); else:; # the group includes both type I and R exponents; ck_R = (; sum(exp.ck for exp in combine if exp.type == exp.types.R) +; sum(exp.ck for exp in combine if exp.type == exp.types.RI); ); ck_I = (; sum(exp.ck for exp in combine if exp.type == exp.type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:7904,coupling,coupling,7904,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['coupling'],['coupling']
Modifiability," = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25426,config,config,25426,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19451,config,config,19451,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; return col_times, col_which; for i in range(ntraj):; qtf90.qutraj_run.get_collapses(i + 1); times = qtf90.qutraj_run.col_times; which = qtf90.qutraj_run.col_which; if times is None:; times = np.array([]); if which is None:; which = np.array([]); else:; which = which - 1; col_times[i] = np.array(times, copy=True); col_which[i] = np.array(which, copy=True); return col_times, col_which. def get_states(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). from scipy.sparse import csr_matrix; if (config.options.average_states):; states = np.array([Qobj()] * nstep); if (self.sparse_dms):; # averaged sparse density matrices; for i in range(nstep):; qtf90.qutraj_run.get_rho_sparse(i + 1); val = qtf90.qutraj_run.csr_val; col = qtf90.qutraj_run.csr_col - 1; ptr = qtf90.qutraj_run.csr_ptr - 1; m = qtf90.qutraj_run.csr_nrows; k = qtf90.qutraj_run.csr_ncols; states[i] = Qobj(csr_matrix((val, col, ptr),; (m, k)).toarray(),; dims=self.dm_dims, shape=se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:13660,config,config,13660,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # ---------------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13790,config,config,13790,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13883,config,config,13883,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13133,config,config,13133,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # P",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38007,config,config,38007,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings; import qutip.settings as qset; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td, spmvpy_csr; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:2574,config,config,2574,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,2,['config'],['config']
Modifiability," DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings; import qutip.settings as qset; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/mesolve.html:2574,config,config,2574,docs/4.1/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability, Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(P,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide.html:2532,Config,Configuring,2532,docs/4.7/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html,1,['Config'],['Configuring']
Modifiability," Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26340,config,config,26340,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14700,config,config,14700,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15692,config,config,15692,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_lev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:107343,config,configuration,107343,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability," GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:69815,variab,variables,69815,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability," Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinst",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1132,config,config,1132,docs/4.7/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html,2,['config'],['config']
Modifiability," H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # -----------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37006,config,config,37006,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36004,config,config,36004,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:27391,config,configure,27391,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,2,['config'],['configure']
Modifiability," H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]¶; Reset any attributes to default values. run(self, rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:34106,coupling,coupling,34106,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38213,config,config,38213,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html:1308,extend,extend,1308,docs/4.6/development/ideas/heom-gpu.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html,2,['extend'],['extend']
Modifiability," Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:13758,config,configuration,13758,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['config'],['configuration']
Modifiability," It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]¶; clear any temporarily held status data. compute_fid_grad(self)[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]¶; Check configuration and initialise the normalisation. init_normalization(self)[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]¶. normalize_SU(self, A)[source]¶. normalize_gradient_PSU(self, grad)[source]¶; Normalise the gradient matrix pas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:110213,config,config,110213,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['config']
Modifiability," LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approxim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:2707,variab,variables,2707,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['variab'],['variables']
Modifiability," LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian ap",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:2678,variab,variables,2678,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['variab'],['variables']
Modifiability," Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12355,config,config,12355,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability," List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. options : qutip.solver.Options; Options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters:; H : qutip.qobj. System Hamiltonian. a_ops : list; Nested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cb : list; Depreciated. c_ops : list; List of system collapse operators. use_secular : bool {True, False}; Flag that indicates if the secular approximation should; be used. sec_cutoff : float {0.1}; Threshold for secular approximation. atol : float {qutip.settings.atol}; Threshold for removing small parameters. Returns:; R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`; R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_ten",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:67172,coupling,couplingto,67172,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['coupling'],['couplingto']
Modifiability," M_i\); projection operators if ops correspond to; projectors (s.t. \(E_i = M_i^\dagger = M_i\)); kets (transformed to projectors). targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply; the measurement using qutip.qip.operations.gates.expand_operator; to expand ops into full dimension. Returns. collapsed_stateslist of QobjThe collapsed states obtained after measuring the qubits and obtaining; the qubit specified by the target in the state specified by the index. probabilitieslist of floatsThe probability of measuring a state in a the state specified by the; index. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of; Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo’s description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opsNone / list / callback function, optionalA list of operators as Qobj and/or ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:79043,Evolve,Evolve,79043,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['Evolve'],['Evolve']
Modifiability," None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:3865,config,config,3865,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability," None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:3946,config,config,3946,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability," Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics¶; Dynamics (subclass instance) – describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config¶; OptimConfig instance – various configuration options; (see OptimConfig for details). termination_conditions¶; TerminationCondition instance – attributes determine when the optimisation will end. pulse_generator¶; PulseGen (subclass instance) – (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats¶; Stats – attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump¶; dump.OptimDump – Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:62082,config,config,62082,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,2,['config'],"['config', 'configuration']"
Modifiability," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:175131,variab,variable,175131,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variable']
Modifiability," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:183701,variab,variable,183701,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variable']
Modifiability," Note; This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:L : qobj. Liouvillian of the system. rho0 : qobj. Initial state vector or density matrix. Returns:eseries : qutip.eseries. eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:63658,coupling,coupling,63658,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability," ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28831,config,config,28831,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2295,config,config,2295,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability," OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:2889,variab,variables,2889,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,8,"['config', 'variab']","['config', 'variables']"
Modifiability," OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (loc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:82071,config,config,82071,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['config']
Modifiability," OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm; Attributes. max_metric_corr; (integer) The maximum number of variable metric corrections used to define the limited memory matrix. That is the number of previous gradient values that are used to approximate the Hessian see the scipy.optimize.fmin_l_bfgs_b documentation for description of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:65279,config,config,65279,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['config'],['config']
Modifiability," Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state accor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html:1565,evolve,evolve,1565,docs/4.5/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html,1,['evolve'],['evolve']
Modifiability," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:11287,config,configuration,11287,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,9,['config'],['configuration']
Modifiability," Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:8754,config,config,8754,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,2,['config'],['config']
Modifiability," QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require approx 10GB of disk space, much of which does have to be on the system drive. If this is not feasible, then it is possible to run QuTiP under Python 2.7. Windows and Python 2.7¶. Important; Running QuTiP under Python",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:6024,config,configuration,6024,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,5,['config'],['configuration']
Modifiability," Run time: 17.62s. Est. time left: 00:00:00:00; Total run time: 17.63s. we can extract the relevant expectation values using:; In [17]: expt1 = data.expect[0]. In [18]: expt10 = data.expect[1]. In [19]: expt100 = data.expect[2]. In [20]: expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [21]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [22]: times = np.linspace(0.0, 10.0, 200). In [23]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [24]: a = tensor(qeye(2), destroy(10)). In [25]: sm = tensor(destroy(2), qeye(10)). In [26]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [27]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 0.83s. Est. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html:16539,config,configuration,16539,docs/4.4/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html,1,['config'],['configuration']
Modifiability," Run time: 26.46s. Est. time left: 00:00:00:00; Total run time: 26.52s. we can extract the relevant expectation values using:; In [17]: expt1 = data.expect[0]. In [18]: expt10 = data.expect[1]. In [19]: expt100 = data.expect[2]. In [20]: expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [21]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [22]: times = np.linspace(0.0, 10.0, 200). In [23]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [24]: a = tensor(qeye(2), destroy(10)). In [25]: sm = tensor(destroy(2), qeye(10)). In [26]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [27]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.21s. Est. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html:12280,config,configuration,12280,docs/4.5/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html,1,['config'],['configuration']
Modifiability," SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:2248,config,configuration,2248,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,5,['config'],['configuration']
Modifiability," SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will sto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:70543,config,config,70543,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['config']
Modifiability," SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:67548,config,config,67548,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,3,['config'],['config']
Modifiability," Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; self.log_level = lvl; logger.setLevel(lvl). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). [docs] def init_time_slots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.evo_time/self.num_tslots; self.time = np.zeros(self.num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self.num_tslots):; self.time[t+1] = self.time[t] + self.tau[t]. def _init_lists(self):; """"""; Create the container lists / arrays for the:; dynamics generations, propagators, and evolutions etc; Set the time slices and cumulative time; """""". # Create containers for control Hamiltonian etc; shp = self.drift_dyn_gen.shape; # set H to be just empty float arrays with the shape of H; self.dyn_gen = [np.empty(shp, dtype=complex); for x in range(self.num_tslots)]; # the exponetiation of H. Just empty float arrays with the shape of H; self.prop = [np.empty(shp, dtype=comple",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:12229,config,config,12229,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability," Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1954,coupling,coupling,1954,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['coupling'],['coupling']
Modifiability," Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:1519,evolve,evolves,1519,docs/4.7/guide/dynamics/dynamics-krylov.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html,2,['evolve'],['evolves']
Modifiability," Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:8104,coupling,coupling,8104,docs/4.6/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html,4,['coupling'],['coupling']
Modifiability," TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:3833,coupling,coupling,3833,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,10,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability," TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:76331,variab,variables,76331,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability," These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self._phase_application = 'preop'; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). [docs] def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); if self._num_ctrls is None:; self._num_ctrls = self._get_num_ctrls(); return self._num_ctrls. def _get_onto_evo_target(self):; """"""; Get the adjoint of the target.; Used for calculating the 'backward' evolution; """"""; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); else:; self._onto_evo_target = self._target.T.conj(); return self._onto_evo_target. def _spectral_decomp(self, k):; """"""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:46874,config,configuration,46874,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,7,['config'],['configuration']
Modifiability," This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5564,extend,extending,5564,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,2,['extend'],['extending']
Modifiability," This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:63410,coupling,coupling,63410,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability," TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32280,config,config,32280,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. « Visualization of... Saving QuTiP Obj... ». Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; In [11]: result = p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-parfor.html:2288,variab,variables,2288,docs/3.1.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html,2,['variab'],['variables']
Modifiability," [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'; ; Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header prope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:13446,variab,variables,13446,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['variab'],['variables']
Modifiability," \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q – Values representing the Q-function calculated over the specified range; [xvec,yvec]. Return type:array. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:; state (qobj) – A state vector or density matrix for a spin-j quantum system.; theta (array_like) – theta-coordinates at which to calculate the Q function.; phi (array_like) – phi-coordinates at which to calculate the Q function. Returns:Q, THETA, PHI – Values representing the spin Q fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:110635,config,config,110635,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['config'],['config']
Modifiability," _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27053,config,config,27053,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28056,config,config,28056,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.sof",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html:7381,config,config,7381,docs/4.0.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the DrudeLorentzBath which constructs; a simpler exponential expansion. Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of Padé exponentials terms used to approximate the bath; correlation functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Padé terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Padé terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class UnderDampedBath(Q, lam, gamma, w0, T, Nk, combine=True, tag=None)[source]¶;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:56730,coupling,coupling,56730,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/Ph",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:68978,coupling,coupling,68978,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," a single operator; # if so convert it to a list containing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:9839,config,config,9839,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['config'],['config']
Modifiability," a specific conda environment, or you have installed Miniconda, then you will need to install the required packages for QuTiP.; recommended:; conda install numpy scipy cython matplotlib pytest pytest-cov jupyter notebook spyder. minimum (recommended):; conda install numpy scipy cython pytest pytest-cov matplotlib. absolute mimimum:; conda install numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks). Spyder is an IDE for scientific development with Python. Adding the conda-forge channel¶; If you have conda 4.1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To instal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:4237,config,config,4237,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['config'],['config']
Modifiability," an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:31421,config,config,31421,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:128015,coupling,coupling,128015,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.parallel. Source code for qutip.parallel; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from numpy import array; import multiprocessing; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if sys.platform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/parallel.html:1239,variab,variable,1239,docs/4.7/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html,2,['variab'],['variable']
Modifiability," and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15030,config,config,15030,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16022,config,config,16022,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," and/or lindblad noise. If there are; pulse independent noise, a dummy Pulse can be created by; Pulse(None, None). The modified input pulses should always; be at the begining of the list, followed by the dummy pulses. get_noisy_dynamics(self, pulses, dims)[source]¶; Template method.; It should return a list of pulses with noise. Parameters. pulses: list of :class:`qutip.qip.Pulse`The input pulses, on which the noise object will be applied. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. Returns. noisy_pulses: list of qutip.qip.PulseThe input Pulse object with additional noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label=None)[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:137531,variab,variables,137531,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['variab'],['variables']
Modifiability," and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # ------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13622,config,config,13622,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_bins : int; Number of time bins; the range over which each index can vary. Returns:; temporal_basis_vector : :class: qutip.Qobj; A basis vecto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:111505,config,config,111505,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['config'],['config']
Modifiability," array_like; Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data : instance/array_like; Input Python object to be stored. filename : str; Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func : function_type; A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:; result : list; A list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:; task : a Python function; The function that is to be called for each value in task_vec. values : array / list; The list or array of values for which the task function is to be; evaluated. task_args : list / dictionary; The optional additional argument ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:210102,variab,variables,210102,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability," as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:3862,enhance,enhancement,3862,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,4,['enhance'],['enhancement']
Modifiability," bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:14623,config,config,14623,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,4,['config'],['config']
Modifiability," be checked. Returns. taus: dictA dictionary of key, val as {tau: value} consisting of the valid; taus for this row and column of the Dicke space element. One-Dimensional Lattice¶. class Lattice1d(num_cell=10, boundary='periodic', cell_num_site=1, cell_site_dof=[1], Hamiltonian_of_cell=None, inter_hop=None)[source]¶; A class for representing a 1d crystal.; The Lattice1d class can be defined with any specific unit cells and a; specified number of unit cells in the crystal. It can return dispersion; relationship, position operators, Hamiltonian in the position represention; etc. Parameters. num_cellintThe number of cells in the crystal. boundarystrSpecification of the type of boundary the crystal is defined with. cell_num_siteintThe number of sites in the unit cell. cell_site_doflist of int/ intThe tensor structure of the degrees of freedom at each site of a unit; cell. Hamiltonian_of_cellqutip.QobjThe Hamiltonian of the unit cell. inter_hopqutip.Qobj / list of QobjThe coupling between the unit cell at i and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:60287,coupling,coupling,60287,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,5,['coupling'],['coupling']
Modifiability," boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, pl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:28870,config,config,28870,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['config']
Modifiability," by stacking; them together. get_ops_labels()[source]¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(qc)[source]¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. optimize_circuit(qc)[source]¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. Returns:; qc: QubitCircuit; The optimal circuit representation. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:67158,config,configuration,67158,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability," cached, because it is used in the gradient calculation. init_comp(self)[source]¶; Check configuration and initialise the normalisation. init_normalization(self)[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]¶. normalize_SU(self, A)[source]¶. normalize_gradient_PSU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:111355,config,configuration,111355,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configuration']
Modifiability," can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly installed on OS X using Homebrew and the automated installation shell scripts. Python 2.7 installation script; Python 3.4 installation script. Having downloaded the script corresponding to the version of Python you want to use, the installation script can be run from the terminal using (replacing X with 2 or 3); sh install_qutip_pyX.sh. The script will then install Homebrew and the required QuTiP dependencies before installing QuTiP itself and running the built in test suite. Any errors in the homebrew configuration will be displayed at the end. Using Python 2.7 or 3.4, the python commend-line and IPython interpreter can be run by calling python and ipython or python3 and ipython3, respectively.; If you have installed other packages in the /usr/local/ directory, or have changed the permissions of any of its sub-directories, then this script may fail to install all the necessary tools automatically. Setup Using Macports¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’.; On the Mac OS, you can install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via (Replace ‘34’ with ‘27’ if you want Python 2.7); sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel; sudo port install py34-pip. Now",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:7168,config,configuration,7168,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['config'],['configuration']
Modifiability, cnot() (in module qutip.qip.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Du,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:4273,config,configure,4273,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['config'],['configure']
Modifiability," collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('fro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28235,config,config,28235,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15093,config,config,15093,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16085,config,config,16085,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j *",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34095,config,config,34095,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33086,config,config,33086,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13545,config,config,13545,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23732,config,config,23732,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in rang",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:35143,config,config,35143,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16860,config,config,16860,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TI",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:24545,config,config,24545,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,2,['config'],['config']
Modifiability," config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30250,config,config,30250,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13165,config,config,13165,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability," configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:41101,coupling,coupling,41101,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," contains a single element. If 'e_ops' were provided""; "", return its corresponding expectation values at 'psi0', else ""; ""return 'psi0'.""; ). progress_bar.start(1). res, expt_callback, options, n_expt_op = _e_ops_outputs(; res, e_ops, n_tlist_steps, options; ). if options.store_states:; res.states = [psi0]. e_0 = None; if expt_callback:; # use callback method; e_0 = e_ops(0, psi0); res.expect.append(e_0). e_m_0 = []; for m in range(n_expt_op):; op = e_ops[m]. if not isinstance(op, Qobj) and callable(op):; e_m_0.append(op(0, psi0)); res.expect[m][0] = e_m_0[m]; continue. e_m_0.append(expect(op, psi0)); res.expect[m][0] = e_m_0[m]. if happy_breakdown:; res = _happy_breakdown(; tlist,; options,; res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:13813,evolve,evolves,13813,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,['evolve'],['evolves']
Modifiability," ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None impli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:30934,variab,variables,30934,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['variab'],['variables']
Modifiability," decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-steady.html:10431,coupling,coupling,10431,docs/4.6/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html,4,['coupling'],['coupling']
Modifiability," def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16002,config,config,16002,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16994,config,config,16994,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Mo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:10399,variab,variable,10399,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['variab'],['variable']
Modifiability," del top_path. # -----------------------------------------------------------------------------; # setup the cython environment; #; _cython_requirement = ""0.15.0""; try:; import Cython; if _version2int(Cython.__version__) < _version2int(_cython_requirement):; print(""QuTiP warning: old version of cython detected "" +; (""(%s), requiring %s."" %; (Cython.__version__, _cython_requirement))). import pyximport; os.environ['CFLAGS'] = '-O3 -w -ffast-math -march=native -mfpmath=sse'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}). except Exception as e:; print(""QuTiP warning: Cython setup failed: "" + str(e)); else:; del Cython, pyximport. # -----------------------------------------------------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass. # -----------------------------------------------------------------------------; # cpu/process configuration; #; import multiprocessing. # Check if environ flag for qutip processes is set; if 'QUTIP_NUM_PROCESSES' in os.environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number of cores; from qutip.hardware_info import hardware_info; info = hardware_info(); if 'cpus' in info:; qutip.settings.num_cpus = info['cpus']; else:; qutip.settings.num_cpus = multiprocessing.cpu_count(). # ----------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:6528,config,config,6528,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['config'],['config']
Modifiability," deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:9690,variab,variables,9690,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['variab'],['variables']
Modifiability," described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:14810,config,configuration,14810,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,2,['config'],['configuration']
Modifiability," destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17716,coupling,coupling,17716,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,2,['coupling'],['coupling']
Modifiability," do explicit loops here in case spectra_cb[k] can not deal with array arguments; for n in range(N):; for m in range(N):; Jw[k, n, m] = a_ops[k][1](W[n, m]). dw_min = np.abs(W[W.nonzero()]).min(). # pre-calculate mapping between global index I and system indices a,b; Iabs = np.empty((N*N,3),dtype=int); for I, Iab in enumerate(Iabs):; # important: use [:] to change array values, instead of creating new variable Iab; Iab[0] = I; Iab[1:] = vec2mat_index(N, I). # unitary part + dissipation from c_ops (if given):; Heb = H.transform(ekets); L = liouvillian(Heb, c_ops=[c_op.transform(ekets) for c_op in c_ops]); ; # dissipative part:; rows = []; cols = []; data = []; for I, a, b in Iabs:; # only check use_secular once per I; if use_secular:; # only loop over those indices J which actually contribute; Jcds = Iabs[np.where(np.abs(W[a, b] - W[Iabs[:,1], Iabs[:,2]]) < dw_min * sec_cutoff)]; else:; Jcds = Iabs; for J, c, d in Jcds:; elem = 0+0j; # summed over k, i.e., each operator coupling the system to the environment; elem += 0.5 * np.sum(A[:, a, c] * A[:, d, b] * (Jw[:, c, a] + Jw[:, d, b])); if b==d:; # sum_{k,n} A[k, a, n] * A[k, n, c] * Jw[k, c, n]); elem -= 0.5 * np.sum(A[:, a, :] * A[:, :, c] * Jw[:, c, :]); if a==c:; # sum_{k,n} A[k, d, n] * A[k, n, b] * Jw[k, d, n]); elem -= 0.5 * np.sum(A[:, d, :] * A[:, :, b] * Jw[:, d, :]); if elem != 0:; rows.append(I); cols.append(J); data.append(elem). R = arr_coo2fast(np.array(data, dtype=complex),; np.array(rows, dtype=np.int32),; np.array(cols, dtype=np.int32), N**2, N**2); ; L.data = L.data + R; ; return L, ekets. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None, ; progress_bar=None,_safe_mode=True):; ; if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]; ; H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:14235,coupling,coupling,14235,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability," documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation wil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:84357,config,config,84357,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['config']
Modifiability," dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38648,config,config,38648,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=<qutip.solver.Options object at 0x2b225f643f98>, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b225f643fd0>, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:54537,evolve,evolved,54537,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['evolve'],['evolved']
Modifiability," energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:74794,variab,variables,74794,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability," entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns; -------; results : Result; Object storing all results from simulation. """"""; if ntraj is None:; ntraj = options.ntraj. if psi0.type != 'ket':; raise Exception(""Initial state must be a state vector.""); config.options = options; # set num_cpus to the value given in qutip.settings; # if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full(); else:; config.psi0 = psi0.full(); config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape; # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; raise Exception(""ntraj as list argument is not supported.""); else:; config.ntraj = ntraj; # ntraj_list = [ntraj]; # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. if not options.rhs_reuse:; config.soft_reset(); # no time dependence; config.tflag = 0; # check for collapse operators; if len(c_ops) > 0:; config.cflag = 1; else:; config.cflag = 0; # Configure data; _mc_data_config(H, psi0, [], c_ops, [], [], e_ops, options, config). # Load Monte Carlo class; mc = _MC_class(); # Set solver type; if (options.method == 'adams'):; mc.mf = 10; elif (options.method == 'bdf'):; mc.mf = 22; else:; if debug:; print('Unrecognized method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:6372,config,config,6372,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:12433,flexible,flexible,12433,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['flexible'],['flexible']
Modifiability," errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:14716,flexible,flexible,14716,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['flexible'],['flexible']
Modifiability," exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29274,config,config,29274,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:69654,evolve,evolves,69654,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['evolve'],['evolves']
Modifiability," exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:40647,evolve,evolves,40647,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['evolve'],['evolves']
Modifiability," exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Matsubara terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class DrudeLorentzPadeBath(Q, lam, gamma, T, Nk, combine=True, tag=None",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:54687,coupling,coupling,54687,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:92822,variab,variables,92822,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['variab'],['variables']
Modifiability," fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/bloch_redfield.html:17825,config,config,17825,docs/4.5/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability," fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TI",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23542,config,config,23542,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,8,['config'],['config']
Modifiability," fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:222115,config,configuration,222115,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['config'],['configuration']
Modifiability," float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29642,config,config,29642,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:207758,Config,Config,207758,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['Config'],['Config']
Modifiability," for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_ind",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34020,config,config,34020,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33011,config,config,33011,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:13846,extend,extended,13846,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,1,['extend'],['extended']
Modifiability," for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(ins",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11543,config,config,11543,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:12549,config,config,12549,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0x2b225f631c18>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_binsintNumber of time bins; the range over which each index can vary. Returns. temporal_basis_vector:class: qutip.QobjA basis vector representing photon ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:111775,config,config,111775,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['config'],['config']
Modifiability," for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/history.html:2714,rewrite,rewrite,2714,docs/4.7/guide/heom/history.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html,2,['rewrite'],['rewrite']
Modifiability," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like. optional list of precomputed tensors \(T_k\). kwargs : dictionary. Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output: qutip.solver.Result. An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:142305,variab,variables,142305,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['variab'],['variables']
Modifiability," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:210507,variab,variables,210507,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['variab'],['variables']
Modifiability," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details). tslot_paramsdictParameters for the Tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:220884,variab,variable,220884,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['variab'],['variable']
Modifiability," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works.; (See TimeslotComputer classes for; details). tslot_paramsdictParameters for the Ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:232997,variab,variable,232997,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['variab'],['variable']
Modifiability," from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.superoperator import liouvillian; from qutip.interpolate import Cubic_Spline; from qutip.cy.spconvert import arr_coo2fast; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:3634,coupling,coupling,3634,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,3,['coupling'],['coupling']
Modifiability," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.12s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.20s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.28s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.36s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.44s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.52s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.60s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.68s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:16854,variab,variables,16854,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.13s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.22s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.31s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.40s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.49s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.58s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.67s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.86s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:16688,variab,variables,16688,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.24s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.44s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.62s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.80s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.00s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.23s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.42s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.62s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16785,variab,variables,16785,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['variab'],['variables']
Modifiability," gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12227,config,config,12227,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHSt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22709,config,config,22709,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," groups:; exp1 = combine[0]; if (exp1.type != exp1.types.RI) and all(; exp2.type == exp1.type for exp2 in combine; ):; # the group is either type I or R; ck = sum(exp.ck for exp in combine); new_exponents.append(BathExponent(; exp1.type, None, exp1.Q, ck, exp1.vk, tag=exp1.tag,; )); else:; # the group includes both type I and R exponents; ck_R = (; sum(exp.ck for exp in combine if exp.type == exp.types.R) +; sum(exp.ck for exp in combine if exp.type == exp.types.RI); ); ck_I = (; sum(exp.ck for exp in combine if exp.type == exp.types.I) +; sum(exp.ck2 for exp in combine if exp.type == exp.types.RI); ); new_exponents.append(BathExponent(; ""RI"", None, exp1.Q, ck_R, exp1.vk, ck2=ck_I,; tag=exp1.tag,; )). return new_exponents. [docs]class DrudeLorentzBath(BosonicBath):; """"""; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). self._dl_terminator = _DrudeLorentzTerminator(; Q=Q, lam=lam, gamma=gamma, T=T,; ). [docs] def terminator(self):; """"""; Return the Matsubara terminator for the bath and the calculated;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:9327,Coupling,Coupling,9327,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['Coupling'],['Coupling']
Modifiability," have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:5406,config,configuration,5406,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['config'],['configuration']
Modifiability," i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37801,config,config,37801,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34183,config,config,34183,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.arr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33174,config,config,33174,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup cons",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37576,config,config,37576,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13127,config,config,13127,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability," import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:3740,coupling,coupling,3740,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,2,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability," import _td_format_check, _td_wrap_array_str; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None,; progress_bar=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (*callback format*). Alternatively, `H` and `c_ops` can be a specified in a nested-list format; where each ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:5061,evolve,evolved,5061,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['evolve'],['evolved']
Modifiability," in DrudeLorentzBath. temperaturefloatBath temperature. Referred to as T in DrudeLorentzBath. N_cutintThe maximum depth of the hierarchy. See max_depth in; HEOMSolver for a full description. N_expintNumber of exponential terms used to approximate the bath correlation; functions. The equivalent Nk in DrudeLorentzBath is one; less than N_exp (see note above). cut_freqfloatBath spectral density cutoff frequency. Referred to as gamma in; DrudeLorentzBath. bnd_cut_approxboolUse boundary cut off approximation. If true, the Matsubara; terminator is added to the system Liouvillian (and H_sys is; promoted to a Liouvillian if it was a Hamiltonian). optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_barNone, True or BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the solver. If True, an instance of; TextProgressBar is used instead. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. class BathExponent(type, dim, Q, ck, vk, ck2=None, sigma_bar_k_offset=None, tag=None)[source]¶; Represents a single exponent (naively, an excitation mode) within the; decomposition of the correlation functions of a bath. Parameters. type{“R”, “I”, “RI”, “+”, “-“} or BathExponent.ExponentTypeThe type of bath exponent.; “R” and “I” are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion.; “RI” is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single vk. The ck is the coefficient in the real; expansion and ck2 is the coefficient in the imaginary expansion.; “+” and “-” are fermionic bath exponents. These fermionic bath; exponents must specify sigma_bar_k_offset which specifies; the amount to add to k (the exponent index within the bath of this; exponent) to determ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:49391,coupling,coupling,49391,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:195926,config,config,195926,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['config'],['config']
Modifiability," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local min",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:76164,config,config,76164,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['config']
Modifiability," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. max_metric_corr¶; integer – The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:68281,config,config,68281,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['config']
Modifiability," in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15331,config,config,15331,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16323,config,config,16323,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of cor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:91524,variab,variables,91524,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['variab'],['variables']
Modifiability," in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23695,config,config,23695,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,10,['config'],['config']
Modifiability," in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:76022,variab,variables,76022,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability," is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); tlist = np.asarray(tlist); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:34731,evolve,evolve,34731,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,2,['evolve'],['evolve']
Modifiability," is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:34359,variab,variable,34359,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['variab'],['variable']
Modifiability," k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and the imaginary part, \(C_{imag}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; And now the same numbers calculated in Python:; # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:; from qutip.nonmarkov.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we’re done!; The BosonicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths¶; The HEOMSolver supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath.; In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the Fenna–Matthews–Olson (FMO); pigment-protein complex which plays an important role in photosynthesis (; for a full FMO example see the note",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:10028,extend,extend,10028,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,2,['extend'],['extend']
Modifiability," last element of `coeff` has no effect. -""cubic"": Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The `QobjEvo` representation of the evolution element.; """"""; try:; return self._get_qobjevo_helper(spline_kind, dims=dims); except Exception as err:; print(; ""The Evolution element went wrong was\n {}"".format(str(self))); raise(err). def __str__(self):; return str({""qobj"": self.qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:4172,variab,variables,4172,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,5,['variab'],['variables']
Modifiability," left: 00:00:00:07; 90.0%. Run time: 33.20s. Est. time left: 00:00:00:03; 100.0%. Run time: 36.90s. Est. time left: 00:00:00:00; Total run time: 37.02s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [30]: kappa = 0.5. In [31]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [32]: N = 10 # number of basis states. In [33]: a = destroy(N). In [34]: H = a.dag() * a # simple HO. In [35]: psi0 = basis(N, 9) # initial state. In [36]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [37]: times = np.linspace(0, 10, 100). In [38]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [39]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [40]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:10128,variab,variable,10128,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,2,['variab'],"['variable', 'variables']"
Modifiability," len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32480,config,config,32480,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters:; N (int) – Square root of the dimension of the superoperator to be returned.; enforce_tp (bool) – If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced.; rank (int or None) – Rank of the sampled superoperator. If None, a full-rank; superoperator is generated.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:rho – A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Return type:Qobj. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states – array of three level atom basis vectors. Return type:array. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops – array of three level operators. Return type:array. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:36755,config,configuration,36755,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['config'],['configuration']
Modifiability," likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:8150,variab,variables,8150,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['variab'],['variables']
Modifiability," list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=comple",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:17472,extend,extends,17472,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,9,['extend'],['extends']
Modifiability," list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:32836,config,config,32836,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:6948,config,config,6948,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability," map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7689,config,config,7689,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability," matrices A & B. Parameters:; A (qobj) – Density matrix or state vector.; B (qobj) – Density matrix or state vector with same dimensions as A. Returns:dist – Hilbert-Schmidt distance between density matrices. Return type:float. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters:; A (Qobj) – Quantum object representing a superoperator.; target (Qobj) – Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns:fid – Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. Return type:float. process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. Continous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:; basis (list) – List of operators that defines the basis for the correlation matrix.; rho (Qobj) – Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:corr_mat – A 2-dimensional array of correlation values or operators. Return type:ndarray. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:50331,variab,variable,50331,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variable']
Modifiability," minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm; Attributes. max_metric_corr; (integer) The maximum number of variable metric corrections used to define the limited memory matrix. That is the number of previous gradient values that are used to approximate the Hessian see the scipy.optimize.fmin_l_bfgs_b documentation for description of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:65889,config,configuration,65889,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['config'],['configuration']
Modifiability," named ‘filename.qu’ in current directory. Parameters:; name : str; Name of data file to be loaded. Returns:; qobject : instance / array_like; Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data : instance/array_like; Input Python object to be stored. filename : str; Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func : function_type; A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:; result : list; A list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:; task : a Python function; The function that is to be called for each value in task_vec. values : array / list; The list o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:210042,variab,variables,210042,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variables']
Modifiability," object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:43356,config,configurations,43356,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['config'],['configurations']
Modifiability," of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/history.html:1787,flexible,flexible,1787,docs/4.7/guide/heom/history.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html,2,['flexible'],['flexible']
Modifiability," of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]¶; Check configuration and initialise the normalisation. init_normalization(self)[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]¶. normalize_SU(self, A)[source]¶. normalize_gradient_PSU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[sourc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:110459,config,configuration,110459,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configuration']
Modifiability," of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:3202,Extend,Extending,3202,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,1,['Extend'],['Extending']
Modifiability," of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of; qutip.parallel.parallel_map. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of va",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:262606,variab,variables,262606,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['variab'],['variables']
Modifiability," operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27884,config,config,27884,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:13450,layers,layers,13450,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,4,['layers'],['layers']
Modifiability," optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:79888,config,configuration,79888,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['config'],['configuration']
Modifiability," or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of qutip.parallel_map. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:250415,variab,variables,250415,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['variab'],['variables']
Modifiability," otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/correlation.html:37395,config,config,37395,docs/4.4/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/correlation.html,1,['config'],['config']
Modifiability," otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary; def _transform_shift_one_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:37448,config,config,37448,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,1,['config'],['config']
Modifiability," otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary; def _transform_shift_one_c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:38024,config,config,38024,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,2,['config'],['config']
Modifiability," parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:8526,config,config,8526,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,2,['config'],['config']
Modifiability," params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:82232,variab,variable,82232,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['variab'],['variable']
Modifiability," period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floque",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:71302,variab,variables,71302,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['variab'],['variables']
Modifiability," phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:7191,variab,variable,7191,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,8,['variab'],['variable']
Modifiability," possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:8165,config,config,8165,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," precision, for ranks less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters:N : int. Square root of the dimension of the superoperator to be returned. enforce_tp : bool. If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rank : int or None. Rank of the sampled superoperator. If None, a full-rank; superoperator is generated. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:rho : Qobj. A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:35441,config,configuration,35441,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['config'],['configuration']
Modifiability," problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12491,config,config,12491,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability," psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:15588,variab,variables,15588,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,4,['variab'],['variables']
Modifiability," qutip.bloch_redfield.bloch_redfield_tensor also returns a list of eigenkets ekets, since they are calculated in the process of calculating the Bloch-Redfield tensor R, and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; >>> tlist = linspace(0, 15.0, 1000); >>> psi0 = rand_ket(2); >>> e_ops = [sigmax(), sigmay(), sigmaz()]; >>> expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops); >>>; >>> sphere = Bloch(); >>> sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]); >>> sphere.vector_color = ['r']; >>> # Hamiltonian axis; >>> sphere.add_vectors(array([delta, 0, eps0]) / sqrt(delta ** 2 + eps0 ** 2)); >>> sphere.make_sphere(); >>> show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; >>> output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.Odedata. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html:13249,evolve,evolve,13249,docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,1,['evolve'],['evolve']
Modifiability," qutip.bloch_redfield.bloch_redfield_tensor also returns a list of eigenkets ekets, since they are calculated in the process of calculating the Bloch-Redfield tensor R, and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; >>> tlist = linspace(0, 15.0, 1000); >>> psi0 = rand_ket(2); >>> e_ops = [sigmax(), sigmay(), sigmaz()]; >>> expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops); >>>; >>> sphere = Bloch(); >>> sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]); >>> sphere.vector_color = ['r']; >>> # Hamiltonian axis; >>> sphere.add_vectors(array([delta, 0, eps0]) / sqrt(delta ** 2 + eps0 ** 2)); >>> sphere.make_sphere(); >>> show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; >>> output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.Odedata. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:13187,evolve,evolve,13187,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,1,['evolve'],['evolve']
Modifiability," raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrod",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:29677,config,config,29677,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,4,['config'],['config']
Modifiability," reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.02s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.02s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.03s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.03s. Est. time left: 00:00:00:00; Total run time: 25.10s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-parfor.html:6193,config,configurations,6193,docs/4.5/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-parfor.html,1,['config'],['configurations']
Modifiability," seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:14302,config,config,14302,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, ke",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11282,config,config,11282,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['config'],['config']
Modifiability," simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:77221,evolve,evolved,77221,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['evolve'],['evolved']
Modifiability," since they are calculated in the process of calculating the Bloch-Redfield tensor R, and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; In [6]: import matplotlib.pyplot as plt. In [7]: tlist = np.linspace(0, 15.0, 1000). In [8]: psi0 = rand_ket(2). In [9]: e_ops = [sigmax(), sigmay(), sigmaz()]. In [10]: expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). In [11]: sphere = Bloch(). In [12]: sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). In [13]: sphere.vector_color = ['r']. In [14]: sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). In [15]: sphere.make_sphere(). In [16]: plt.show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; In [17]: output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.solver.Result. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html:13408,evolve,evolve,13408,docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,1,['evolve'],['evolve']
Modifiability," solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12220,config,config,12220,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots();",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:18595,config,config,18595,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,4,['config'],['config']
Modifiability," spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17136,config,config,17136,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16088,config,config,16088,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:17080,config,config,17080,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H.; Tsteps (integer) – The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output – An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Return type:qutip.solver.Result. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initial density matrix or state vect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:75449,variab,variables,75449,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['variab'],['variables']
Modifiability," store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:39880,config,config,39880,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,10,['config'],['config']
Modifiability," temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:100157,variab,variables,100157,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['variab'],['variables']
Modifiability," terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:53960,coupling,coupling,53960,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36545,config,config,36545,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35543,config,config,35543,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," the default Python version, if you want to use Python 3 with MS Windows, then it must be python=3.4); recommended:; conda create -n qutip python=3 mkl numpy scipy cython matplotlib nose multiprocess jupyter notebook spyder. minimum (recommended):; conda create -n qutip numpy scipy cython nose matplotlib. absolute mimimum:; conda create -n qutip numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks).; Spyder is an IDE for scientific development with Python. Adding the conda-forge channel¶; If you have conda 4.1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development versi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:4377,config,config,4377,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['config'],['config']
Modifiability," the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. f_coeff : array. The coefficients for Floquet decomposition of the initial wavefunction. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:73313,variab,variables,73313,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['variab'],['variables']
Modifiability," the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.av",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:6734,config,config,6734,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability," the spinchain model and save them in the; attribute `ctrls`. Parameters; ----------; N: int; The number of qubits in the system.; """"""; self.pulse_dict = {}; index = 0; # sx_ops; for m in range(N):; self.pulses.append(; Pulse(sigmax(), m, spline_kind=self.spline_kind)); self.pulse_dict[""sx"" + str(m)] = index; index += 1; # sz_ops; for m in range(N):; self.pulses.append(; Pulse(sigmaz(), m, spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # sxsy_ops; operator = tensor([sigmax(), sigmax()]) + tensor([sigmay(), sigmay()]); for n in range(N - 1):; self.pulses.append(; Pulse(operator, [n, n+1], spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(self, sx, sz):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", and ""sxsy"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""sxsy"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; sx: float or list; The coefficient of sigmax in the model. sz: flaot or list; The coefficient of sigmaz in the model. Notes; -----; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(sx, self.N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(sz, self.N); self._params[""sz""] = sz_para. @property; def sx_ops(self):; return self.ctrls[: self.N]. @property; def sz_ops(self):; return self.ctrls[self.N: 2*self.N]. @property; def sxsy_ops(self):; return self.ctrls[2*self.N:]. @property; def sx_u(self):; return self.coeffs[: self.N]. @property; def sz_u(self):; return self.coeffs[self.N: 2*self.N]. @property; def sxsy_u(self):; return self.coeffs[2*self.N:]. [docs] def load_circuit(; self, qc, setup, schedule_mode=""ASAP"", compiler=None):; """"""; Decompose a :class:`.QubitCircuit` in to the control; amplitu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:5764,coupling,coupling,5764,docs/4.6/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html,4,['coupling'],['coupling']
Modifiability," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:17370,config,configuration,17370,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,4,['config'],"['configuration', 'configure']"
Modifiability," the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11447,config,config,11447,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability," the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:9185,variab,variable,9185,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['variab'],['variable']
Modifiability," the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:75423,variab,variables,75423,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability," time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3573,variab,variables,3573,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,8,['variab'],['variables']
Modifiability," time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('fro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29255,config,config,29255,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability," to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:73438,coupling,coupling,73438,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability," to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import quti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:3862,variab,variables,3862,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['variab'],['variables']
Modifiability," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:222174,config,configuration,222174,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['config'],['configuration']
Modifiability," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:102888,config,configuration,102888,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['configuration']
Modifiability," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:94580,config,configuration,94580,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability," used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed cohere",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:27250,coupling,coupling,27250,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['coupling'],['coupling']
Modifiability," verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:15325,config,config,15325,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,3,['config'],['config']
Modifiability," w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:8893,config,config,8893,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,8,['config'],['config']
Modifiability," where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32352,config,config,32352,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability," which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters. Hqutip.qobj; System Hamiltonian. a_opslistNested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eket",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:66077,coupling,couplingto,66077,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['coupling'],['couplingto']
Modifiability," while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28633,config,config,28633,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability," y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26625,config,config,26625,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability," – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Return type:qutip.solver. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:56672,evolve,evolved,56672,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['evolve'],['evolved']
Modifiability,""" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:37683,config,config,37683,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,""" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36886,config,config,36886,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"""""""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:13993,config,config,13993,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['config'],['config']
Modifiability,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:7033,config,configuration,7033,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,2,['config'],['configuration']
Modifiability,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:7033,config,configuration,7033,docs/4.2/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html,8,['config'],['configuration']
Modifiability,"""""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12194,config,config,12194,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,""","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:38605,config,config,38605,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:7648,config,configuration,7648,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['config'],['configuration']
Modifiability,"""Number of trajectories for each process: "" +; str(self.ntrajs)). for i in range(self.nprocs):; p = Process(target=self.evolve_serial,; args=((resq, self.ntrajs[i], i, self.seed * (i + 1)),)); p.start(); processes.append(p); cnt = 0. while True:; try:; sols.append(resq.get()); resq.task_done(); cnt += 1; if (cnt >= self.nprocs):; break; except KeyboardInterrupt:; break; except:; pass. resq.join(); for proc in processes:; try:; proc.join(); except KeyboardInterrupt:; if debug:; print(""Cancel thread on keyboard interrupt""); proc.terminate(); proc.join(); resq.close(); return sols. def serial(self):. if debug:; print(inspect.stack()[0][3]). self.nprocs = 1; self.ntrajs = [self.ntraj]; if debug:; print(""Running in serial.""); print(""Number of trajectories: "" + str(self.ntraj)); sol = self.evolve_serial((0, self.ntraj, 0, self.seed)); return [sol]. def run(self):. if debug:; print(inspect.stack()[0][3]). from numpy.random import random_integers; if (config.c_num == 0):; # force one trajectory if no collapse operators; config.ntraj = 1; self.ntraj = 1; # Set unravel_type to 1 to integrate without collapses; self.unravel_type = 1; if (config.e_num == 0):; # If we are returning states, and there are no; # collapse operators, set average_states to False to return; # ket vectors instead of density matrices; config.options.average_states = False; # generate a random seed, useful if e.g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:10691,config,config,10691,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:36071,evolve,evolve,36071,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,3,['evolve'],['evolve']
Modifiability,"# ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operator",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38150,config,config,38150,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"# determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28870,config,config,28870,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"############################################################################. __all__ = ['wigner', 'qfunc', 'QFunc', 'spin_q_function',; 'spin_wigner', 'wigner_transform']. import numpy as np; import warnings; from numpy import (; zeros, array, arange, exp, real, conj, pi, copy, sqrt, meshgrid, cos, sin,; ); import scipy.sparse as sp; import scipy.fftpack as ft; import scipy.linalg as la; import scipy.special; from scipy.special import genlaguerre, binom, sph_harm, factorial. import qutip; from qutip import Qobj, ket2dm, jmat; from qutip.parallel import parfor; from qutip.cy.sparse_utils import _csr_get_diag; from qutip.sparse import eigh. def wigner_transform(psi, j, fullparity, steps, slicearray):; """"""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:2972,variab,variable,2972,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['variab'],"['variable', 'variables']"
Modifiability,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:3033,coupling,coupling,3033,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,8,['coupling'],['coupling']
Modifiability,"#########. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, random_integers; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.solver import Options, Result, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:4201,variab,variables,4201,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['variab'],['variables']
Modifiability,"& at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34246,config,config,34246,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30456,config,config,30456,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"'); Out[12]: <matplotlib.text.Text at 0x10d263f90>. In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from qutip import *; import pylab as plt. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = correlation_ss(H, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-correlation.html:6587,coupling,coupling,6587,docs/3.1.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html,1,['coupling'],['coupling']
Modifiability,"', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30495,config,config,30495,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"', 'atan2', 'atanh', 'ceil'; , 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1'; , 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma'; , 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p'; , 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']. Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; >>> H = [H0, [H1, '9 * exp(-(t / 5.) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)':; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e or pi will mess things up when using the string-based format. Collapse operators are handled in the exact same way. Function Based Hamiltonian¶; In the previous version of QuTiP, the simulation of time-dependent problems required writing the Hamiltonian itself as a Python function. However, this method does not allow for time-dependent collapse operators, and is therefore more restrictive. Furthermore, it is less efficient than the other methods for all but the most basic of Hamiltonians (see the next section for a comparison of times.). In this format, the entire Hamiltonian is written as a Python function:; def Hfunc(t, args):; H0 = args[0]; H1 = args[1]; w = 9 * exp(-(t/5.)**2); return H0 - w * H1. where the args variable must always be given, and is now a list of Hamiltonian terms: args=[H0, H1]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:12879,variab,variable,12879,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,4,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30333,config,config,30333,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"', 'lgamma', 'log', 'log10', 'log1p'; , 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']. Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; >>> H = [H0, [H1, '9 * exp(-(t / 5.) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)':; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e or pi will mess things up when using the string-based format. Collapse operators are handled in the exact same way. Function Based Hamiltonian¶; In the previous version of QuTiP, the simulation of time-dependent problems required writing the Hamiltonian itself as a Python function. However, this method does not allow for time-dependent collapse operators, and is therefore more restrictive. Furthermore, it is less efficient than the other methods for all but the most basic of Hamiltonians (see the next section for a comparison of times.). In this format, the entire Hamiltonian is written as a Python function:; def Hfunc(t, args):; H0 = args[0]; H1 = args[1]; w = 9 * exp(-(t/5.)**2); return H0 - w * H1. where the args variable must always be given, and is now a list of Hamiltonian terms: args=[H0, H1]. In this format, our call to the master equation is now:; >>> output = mesolve(Hfunc, psi0, times, c_ops, [a.dag() * a], args=[H0, H1]). We cannot evaluate time-dependent collapse operators in this f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:13160,variab,variables,13160,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['variab'],['variables']
Modifiability,"("":cell(i+1) >""); llt = ''.join(llt); T_inter_cell_s[ir][jr] = llt. H_cell = np.zeros(np.shape(H_cell_s), dtype=complex); T_inter_cell = np.zeros(np.shape(T_inter_cell_s), dtype=complex); return (H_cell_s, T_inter_cell_s, H_cell, T_inter_cell). [docs]class Lattice1d():; """"""A class for representing a 1d crystal. The Lattice1d class can be defined with any specific unit cells and a; specified number of unit cells in the crystal. It can return dispersion; relationship, position operators, Hamiltonian in the position represention; etc. Parameters; ----------; num_cell : int; The number of cells in the crystal.; boundary : str; Specification of the type of boundary the crystal is defined with.; cell_num_site : int; The number of sites in the unit cell.; cell_site_dof : list of int/ int; The tensor structure of the degrees of freedom at each site of a unit; cell.; Hamiltonian_of_cell : qutip.Qobj; The Hamiltonian of the unit cell.; inter_hop : qutip.Qobj / list of Qobj; The coupling between the unit cell at i and at (i+unit vector). Attributes; ----------; num_cell : int; The number of unit cells in the crystal.; cell_num_site : int; The nuber of sites in a unit cell.; length_for_site : int; The length of the dimension per site of a unit cell.; cell_tensor_config : list of int; The tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]; lattice_tensor_config : list of int; The tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]; length_of_unit_cell : int; The length of the dimension for a unit cell.; period_bnd_cond_x : int; 1 indicates ""periodic"" and 0 indicates ""hardwall"" boundary condition; inter_vec_list : list of list; The list of list of coefficients of inter unitcell vectors' components; along Cartesian uit vectors.; lattice_vectors_list : list of list; The list of list of coefficients of lattice basis vectors' components; along Cartesian unit vectors.; H_intra : qutip.Qobj; The Qobj storing the Hamilton",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/lattice.html:7923,coupling,coupling,7923,docs/4.5/modules/qutip/lattice.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/lattice.html,5,['coupling'],['coupling']
Modifiability,"((sol.entropy,; np.array(sols[j].entropy))); if (config.options.average_states or config.options.average_expect):; if (config.e_num == 0):; sol.states = sol.states / len(sols); else:; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _comple",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18792,config,config,18792,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html:13197,enhance,enhanced,13197,docs/3.0.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html,1,['enhance'],['enhanced']
Modifiability,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:13135,enhance,enhanced,13135,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,1,['enhance'],['enhanced']
Modifiability,"(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) +",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17055,coupling,coupling,17055,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,2,['coupling'],['coupling']
Modifiability,"(; Q=Q, lam=lam, gamma=gamma, T=T,; ). [docs] def terminator(self):; """"""; Return the Matsubara terminator for the bath and the calculated; approximation discrepancy. Returns; -------; delta: float. The approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the ``Nk`` exponential terms is approximately ``2 * delta *; dirac(t)``, where ``dirac(t)`` denotes the Dirac delta function. terminator : Qobj. The Matsubara terminator -- i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond ``Nk``. It should be used by adding it to; the system liouvillian (i.e. ``liouvillian(H_sys)``).; """"""; delta, L = self._dl_terminator.terminator(self.exponents); return delta, L. def _matsubara_params(self, lam, gamma, T, Nk):; """""" Calculate the Matsubara coefficents and frequencies. """"""; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class DrudeLorentzPadeBath(BosonicBath):; """"""; A helper class for constructing a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`DrudeLorentzBath` wh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:11173,extend,extend,11173,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['extend'],['extend']
Modifiability,"(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_results, expt_callback, options, n_expt_op = _e_ops_outputs(; krylov_results, e_ops, n_tlist_steps, options; ). # parameters for the lazy iteration evolve tlist; psi_norm = np.linalg.norm(_psi); last_t = t0. for idx, partition in enumerate(partitions):. evolved_states = _evolve_krylov_tlist(; H=_H,; psi0=_psi,; krylov_dim=dim_m,; tlist=partition,; t0=last_t,; psi_norm=psi_norm,; krylov_basis=krylov_basis,; T_m=T_m,; sparse=sparse,; ). if idx == 0:; krylov_basis = None; T_m = None; t_idx = 0. _psi = evolved_states[-1]; psi_norm = np.linalg.norm(_psi); last_t = partition[-1]. # apply qobj to each evolved state, remove repeated tail elements; qobj_evolved_states = [; Qobj(state, dims=psi0.dims) for state in evolved_states[1:-1]; ]. krylov_results = _expectation_values(; e_ops,; n_expt_op,; expt_callback,; krylov_results,; qobj_evolved_states,; partitions,; idx,; t_idx,; options,; ). t_idx += len(partition[1:-1]). pbar.update(idx). pbar.finished(). if e_ops_dict:; krylov_results.expect = {; e: krylov_results.expect[n]; for n, e in enumerate(e_ops_dict.keys()); }. return krylov_results. def _expectation_values(; e_ops,; n_expt_op,; expt_callback,; res,; evolved_states,; partitions,; idx,; t_idx,; options,; ):. if options.store_states:; res.states += evolved_states. for t, state in zip(; range(t_idx, t_idx + len(partitions[idx][1:-1])), evolved_states; ):. if expt_callback:; # use callback method; res.expect.append(e_ops(t, state)). for m in range(n_expt_op):; op = e_ops[m]; if not isinstance(op, Qobj) and callable(op):; res.expect[m][t] = op(t, state); continue. res.expect[m][t] = expect(op, state). if (; idx == len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:5963,evolve,evolved,5963,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,['evolve'],['evolved']
Modifiability,"(H, rho0, c_ops, e_ops, args); ; ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check whether c_ops or e_ops is is a single operator; # if so convert it to a list containing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:9645,config,config,9645,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:35596,config,config,35596,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,3,['config'],['config']
Modifiability,"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2841,config,config,2841,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['config'],['config']
Modifiability,"(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:20013,config,config,20013,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38617,config,config,38617,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36919,config,config,36919,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35917,config,config,35917,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29808,config,config,29808,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9841,config,config,9841,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"(config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_z",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:24007,config,config,24007,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"(e2); groups.append(group). new_exponents = []; for combine in groups:; exp1 = combine[0]; if (exp1.type != exp1.types.RI) and all(; exp2.type == exp1.type for exp2 in combine; ):; # the group is either type I or R; ck = sum(exp.ck for exp in combine); new_exponents.append(BathExponent(; exp1.type, None, exp1.Q, ck, exp1.vk, tag=exp1.tag,; )); else:; # the group includes both type I and R exponents; ck_R = (; sum(exp.ck for exp in combine if exp.type == exp.types.R) +; sum(exp.ck for exp in combine if exp.type == exp.types.RI); ); ck_I = (; sum(exp.ck for exp in combine if exp.type == exp.types.I) +; sum(exp.ck2 for exp in combine if exp.type == exp.types.RI); ); new_exponents.append(BathExponent(; ""RI"", None, exp1.Q, ck_R, exp1.vk, ck2=ck_I,; tag=exp1.tag,; )). return new_exponents. [docs]class DrudeLorentzBath(BosonicBath):; """"""; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). self._dl_terminator = _DrudeLorentzTerminator(; Q=Q, lam=lam, gamma=gamma, T=T,; ). [docs] def terminator(self):; """"""; Re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:9280,coupling,coupling,9280,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['coupling'],['coupling']
Modifiability,"(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zer",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15946,config,config,15946,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zer",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16938,config,config,16938,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:33095,config,config,33095,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"(out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:30193,config,config,30193,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:7976,coupling,coupling,7976,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['coupling'],['coupling']
Modifiability,") != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:34871,variab,variable,34871,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['variab'],['variable']
Modifiability,") * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). (png, hires.png, pdf). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 and later, P.D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17636,coupling,coupling,17636,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,2,['coupling'],['coupling']
Modifiability,") * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.dat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31858,config,config,31858,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,") ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15240,config,config,15240,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,") ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16232,config,config,16232,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,") +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup cons",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:38384,config,config,38384,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,") and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat[t_idx, :] += \; 1/(4*options.ntraj[0]) * (c_tau[0] - c_tau[2] -; 1j*c_tau[1] + 1j*c_tau[3]); if t_idx == 1:; options.rhs_reuse = True. return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.tran",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:36776,evolve,evolve,36776,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['evolve'],['evolve']
Modifiability,"))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # ------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:14884,config,config,14884,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15141,config,config,15141,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['config'],['config']
Modifiability,")),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:9537,extend,extend,9537,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,5,['extend'],['extend']
Modifiability,")); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:31564,config,config,31564,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,")); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30544,config,config,30544,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,")); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; self.psi0_shape = None; self.dm_dims = None; self.dm_shape = None; self.unravel_type = 2; self.ptrace_sel = []; self.calc_entropy = False. def parallel(self):; from multiprocessing import Process, Queue, JoinableQueue. if debug:; print(inspect.stack()[0][3]). self.ntrajs = []; for i in range(self.cpus):; self.ntrajs.append(min(int(np.floor(float(self.ntraj); / self.cpus)),; self.ntraj - sum(self.ntrajs))); cnt = sum(self.ntrajs); while cnt < self.ntraj:; for i in range(self.cpus):; self.ntrajs[i] += 1; cnt += 1; if (cnt >= self.ntraj):; break; s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:8355,config,config,8355,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26841,config,config,26841,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:27844,config,config,27844,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeffs (PulseGenCrab attribute). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). col_times (Result attribute). col_which (Result attribute). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). config (Optimizer attribute). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method), [1]. controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method), [1]. coup_op (HEOMSolver attribute). coup_strength (HEOMSolver attribute). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:3599,config,config,3599,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['config'],['config']
Modifiability,"). def _check_coup_op(self, Q):; if not isinstance(Q, Qobj):; raise ValueError(""The coupling operator Q must be a Qobj.""). def __init__(self, Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=None):; self._check_cks_and_vks(ck_plus, vk_plus, ck_minus, vk_minus); self._check_coup_op(Q). exponents = []; for ckp, vkp, ckm, vkm in zip(ck_plus, vk_plus, ck_minus, vk_minus):; exponents.append(BathExponent(; ""+"", 2, Q, ckp, vkp, sigma_bar_k_offset=1, tag=tag,; )); exponents.append(BathExponent(; ""-"", 2, Q, ckm, vkm, sigma_bar_k_offset=-1, tag=tag,; )); super().__init__(exponents). [docs]class LorentzianBath(FermionicBath):; """"""; A helper class for constructing a Lorentzian fermionic bath from the; bath parameters (see parameters below). .. note::. This Matsubara expansion used in this bath converges very slowly; and ``Nk > 20`` may be required to get good convergence. The; Padé expansion used by :class:`LorentzianPadeBath` converges much; more quickly. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(self, Q, gamma, w, mu, T, Nk, tag=None):; ck_plus, vk_plus = self._corr(gamma, w, mu, T, Nk, sigma=1.0); ck_minus, vk_minus = self._corr(gamma, w, mu, T, Nk, sigma=-1.0). super().__init__(; Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=tag,; ). def _corr(self, gamma, w, mu, T, Nk, sigma):; beta = 1. / T; kappa = [0.]; kappa.extend([1. for _ in range(1, Nk + 1)]); epsilon = [0]; epsilon.extend([(2 * ll - 1) * np.pi for ll in range(1, Nk + 1)]). def f(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:21694,coupling,coupling,21694,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['coupling'],['coupling']
Modifiability,"):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:14938,config,config,14938,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wav",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15195,config,config,15195,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['config'],['config']
Modifiability,"); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:7492,config,config,7492,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,6,['config'],['config']
Modifiability,"); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9739,variab,variable,9739,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,4,['variab'],"['variable', 'variables']"
Modifiability,"); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21019,config,config,21019,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class DrudeLorentzPadeBath(BosonicBath):; """"""; A helper class for constructing a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`DrudeLorentzBath` which constructs; a simpler exponential expansion. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of Padé exponentials terms used to approximate the bath; correlation functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, T, Nk, combine=True, tag=None; ):; eta_p, gamma_p = self._corr(lam=lam, gamma=gamma, T=T, Nk=Nk). ck_real = [np.real(eta) for eta in eta_p]; vk_real = [gam for gam in gamma_p]; # There is only one term in the expansion of the imaginary part of the; # Drude-Lorentz correlation function.; ck_imag = [np.imag(eta_p[0])]; vk_imag = [gamma_p[0]].",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:12298,coupling,coupling,12298,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['coupling'],['coupling']
Modifiability,")\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = linspace(0, 100, 5000); corr = correlation_ss(H, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum_ss, which internally uses essolve; # to solve for the dynamics; wlist2 = linspace(0.25, 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-correlation.html:6094,coupling,coupling,6094,docs/3.0.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html,2,['coupling'],['coupling']
Modifiability,"*2 / (4 * Om),; -1.0j * lam**2 / (4 * Om),; ]. vk_imag = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class FermionicBath(Bath):; """"""; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the ``+`` and ``-`` modes of; the bath correlation function. There must be the same number of ``+`` and ``-`` modes and their; coefficients must be specified in the same order so that ``ck_plus[i],; vk_plus[i]`` are the plus coefficient and frequency corresponding; to the minus mode ``ck_minus[i], vk_minus[i]``. In the fermionic case the order in which excitations are created or; destroyed is important, resulting in two different correlation functions; labelled ``C_plus(t)`` and ``C_plus(t)``::. C_plus(t) = sum(ck_plus * exp(- vk_plus * t)); C_minus(t) = sum(ck_minus * exp(- vk_minus * t)). where the expansions above define the coeffiients ``ck`` and the; frequencies ``vk``. Parameters; ----------; Q : Qobj; The coupling operator for the bath. ck_plus : list of complex; The coefficients of the expansion terms for the ``+`` part of the; correlation function. The corresponding frequencies are passed as; vk_plus. vk_plus : list of complex; The frequencies (exponents) of the expansion terms for the ``+`` part; of the correlation function. The corresponding ceofficients are passed; as ck_plus. ck_minus : list of complex; The coefficients of the expansion terms for the ``-`` part of the; correlation function. The corresponding frequencies are passed as; vk_minus. vk_minus : list of complex; The frequencies (exponents) of the expansion terms for the ``-`` part; of the correlation function. The corresponding ceofficients are passed; as ck_minus. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """""". def _check_cks_and_vks(self, ck_plus, vk_plus, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:19210,coupling,coupling,19210,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['coupling'],['coupling']
Modifiability,"+ str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:38035,config,config,38035,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"+ str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-depende",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37074,config,config,37074,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"+; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20664,config,config,20664,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,", 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27423,config,config,27423,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28426,config,config,28426,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,", 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27363,config,config,27363,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28366,config,config,28366,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,", INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Original Code by Arne Grimsmo (2012): github.com/arnelg/qutipf90mc; ###############################################################################. import numpy as np. from qutip.fortran import qutraj_run as qtf90; from qutip.qobj import Qobj; from qutip.mcsolve import _mc_data_config; from qutip.solver import Options, Result, config; from qutip.settings import debug; import qutip.settings. if debug:; import inspect; import os. # Working precision; wpr = np.dtype(np.float64); wpc = np.dtype(np.complex128). [docs]def mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None,; options=Options(), sparse_dms=True, serial=False,; ptrace_sel=[], calc_entropy=False):; """"""; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters; ----------; H : qobj; System Hamiltonian.; psi0 : qobj; Initial state vector; tlist : array_like; Times at which results are recorded.; ntraj : int; Number of trajectories to run.; c_ops : array_like; ``list`` or ``array`` of collapse operators.; e_ops : array_like; ``list`` or ``array`` of operators for calculating expectation values.; options : Options; Instance of solver options.; sparse_dms : boolean; If averaged density matrices are returned, they will be s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:3587,config,config,3587,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,", Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12701,config,config,12701,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,", \(C_{real}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,real} &= \begin{cases}; \gamma & k = 0\\; {2 \pi k} / {\beta } & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and the imaginary part, \(C_{imag}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; And now the same numbers calculated in Python:; # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:; from qutip.nonmarkov.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we’re done!; The BosonicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths¶; The HEOMSolver supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath.; In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the Fe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:9882,extend,extend,9882,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,2,['extend'],['extend']
Modifiability,", c_ops, a_op, b_op,; solver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadysta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:30708,config,config,30708,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,10,['config'],['config']
Modifiability,", config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # ------------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15471,config,config,15471,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # ------------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16463,config,config,16463,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,", config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15219,config,config,15219,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16211,config,config,16211,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,", config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17158,config,config,17158,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,", dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:196087,variab,variable,196087,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['variab'],['variable']
Modifiability,", globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<strin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28301,config,config,28301,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,", or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:73305,coupling,coupling,73305,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['coupling'],['coupling']
Modifiability,", psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:9739,variab,variable,9739,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,4,['variab'],"['variable', 'variables']"
Modifiability,", self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html:30325,variab,variables,30325,docs/4.4/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html,1,['variab'],['variables']
Modifiability,", tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:32071,config,config,32071,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['config'],['config']
Modifiability,", tlist: numpy.array, krylov_dim: int, e_ops=None, options=None, progress_bar: Optional[bool] = None, sparse: bool = False)[source]¶; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (“psi0”) finding an approximation for the time; evolution operator of Hamiltonian (“H”) by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)).; The output is either the state vector or the expectation values of; supplied operators (“e_ops”) at arbitrary points at (“tlist”).; Additional options; Additional options to krylovsolve can be set with the following:. “store_states”: stores states even though expectation values are; requested via the “e_ops” argument.; “store_final_state”: store final state even though expectation values are; requested via the “e_ops” argument. Parameters. Hqutip.QobjSystem Hamiltonian. psi0:class: qutip.QobjInitial state vector (ket). tlistNone / list / arrayList of times on which to evolve the initial state. If None, nothing; happens but the code won’t break. krylov_dim: intDimension of Krylov approximation subspaces used for the time; evolution approximation. e_opsNone / list of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. optionsOptions; Instance of ODE solver options, as well as krylov parameters.; atol: controls (approximately) the error desired for the finalsolution. (Defaults to 1e-8). nsteps: maximum number of krylov’s internal number of Lanczositerations. (Defaults to 10000). progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. sparsebool (default False)Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array result.expect of expectation values for the times; tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:92004,evolve,evolve,92004,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['evolve'],['evolve']
Modifiability,",; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29455,config,config,29455,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,",; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15858,config,config,15858,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,",; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16850,config,config,16850,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,",; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:13933,config,configurability,13933,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['config'],['configurability']
Modifiability,"-----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19789,config,config,19789,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"---------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23244,config,config,23244,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"----------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19975,config,config,19975,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"---------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22258,config,config,22258,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"---------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23379,config,config,23379,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"---------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22393,config,config,22393,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamilton",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14622,config,config,14622,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamilton",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15614,config,config,15614,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"----------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23268,config,config,23268,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14756,config,config,14756,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15748,config,config,15748,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13051,config,config,13051,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.succ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17422,config,config,17422,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"-----------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19804,config,config,19804,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"----------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22282,config,config,22282,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9165,config,config,9165,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"----------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25954,config,config,25954,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"-------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14777,config,config,14777,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15769,config,config,15769,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.ps",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19823,config,config,19823,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"-----------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14644,config,config,14644,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-----------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15636,config,config,15636,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-----------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; sel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12052,config,config,12052,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-----------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:23291,config,config,23291,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"---------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:14356,config,config,14356,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['config'],['config']
Modifiability,"--------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17296,config,config,17296,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"-------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:33976,config,config,33976,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32967,config,config,32967,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-----------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22305,config,config,22305,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"----------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13173,config,config,13173,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32570,config,config,32570,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"---------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38194,config,config,38194,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"---------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12174,config,config,12174,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29653,config,config,29653,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-----------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25976,config,config,25976,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"--------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14665,config,config,14665,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"--------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15657,config,config,15657,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17482,config,config,17482,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:29101,config,config,29101,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['config'],['config']
Modifiability,"---; type : {""R"", ""I"", ""RI"", ""+"", ""-""} or BathExponent.ExponentType; The type of bath exponent. ""R"" and ""I"" are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion. ""RI"" is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single ``vk``. The ``ck`` is the coefficient in the real; expansion and ``ck2`` is the coefficient in the imaginary expansion. ""+"" and ""-"" are fermionic bath exponents. These fermionic bath; exponents must specify ``sigma_bar_k_offset`` which specifies; the amount to add to ``k`` (the exponent index within the bath of this; exponent) to determine the ``k`` of the corresponding exponent with; the opposite sign (i.e. ""-"" or ""+""). dim : int or None; The dimension (i.e. maximum number of excitations for this exponent).; Usually ``2`` for fermionic exponents or ``None`` (i.e. unlimited) for; bosonic exponents. Q : Qobj; The coupling operator for this excitation mode. vk : complex; The frequency of the exponent of the excitation term. ck : complex; The coefficient of the excitation term. ck2 : optional, complex; For exponents of type ""RI"" this is the coefficient of the term in the; imaginary expansion (and ``ck`` is the coefficient in the real; expansion). sigma_bar_k_offset : optional, int; For exponents of type ""+"" this gives the offset (within the list of; exponents within the bath) of the corresponding ""-"" bath exponent.; For exponents of type ""-"" it gives the offset of the corresponding; ""+"" exponent. tag : optional, str, tuple or any other object; A label for the exponent (often the name of the bath). It; defaults to None. Attributes; ----------. All of the parameters are available as attributes.; """"""; types = enum.Enum(""ExponentType"", [""R"", ""I"", ""RI"", ""+"", ""-""]). def _check_ck2(self, type, ck2):; if type == self.types[""RI""]:; if ck2 is None:; raise ValueError(""RI bath exponents require ck2""); else:; if ck2 is not",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:2086,coupling,coupling,2086,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['coupling'],['coupling']
Modifiability,"-. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14815,config,config,14815,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"-. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:15807,config,config,15807,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"-2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args, options=copy(options)). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None,; options=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:4130,variab,variables,4130,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['variab'],['variables']
Modifiability,"-; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():; As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; In [3]: options = Options(). In [4]: options.num_cpus = 3. In [5]: options.atol = 1e-10. or one can use an inline method,; In [6]: options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [7]: print(options); Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-options.html:2599,variab,variable,2599,docs/4.5/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-options.html,1,['variab'],['variable']
Modifiability,"-; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():; As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; In [3]: options = Options(). In [4]: options.num_cpus = 3. In [5]: options.atol = 1e-10. or one can use an inline method,; In [6]: options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [7]: print(options); Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-options.html:2574,variab,variable,2574,docs/4.4/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-options.html,1,['variab'],['variable']
Modifiability,"-Based Time-Dependent Problems using Parfor. Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:1682,coupling,coupling,1682,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,2,['coupling'],['coupling']
Modifiability,"-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:16222,coupling,coupling,16222,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['coupling'],['coupling']
Modifiability,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-control.html:13564,variab,variable,13564,docs/4.3/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html,1,['variab'],['variable']
Modifiability,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-control.html:13562,variab,variable,13562,docs/4.4/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-control.html,4,['variab'],['variable']
Modifiability,". . qutip.qip.pulse — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; from copy import deepcopy. import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`qutip.qip.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = QobjEvo(ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:719,variab,variables,719,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,1,['variab'],['variables']
Modifiability,". Functions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)I",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:572,Variab,Variables,572,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['Variab'],['Variables']
Modifiability,". Functions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Krylov Subspace Solver; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:572,Variab,Variables,572,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['Variab'],['Variables']
Modifiability,". H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); self.H = self.dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; including the -i factor; """"""; return -1j*self.dyn_gen[k]. [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; including the -i factor; """"""; return -1j*self.ctrl_dyn_gen[j]. def get_num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); return Dynamics.get_num_ctrls(self). def get_owd_evo_target(self):; return self.target.conj().T. [docs] def spectral_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:24102,config,configuration,24102,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['config'],['configuration']
Modifiability,". Montenegro et al., ""Macroscopic nonclassical-state preparation via postselection"", ; Phys. Rev. A 96, 053851 (2017). 243. Cirio et al., ""Amplified Optomechanical Transduction of Virtual Radiation Pressure"", ; Phys. Rev. Lett. 119, 053601 (2017). 242. Romero et al., ""Quantum autoencoders for efficient compression of quantum data"", ; Quantum Sci. Technol. 2, 045001 (2017). 241. Zhong, ""Controllable and fast quantum-information transfer between distant nodes in two-dimensional networks"", ; Sci. Rep. 6, 8 (2016). 240. Guo et al., ""Giant acoustic atom: A single quantum system with a deterministic time delay"", ; Phys. Rev. A 95, 053821 (2017). 239. Vermersch et al., ""Quantum State Transfer via Noisy Photonic and Phononic Waveguides"", ; Phys. Rev. Lett. 118, 133601 (2017). 238. Gudmundsson et al., ""Time-dependent current into and through multilevel parallel quantum dots in a photon cavity"", ; Phys. Rev. B 95, 195307 (2017). 237. Braumüller et al., ""Analog quantum simulation of the Rabi model in the ultra-strong coupling regime"", ; Nat. Commun. 8, 779 (2017). 236. Lagoudakis et al., ""Ultrafast coherent manipulation of trions in site-controlled nanowire quantum dots"", ; Optica 3, 1430 (2016). 235. Roghani et al., ""Dissipative Preparation of Entangled Many-Body States with Rydberg Atoms"", ; arXiv:1611.09612. 234. Lambert et al., ""Superradiance with an ensemble of superconducting flux qubits"", ; Phys. Rev. B 94, 224510 (2016). 233. Yanay et al., ""Shelving-style QND phonon-number detection in quantum optomechanics"", ; New J. Phys. 19, 033014 (2017). 232. Kirton et al., ""Suppressing and Restoring the Dicke Superradiance Transition by Dephasing and Decay"", ; Phys. Rev. Lett. 118, 123602 (2017). 231. Fischer et al., ""On-Chip Architecture for Self-Homodyned Nonclassical Light"", ; Phys. Rev. Applied 7, 044002 (2017).; Notebook. 230. Combes et al., ""The SLH framework for modeling quantum input-output networks"", ; Advances in Physics: X 2, 784 (2017). 229. Lucarelli, ""Quantum optimal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:17726,coupling,coupling,17726,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,". Plotting on the Bloch Sphere — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before gettin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-bloch.html:560,Config,Configuring,560,docs/4.7/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html,1,['Config'],['Configuring']
Modifiability,". The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossib",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:6817,variab,variables,6817,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,12,['variab'],"['variable', 'variables']"
Modifiability,". Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:7704,enhance,enhancements,7704,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['enhance'],['enhancements']
Modifiability,". amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fideli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:7447,variab,variable,7447,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,2,['variab'],['variable']
Modifiability,". amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string; Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control ampli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:16182,variab,variable,16182,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['variab'],['variable']
Modifiability,". property dumping¶. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:79026,variab,variables,79026,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['variab'],['variables']
Modifiability,". qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestrName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:207747,variab,variables,207747,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['variab'],['variables']
Modifiability,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:722,config,config,722,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,2,['config'],['config']
Modifiability,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:461,variab,variable,461,docs/4.7/modules/qutip/continuous_variables.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html,2,['variab'],['variable']
Modifiability,". qutip.control.fidcomp — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.fidcomp. Source code for qutip.control.fidcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling wi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html:954,config,configuration,954,docs/4.7/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html,2,['config'],['configuration']
Modifiability,". qutip.control.pulseoptim — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:654,config,configuration,654,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['config'],['configuration']
Modifiability,". qutip.control.stats — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.stats. Source code for qutip.control.stats; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/stats.html:827,config,configurations,827,docs/4.7/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/stats.html,2,['config'],['configurations']
Modifiability,". qutip.matplotlib_utilities — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.matplotlib_utilities. Source code for qutip.matplotlib_utilities; """"""; This module contains utility functions that enhance Matplotlib; in one way or another.; """""". __all__ = ['wigner_cmap', 'MidpointNorm', 'complex_phase_cmap']. import numpy as np. try:; import matplotlib as mpl; from matplotlib import cm; from matplotlib.colors import (Normalize, ColorConverter); except:; class Normalize(object):; def __init__(self, vmin=None, vmax=None, clip=False):; pass. [docs]def wigner_cmap(W, levels=1024, shift=0, max_color='#09224F',; mid_color='#FFFFFF', min_color='#530017',; neg_color='#FF97D4', invert=False):; """"""A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters; ----------; W : array; Wigner function array, or any array.; levels : int; Number of color levels to create.; shift : float; Shifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5).; max_color : str; String for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter.; mid_color : str; Color corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter.; min_color : str; Color corresponding to minimum data values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter.; neg_color : str; Color that starts highlighting negative values. Accepts any string; format compatible with the Matplotlib.colors.ColorConverter.; invert : bool; Invert the color scheme for negative values so that smaller negative; values have darker color. Returns; -------; Returns ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html:434,enhance,enhance,434,docs/4.7/modules/qutip/matplotlib_utilities.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html,2,['enhance'],['enhance']
Modifiability,". qutip.qip.pulse — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = QobjEvo(mat, tlist=self.tl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:712,variab,variables,712,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,2,['variab'],['variables']
Modifiability,". qutip.qip.pulse — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/pulse.html:737,variab,variables,737,docs/4.7/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/pulse.html,2,['variab'],['variables']
Modifiability,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:573,config,config,573,docs/4.7/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html,6,['config'],['config']
Modifiability,". qutip.scattering — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.scattering. Source code for qutip.scattering; """"""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/scattering.html:542,config,configuration,542,docs/4.7/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html,2,['config'],['configuration']
Modifiability,". qutip.sesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.sesolve. Source code for qutip.sesolve; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/sesolve.html:928,config,config,928,docs/4.7/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,". qutip.three_level_atom — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.three_level_atom. Source code for qutip.three_level_atom; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html:661,config,configuration,661,docs/4.7/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html,4,['config'],"['configuration', 'configurations']"
Modifiability,".'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:13623,coupling,coupling,13623,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,4,['coupling'],['coupling']
Modifiability,".'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:17083,coupling,coupling,17083,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability,"., ""Influence of the asymmetric excited state decay on coherent population trapping: atom × quantum dot"", ; arXiv:1702.07692. 266. Pleinert et al., ""Hyperradiance from collective behavior of coherently driven atoms"", ; Optica 4, 779 (2017). 265. Oviedo-Casado et al., ""Magnetic field enhancement of organic photovoltaic cells performance"", ; Sci. Rep. 7, 4297 (2017). 264. Whalen et al., ""Open quantum systems with delayed coherent feedback"", ; Quantum Sci. Technol. 2, 044008 (2017). 263. Cottet et al., ""Observing a quantum Maxwell demon at work"", ; Proc. Natl. Acad. Sci. U.S.A. 114, 7561 (2017). 262. Mazloom et al., ""Adiabatic state preparation of stripe phases with strongly magnetic atoms"", ; Phys. Rev. A 96, 033602 (2017). 261. Poonia et al., ""Functional window of the avian compass"", ; Phys. Rev. E 95, 052417 (2017). 260. Su et al., ""Generating double NOON states of photons in circuit QED"", ; Phys. Rev. A 95, 022339 (2017). 259. Kiukas et al., ""Remote parameter estimation in a quantum spin chain enhanced by local control"", ; Phys. Rev. A 95, 052132 (2017). 258. Gely et al., ""Convergence of the multimode quantum Rabi model of circuit quantum electrodynamics"", ; Phys. Rev. B 95, 245115 (2017). 257. Radtke et al., ""Photonic Quantum Operations via the Quantum Carburettor Effect"", ; arXiv:1701.04251. 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 54",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:14722,enhance,enhanced,14722,users.html,https://qutip.org,https://qutip.org/users.html,1,['enhance'],['enhanced']
Modifiability,".PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:35218,variab,variable,35218,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['variab'],['variable']
Modifiability,".Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:5014,config,config,5014,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,".X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:4795,adapt,adaptive,4795,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['adapt'],['adaptive']
Modifiability,"._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:16033,config,config,16033,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,7,['config'],['config']
Modifiability,"._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:14786,config,config,14786,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['config'],['config']
Modifiability,"._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.le",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:16001,config,config,16001,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,"._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28679,config,config,28679,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11269,config,config,11269,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,".append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if iske",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:20099,config,config,20099,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,".append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'); ; ; for kk, c in enumerate(c_ops):; if isinstance(c, Qobj):; C_terms.append(c.full('f')); C_td_terms.append('1'); elif isinstance(c, list):; C_terms.append(c[0].full('f')); if isinstance(c[1], Cubic_Spline):; CA_obj.append(c[1].coeffs); spline_count[0] += 1; C_td_terms.append(c[1]); else:; raise Exception('Invalid collape operator specification.'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:16534,coupling,coupling,16534,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['coupling'],['coupling']
Modifiability,".append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27998,config,config,27998,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; glo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:29001,config,config,29001,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,".array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15775,config,config,15775,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term - np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:16767,config,config,16767,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,".average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:24065,config,config,24065,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,".dims = op.dims; for i in range(1, l):; h = qt.tensor(I, h); for i in range(l+1, k+1):; h = qt.tensor(h, I); return h. def _genptrace(E, k):; """"""; Perform a gneralized partial trace on a superoperator E, tracing out all; subsystems but one.; """"""; for l in range(k-1):; nsys = len(E.dims[0][0]); E = qt.tensor_contract(E, (0, 2*nsys+1), (nsys, 3*nsys+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:11616,coupling,coupling,11616,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,10,['coupling'],['coupling']
Modifiability,".environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number of cores; from qutip.hardware_info import hardware_info; info = hardware_info(); if 'cpus' in info:; qutip.settings.num_cpus = info['cpus']; else:; qutip.settings.num_cpus = multiprocessing.cpu_count(). # -----------------------------------------------------------------------------; # Load configuration from environment variables: override defaults and; # configuration file.; #. # check for fortran mcsolver files; try:; from qutip.fortran import mcsolve_f90; except:; qutip.settings.fortran = False; else:; qutip.settings.fortran = True. # check for scikits.umfpack; try:; import scikits.umfpack as umfpack; except:; qutip.settings.umfpack = False; else:; qutip.settings.umfpack = True; del umfpack; # -----------------------------------------------------------------------------; # Check that import modules are compatible with requested configuration; #. # Check for Matplotlib; try:; import matplotlib; except:; warnings.warn(""matplotlib not found: Graphics will not work.""); else:; del matplotlib. # -----------------------------------------------------------------------------; # Clean name space; #; del os, sys, numpy, scipy, multiprocessing. # -----------------------------------------------------------------------------; # Load modules; #. # core; from qutip.qobj import *; from qutip.states import *; from qutip.operators import *; from qutip.expect import *; from qutip.tensor import *; from qutip.superoperator import *; from qutip.superop_reps import *; from qutip.subsystem_apply import *; from qutip.graph import *. # graphics; from qutip.bloch import *; from qutip.visualization import *; from qutip.orbital import *; from qutip.bloch3d import *; from qutip.matplotlib_utilities import *. # library functions; from qutip.tomography import *; from ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:8116,config,configuration,8116,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['config'],['configuration']
Modifiability,".evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True. def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:20149,config,config,20149,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,6,['config'],['config']
Modifiability,".evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:18812,config,config,18812,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,3,['config'],['config']
Modifiability,".evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:20163,config,config,20163,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,".expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = vec2mat(r.y). if opt.store_states:; output.states.append(Qobj(rho)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = vec2mat(r.y); output.final_state = Qobj(rho). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:26481,config,config,26481,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,".figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-bloch-redfield.html:18379,coupling,coupling,18379,docs/4.4/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-bloch-redfield.html,1,['coupling'],['coupling']
Modifiability,".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_va",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15004,config,config,15004,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,8,['config'],['config']
Modifiability,".g. running with MPI; self.seed = random_integers(1e8); if (self.serial_run):; # run in serial; sols = self.serial(); else:; # run in paralell; sols = self.parallel(); # gather data; self.sol = _gather(sols). def evolve_serial(self, args):. if debug:; print(inspect.stack()[0][3] + "":"" + str(os.getpid())). # run ntraj trajectories for one process via fortran; # get args; queue, ntraj, instanceno, rngseed = args; # initialize the problem in fortran; _init_tlist(); _init_psi0(); if (self.ptrace_sel != []):; _init_ptrace_stuff(self.ptrace_sel); _init_hamilt(); if (config.c_num != 0):; _init_c_ops(); if (config.e_num != 0):; _init_e_ops(); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12062,config,config,12062,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,".get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:68951,config,config,68951,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,1,['config'],['config']
Modifiability,".h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in rang",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34141,config,config,34141,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:3098,variab,variables,3098,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['variab'],['variables']
Modifiability,".map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7748,config,config,7748,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,".method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25021,config,config,25021,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,".parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_leve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:29260,variab,variables,29260,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['variab'],['variables']
Modifiability,".qutraj_run.csr_col - 1; ptr = qtf90.qutraj_run.csr_ptr - 1; m = qtf90.qutraj_run.csr_nrows; k = qtf90.qutraj_run.csr_ncols; states[i] = Qobj(csr_matrix((val, col, ptr),; (m, k)).toarray(),; dims=self.dm_dims, shape=self.dm_shape); else:; # averaged dense density matrices; for i in range(nstep):; states[i] = Qobj(qtf90.qutraj_run.sol[0, i, :, :],; dims=self.dm_dims, shape=self.dm_shape); else:; # all trajectories as kets; if (ntraj == 1):; states = np.array([Qobj()] * nstep, dtype=object); for i in range(nstep):; states[i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, 0, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); else:; states = np.array([np.array([Qobj()] * nstep, dtype=object)] *; ntraj); for traj in range(ntraj):; for i in range(nstep):; states[traj][i] = Qobj(np.matrix(; qtf90.qutraj_run.sol[0, traj, i, :]).transpose(),; dims=self.psi0_dims, shape=self.psi0_shape); return states. def get_expect(self, nstep, ntraj):. if debug:; print(inspect.stack()[0][3]). if (config.options.average_expect):; expect = []; for j in range(config.e_num):; if config.e_ops_isherm[j]:; expect += [np.real(qtf90.qutraj_run.sol[j, 0, :, 0])]; else:; expect += [qtf90.qutraj_run.sol[j, 0, :, 0]]; else:; expect = np.array([[np.array([0. + 0.j] * nstep)] *; config.e_num] * ntraj); for j in range(config.e_num):; expect[:, j, :] = qtf90.qutraj_run.sol[j, :, :, 0]; return expect. def get_entropy(self, nstep):. if debug:; print(inspect.stack()[0][3]). if (not self.calc_entropy):; raise Exception('get_entropy: calc_entropy=False. Aborting.'); entropy = np.array([0.] * nstep); entropy[:] = qtf90.qutraj_run.reduced_state_entropy[:]; return entropy. def finalize():; # not in use... if debug:; print(inspect.stack()[0][3]). qtf90.qutraj_run.finalize_work(); qtf90.qutraj_run.finalize_sol(). def _gather(sols):; # gather list of Result objects, sols, into one.; sol = Result(); # sol = sols[0]; ntraj = sum([a.ntraj for a in sols]); sol.col_times = np.zeros((ntraj), dtype=np.ndarray); s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:15438,config,config,15438,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,".shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.meth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23026,config,config,23026,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19561,config,config,19561,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,".steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23586,config,config,23586,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,".upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13064,config,configuration,13064,docs/4.3/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html,7,['config'],['configuration']
Modifiability,".use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum ev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12446,config,config,12446,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,"/ val for val in evals[0: Nk - 1]]; return chi. class _DrudeLorentzTerminator:; """""" A class for calculating the terminator of a Drude-Lorentz bath; expansion.; """"""; def __init__(self, Q, lam, gamma, T):; self.Q = Q; self.lam = lam; self.gamma = gamma; self.T = T. def terminator(self, exponents):; """""" Calculate the terminator for a Drude-Lorentz bath. """"""; Q = self.Q; lam = self.lam; gamma = self.gamma; beta = 1 / self.T. delta = 2 * lam / (beta * gamma) - 1j * lam. for exp in exponents:; if exp.type == BathExponent.types[""R""]:; delta -= exp.ck / exp.vk; elif exp.type == BathExponent.types[""RI""]:; delta -= (exp.ck + 1j * exp.ck2) / exp.vk; else:; delta -= 1j * exp.ck / exp.vk. op = -2*spre(Q)*spost(Q.dag()) + spre(Q.dag()*Q) + spost(Q.dag()*Q); L_bnd = -delta * op. return delta, L_bnd. [docs]class UnderDampedBath(BosonicBath):; """"""; A helper class for constructing an under-damped bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. w0 : float; Bath spectral density resonance frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, w0, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; w0=w0,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). def _matsubara_params(self, lam, gamma, w0, T, Nk):; """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:16572,coupling,coupling,16572,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['coupling'],['coupling']
Modifiability,"/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 201",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:36066,config,config,36066,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,2,['config'],['config']
Modifiability,"0)\right>$'); Out[12]: Text(0,0.5,'Correlation $\\left<x(t)x(0)\\right>$'). In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; import pylab as plt; from qutip import *. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-correlation.html:5784,coupling,coupling,5784,docs/4.5/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-correlation.html,1,['coupling'],['coupling']
Modifiability,"0, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_ou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18353,config,config,18353,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:1663,enhance,enhancements,1663,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,1,['enhance'],['enhancements']
Modifiability,"0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [14]: psi0 = basis(2,1). In [15]: H = sigmaz(). In [16]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [18]: es; Out[18]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-eseries.html:6440,evolve,evolved,6440,docs/3.1.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html,1,['evolve'],['evolved']
Modifiability,"0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [16]: psi0 = basis(2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [20]: es; Out[20]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-eseries.html:6343,evolve,evolved,6343,docs/3.0.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html,2,['evolve'],['evolved']
Modifiability,"0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if nece",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7813,config,config,7813,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,3,['config'],['config']
Modifiability,"000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13030,config,config,13030,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:2201,coupling,coupling,2201,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['coupling'],['coupling']
Modifiability,"1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.conj().transpose(),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.conj().transpose(). # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.meth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:24029,config,config,24029,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19328,config,config,19328,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"1.0"". elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolutio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12152,config,config,12152,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['config'],['config']
Modifiability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string. Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:173518,variab,variable,173518,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['variab'],['variable']
Modifiability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict. Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string. Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:182149,variab,variable,182149,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['variab'],['variable']
Modifiability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:188319,variab,variable,188319,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variable']
Modifiability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:196954,variab,variable,196954,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['variab'],['variable']
Modifiability,"116, 237203 (2016). 125. Verdon-Akzam et al., ""Asymptotically limitless quantum energy teleportation via qudit probes"", ; Phys. Rev. A 93, 022308 (2016). 124. Overbeck et al., ""Time evolution of open quantum many-body systems"", ; Phys. Rev. A 93, 012106 (2016). 123. Dast et al., ""Purity oscillations in Bose-Einstein condensates with balanced gain and loss"", ; Phys. Rev. A 93, 033617 (2016). 122. Zhao et al., ""Quantum statistics control with a plasmonic nanocavity: Multimode-enhanced interferences"", ; Phys. Rev. A 92, 033836 (2015). 121. Granade et al., ""Practical Bayesian tomography"", ; New J. Phys. 18, 033024 (2016). 120. Wan et al., ""Tolerance in the Ramsey interference of a trapped nanodiamond"", ; Phys. Rev. A 93, 043852 (2016). 119. Cirio et al., ""Ground State Electroluminescence"", ; Phys. Rev. Lett. 116, 113601 (2016). 118. Lee et al., ""Ramsey interference in a multilevel quantum system"", ; Phys. Rev. B 93, 085407 (2016). 117. Huang et al., ""Dark state in a nonlinear optomechanical system with quadratic coupling"", ; Phys. Rev. A 92, 013829 (2015). 116. Friis et al., ""Coherent controlization using superconducting qubits"", ; Sci. Rep. 5, 18036 (2015). 115. Glaser et al., ""Training Schrödinger's cat: quantum optimal control"", ; Eur. Phys. J. D 69, 279 (2015). 114. Łobejko et al., ""Interference of qubits in pure dephasing and almost pure dephasing environments"", ; J. Phys. A: Math. Theor. 48, 275302 (2015). 113. Hua et al., ""Quantum state transfer and controlled-phase gate on one-dimensional superconducting resonators assisted by a quantum bus"", ; Sci. Rep. 6, 22037 (2016). 112. Layden et al., ""Universal scheme for indirect quantum control"", ; Phys. Rev. A 93, 040301(R) (2016). 111. Zhang et al., ""Coherent manipulation of a Majorana qubit by a mechanical resonator"", ; Phys. Rev. B 92, 115303 (2015). 110. Yang et al., ""Entangling superconducting qubits in a multi-cavity system"", ; New. J. Phys. 18, 013025 (2016). 109. Hou et al., ""A multi-model Python wrapper for op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:33783,coupling,coupling,33783,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,"17). 272. Cesa et al., ""Two-qubit entangling gates between distant atomic qubits in a lattice"", ; Phys. Rev. A 95, 052330 (2017). 271. Ren et al., ""Evanescent-Vacuum-Enhanced Photon-Exciton Coupling and Fluorescence Collection"", ; Phys. Rev. Lett. 118, 073604 (2017). 270. Chu et al., ""Quantum acoustics with superconducting qubits"", ; Science 358, 199 (2017). 269. Fischer et al., ""Signatures of two-photon pulses from a quantum two-level system"", ; Nat. Phys. 13, 649 (2017). 268. Marshman et al., ""Investigating and improving student understanding of the probability distributions for measuring physical observables in quantum mechanics"", ; Eur. J. Phys. 38, 025705 (2017). 267. Borges et al., ""Influence of the asymmetric excited state decay on coherent population trapping: atom × quantum dot"", ; arXiv:1702.07692. 266. Pleinert et al., ""Hyperradiance from collective behavior of coherently driven atoms"", ; Optica 4, 779 (2017). 265. Oviedo-Casado et al., ""Magnetic field enhancement of organic photovoltaic cells performance"", ; Sci. Rep. 7, 4297 (2017). 264. Whalen et al., ""Open quantum systems with delayed coherent feedback"", ; Quantum Sci. Technol. 2, 044008 (2017). 263. Cottet et al., ""Observing a quantum Maxwell demon at work"", ; Proc. Natl. Acad. Sci. U.S.A. 114, 7561 (2017). 262. Mazloom et al., ""Adiabatic state preparation of stripe phases with strongly magnetic atoms"", ; Phys. Rev. A 96, 033602 (2017). 261. Poonia et al., ""Functional window of the avian compass"", ; Phys. Rev. E 95, 052417 (2017). 260. Su et al., ""Generating double NOON states of photons in circuit QED"", ; Phys. Rev. A 95, 022339 (2017). 259. Kiukas et al., ""Remote parameter estimation in a quantum spin chain enhanced by local control"", ; Phys. Rev. A 95, 052132 (2017). 258. Gely et al., ""Convergence of the multimode quantum Rabi model of circuit quantum electrodynamics"", ; Phys. Rev. B 95, 245115 (2017). 257. Radtke et al., ""Photonic Quantum Operations via the Quantum Carburettor Effect"", ; arXiv:17",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:13996,enhance,enhancement,13996,users.html,https://qutip.org,https://qutip.org/users.html,1,['enhance'],['enhancement']
Modifiability,"17). 304. Bauckhage et al., ""Adiabatic Quantum Computing for Binary Clustering"", ; arXiv:1706.05528. 303. Nigg, ""Observing quantum synchronization blockade in circuit quantum electrodynamics"", ; Phys. Rev. A 97, 013811 (2018). 302. Liu et al., ""High Purcell factor generation of coherent on-chip single photons"", ; arXiv:1706.04422. 301. Román-Ancheyta et al., ""Dynamical Casimir effect in stochastic systems: Photon harvesting through noise"", ; Phys. Rev. A 96, 032501 (2017). 300. Hong et al., ""Hanbury Brown and Twiss interferometry of single phonons from an optomechanical resonator"", ; Science 358, 203 (2017). 299. Pérez-Ríos et al., ""Ultracold molecule assembly with photonic crystals"", ; New J. Phys. 19, 123035 (2017). 298. Zambrano-Serrano et al., ""Chaos generation in fractional-order switched systems and its digital implementation"", ; International Journal of Electronics and Communications (2017). 297. Yoshihara et al., ""Characteristic spectra of circuit quantum electrodynamics systems from the ultrastrong- to the deep-strong-coupling regime"", ; Phys. Rev. A 95, 053824 (2017). 296. Endo et al., ""Dynamics of an ultra-strongly-coupled system interacting with a driven nonlinear resonator"", ; arXiv:1705.08688. 295. Venkatesh et al., ""Cooperative Effects in Closely Packed Quantum Emitters with Collective Dephasing"", ; Phys. Rev. Lett. 120, 033602 (2018). 294. Snijders et al., ""A fiber coupled cavity QED source of identical single photons"", ; arXiv:1705.05876. 293. Zanker et al., ""Analyzing the spectral density of a perturbed analog quantum simulator using Keldysh formalism"", ; arXiv:1705.02325. 292. Csurgay et al., ""Toward engineering design of quantum circuits"", ; Int. J. Circ. Theor. Appl. (2017). 291. Megyeri et al., ""Why material slow light does not improve cavity-enhanced atom detection"", ; J. Mod. Phys. (2017). 290. Huembeli et al., ""Towards a heralded eigenstate-preserving measurement of multi-qubit parity in circuit QED"", ; Phys. Rev. A 96, 012313 (2017). 289. Sh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:9942,coupling,coupling,9942,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,"1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:21967,variab,variables,21967,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['variab'],['variables']
Modifiability,"1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:14435,config,config,14435,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,3,['config'],['config']
Modifiability,"1], type = oper, isherm = True; Qobj data =; [[ 3.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 4.]]]. In [15]: print(c); ['' 'a' 'aa' 'aaa' 'aaaa']. Note; New in QuTiP 3. One can also define functions with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-parfor.html:4416,config,configurations,4416,docs/3.0.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html,2,['config'],['configurations']
Modifiability,"1d: Spin-Bath model, fitting of spectrum and correlation functions; HEOM 1e: Spin-Bath model (pure dephasing); HEOM 2: Dynamics in Fenna-Mathews-Olsen complex (FMO); HEOM 3: Quantum Heat Transport; HEOM 4: Dynamical decoupling of a non-Markovian environment; HEOM 5a: Fermionic single impurity model; HEOM 5b: Discrete boson coupled to an impurity and fermionic leads; Hierarchical Equation of Motion Examples. Miscellaneous tutorials. Lecture: Single-photon Interference. Quantum mechanics lectures with QuTiP; These lecture-style notebooks focus on particular quantum mechanics; topics and analyze them numerically using QuTiP (some more detailed than others). Lecture 0 - Introduction to QuTiP; Lecture 1 - Vacuum Rabi oscillations in the Jaynes-Cummings model; Lecture 2A - Simulation of a two-qubit gate using a resonator as coupler; Lecture 2B - Single-Atom-Lasing; Lecture 3A - The Dicke model; Lecture 3B - Jaynes-Cummings-like model in the ultrastrong coupling regime; Lecture 4 - Correlation functions; Lecture 5 - Evolution and quantum statistics of a quantum parameter amplifier; Lecture 6 - Quantum Monte-Carlo Trajectories; Lecture 7 - Two-qubit iSWAP gate and process tomography; Lecture 8 - Adiabatic sweep; Lecture 9 - Squeezed states of a quantum harmonic oscillator; Lecture 10 - Cavity-QED in the dispersive regime; Lecture 11 - Superconducting Josephson charge qubits; Lecture 12 - Decay into a squeezed vacuum field; Lecture 13 - Resonance flourescence; Lecture 14 - Kerr nonlinearities; Lecture 15 - Nonclassically driven atoms (cascaded quantum systems); Lecture 16 - Gallery of Wigner functions. Contributing; If you would like to contribute a notebook or report a bug, you may open; an issue or pull request in the; qutip-tutorials; GitHub repository. A few of the notebooks are still maintained in the repository; qutip-notebooks and; a complete archive of older versions of the tutorials is maintained there. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-tutorials/index-v4.html:5212,coupling,coupling,5212,qutip-tutorials/index-v4.html,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html,1,['coupling'],['coupling']
Modifiability,"2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:2234,coupling,coupling,2234,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['coupling'],['coupling']
Modifiability,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:2790,enhance,enhanced,2790,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['enhance'],['enhanced']
Modifiability,"2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26385,config,config,26385,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [2]: tensor([basis(2, 0), basis(2, 0)]); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [3]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[3]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:3191,extend,extended,3191,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,3,['extend'],['extended']
Modifiability,"2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [2]: tensor([basis(2, 0), basis(2, 0)]); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [3]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[3]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-tensor.html:3991,extend,extended,3991,docs/3.1.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html,1,['extend'],['extended']
Modifiability,"2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [3]: tensor([basis(2, 0), basis(2, 0)]); Out[3]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [4]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[4]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-tensor.html:3848,extend,extended,3848,docs/3.0.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html,2,['extend'],['extended']
Modifiability,"2]: es3_expect; Out[12]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = (-0-1j); (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([-1.000000e+00, -6.123234e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [14]: psi0 = basis(2,1). In [15]: H = sigmaz(). In [16]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by pri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-eseries.html:5540,evolve,evolve,5540,docs/4.5/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-eseries.html,1,['evolve'],['evolve']
Modifiability,"2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26560,config,config,26560,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"6). 169. Vermersch et al., ""Implementation of chiral quantum optics with Rydberg and trapped-ion setups"", ; Phys. Rev. A 93, 063830 (2016). 168. Apollaro et al., ""Entanglement entropy in a periodically driven quantum Ising ring"", ; Phys. Rev. B 94, 134304 (2016). 167. Jonas, ""Fortran code for generating random probability vectors, unitaries, and quantum states"", ; Frontiers in ICT 3 (2016). 166. Ong et al., ""The Effect of Spin Squeezing on the Entanglement Entropy of Kicked Tops"", ; Entopy 18, 116 (2016). 165. Yang et al., ""Crosstalk-insensitive method for simultaneously coupling multiple pairs of resonators"", ; Phys. Rev. A 93, 042307 (2016). 164. Mavalankar et al., ""Photon-assisted tunneling and charge dephasing in a carbon nanotube double quantum dot"", ; Phys. Rev. B 93, 235428 (2016). 163. Hush et al., ""Quantum state transfer through time reversal of an optical channel"", ; Phys. Rev. A 94, 062302 (2016). 162. Royer et al., ""Fast and high-fidelity entangling gate through parametrically modulated longitudinal coupling"", ; Quantum 1, 11 (2017). 161. Lörch et al., ""Genuine Quantum Signatures in Synchronization of Anharmonic Self-Oscillators"", ; Phys. Rev. Lett. 117, 073601 (2016). 160. Ejtemaee et al., ""3D Sisyphus Cooling of Trapped Ions"", ; Phys. Rev. Lett. 119, 043001 (2017). 159. Rogers, ""The EPR Paradox Implies A Minimum Achievable Temperature"", ; Phys. Rev. E 95, 012149 (2017). 158. Fischer et al., ""Self-homodyne measurement of a dynamic Mollow triplet in the solid state"", ; Nat. Photonics 10, 163 (2016). 157. Zhao et al., ""Vacuum Rabi Splitting in Nanomechanical QED System with Nonlinear Resonator"", ; arXiv:1603.00215. 156. Türkpençe et al., ""Quantum fuel with multilevel atomic coherence for ultrahigh specific work in a photonic Carnot engine"", ; Phys. Rev. E 93, 012145 (2016). 155. Joo et al., ""Deterministic amplification of Schrödinger cat states in circuit quantum electrodynamics"", ; New J. Phys. 18, 023028 (2016). 154. Hofer et al., ""Quantum heat engine b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:27903,coupling,coupling,27903,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,": :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:9555,config,config,9555,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,12,['config'],['config']
Modifiability,": QobjThe circular spin chain circuit to be resolved. rwa: BooleanSpecify if RWA is used or not. Returns. qc: QubitCircuitReturns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. get_ops_and_u(self)[source]¶; Returns the Hamiltonian operators and corresponding values by stacking; them together. get_ops_labels(self)[source]¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(self, qc)[source]¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. optimize_circuit(self, qc)[source]¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. Returns. qc: QubitCircuitThe optimal circuit representation. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:72808,config,config,72808,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['config'],['config']
Modifiability,": float or array; Frequency of the oscillator. w_th : float; The temperature in units of frequency (or the same units as w). Returns:; n_avg : float or array; Return the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. linspace_with(start, stop, num=50, elems=[])[source]¶; Return an array of numbers sampled over specified interval; with additional elements added.; Returns num spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:; start : int; The starting value of the sequence. stop : int; The stoping values of the sequence. num : int, optional; Number of samples to generate. elems : list/ndarray, optional; Requested elements to include in array. Returns:; samples : ndadrray; Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns:; cg_coeff : float; Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value : float / array; The energy in the old unit. orig : string; The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string; The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to sto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:207419,coupling,coupling,207419,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['coupling'],['coupling']
Modifiability,": float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string. Fidelity error (and fidelity error gradi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:132955,variab,variable,132955,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,2,['variab'],['variable']
Modifiability,": float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. amp_update_mode : string. determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string. type / shape of pulse(s) used to initialise the; the control amplitudes. Options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:139496,variab,variable,139496,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['variab'],['variable']
Modifiability,": int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)[source]¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:25179,config,configuration,25179,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['config'],['configuration']
Modifiability,": return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, nu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17330,config,config,17330,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,":. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3.; quite.cite() is improved.; Added matplotlib as optional dependency and updated numpy and scipy requirements.; Fixed matrix generating coherent spin states in qutip.piqs to include complex coefficients. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEAT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:1917,variab,variable,1917,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,1,['variab'],['variable']
Modifiability,"::-1], kraus_list[0].dims[::-1]],; type='super', superrep='choi'). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:9877,extend,extend,9877,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,1,['extend'],['extend']
Modifiability,":; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:2756,enhance,enhanced,2756,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,1,['enhance'],['enhanced']
Modifiability,":; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18617,config,config,18617,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,":; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20274,config,config,20274,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,":; string_list.append(str(value)); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=len(Lcoeff), h_tdterms=Lcoeff, ; c_td_splines=me_cops_coeff, ; c_td_spline_flags=me_cops_obj_flags, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mesolve.html:22627,config,config,22627,docs/4.3/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,":class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_ste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html:6994,config,config,6994,docs/4.0.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"; """""". def __init__(self, N, reverse_states=True):. # number of qubits in the register; self.N = N; self.reverse_states = reverse_states; self.gates = []; self.U_list = []. [docs] def add_gate(self, gate, targets=None, controls=None, arg_value=None,; arg_label=None):; """"""; Adds a gate with specified parameters to the circuit. Parameters; ----------; gate: String or `Gate`; Gate name. If gate is an instance of `Gate`, parameters are; unpacked and added.; targets: List; Gate targets.; controls: List; Gate controls.; arg_value: Float; Argument value(phi).; arg_label: String; Label for gate representation.; """"""; if isinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label. else:; name = gate; self.gates.append(Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label)). [docs] def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : String; Gate name.; start : Integer; Starting location of qubits.; end : Integer; Last qubit for the gate.; qubits : List; Specific qubits for applying gates.; arg_value : Float; Argument value(phi).; arg_label : String; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for i in range(len(qubits)):; self.gates.append(Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value,; arg_label=arg_label)). else:; if end is None:; end = self.N - 1; for i in range(start, end):; self.gates.append(Gate(name, targets=i, controls=None,; arg_value=arg_value,; arg_label=arg_label)). [docs] def add_circuit(self, qc, start=0):; """"""; Adds a block of a qubit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/circuit.html:6174,variab,variable,6174,docs/4.1/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/circuit.html,2,['variab'],['variable']
Modifiability,"; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12324,config,config,12324,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['config'],['config']
Modifiability,"; # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35276,config,config,35276,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34883,config,config,34883,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12553,config,config,12553,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; # attach args to od",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:36506,config,config,36506,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35504,config,config,35504,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3246,Extend,Extending,3246,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,1,['Extend'],['Extending']
Modifiability,"; C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35409,config,config,35409,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:7198,flexible,flexible,7198,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['flexible'],['flexible']
Modifiability,"; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-eseries.html:1983,parameteriz,parameterized,1983,docs/3.0.1/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-eseries.html,1,['parameteriz'],['parameterized']
Modifiability,"; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:4204,Coupling,Coupling,4204,docs/4.6/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html,2,['Coupling'],['Coupling']
Modifiability,; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(P,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide.html:2312,Config,Configuring,2312,docs/4.6/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide.html,1,['Config'],['Configuring']
Modifiability,"; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITI",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:98864,config,configuration,98864,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['config'],['configuration']
Modifiability,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:88510,variab,variable,88510,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,12,['variab'],"['variable', 'variables']"
Modifiability,"; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:6352,config,config,6352,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,3,['config'],['config']
Modifiability,"; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6156,config,config,6156,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,5,['config'],['config']
Modifiability,"; LorentzianPadeBath.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/fermionic.html:3195,coupling,coupling,3195,docs/4.7/guide/heom/fermionic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html,2,['coupling'],['coupling']
Modifiability,"; Neill Lambert. Author; Eric Giguere. version; 4.4. status; Released (July 18, 2018). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/frontmatter.html:1822,coupling,coupling,1822,docs/4.4/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html,1,['coupling'],['coupling']
Modifiability,"; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=fl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18502,config,config,18502,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:6098,coupling,coupling,6098,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,6,['coupling'],['coupling']
Modifiability,"; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-tensor.html:6898,coupling,coupling,6898,docs/3.1.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html,1,['coupling'],['coupling']
Modifiability,"; _H = H.full().copy() # np.ndarray; _psi = psi0.full().copy(); _psi = _psi / np.linalg.norm(_psi). # create internal variable and output containers; if options is None:; options = Options(nsteps=10000); krylov_results = Result(); krylov_results.solver = ""krylovsolve"". # handle particular cases of an empty tlist or single element; n_tlist_steps = len(tlist); if n_tlist_steps < 1:; return krylov_results. if n_tlist_steps == 1: # if tlist has only one element, return it; krylov_results = particular_tlist_or_happy_breakdown(; tlist, n_tlist_steps, options, psi0, e_ops, krylov_results, pbar; ) # this will also raise a warning; return krylov_results. tf = tlist[-1]; t0 = tlist[0]. # optimization step using Lanczos, then reuse it for the first partition; dim_m = krylov_dim; krylov_basis, T_m = lanczos_algorithm(; _H, _psi, krylov_dim=dim_m, sparse=sparse; ). # check if a happy breakdown occurred; if T_m.shape[0] < krylov_dim + 1:; if T_m.shape[0] == 1:; # this means that the state does not evolve in time, it lies in a; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; options,; psi0,; e_ops,; krylov_results,; pbar,; happy_breakdown=True,; ); return krylov_results; else:; # no optimization is required, convergence is guaranteed.; delta_t = tf - t0; n_timesteps = 1; else:. # calculate optimal number of internal timesteps.; delta_t = _optimize_lanczos_timestep_size(; T_m, krylov_basis=krylov_basis, tlist=tlist, options=options; ); n_timesteps = int(ceil((tf - t0) / delta_t)). if n_timesteps >= options.nsteps:; raise Exception(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_result",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:4366,evolve,evolve,4366,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,['evolve'],['evolve']
Modifiability,"; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See :obj:`~TimeslotComp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:45188,variab,variable,45188,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['variab'],['variable']
Modifiability,"; arXiv:1712.09762. 359. Dahlberg et al., ""SimulaQron - A simulator for developing quantum internet software"", ; arXiv:1712.08032. 358. Abdel-Wahab et al., ""Dynamic evolution of double Λ five-level atom interacting with one-mode electromagnetic cavity field"", ; Pramana - J. Phys. 89, 87 (2017). 357. Dai et al., ""Quantum simulation of the general semi-classical Rabi model in regimes of arbitrarily strong driving"", ; Appl. Phys. Lett. 111, 242601 (2017). 356. Zhou et al., ""Simulating the Lipkin-Meshkov-Glick model in a hybrid quantum system"", ; arXiv:1712.06234. 355. Otterbach et al., ""Unsupervised Machine Learning on a Hybrid Quantum Computer"", ; arXiv:1712.05771. 354. Wang et al., ""Parallel quantum operations with chiral spin states in a superconducting circuit"", ; arXiv:1712.05261. 353. Tugen et al., ""A Comparative Study of Coupled High-Q Cavity-Quantum Dot System Regarding Dipole Induced Transparency"", ; arXiv:1712.01944. 352. Chen et al., ""Tuning coupling between superconducting resonators with collective qubits"", ; arXiv:1712.04357. 351. Touzard et al., ""Coherent oscillations inside a quantum manifold stabilized by dissipation"", ; arXiv:1705.02401. 350. Zhao et al., ""Two-photon driven Kerr resonator for quantum annealing with three-dimensional circuit QED"", ; arXiv:1712.03613. 349. Tezak et al., ""Low-dimensional manifolds for exact representation of open quantum systems"", ; Phys. Rev. A 96, 062113 (2017). 348. Lambert et al., ""Amplified and tunable transverse and longitudinal spin-photon coupling in hybrid circuit-QED"", ; arXiv:1712.02077. 347. Mirkin et al., ""In the quest of relations between non-Markovianity and quantum optimal control"", ; arXiv:1711.10551. 346. Gu et al., ""Topological edge states and pumping in a chain of coupled superconducting qubits"", ; arXiv:1711.06829. 345. Jiang et al., ""Quantum algorithms to simulate many-body physics of correlated fermions"", ; arXiv:1711.05395. 344. Brambilla et al., ""Heavy quarkonium suppression in a fireball"", ; arX",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:2782,coupling,coupling,2782,users.html,https://qutip.org,https://qutip.org/users.html,1,['coupling'],['coupling']
Modifiability,"; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def __init__(; self, Q, lam, gamma, w0, T, Nk, combine=True, tag=None,; ):; ck_real, vk_real, ck_imag, vk_imag = self._matsubara_params(; lam=lam,; gamma=gamma,; w0=w0,; T=T,; Nk=Nk,; ). super().__init__(; Q, ck_real, vk_real, ck_imag, vk_imag, combine=combine, tag=tag,; ). def _matsubara_params(self, lam, gamma, w0, T, Nk):; """""" Calculate the Matsubara coefficents and frequencies. """"""; beta = 1/T; Om = np.sqrt(w0**2 - (gamma/2)**2); Gamma = gamma/2. ck_real = ([; (lam**2 / (4 * Om)); * (1 / np.tanh(beta * (Om + 1.0j * Gamma) / 2)),; (lam**2 / (4*Om)); * (1 / np.tanh(beta * (Om - 1.0j * Gamma) / 2)),; ]). ck_real.extend([; (-2 * lam**2 * gamma / beta) * (2 * np.pi * k / beta); / (; ((Om + 1.0j * Gamma)**2 + (2 * np.pi * k/beta)**2); * ((Om - 1.0j * Gamma)**2 + (2 * np.pi * k / beta)**2); ); for k in range(1, Nk + 1); ]). vk_real = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]; vk_real.extend([; 2 * np.pi * k * T; for k in range(1, Nk + 1); ]). ck_imag = [; 1.0j * lam**2 / (4 * Om),; -1.0j * lam**2 / (4 * Om),; ]. vk_imag = [-1.0j * Om + Gamma, 1.0j * Om + Gamma]. return ck_real, vk_real, ck_imag, vk_imag. [docs]class FermionicBath(Bath):; """"""; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the ``+`` and ``-`` modes of; the bath correlation function. There must be the same number of ``+`` and ``-`` modes and their; coefficients must be specified in the same order so that ``ck_plus[i],; vk_plus[i]`` are the plus coefficient and frequency corresponding; to the minus mode ``ck_minus[i], vk_minus[i]``. In the fermionic case the order in which excitations are created or; destroyed is important, resulting in two different correlation functions; labelled ``C_plus(t)`` and ``C_plus(t)``::. C_plus(t) = sum(ck_plus * exp(- vk_plus * t)); C_minus(t) = sum(ck_minus * exp(- vk_minus * t)). where the expansions above define the coeffii",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:18122,extend,extend,18122,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['extend'],['extend']
Modifiability,"; class _LiouvillianFromFunc:; def __init__(self, func, c_ops, rho_dims):; self.f = func; self.c_ops = c_ops; self.rho_dims = rho_dims. def H2L(self, t, rho, args):; Ht = self.f(t, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def H2L_with_state(self, t, rho, args):; Ht = self.f(t, rho, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L(self, t, rho, args):; Lt = self.f(t, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L_with_state(self, t, rho, args):; Lt = self.f(t, rho, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def _mesolve_func_td(L_func, c_op_list, rho0, tlist, args, opt):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """"""; c_ops = []; for op in c_op_list:; td = QobjEvo(op, args, tlist=tlist, copy=False); c_ops.append(td if td.cte.issuper else lindblad_dissipator(td)); c_ops_ = [sum(c_ops)] if c_op_list else []; L_api = _LiouvillianFromFunc(L_func, c_ops_, rho0.dims); if opt.rhs_with_state:; obj = L_func(0., rho0.full().ravel(""F""), args); L_func = L_api.L_with_state if issuper(obj) else L_api.H2L_with_state; else:; obj = L_func(0., args); L_func = L_api.L if issuper(obj) else L_api.H2L; ss = SolverSystem(); ss.L = L_func; ss.makefunc = _Lfunc_set; solver_safe[""mesolve""] = ss; return ss. def _Lfunc_set(HS, rho0, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; L_func = HS.L; if issuper(rho0):; func = _ode_super_func_td; else:; func = _ode_rho_func_td. return func, (L_func, args). def _ode_rho_func_td(t, y, L_func, args):; L = L_func(t, y, args); return spmv(L, y). def _ode_super_func_td(t, y, L_fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:14212,Evolve,Evolve,14212,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,2,['Evolve'],['Evolve']
Modifiability,"; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set init",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23333,config,config,23333,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:14660,config,configuration,14660,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['config'],['configuration']
Modifiability,"; e_ops=None,; options=None,; progress_bar: bool = None,; sparse: bool = False,; ):; """"""; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (""psi0"") finding an approximation for the time; evolution operator of Hamiltonian (""H"") by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)). The output is either the state vector or the expectation values of; supplied operators (""e_ops"") at arbitrary points at (""tlist""). **Additional options**. Additional options to krylovsolve can be set with the following:. * ""store_states"": stores states even though expectation values are; requested via the ""e_ops"" argument. * ""store_final_state"": store final state even though expectation values are; requested via the ""e_ops"" argument. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian.; psi0 : :class: `qutip.Qobj`; Initial state vector (ket).; tlist : None / *list* / *array*; List of times on which to evolve the initial state. If None, nothing; happens but the code won't break.; krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation.; e_ops : None / list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values.; options : Options; Instance of ODE solver options, as well as krylov parameters.; atol: controls (approximately) the error desired for the final; solution. (Defaults to 1e-8); nsteps: maximum number of krylov's internal number of Lanczos; iterations. (Defaults to 10000); progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; sparse : bool (default False); Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns; -------; result: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`, which contains; e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:1907,evolve,evolve,1907,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,['evolve'],['evolve']
Modifiability,"; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calcul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:47995,config,configuration,47995,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,3,['config'],['configuration']
Modifiability,"; else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:14790,variab,variables,14790,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['variab'],['variables']
Modifiability,"; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17583,config,config,17583,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"; for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27014,config,config,27014,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28017,config,config,28017,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33926,config,config,33926,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20948,config,config,20948,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['config'],['config']
Modifiability,"; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:3270,Evolve,Evolve,3270,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,2,['Evolve'],['Evolve']
Modifiability,"; if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12154,config,config,12154,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['config'],['config']
Modifiability,"; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if phase is not None:; self._dyn_gen_phase = phase. def _get_dyn_gen_phas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:52850,config,config,52850,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,1,['config'],['config']
Modifiability,"; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_ind",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32696,config,config,32696,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if self.compiled:; self.dynamics_args[i][2].compile(); self._d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:22706,variab,variables,22706,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['variab'],['variables']
Modifiability,"; passed as ck_imag. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""; def _check_cks_and_vks(self, ck_real, vk_real, ck_imag, vk_imag):; if len(ck_real) != len(vk_real) or len(ck_imag) != len(vk_imag):; raise ValueError(; ""The bath exponent lists ck_real and vk_real, and ck_imag and""; "" vk_imag must be the same length.""; ). def _check_coup_op(self, Q):; if not isinstance(Q, Qobj):; raise ValueError(""The coupling operator Q must be a Qobj.""). def __init__(; self, Q, ck_real, vk_real, ck_imag, vk_imag, combine=True,; tag=None,; ):; self._check_cks_and_vks(ck_real, vk_real, ck_imag, vk_imag); self._check_coup_op(Q). exponents = []; exponents.extend(; BathExponent(""R"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_real, vk_real); ); exponents.extend(; BathExponent(""I"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_imag, vk_imag); ). if combine:; exponents = self.combine(exponents). super().__init__(exponents). [docs] @classmethod; def combine(cls, exponents, rtol=1e-5, atol=1e-7):; """"""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; --",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:6883,extend,extend,6883,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['extend'],['extend']
Modifiability,"; qc: Qobj; The circular spin chain circuit to be resolved. rwa: Boolean; Specify if RWA is used or not. Returns:; qc: QubitCircuit; Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. get_ops_and_u()[source]¶; Returns the Hamiltonian operators and corresponding values by stacking; them together. get_ops_labels()[source]¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(qc)[source]¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. optimize_circuit(qc)[source]¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. Returns:; qc: QubitCircuit; The optimal circuit representation. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:66855,config,config,66855,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['config'],['config']
Modifiability,"; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:12596,config,configure,12596,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['config'],['configure']
Modifiability,"; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if pha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:52795,config,configuration,52795,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,1,['config'],['configuration']
Modifiability,"; self.propagators[t2][t1] = propagator(self.H, [t1, t2],; options=self.options,; unitary_mode='single'); # Something is still broken about batch unitary mode (see #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Returns; -------; partition : iterable; The partitioning of collection into num_sets sets.; """"""; for partitioning in product(range(num_sets), repeat=len(collection)):; partition = [[] for _ in range(num_sets)]; for i, set_index in enumerate(partitioning):; partition[set_index].append(collection[i]); yield tuple(tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/scattering.html:5526,evolve,evolver,5526,docs/4.3/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/scattering.html,7,['evolve'],['evolver']
Modifiability,"; sol.expect = list(sol.expect / len(sols)); inds = np.where(config.e_ops_isherm)[0]; for jj in inds:; sol.expect[jj] = np.real(sol.expect[jj]); if (hasattr(sols[0], 'entropy')):; sol.entropy = sol.entropy / len(sols). # convert sol.expect array to list and fix dtypes of arrays; if (not config.options.average_expect) and config.e_num != 0:; temp = [list(sol.expect[ii]) for ii in range(ntraj)]; for ii in range(ntraj):; for jj in np.where(config.e_ops_isherm)[0]:; temp[ii][jj] = np.real(temp[ii][jj]); sol.expect = temp; # convert to list/array to be consistent with qutip mcsolve; sol.states = list(sol.states); return sol. #; # Functions to initialize the problem in fortran; #; def _init_tlist():; Of = _realarray_to_fortran(config.tlist); qtf90.qutraj_run.init_tlist(Of, np.size(Of)). def _init_psi0():; # Of = _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:18956,config,config,18956,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"<; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26428,config,config,26428,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['config'],['config']
Modifiability,"<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data str",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:31770,config,config,31770,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['config'],['config']
Modifiability,"<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltoni",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30750,config,config,30750,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"= 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28702,config,config,28702,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['config'],['config']
Modifiability,"= None; compiled_coeffs[i] = None; else:; compiled_tlist[i] = np.concatenate(compiled_tlist[i]); compiled_coeffs[i] = np.concatenate(compiled_coeffs[i]); return compiled_tlist, compiled_coeffs. def _process_gate_pulse(; self, start_time, tlist, coeff):; # compute the gate time, step size and coeffs; # according to different pulse mode; if np.isscalar(tlist):; pulse_mode = ""discrete""; # a single constant rectanglar pulse, where; # tlist and coeff are just float numbers; step_size = tlist; coeff = np.array([coeff]); gate_tlist = np.array([tlist]); elif len(tlist) - 1 == len(coeff):; # discrete pulse; pulse_mode = ""discrete""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff); gate_tlist = np.asarray(tlist)[1:] # first t always 0 by def; elif len(tlist) == len(coeff):; # continuos pulse; pulse_mode = ""continuous""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff)[1:]; gate_tlist = np.asarray(tlist)[1:]; else:; raise ValueError(; ""The shape of the compiled pulse is not correct.""); return gate_tlist, coeff, step_size, pulse_mode. def _process_idling_tlist(; self, pulse_mode, start_time, last_pulse_time, step_size):; idling_tlist = []; if pulse_mode == ""continuous"":; # We add sufficient number of zeros at the begining; # and the end of the idling to prevent wrong cubic spline.; if start_time - last_pulse_time > 3 * step_size:; idling_tlist1 = np.linspace(; last_pulse_time + step_size/5,; last_pulse_time + step_size,; 5; ); idling_tlist2 = np.linspace(; start_time - step_size,; start_time,; 5; ); idling_tlist.extend([idling_tlist1, idling_tlist2]); else:; idling_tlist.append(; np.arange(; last_pulse_time + step_size,; start_time, step_size; ); ); elif pulse_mode == ""discrete"":; # idling until the start time; idling_tlist.append([start_time]); return np.concatenate(idling_tlist). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/gatecompiler.html:8928,extend,extend,8928,docs/4.7/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/gatecompiler.html,2,['extend'],['extend']
Modifiability,"= ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~Qobj`, :class:`~QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~Qobj , list of :obj:`Qobj` and; coefficient, :obj:`~QObjEvo`, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo's; description. psi0 : :class:`~Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/sesolve.html:3091,Evolve,Evolve,3091,docs/4.6/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html,1,['Evolve'],['Evolve']
Modifiability,"= ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~qutip.Qobj`, :class:`~qutip.QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~qutip.Qobj` , list of; :obj:`~qutip.Qobj` and coefficient, :obj:`~qutip.QobjEvo`,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo's description. psi0 : :class:`~qutip.Qobj`; Initial state vector (ket) or initial unitary operator ``psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/sesolve.html:1356,Evolve,Evolve,1356,docs/4.7/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html,1,['Evolve'],['Evolve']
Modifiability,"= [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hami",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32530,config,config,32530,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['config'],['config']
Modifiability,"= _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1]; return data, indices + 1, indptr + 1, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19814,config,config,19814,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
Modifiability,"= _qobj_to_fortranfull(config.psi0); Of = _complexarray_to_fortran(config.psi0); qtf90.qutraj_run.init_psi0(Of, np.size(Of)). def _init_ptrace_stuff(sel):; psi0 = Qobj(config.psi0,; dims=config.psi0_dims,; shape=config.psi0_shape); qtf90.qutraj_run.init_ptrace_stuff(config.psi0_dims[0],; np.array(sel) + 1,; psi0.ptrace(sel).shape[0]). def _init_hamilt():; # construct effective non-Hermitian Hamiltonian; # H_eff = H - 0.5j*sum([c_ops[i].dag()*c_ops[i]; # for i in range(len(c_ops))]); # Of = _qobj_to_fortrancsr(H_eff); # qtf90.qutraj_run.init_hamiltonian(Of[0],Of[1],; # Of[2],Of[3],Of[4]); d = np.size(config.psi0); qtf90.qutraj_run.init_hamiltonian(; _complexarray_to_fortran(config.h_data),; config.h_ind + 1, config.h_ptr + 1, d, d). def _init_c_ops():; d = np.size(config.psi0); n = config.c_num; first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(c_ops[i]); # qtf90.qutraj_run.init_c_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_c_ops(; i + 1, n, _complexarray_to_fortran(config.c_ops_data[i]),; config.c_ops_ind[i] + 1, config.c_ops_ptr[i] + 1, d, d, first); first = False. def _init_e_ops():; d = np.size(config.psi0); # n = config.e_num; n = len(config.e_ops_data); first = True; for i in range(n):; # Of = _qobj_to_fortrancsr(e_ops[i]); # qtf90.qutraj_run.init_e_ops(i+1,n,Of[0],Of[1],; # Of[2],Of[3],Of[4],first); qtf90.qutraj_run.init_e_ops(; i + 1, n, _complexarray_to_fortran(config.e_ops_data[i]),; config.e_ops_ind[i] + 1, config.e_ops_ptr[i] + 1, d, d, first); first = False. #; # Misc. converison functions; #; def _realarray_to_fortran(a):; datad = np.array(a, dtype=wpr); return datad. def _complexarray_to_fortran(a):; datad = np.array(a, dtype=wpc); return datad. def _qobj_to_fortranfull(A):; datad = np.array(A.data.toarray(), dtype=wpc); return datad. def _qobj_to_fortrancsr(A):; data = np.array(A.data.data, dtype=wpc); indices = np.array(A.data.indices); indptr = np.array(A.data.indptr); m = A.data.shape[0]; k = A.data.shape[1];",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:19790,config,config,19790,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['config'],['config']
