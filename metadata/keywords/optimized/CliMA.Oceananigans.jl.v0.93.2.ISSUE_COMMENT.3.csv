quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,"Sounds like it would be more productive if we discussed this PR (and what we want ""diagnostics"" to look like) in person. Diagnostics may not be the best name. I'm not advocating for diagnostics for all use cases, but we should provide at least a few common ones (e.g. horizontal averages which we already use a lot) and users can build their own using the provided diagnostics as examples. Users shouldn't have to worry about pre-allocating arrays for their horizontal averages. Something as basic as a horizontal average should be fast and allocate zero memory out of the box.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520514848:541,allocate,allocate,541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520514848,1,['allocate'],['allocate']
Energy Efficiency,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2072,adapt,adapt,2072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Energy Efficiency,Sure! only the first halo node is required since we have 2nd order viscous terms and advection reduces to second order near the boundary,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2369#issuecomment-1074294876:95,reduce,reduces,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2369#issuecomment-1074294876,1,['reduce'],['reduces']
Energy Efficiency,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:154,Adapt,Adapt,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928,1,['Adapt'],['Adapt']
Energy Efficiency,"Sure, the PR resolves the rounding issue caused by `previous_interval_stop_time` through the use of actuations (as inspired by its application [here](https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L58-L63)).; Here is the part of the code showing these [changes](https://github.com/CliMA/Oceananigans.jl/pull/3721/commits/a52812b00eb38e712ed20c7a6db3cf2e0c3a7877#diff-532eb4a17264dc44a7cae7601aca768c39bfb08f0493561c333f24a3261d6a46R123-R130). Another important change is that ; ```julia. # Save averaging start time and the initial data collection time; wta.window_start_time = model.clock.time; wta.window_start_iteration = model.clock.iteration; wta.previous_collection_time = model.clock.time. wta.schedule.collecting = false; wta.schedule.actuations += 1; ```. occurs only when the window ends, i.e., when `end_of_window(wta.schedule, model.clock) == true`. In contrast, the [previous version](https://github.com/CliMA/Oceananigans.jl/pull/3721/commits/a52812b00eb38e712ed20c7a6db3cf2e0c3a7877#diff-532eb4a17264dc44a7cae7601aca768c39bfb08f0493561c333f24a3261d6a46L265-L268) triggered this only when the model wasn't collecting. > I'm wondering if it makes sense that this is hard or if we should actually consider a more fundamental redesign to make it more robust... I agree that a more fundamental redesign could improve robustness in the long term. That said, the current adjustments seem to resolve the issue for now (I'll look into why certain cases aren't passing the test). We can continue to monitor its performance and consider a redesign if further issues arise.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379285570:247,schedul,schedules,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379285570,5,"['monitor', 'schedul']","['monitor', 'schedule', 'schedules']"
Energy Efficiency,"Sure, these are the results for WENO order 3rd up to 11th. Since it is a linear problem (I am just advecting with a constant velocity), the order is retained also with a dimension by dimension reconstruction (we reduce to second order only on non-linear problems).; ![weno2](https://user-images.githubusercontent.com/33547697/176909442-95600577-37e4-432f-a862-ac0436f5a10a.png); ![weno3](https://user-images.githubusercontent.com/33547697/176909448-1fcad0e9-6cbd-46e0-9791-5a8f8adb8a8f.png); ![weno4](https://user-images.githubusercontent.com/33547697/176909451-3d81adee-6a70-46bc-b11f-678a7287b905.png); ![weno5](https://user-images.githubusercontent.com/33547697/176909452-314da3b7-f869-4cd9-9222-4d4f9f115feb.png); ![weno6](https://user-images.githubusercontent.com/33547697/176909455-c96c1650-b234-4d9b-83d5-85741158c4a9.png); ; for `WENON` the order is `2N-1`) In the legend `(x)` stands for advection in x and y, `(y)` is advection in y and z and `(z)` is advection in x and z, I forgot to change the legend from the one dimensional case",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172381519:212,reduce,reduce,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172381519,1,['reduce'],['reduce']
Energy Efficiency,"Tests fail on v0.76.5 on GPU... weird... ```Julia; nc3020@gadi-gpu-v100-0100:/g/data/v45/nc3020/OC.jl$ julia-1.6 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| |; |__/ |. (Oceananigans) pkg> test; Testing Oceananigans; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Project.toml`; [79e6a3ab] Adapt v3.3.3; [6e4b80f9] BenchmarkTools v1.3.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [124859b0] DataDeps v0.7.10; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:477,Adapt,Adapt,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Energy Efficiency,Thank you @simonbyrne!. @glwagner I tried to fix `all_*_nodes` so that we can `set!` reduced fields (which `model.free_surface` now is) but not sure if `[]` is the best solution. If tests pass we should merge and tag v0.54.1.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1573#issuecomment-819020035:85,reduce,reduced,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1573#issuecomment-819020035,1,['reduce'],['reduced']
Energy Efficiency,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297:825,adapt,adaptive,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297,1,['adapt'],['adaptive']
Energy Efficiency,"Thank you for the links !. The Oceananigans src code is very clearly written so the reading is relatively OK (I could use some explanations on your closure usage). If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. . The GPU shared memory is basically a programmable cache while the cache of CPU can't be (easily) controlled. In both cases there is cache so, if you compute multiple partial derivatives of a given (set of) field(s) (d/dx,d/dy, d2/dx2,...) once a block has been fetched in the cache then the memory operations are cheap. Cache is also useful for performing tiny transpositions enabling fast access and vectorized (SIMD) CPU or GPU ops in both X,Y or Z directions. . I hope that obtaining an efficient code for both (multicore SIMD) CPUs and GPUs maybe possible adjusting the (recursive?) block sizes (i.e. controlling the data layout and adapt it to the computing target). I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). Kudos again to your team for this inspiring package. Laurent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592:797,efficient,efficient,797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592,2,"['adapt', 'efficient']","['adapt', 'efficient']"
Energy Efficiency,"Thanks @glwagner and @ali-ramadhan for your suggestions. They all sound very interesting and gives me a lot to think about. Here are my initial reactions. Given that I don't know the numerics of Oceananigans, yet, but know the physics, I can imagine myself contributing to the following pretty quickly:. 1. Shallow Water model (and maybe even a Green-Naghdi version) with several layers for fun.; 2. Layered and stratified Quasi-Geostrophic Model; 3. Hydrostatic Boussinesq Model (rigid lid first and then a free-surface). Something that I can imagine giving to good undergraduate research students would be. 4. Verticall-Implicit time-stepping for diffusion. ; 5. Profiling parallelism. If I had keen student in computer science then maybe . 6. Distributed parallelism with MPI. . I have never used GPU's before but given the efficiency of GPU's vs CPU's that you have in the docs, I am definitely going to learn. Initial thougths on 1 and 2:; I know that FourierFlows has both QG and SW, which are spectrally based. I gather that Oceananigans is Finite Volume based. If I wanted to start with either of these would you suggest I start wtih FourierFlows or ignore that?. I kind of like the idea of having a QG code that can either be FV or Spectral, depending on the users whims, but that might be difficult, depending on how compatable these two libraries are. I suppose I should start in reading the code in detail and planning out what I think needs to be done. Any suggestions are welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151:345,Green,Green-Naghdi,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151,1,['Green'],['Green-Naghdi']
Energy Efficiency,"Thanks @glwagner for the help. Much appreciated. I tried to adapt it and the good news is that I don't get an error. The bad news is that I don't think the boundary conditions are being set correctly. . Below are a few ideas of things I think I need to do. Maybe you can confirm whether I understand this correctly?. - You had it set up for the sponge to depend on x but if I want the inflow and outflow to be in the south and north, respectively, then it should depend on `y`, right?; - `smoothed_step_mask` is currently only acting on the south. I pressume I need to add a similar function for the north?; - Do I need to have a sponge on `h` as well? I thought imposing this on `vh` might be enough in the case when the flow doesn't vary in the zonal direction. I imagine if I want inflow from the west only, which I do want, and the meridonal velocity depends on the zonal coordiante, then I should pick the sponge to relax to a geostrophically balanced state.; - Even though I am trying to set the inflow/outflow boundary conditions to `vh -> h` so that `v -> 1`, when I look at the final matrix, I have that `vh` is zero everywhere. This tells me that the boundary conditions are not being set. It does seem to say that `vh` does have `NormalFlow` boundary conditions so that seems like something is right. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size=(64, 64),; x=(-10, 10), y=(0, 5),; topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2); grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). damping_rate = 1/100 # relax fields on a 100 second time-scale; const y0 = 0 # center point of sponge; const dy = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((y - y0) / dy)). vh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935:60,adapt,adapt,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935,1,['adapt'],['adapt']
Energy Efficiency,"Thanks @glwagner for the quickly and in depth rely!. I don't know the details of AEL but sounds interesting, and complicated. I think what I am suggesting is much simpler, but certainly related. Maybe this could be a first step in that bigger problem? . Starting simple, `ShallowWaterModel` would be the place to start as it only has horizontal coordiantes and so there would not need to be any need (I don't think) to create any new operators. The steps to do this could include the following:. - [ ] Create a dispatch between `ConservationForm` and `VectorInvariantForm` (similar to `HydrostaticModel` I presume); - [ ] Define a new grid, maybe called `BoundaryFollowingGrid`; - [ ] Merge the two together. Could it be that easy? If @glwagner could help with the dispactching between the two forms, then I think I could borrow heavily from `HydrostaticModel` to put together the right equations. As a bonus, this would also allow us to do `SphericalShallowWater` free of charge. . As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in `xz` space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. Actually Allistair had some great news of a class he taught at MIT on the MITgcm, that explaines it very well. I know as that's where I learned it from. . But as per usual, maybe I will suggest doing shallow water first as it's easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133:973,charge,charge,973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133,1,['charge'],['charge']
Energy Efficiency,"Thanks @simone-silvestri !. I had to do a few changes, replace `Int` with `Float`, and manually exclude the halo regions in mask, but in the end I was able to make an animation. . I am including my code below.; ```; mask = Float32.(file[""grid/immersed_boundary/mask""][5:end-4,4:end-4,1]); mask[mask .== 1] .= NaN. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = @lift(file[""timeseries/ζ/"" * string($iter)][:, :, 1] + mask). title = @lift(@sprintf(""Vorticity in Shallow Water Model at time = %s"", prettytime(file[""timeseries/t/"" * string($iter)]))); fig = Figure(resolution = (2000, 1000)); ax = Axis(fig[1,1], xlabel = ""longitude"", ylabel = ""latitude"", title=title). heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:green). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011:774,green,green,774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011,1,['green'],['green']
Energy Efficiency,"Thanks @simone-silvestri . I agree. I changed my list to a checked boxes, to help with monitoring the progress. I can also change the main script to go back to volumes, if we decide this is what we perfer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1166146068:87,monitor,monitoring,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1166146068,1,['monitor'],['monitoring']
Energy Efficiency,Thanks @simone-silvestri for adding a GPU test for `FieldTimeSeries`! I've adapted it correctly now and tests pass locally so I think this PR is ready for review. Actually I should add a test that uses the new kwargs. Would do a test where multiple threads open the same `FieldTimeSeries` but don't think we have multi-threaded tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158:75,adapt,adapted,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158,1,['adapt'],['adapted']
Energy Efficiency,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:512,adapt,adapt,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['adapt'],['adapt']
Energy Efficiency,"Thanks for linking to the papers, we consulted them a while back but forgot to reference them in the documentation. Another needed change is that I incorrectly use the term geopotential. . We can definitely put them in a separate package, I'm sure someone else might find it useful. We might still need to have a separate version for ourselves that integrates with `CellField`s, pre-allocated wavenumbers, and integrates the DCT with the time stepping on the GPU. So might be better if we just spawn off a package as the core functionality of solving the poisson equation can be done in a small amount of code and doesn't need frequent updates.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469315731:383,allocate,allocated,383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469315731,1,['allocate'],['allocated']
Energy Efficiency,"Thanks for the link!. Hmmm, maybe the better approach without be to try using the `@stencil` abstraction on a smaller problem like a Laplacian kernel and once that works efficiently, try the Oceananigans kernels again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/442#issuecomment-538481053:170,efficient,efficiently,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442#issuecomment-538481053,1,['efficient'],['efficiently']
Energy Efficiency,Thanks for the useful link. That makes sense that it's all about efficient memory arrangement. Since it's a micro-optimization I'll mark it as wontfix and revisit when we have a model that runs on GPUs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462555060:65,efficient,efficient,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462555060,1,['efficient'],['efficient']
Energy Efficiency,"Thanks, @hdrake, for bringing up this important point. I guess we should also remember that the sorting procedure is only an approximation to the actual calculation of background potential energy. It's super useful and easy in most cases, so most people jump straight to that, but the more ""proper"" calculation of BPE involves calculating the quantity `z_*`:. ![Screenshot from 2021-05-11 18-44-11](https://user-images.githubusercontent.com/13205162/117906167-3edf0900-b289-11eb-9f0e-a4b7accab2a0.png). from [Winters et alia, (1995).](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/available-potential-energy-and-mixing-in-densitystratified-fluids/A45F1A40521FF0A0DC82BC705AD398DA). I think calculating BPE this way still has some complications, but at least I believe the calculation is unique. It might be the preferred for cases with topography, stretched grids, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174:189,energy,energy,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839372174,2,['energy'],"['energy', 'energy-and-mixing-in-densitystratified-fluids']"
Energy Efficiency,"Thanks, @tomchor ! ; Is that a reason why you define the closure for the coarse_model?. Until now, what I was doing was something like this. ```julia; for i = 1:10:model.Nz; key = Symbol(""xy"", i) # Create the dictionary key dynamically; fname = ""vxy_z$(@sprintf(""%05d"", i)).nc""; simulation.output_writers[key] = NetCDFOutputWriter(model, output_fields,; schedule = TimeInterval(output_interval),; filename = fname,; indices = (:,:,i),; with_halos = false,; overwrite_existing = overwrite_existing,; array_type = Array{Float32}); end; ```; Which creates a file for each subset level. While I think that @tomchor solution is the best because it is more general and can be for any arbitrary new grid, I still think we should also be able to simply pass the indices to `NetCDFOutputWriter`. For example, this should work. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; indices = (:,:,1:10:model.Nz),; overwrite_existing=true,). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091084470:354,schedul,schedule,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091084470,3,['schedul'],['schedule']
Energy Efficiency,That code allows two things that would not be possible with `maximum(parent(f.data))`. - it returns a `ReducedField` instead of an Array if `dims != :`; - it is possible to perform a conditional reduction which means that we can remove immersed cells from the reduction. It can be done in another way though if it errors... when do you find the error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870:103,Reduce,ReducedField,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870,1,['Reduce'],['ReducedField']
Energy Efficiency,"That error is a weird way to say that the file was not found. I moved around a few things and maybe some of those didn't stick. I'll get it working. Yes, I think we should merge this before arbitrary tracers. I think you're right that we should reduce `test_step!`. I'll request another review when I make the changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542412461:245,reduce,reduce,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542412461,1,['reduce'],['reduce']
Energy Efficiency,"That solution looks pretty good!. As far as I can tell I think it makes sense for the ""full"" pressure field to continue smoothly into the IB, since the pressure field is somehow a solution to Poisson's equation --- even if the RHS of the Poisson equation varies rapidly close to the IB (?). Does the magnitude of the velocity error scale with the time-step, or resolution? Perhaps plotting the dependence of the error on some of those parameters can give us confidence that the method is working as expected. Should we try iterating the IB correction + pressure solve to see if it reduces the velocity error, as we hypothesized it might?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738270609:581,reduce,reduces,581,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738270609,1,['reduce'],['reduces']
Energy Efficiency,"That was for sure a problem, we want both bathymetry and `h` to be positive (I changed it in the later commit) It still NaNs very quickly though. . It is for sure vanishing `h`... if I displace the bathymetry by 400 meters, it's stable",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129196732:216,meter,meters,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129196732,1,['meter'],['meters']
Energy Efficiency,That was just an example. There's a lot of erroneous usage. This might help:. ```; (base) gregorywagner:src/ (glw/fix-adapt) $ grep -r unroll ./* [11:11:55]; ./Advection/Advection.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./BoundaryConditions/fill_halo_regions_open.jl:# and need to unroll a loop over the boundary normal direction.; ./BoundaryConditions/fill_halo_regions.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_flux.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl: @inbounds @unroll for k = 1:target_grid.Nz; ./Fields/regridding_fields.jl: @unroll for k_src = k₋_src:k₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for j = 1:target_grid.Ny; ./Fields/regridding_fields.jl: @unroll for j_src = j₋_src:j₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for i = 1:target_grid.Nx; ./Fields/regridding_fields.jl: @unroll for i_src = i₋_src:i₊_src-1; ./Fields/field_boundary_buffers.jl:using KernelAbstractions.Extras.Lo,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155:118,adapt,adapt,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155,1,['adapt'],['adapt']
Energy Efficiency,That's a good point. Upon further inspection I can see that indeed the time step wizard increases Δt past that 100 s at some point. I ran the same set-up for a fixed `Δt=10` (also for 10 days) and the energy increased by a factor of 5. Definitely better! But it still seems too large of an increase for a quasi-quiescent run for such a short period of time for me. I'd expect something in the single-digit percentages...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442553443:201,energy,energy,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442553443,1,['energy'],['energy']
Energy Efficiency,"That's great news @ali-ramadhan . I guess by looking at your code I can learn how to adapt it to `ShallowWaterModel`. Maybe I will start by doing some tests for the two-dimensional turbulence example, or has someone done that already? By that I mean checking scalabiilty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921:85,adapt,adapt,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921,1,['adapt'],['adapt']
Energy Efficiency,That's great. So the differences between this and `KernelComputedField` are the here we can reduce on the fly and we don't need to define a `getindex` method?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827802530:92,reduce,reduce,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827802530,1,['reduce'],['reduce']
Energy Efficiency,"That's very nice @apaloczy, thank you! I have to think about it more but I think the hypothesis is rational: there is an unavoidable error associated with step topography, but the error can be reduced by using partial cells vs full cells. If that holds this would be an excellent case to use to motivate/develop cut cells. Note there are a few articles that suggest the same:. - [How slippery are piecewise-constant coastlines in numerical ocean models?](https://www.tandfonline.com/doi/abs/10.3402/tellusa.v50i1.14514); - [Sliding or Stumbling on the Staircase: Numerics of Ocean Circulation Along Piecewise-Constant Coastlines](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2022MS003594). This could be a good bona fide example I think. We only have an internal tide example now, right? But definitely a validation test otherwise.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2273594015:193,reduce,reduced,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2273594015,1,['reduce'],['reduced']
Energy Efficiency,"The ""long line"" issue is not just a problem for diff's by the way. I use a text editor (and many others do too) in which navigation is performed by the keyboard. Navigating to the middle of an extremely long line is annoying and time consuming (I could possible build in shortcuts that jump many words at at time for that... but I haven't). Code navigation is more efficient (for me) when the lines are short and I can navigate through the text by jumping lines.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470523539:365,efficient,efficient,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470523539,1,['efficient'],['efficient']
Energy Efficiency,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:272,energy,energy,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272,1,['energy'],['energy']
Energy Efficiency,"The basic munerics of oceananigans is the same as MITgcm: we use a scheme; which conserves tracer variance: e.g. D/Dt (T**2) = exactly 0 in the; absence of sources and sinks. This is ensured by just taking the average of; the T between adjacent boxes when one is computing the flux of T across the; cell face. This is true even in the vertical when del_z is not constant.; John. On Tue, Oct 22, 2019 at 1:41 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Is the idea that there is some kind of compromise with putting the u-points; > at the ""center"" of the u control volumes, versus putting the tracer; > points at the center of the tracer control volumes? I see that it is; > impossible to achieve both.; >; > In other words, certain assumptions about ""interpolation"" are baked into; > the interpolation operators (we do not do a true interpolation between the; > different grids for u, v, w, etc).; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/491?email_source=notifications&email_token=AKXUEQRCTHJHAZRI5GKCT6TQP43NXA5CNFSM4JDC6IX2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEB6S3NQ#issuecomment-545074614>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSMDJBGJELHENZ6XVLQP43NXANCNFSM4JDC6IXQ>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-545300631:1472,Green,Green,1472,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-545300631,1,['Green'],['Green']
Energy Efficiency,"The boundary condition functions should have the arguments `x, y, t, p` (no `z`!) so. ```julia; Qᵘ(x, y, t, p) = radius(x, y) < p.L ? imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; Qᵛ(x, y, t, p) = radius(x, y) < p.L ? - real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; ```. You may also want to tag functions with `@inline` and use `ifelse` rather than the shortcircuiting ternary `? :` for performance:. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline U(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = ifelse(d(x, y) < p.L, +imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = ifelse(d(x, y) < p.L, -real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; ```. Is `U` air speed? We sometimes recommend using the momentum flux itself as an input, rather than introducing a bulk formula (like a drag law) because this reduces the number of parameters in the problem (making it easier to understand and reproduce) --- but that's up to you. Here you could write. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline s(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, +imag(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, -real(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; ```. or something like that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300:983,reduce,reduces,983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300,1,['reduce'],['reduces']
Energy Efficiency,"The change is great!. Before merging, the code needs to be proofread to remove formatting inconsistencies. I may not have caught all of them, so I think it'd be good to look over every file individually. It may be more efficient in the future to issue search and replace in individual files, so the change sites can be inspected at that time (except in lucky cases where the replaced pattern has the same number of characters as the original one, like incompressible -> nonhydrostatic).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1884#issuecomment-884797579:219,efficient,efficient,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1884#issuecomment-884797579,1,['efficient'],['efficient']
Energy Efficiency,"The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way. Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803:44,allocate,allocates,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803,3,"['allocate', 'reduce']","['allocate', 'allocates', 'reduce']"
Energy Efficiency,The default now it `Implicit` right? I think `SplitExplicit` will be more efficient. `Implicit` is done on only one GPU while split explicit takes advantage of all the workers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1998700298:74,efficient,efficient,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1998700298,1,['efficient'],['efficient']
Energy Efficiency,"The discussion about molecular viscosity being resolved/modeled physics is a deep one. Probably too deep for a github issue. After many discussions with Jim McWilliams he managed to convince me that the only difference between the modeling of eddy versus molecular diffusion is scale separation between processes. The issue about always keeping a more rigorous set of equations and including the molecular diffusivity by default (even though it's probably not important in the vast majority of cases) is one of many modeling philosophies. I highly recommend the paper by [Kerry Emanuel](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2019AV000129). It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:959,energy,energy,959,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802,1,['energy'],['energy']
Energy Efficiency,"The issue with the power method is that its convergence depends on the _difference_ between the two largest eigenvalues, and this can be really slow. Arnoldi iteration does a lot better, and gives you multiple eigenmodes. I think it should also be easy to add since most implementations (including ArnoldiMethod.jl, it looks like) are matrix-free. Directly calculating the full spectrum might be harder -- Dedalus can do this because it forms sparse matrices for the global linear operator, but I don't think oceananigans does this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731279135:19,power,power,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731279135,1,['power'],['power']
Energy Efficiency,"The issues with the `HydrostaticFreeSurfaceModel` are the tendency kernels. The difference with the non-hydrostatic model is that we do not know a priori which RHS function to call (for example CATKE has an `:e` tracer that requires a different RHS function and the same goes with a 1 equation parameterization of mesoscales that evolves an additional tracer equation for the mesoscale energy `:K`). Our solution now is to infer the RHS function and pass it as an argument to the kernel. Apparently, this prevents compilation. I ll come up with a solution today",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926:386,energy,energy,386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926,1,['energy'],['energy']
Energy Efficiency,"The library computes the derivatives that are required to compute the tendencies, but they are not stored since that would not be very efficient. Getting some of these values but I don't know what that would look like. Also, if you are not computing this field at every time step, the cost of computing it sepratelyl might not be that high, but that of course depends on the particular problem you are dealing with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025:135,efficient,efficient,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025,1,['efficient'],['efficient']
Energy Efficiency,The memory savings is a major advantage of this closure over `AnisotropicMinimumDissipation` for problems with very large numbers of tracers (eg biogeochemistry problems with 10+ tracers). Note also that there is overhead to launching a kernel which cannot be ignored --- we can't estimate computational cost just by adding the number of operations. Typically (though not always) our goal is to reduce the number of kernel launches as much as possible.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419789153:395,reduce,reduce,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419789153,1,['reduce'],['reduce']
Energy Efficiency,"The notes look great! . One question though. In your definition for the reduced gravity, why not divide by $\rho_j$ instead of $\rho_{j+1}$, since that's what naturally apprears in the pressure graident term? I know that because the densities are almsot the same, it won't matter much, but it is not clear why you make this approximation when you don't need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348:72,reduce,reduced,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348,1,['reduce'],['reduced']
Energy Efficiency,"The only parts of the solver algorithm that require communication between nodes are `norm` and `dot`, right?. The ""matrix product"" --- a Poisson operator for us --- has unavoidable communication as well. But, we should be able to keep this limited in scope and we only need 1 halo. The trickier part where I think there is room for significant optimization is in the development of an effective multi-GPU preconditioner that is also efficient in parallel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386795222:433,efficient,efficient,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386795222,1,['efficient'],['efficient']
Energy Efficiency,"The problem is in the calculation of the linear operator. ```; @inline ∫ᶻ_Ax_∂x_ηᶠᶜᶜ(i, j, k, grid, ∫ᶻ_Axᶠᶜᶜ, η) = @inbounds ∫ᶻ_Axᶠᶜᶜ[i, j, k] * ∂xᶠᶜᶜ(i, j, k, grid, η); @inline ∫ᶻ_Ay_∂y_ηᶜᶠᶜ(i, j, k, grid, ∫ᶻ_Ayᶜᶠᶜ, η) = @inbounds ∫ᶻ_Ayᶜᶠᶜ[i, j, k] * ∂yᶜᶠᶜ(i, j, k, grid, η); ```. These functions are evaluated at `k = 1` because they are reduced fields, but in the example script at `k=1` there is an immersed boundary. Hence the conditional derivatives get triggered returning a 0 where there shouldn't be any. We need to have reduced fields with the correct location (in this case for the free surface the field is located at `grid.Nz`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1224045899:340,reduce,reduced,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1224045899,2,['reduce'],['reduced']
Energy Efficiency,"The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size . for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz`; for a `(Center, Center, Nothing)` it will be of size `Ny`. For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937:58,reduce,reduced,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937,4,['reduce'],['reduced']
Energy Efficiency,"The problem is not with the reduction but with derivatives that act on reduced fields.; The reductions are not an issue, because by performing a reduction we know what operation leads us to a reduced field, so we can perform the reduction accordingly (for example we exclude immersed cells from reductions). . When performing a derivative we use all three indices regardless of the field being reduced or not. ; In this case we get a funky result where we are trying to evaluate a derivative at `k == 1` for a reduced field that does not necessarily live at `k == 1`. In other words, the assumption that the field lives at `k == 1` is wrong for a reduced field; the right solution, on the other hand, is not so clear cut:. If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708:71,reduce,reduced,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708,9,['reduce'],['reduced']
Energy Efficiency,"The problem is this iteration:. ```julia; [ Info: Iter: 32, time: 300 ms , u-avg: 2.5442761423093008, window_start_time: 0.28, window_start_iteration: 30, previous_collection_time: 0.3, fetch_operand: true, interval: 0.03, previous_interval_stop_time: 0.27, collecting: true; ```. We should have `collecting: false`. That means `end_of_window`. https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/OutputWriters/windowed_time_average.jl#L270. spuriously returns `false`. https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/OutputWriters/windowed_time_average.jl#L93. So we want to look at `model.clock.time` and `sch.previous_interval_stop_time + sch.interval`. It does seem probable the issue is roundoff error. Probably `AveragedTimeInterval` needs to be updated to align more with the (new) criteria currently being used for `TimeInterval` eg we need a similar criteria as used for `next_actuation_time`:. https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/Utils/schedules.jl#L56-L61. Would be helpful to have a test too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2264548157:1083,schedul,schedules,1083,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2264548157,1,['schedul'],['schedules']
Energy Efficiency,There is no adapt method for the model. I don't know how it would play to send the whole model to the GPU. We might have some parameter space issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517:12,adapt,adapt,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517,1,['adapt'],['adapt']
Energy Efficiency,"There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. The problem can be fixed by dispatching the main constructor for `Average` on `Union{Field, Computation}`. I am ok with this restriction of `Average`. However, it's worth noting that it's changes its capability. Previously, `Average` would work with anything that defines `parent` and `architecture`, including arbitrary user-defined types (this is why it works with `Computation`s, for example). With this change, it will only work with types that are specifically allowed by the constructor. Partly I think the underlying motivation for this PR could suggest we need to put a bit more effort into streamlining the user interface to `AbstractOperations` and `Computation`s. For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. We may also need to spend some more time refining the `Field` abstraction, and formalizing the connection between `Field`s and other similar objects like `Computation`s and `Average`s. In that case, we could define `Computation` as a subtype of `AbstractField`, and dispatch on `AbstractField` in the constructor for `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389:1031,allocate,allocated,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,There was some power interruption at MIT. Now it's fixed but probably someone has to go turn on Sverdrup (where the GPU tests run on).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216054364:15,power,power,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216054364,1,['power'],['power']
Energy Efficiency,"There's some info in CUDA docs but it doesn't explicitly answer my question:. > For small integer powers (e.g., x2 or x3), explicit multiplication is almost certainly faster than the use of general exponentiation routines such as pow(). While compiler optimization improvements continually seek to narrow this gap, explicit multiplication (or the use of an equivalent purpose-built inline function or macro) can have a significant advantage. This advantage is increased when several powers of the same base are needed (e.g., where both x2 and x5 are calculated in close proximity), as this aids the compiler in its common sub-expression elimination (CSE) optimization. So maybe we shouldn't square at all here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593:98,power,powers,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593,2,['power'],['powers']
Energy Efficiency,"There's two challenges. One is refactoring `Reduction` to be more general. `cumsum!` has a diffeerent pattern, the dimensionality is not reduced for the output and it has a slightly different syntax. But I figured that stuff out here:. https://github.com/CliMA/Oceananigans.jl/pull/3590. The next challenge is to figure out how to integrate downwards rather than up; this is a little trickier I think because we may need an abstraction that reverses indices or something. There is also the metric part but that's kind of trivial, its the same thing as with `Integral` or `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956:137,reduce,reduced,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956,1,['reduce'],['reduced']
Energy Efficiency,"These are exported types that got renamed: `EnergyConservingScheme` -> `EnergyConserving`, `EnstrophyConservingScheme` -> `EnstrophyConserving`,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1780255367:44,Energy,EnergyConservingScheme,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341#issuecomment-1780255367,2,['Energy'],"['EnergyConserving', 'EnergyConservingScheme']"
Energy Efficiency,"These are good points. I'll close the issue. I hope you don't mind if I use your comments in the documentation under the adaptive time-stepping section. I ended up finding other ways to transition to turbulence in a stable manner using `TimeStepWizard` as is, e.g. either increasing the CFL with time; ```julia; cfl(t) = min(0.005*t, 0.1); wizard.cfl = cfl(model.clock.time); ```; or changing the number of time steps between adaptive time steps with time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520902324:121,adapt,adaptive,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520902324,2,['adapt'],['adaptive']
Energy Efficiency,"Thinking about this a bit more --- do we need to use `mapreduce` at all? Supposedly `mean` will take an iterator as an argument:. ```julia; help?> mean; search: mean mean! median median! SegmentationFault macroexpand @macroexpand @macroexpand1 Meta numerator enumerate timedwait promote_shape MethodSummary. mean(itr). Compute the mean of all elements in a collection.; ```. Does this mean we can use `AbstractOperations` directly in `mean` (if they iterate correctly?) . This may also provide a way to compute correct averages on-the-fly on stretched grids, combined with #1452 (which we haven't discussed yet). I might be missing something about specifically how we would use `mapreduce`. As a side note, if we do need to use `mapreduce`, we may want to use `Base.mapreducedim!` (which stores results in a previously allocated array, as I think we want).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1422#issuecomment-811595869:819,allocate,allocated,819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422#issuecomment-811595869,1,['allocate'],['allocated']
Energy Efficiency,"Thinking about this a bit more, I think we can actually just define `IsotropicDiffusivity` and `AnisotropicDiffusivity`, and use dispatch to produce the appropriate behavior when the specific diffusivity is either a constant or a function. In other words, the user can write. ```julia; closure = IsotropicDiffusivity(κ = 1.0); ```. or. ```julia; closure = IsotropicDiffusivity(κ = (x, y, z, t) -> 1.0 * exp(z / 10)); ```. and correct behavior will result. Perhaps we should just assume the diffusivity is also a function of time for maximum generality. While we are mutilating the API, does it make sense to use a more verbose terminology than ""`κ`"" and ""`ν`""? We might instead use. ```julia; closure = IsotropicDiffusivity(tracers = 1.0, velocities = 2.0); ```. or something like that. This might not be a good idea, since it could actually reduce readability. Not sure. This is a major change to the API. However, we can ease the transition by providing the aliases `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` that reproduce previous behavior, if we want. @ali-ramadhan curious what you think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/781#issuecomment-652495375:842,reduce,reduce,842,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/781#issuecomment-652495375,1,['reduce'],['reduce']
Energy Efficiency,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:345,adapt,adaptive,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,2,"['adapt', 'allocate']","['adaptive', 'allocated']"
Energy Efficiency,"This PR was created yesterday to start a discussion about how we might want to change the input arguments for `VerticallyStetchedRectilinearGrid`. After some disucssion there is no concensus that a chance should be made so I'm going to close this PR. . I think it's better that users get to play with stretched grids in any or all dimensions sooner rather than later. Hence, I'm going to return to #1532 and change the arguments to be inline with what `VerticallyStretchedRectilinearGrid`. . One change that I would like to make is instead of having `zF` as input, I would prefer to have `zFs` or even `zFaces`, to emphasize that all the faces are specified. Usually, when I see `zF` I think of a face, and that's not the case here. @tomchor , what do you think about this?. When users have played with grid stretching we will be better able to asses from experience what is good for the user, and we will be able to adapt to that in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518:917,adapt,adapt,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518,1,['adapt'],['adapt']
Energy Efficiency,"This illustrates the bug (slightly overpowered, because I was trying to figure out what's going wrong):. ```julia; using Oceananigans; using GLMakie. grid = RectilinearGrid(size=3, halo=3, z=(0, 1), topology=(Flat, Flat, Bounded)). c_bottom_bc = ValueBoundaryCondition(1); c_bcs = FieldBoundaryConditions(bottom=c_bottom_bc); closure = ScalarDiffusivity(κ=1). model = HydrostaticFreeSurfaceModel(; grid, closure,; tracers = :c,; buoyancy = nothing,; boundary_conditions=(; c=c_bcs)). simulation = Simulation(model, Δt=1e-2, stop_iteration=100). filename = ""simple_tracer_output_test.jld2""; simulation.output_writers[:c] = JLD2OutputWriter(model, model.tracers; filename,; schedule = IterationInterval(1),; overwrite_existing = true,; with_halos = true). # Evaluate c on boundary; using Oceananigans.Operators: ℑzᵃᵃᶠ. function show_boundary_c(sim); c = sim.model.tracers.c; cb = ℑzᵃᵃᶠ(1, 1, 1, grid, c); @info string(""Iter: "", iteration(sim), "", c(z=0): "", cb); return nothing; end. simulation.callbacks[:show] = Callback(show_boundary_c). run!(simulation). ct = FieldTimeSeries(filename, ""c""). t = ct.times; grid = ct.grid; Nt = length(t); cb = zeros(Nt); for n = 1:Nt; cn = ct[n]; cb[n] = ℑzᵃᵃᶠ(1, 1, 1, grid, cn); end. fig = Figure(); ax = Axis(fig[1, 1], xlabel=""Iteration"", ylabel=""c""); lines!(ax, ct[1, 1, 0, :], label=""c[0]""); lines!(ax, cb, label=""c(z=0)""); lines!(ax, ct[1, 1, 1, :], label=""c[1]""); axislegend(ax); display(fig); ```. giving. <img width=""396"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/f9d97246-0cc1-4185-a346-590a0f7357f1"">. yellow is `c` interpolated to the boundary --- which should be 1 always (as the `show_boundary_c` illustrates is true online). the blue is the halo value, which should not be 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689894462:672,schedul,schedule,672,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689894462,1,['schedul'],['schedule']
Energy Efficiency,This is a lot more sustainable than adding new properties to every output writer every time we want to support splitting a file by a different criterion. It's a decent change to the user interface. I can help if you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454:19,sustainab,sustainable,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454,1,['sustainab'],['sustainable']
Energy Efficiency,"This is about more than just defining inuitive behavior, though. Executing a callback at iteration 0 might be considered a feature. However, I think that sometimes it's not desired. In reality, what we are missing is the concept of callback ""initialization"" (we are also missing the concept of callback ""finalization""). Right now, we use the hack that ""calling at iteration 0"" is tantamount to initialization. I think we should discuss how to generalize our design to something more sustainable...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233490967:483,sustainab,sustainable,483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233490967,1,['sustainab'],['sustainable']
Energy Efficiency,"This is an API change but it won't reduce source code. For `(1, 2)` (eg `HorizonalDirections()`) we use [a scheme from MITgcm](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation) with special conservation properties (eg conserves potential vorticity), whereas for `(1, 2, 3)` we use the standard 3D isotropic formulation in terms of the strain tensor. Each case `1`, `2`, `3` has to be written out because our code isn't written to be ""n-dimensional""; instead we write out `x, y, z` explicitly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2265#issuecomment-1047303258:35,reduce,reduce,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2265#issuecomment-1047303258,1,['reduce'],['reduce']
Energy Efficiency,"This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this:; lambda=1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0)));; end",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082373016:488,meter,meters,488,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082373016,1,['meter'],['meters']
Energy Efficiency,"This is interesting. I like the concept of reusing the `scheme` kwarg. But I think this isn't sustainable given the future planned changes to the advection scheme API, right? Ie an ""advection scheme"" is going to be more comprehensive. Also, it doesn't make sense unless we are using vector invariant. Another possibility is to add another kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1240862371:94,sustainab,sustainable,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1240862371,1,['sustainab'],['sustainable']
Energy Efficiency,"This issue appears to have magically disappeared on 0.71.6 and with Julia 1.6.5:. ```julia; gregorywagner:examples/ (glw/indices✗) $ julia --project [7:02:02]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(64, 64), extent=(1, 1), topology=(Periodic, Periodic, Flat));. julia> c = CenterField(grid); averaged_c = Field(Average(c, dims=1)); 1×64×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 64, 1); ├── grid: 64×64×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 1×1×0 halo; ├── operand: mean! over dims (1,) of 64×64×1 Field{Center, Center, Center} on RectilinearGrid on CPU; └── status: time=0.0. julia> @time compute!(c); 0.000297 seconds (1.08 k allocations: 103.719 KiB, 78.90% compilation time). julia> @time compute!(c); 0.000005 seconds; ```. I'm also not sure why the timings previously were so slow. It's more appropriate now:. ```julia; julia> using Statistics. julia> a = rand(64, 64);. julia> @time mean(a, dims=1); 0.297254 seconds (781.27 k allocations: 44.972 MiB, 5.28% gc time, 99.97% compilation time); 1×64 Matrix{Float64}:; 0.516131 0.572081 0.497259 0.422505 0.505043 0.453625 … 0.511134 0.52023 0.443803 0.503798 0.497578 0.501285. julia> @time mean(a, dims=1); 0.000014 seconds (7 allocations: 1.203 KiB); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059771534:711,reduce,reduced,711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059771534,1,['reduce'],['reduced']
Energy Efficiency,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:110,reduce,reduce,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107,1,['reduce'],['reduce']
Energy Efficiency,"This issue is cropping up now that we regularly timeout on Travis (max runtime is 50 minutes) and we almost always time out on GitLab GPU CI (max runtime is 60 minutes, @maleadt might be able to increase that but it's a shared resource and we probably shouldn't be hogging it up). Surprisingly Appveyor is always fast now. I think free CI servers are just generally underpowered. We definitely want to keep our tests and make them even more comprehensive so here are some ideas we can discuss (probably in January):; 1. See if we can move Travis CI pipelines onto Azure DevOps. They seem to give out more runtime (up to 360 minutes I think) although they might always reduce that in the future if they get more users. CliMA and @simonbyrne seem to be having a good experience with Azure.; 2. Split tests into a fast smaller test set (regression only?) and the full comprehensive test set. But we still need a place to run the comprehensive test set (maybe Azure runs the comprehensive tests?). We'll probably have to do this at some point.; 3. Split up the tests into jobs that run in <50 minutes each. You can have unlimited jobs on Travis. But this feels like a lot of work to set up and the tests would still take long as you can't have that many parallel builds. We'll have to test Oceananigans + MPI pretty soon but we can worry about that later. Slurm CI or setting something up with our 4xTitan V server might be a good option here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566810671:668,reduce,reduce,668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566810671,1,['reduce'],['reduce']
Energy Efficiency,This kind of error arises when using the environment on the branch `integrate-turbulence-closures`:. ```juliarepl; (Oceananigans) pkg> st; Project Oceananigans v0.5.4; Status `/archive1/glwagner/Projects/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v0.4.2; [c5f51814] CUDAdrv v3.0.1; [be33ccc6] CUDAnative v2.1.1; [3a865a2d] CuArrays v1.0.2; [7a1cc6ca] FFTW v0.2.4; [ba82f77b] GPUifyLoops v0.2.3; [4138dd39] JLD v0.9.1; [30363a11] NetCDF v0.7.3; [90137ffa] StaticArrays v0.10.3; [a759f4b9] TimerOutputs v0.5.0; [8ba89e20] Distributed ; [37e2e46d] LinearAlgebra ; [de0858da] Printf ; [9a3f8284] Random ; [10745b16] Statistics ; [8dfed614] Test ; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496478250:246,Adapt,Adapt,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496478250,1,['Adapt'],['Adapt']
Energy Efficiency,"This looks like a symptom of a larger problem and, indeed, does not seem to be tested. ; I think to solve it we should fix the time-indexing of reduced FTS. We seem to be missing the 4D indexing of reduced FTS:; ```julia; @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, j, 1, memory_index(f, n)); @propagate_inbounds getindex(f::XZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, 1, k, memory_index(f, n)); @propagate_inbounds getindex(f::YZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, 1, j, k, memory_index(f, n)); ```; to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L108). and the 2D-Time indexing of reduced FTS; ```julia ; @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, time_index::Time) = getindex(f, i, j, 1, time_index); @propagate_inbounds getindex(f::XZFTS, i::Int, k::Int, time_index::Time) = getindex(f, i, 1, k, time_index); @propagate_inbounds getindex(f::YZFTS, j::Int, k::Int, time_index::Time) = getindex(f, 1, j, k, time_index); ```; maybe to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L116). and all the respective methods for 1D and 0D FTS.; In theory, the boundary conditions should work as intended. Indeed, we should add a test for it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251176411:144,reduce,reduced,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251176411,3,['reduce'],['reduced']
Energy Efficiency,"This may be a caveat about attempting to solve fluids problems with single precision. For example [these authors](https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.036315) report issues running two-dimensional turbulence simulations at single precision. You may ameliorate issues with round-off error and finite precision by perhaps using a different (non-)dimensionalization of the equations of motion, parameters, and initial conditions. I'm not sure that avenue is worth investigating, however --- it's up to the user. I think you can be reasonably sure that if a calculation is correct in double precision, then the algorithm is correct at single precision as well. Round-off errors will become a problem *at some point* as you reduce the precision of your calculation, no matter what.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/55#issuecomment-465308737:740,reduce,reduce,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/55#issuecomment-465308737,1,['reduce'],['reduce']
Energy Efficiency,This may help https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178:42,Adapt,Adapt,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178,1,['Adapt'],['Adapt']
Energy Efficiency,"This now spits out; ```julia; julia> grid = RectilinearGrid(size = (16, 2, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×2×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.5; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid, advection = WENO());; [ Info: User-defined advection scheme WENO reconstruction order 5 reduced to WENO reconstruction order 3 in the y-direction to comply with grid-size limitations.; ┌ Warning: Inflating model grid halo size to (3, 2, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/development/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:250. julia> grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×1×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid, advection = WENO());; [ Info: User-defined advection scheme WENO reconstruction order 5 reduced to Nothing in the y-direction to comply with grid-size limitations.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310743910:578,reduce,reduced,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310743910,2,['reduce'],['reduced']
Energy Efficiency,"This paper describes a ""cell merging"" technique that can help reduce problems with very small cells: https://journals.ametsoc.org/view/journals/mwre/138/10/2010mwr3252.1.xml?tab_body=abstract-display. There are also some citations in there about an alternative method that they call the ""thin wall"" method.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1595648745:62,reduce,reduce,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1595648745,1,['reduce'],['reduce']
Energy Efficiency,This script:. https://github.com/glwagner/ColumnModelOptimizationProject/blob/master/les/simple_flux.jl. shows how to use the JLD2OutputWriter to calculate horizontal averages efficiently on the GPU. edit: I missed your point about not including the halos.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519589331:176,efficient,efficiently,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519589331,1,['efficient'],['efficiently']
Energy Efficiency,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860:331,allocate,allocate,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860,1,['allocate'],['allocate']
Energy Efficiency,"This would actually be good to work on since a `minimum`, `mean`, etc. that works seamlessly for CPU and GPU would reduce a lot of headaches and accidental CUDA scalar operations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1117#issuecomment-779523805:115,reduce,reduce,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1117#issuecomment-779523805,1,['reduce'],['reduce']
Energy Efficiency,"Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2453,Adapt,Adapt,2453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Energy Efficiency,"To address the first issue, here's the definition of `time_average_outputs`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L11-L16. The arguments are the specified `schedule` (which is an `AveragedTimeInterval` per the API we have designed), the `outputs` (here a `Dict`), `model`, and `field_slicer` (because we support averaging slices of fields). The first line:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L12-L13. converts the `outputs` `Dict` into a `Dict` of `WindowedTimeAverages` by wrapping each member of output in `WindowedTimeAverage`. The second part is to return the `TimeInterval` that corresponds to `AveragedTimeInterval`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L15. It'd be great to improve this functionality if we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599:249,schedul,schedule,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599,1,['schedul'],['schedule']
Energy Efficiency,To avoid `Manifest.toml` merge conflicts should we update NCDatasets.jl (#1217) and StaticArrays.jl (#1222) in this PR as well?. I actually don't think we use StaticArrays.jl...? I used it for the `WENO{N}` implementation but it's currently commented out until it can be made efficient (also users did not like the sympy dependency).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735389432:276,efficient,efficient,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735389432,1,['efficient'],['efficient']
Energy Efficiency,"To include an updatable friction velocity in the model constant calculation, we'd do something like. ```julia; @inline function van_driest_damping_function(x, y, z, p); # Position of first grid cell; z₀ = p.Δz₀ / 2; z₁ = 1 - p.Δz₁ / 2. # Distances to the wall, noting that `δ⁺₀` and `δ⁺₁` are `Ref`; d⁺₀ = (z - z₀) / p.δ⁺₀[]; d⁺₁ = (z₁ - z) / p.δ⁺₁[]; d⁺ = min(d⁺₀, d⁺₁). # Model constants; A⁺ = p.A⁺; C = p.C. return C * (1 - exp(d⁺ / A⁺)); end; # Find grid spacing at top and bottom, assuming rectilinearity; Nz = size(grid, 3); Δz₀ = zspacing(1, 1, 1, grid, Center(), Center(), Center()); Δz₁ = zspacing(1, 1, Nz, grid, Center(), Center(), Center()). δ⁺₀ = Ref(0.0) # allocate an updatable reference to `δ⁺` (for the top and bottom separately), which we will compute within a Callback; δ⁺₁ = Ref(0.0) # Reference to the bottom `δ⁺`. parameters = (C = 0.16,; A⁺ = 26, # :-D; Δz₀ = Δz₀, # vertical grid spacing at the bottom; Δz₁ = Δz₁, # vertical grid spacing at the top; δ⁺₀ = δ⁺₀,; δ⁺₁ = δ⁺₁) # function of molecular_diffusivity.ν. van_driest_damping = FunctionField{Center, Center, Center}(van_driest_damping_function, grid; parameters). # later... function compute_wall_length_scales!(sim); δ⁺₀[] = # computed as function of sim.model.velocities; return nothing; end. simulaton.callbacks[:length_scale_computation] = Callback(compute_wall_length_scales!); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1789395517:671,allocate,allocate,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1789395517,1,['allocate'],['allocate']
Energy Efficiency,"To me this looks like implementing arbitrary functions to replace a specific term in the momentum equations, which is kind of similar to #73 #85. . > I propose that we view a ""closure"" as the addition of a viscosity/diffusivity, even a constant isotropic 'molecular' diffusivity. Is a closure always meant to replace the viscous dissipation (𝜈∇²u) operators? Will Smag/AMD replace the Laplacian diffusion operators (e.g. κ∇²T) as well?. > In addition, we may need to implement special time-stepping methods that apply both to LES closures and diffusivities. Does this apply to constant/dynamic Smagorinsky or AMD?. > We may also want/need to implement LES closures that add additional 'tracers' (like subgrid scale turbulent kinetic energy) that have their own evolution equations. We'll do the easy 'eddy diffusivity' closures first, but we must keep in mind that including optional evolution equations for closure-specific tracers requires an implementation of an abstraction for equations (as discussed in #110). Out of curiousity, can these closures be framed as `ODEProblem`s using DifferentialEquations.jl?. > does that make sense?. Makes sense to me! If it's an arbitrary function then we should be able to implement any closure (or no closure which should produce inviscid flow?). > In order to calculate the stress divergence for eddy viscosities, therefore, we need the eddy viscosity at (Center, Center, Center) . With finite volume the interpolation operators (`avgx!`, `avgy!`, `avgz!`), applied correctly, should allow us to calculate the eddy viscosity at any location. Sounds like #115 (and https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471136259) should be resolved before this closure abstraction is merged in?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472004913:733,energy,energy,733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472004913,1,['energy'],['energy']
Energy Efficiency,"To my mind there are three main ways to approach this:. 1. design simulations such that the output can be directly compared with analytical solutions;; 2. design simulations such that the statistics of the output can be compared with theory; or; 3. design simulations to mimic published results. Option 1 restricts us to systems with tractable analytical solutions, but still contains a wealth of feasible problems, such as:; 1. Munk gyre; 2. Spin down of a flow-field under the influence of friction; 3. Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; 4. Rayleigh–Bénard convection (as mentioned previously); 5. Onset of baroclinic instability: compare growth rates with analytical predictions. Option 2 lets us explore dynamics in the presence of turbulence. Potential test cases here include:; 1. 2D QG turbulence: explore energy and enstrophy cascades; 2. lee wave generation and breaking (will require large-scale flow field and bathymetry). Option 3 lets you do whatever you want - you just need to find a published result and try to reproduce it. It's unlikely that you'll get the exact same answer, so this option is more difficult to implement in a testing framework that doesn't require eyeballs to validate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467159237:888,energy,energy,888,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467159237,1,['energy'],['energy']
Energy Efficiency,"Top: biharmonic diffusion. Bottom: WENO vector invariant with ""divergence damping"" with nu = 100 m^2 / s. Kinetic energy. ![image](https://user-images.githubusercontent.com/33547697/165781484-adc3d55d-bf58-4366-8cda-9565eb3ab5c1.png). Vorticity. ![image](https://user-images.githubusercontent.com/33547697/165783429-b40b86e4-4998-4140-855b-0fea58fe2a67.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112309201:114,energy,energy,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112309201,1,['energy'],['energy']
Energy Efficiency,Tried increasing the problem size by a factor of 8 to 512³. Scaling seems a bit better on Satori and a bit worse on Tartarus (some cores could have been in use by others). Maybe there's something fundamental limiting us to a ~10x speedup?. ```; Tartarus: Julia 1.5.0 + Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; 1 thread: 34.60 s; 4 threads: 12.00 s (2.88x); 8 threads: 7.00 s (4.94x); 16 threads: 4.93 s (7.02x); 24 threads: 4.59 s (7.54x); 32 threads: 4.25 s (8.14x); 40 threads: 4.06 s (8.52x); 48 threads: 4.19 s (8.26x) [some of the 48 cores were in use]. Satori: Julia 1.4.1 + IBM Power System AC922 (8335-GTH); 1 thread: 47.20 s; 4 threads: 21.70 s (2.18x); 8 threads: 11.30 s (4.18x); 16 threads: 7.16 s (6.59x); 32 threads: 5.40 s (8.74x); 64 threads: 4.29 s (11.0x); 128 threads: 4.14 s (11.4x); 160 threads: 4.02 s (11.7x); ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/869#issuecomment-682190586:588,Power,Power,588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/869#issuecomment-682190586,1,['Power'],['Power']
Energy Efficiency,"Try. ```julia; rescale_factor = CUDA.@allowscalar √(target_kinetic_energy / energy[1, 1, 1]) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2021702345:76,energy,energy,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2021702345,1,['energy'],['energy']
Energy Efficiency,Two questions:. > Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Is this one node or multiple nodes? . Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585:277,allocate,allocated,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585,1,['allocate'],['allocated']
Energy Efficiency,"Ultimately I think it’d be nice to build adaptive time stepping into the time step function itself, once we have time stepping methods that are well suited for it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520912411:41,adapt,adaptive,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520912411,1,['adapt'],['adaptive']
Energy Efficiency,"Unfortunately this example. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; coarse_u,), coarse_grid;; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. Throws the following error:. ```; ERROR: LoadError: DimensionMismatch: new dimensions (1, 1, 8, 1) must be consistent with array size 4; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing, Missing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:497,schedul,schedule,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['schedul'],['schedule']
Energy Efficiency,"Update: I have been able to reduce the error to be a procompiling error in oceananigans.jl:; ```; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; I have been trying to make sure that everything is up to date, and I am running on Julia version 1.9.2. My code is just; ```; using Oceananingans; ```; as I have been trying to get the library to load properly. Does anyone have any experience with this error or does it make things any clearer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372:28,reduce,reduce,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372,1,['reduce'],['reduce']
Energy Efficiency,"Update: we think this error arises because `CUDAnative` is not a dependency of `Oceananigans`. As a result, a `launch` function is not compiled by `GPUifyLoops`. In principle, this problem *could* be solved by adding `CUDAnative` to `Oceananigans`. However, this is not possible because `CUDAnative` and `CUDA` (which `Oceananigans` currently uses for CUDA functions / abstractions) cannot be used in the same environment due to conflicting requirements for `Adapt`. cc @sandreza @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/784#issuecomment-652686565:459,Adapt,Adapt,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/784#issuecomment-652686565,1,['Adapt'],['Adapt']
Energy Efficiency,Using short-circuiting logic inside GPU kernels would reduce performance rather than improve it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/987#issuecomment-1056924530:54,reduce,reduce,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987#issuecomment-1056924530,1,['reduce'],['reduce']
Energy Efficiency,"Victoria, is the velocity normal to the cylinder zero? and perhaps the; tangential component too, if you are using no-slip boundary conditions. I; have a nice application of all this if you are going in 3-d. John. On Thu, Dec 3, 2020 at 2:54 PM Gregory L. Wagner <notifications@github.com>; wrote:. > That solution looks pretty good!; >; > As far as I can tell I think it makes sense for the ""full"" pressure field; > to continue smoothly into the IB, since the pressure field is somehow a; > solution to Poisson's equation --- even if the RHS of the Poisson equation; > varies rapidly close to the IB (?); >; > Does the magnitude of the velocity error scale with the time-step, or; > resolution? Perhaps plotting the dependence of the error on some of those; > parameters can give us confidence that the method is working as expected.; >; > Should we try iterating the IB correction + pressure solve to see if it; > reduces the velocity error, as we hypothesized it might?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738270609>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRQB7MCPDWK3EEILQDSS7UJBANCNFSM4SNJ4CSA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738278829:916,reduce,reduces,916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738278829,1,['reduce'],['reduces']
Energy Efficiency,"Visualization is taking a bit of time. I am adding the vorticity as an output field and then hope to adapt the following to create a similar plot to what you produced before. When I get something working I might push it so that others can use it too, if they like. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/near_global_lat_lon/visualize.jl. I have found that I couple of things don't work so easily. `Node(0)`. ` wireframe!(ax, Sphere(Point3f0(0), 1f0), show_axis=false)`. It seems that `Node` and `Point3f0` are not defined. Is there another library that I need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483:101,adapt,adapt,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483,1,['adapt'],['adapt']
Energy Efficiency,"We also need to figure out how to adapt instruction 2:. <img width=""851"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/129913721-0a12190d-af28-43c6-9070-92eb9e8f5a25.png"">. to buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073:34,adapt,adapt,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073,1,['adapt'],['adapt']
Energy Efficiency,We are well above the recommended CFL number for |u| > 0.2 which will most likely happen with a random velocity field. ; (for |u| > 0.45 the CFL > 1.88); I think the correct thing to do is to; (1) set a random seed (should be always done for reproducibility regardless); (2) reduce the time step to satisfy CFL < 0.7; (3) Explicitly write in the example how to calculate the time step and the recommendation for time stepping (setting a time step size is not super trivial and many users could benefit from an explanation in the examples),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3540#issuecomment-2039744835:275,reduce,reduce,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3540#issuecomment-2039744835,1,['reduce'],['reduce']
Energy Efficiency,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:143,schedul,schedule,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949,4,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,We don't know of a way to know at compile time. This might be a question for GPUCompiler.jl or CUDA.jl. I have also found that it's rather limited what can be reduced on-the-fly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1582850631:159,reduce,reduced,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1582850631,1,['reduce'],['reduced']
Energy Efficiency,We don’t need reverse for Fields. We need to go away from reverse since it allocates,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035358102:75,allocate,allocates,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035358102,1,['allocate'],['allocates']
Energy Efficiency,"We have always launched a kernel for flux bcs! Our method is 1) fill halos to nullify diffusive fluxes across boundaries; 2) add the specified fluxes directly to boundary cells. Step 1 requires filling halos, which we have always done for flux bcs. Previously, we used broadcasting for flux bcs, similar to what we do for periodic bcs. When the halo size was greater than 1, the intent of the broadcast operation was violated, however, because zero diffusive flux was not guaranteed for biharmonic diffusivity. This PR corrects that, allowing biharmonic diffusivities to be used in bounded domains. Some informal benchmarks suggest that a KernelAbstractions kernel can be more efficient than using GPUArrays broadcasting. KernelAbstractions kernels are also multithreaded, unlike broadcast operations. Thus I would expect speed up from this change, rather than slowdown (but likely negligible speed up). But of course benchmarking is a good idea, and if there is a problem we should open an issue. Another advantage is that we can utilize KernelAbstractions dependency feature more fully if we get to the point where we do not use broadcasting for anything. We haven't optimized our dependency structure, however. Also, there are a few puzzles to be worked out regarding periodic boundary conditions before we can convert the periodic halo filling to kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/904#issuecomment-686430220:677,efficient,efficient,677,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/904#issuecomment-686430220,1,['efficient'],['efficient']
Energy Efficiency,We maybe need to adapt the constructor of the `KrylovSolvers` (workspaces) for your specific type.; Example: https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/src/krylov_solvers.jl#L162. It works fine for CPU / GPU arrays as well as various partitioned arrays but `Field` seems quite different.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678:17,adapt,adapt,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678,1,['adapt'],['adapt']
Energy Efficiency,"We reduced the number of time steps and the size of the time step, effectively decreasing the simulation time. The leading theory is that non-linearities in the simulation were preventing bitwise reproducibility, so reducing the extent of the simulation did the job",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3028#issuecomment-1485138938:3,reduce,reduced,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3028#issuecomment-1485138938,1,['reduce'],['reduced']
Energy Efficiency,"We should probably improve our suite of examples. Some ideas:. * I think the thermal bubble might be a decent one to re-instate, since it's extremely simple.; * We may want to simply / reduce the length of the internal wave example. It could also be simplified if waves were excited by forcing rather than initial condition... ?; * I think reducing ""deepening mixed layer"" to free convection would be a good idea; * Some simplified version of stratified Couette flow might be nice to show the use of no-slip boundary conditions; * Driven cavity? What else? More ocean-y examples?. We haven't discussed tutorials; perhaps this is out the window.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531048061:185,reduce,reduce,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531048061,1,['reduce'],['reduce']
Energy Efficiency,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:341,Adapt,Adapting,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632,1,['Adapt'],['Adapting']
Energy Efficiency,"We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions). Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293:9,reduce,reduce,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293,1,['reduce'],['reduce']
Energy Efficiency,"We would like a parallel hydrostatic model eventually, you're right. We need to parallelize the preconditioned conjugate gradient solver and ensure that reduced fields parallelize for that. I'm not sure this 2D internal tide problem is large enough to benefit from GPU parallelization --- have you tested GPU parallelization of such small problems?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867978094:153,reduce,reduced,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867978094,1,['reduce'],['reduced']
Energy Efficiency,"Well, `VectorInvariant` is for any vector-invariant-type advection scheme, whereas `WENOVectorInvariant` is specifically for vector invariant scheme with WENO interpolation (ie what Simone is developing in his paper). So `WENOVectorInvariant` is just a convenience function that hopefully reduces boiler plate a bit for hopefully what will become the most-used version of `VectorInvariant`. There are a few other differences, like `vertical_order` instead of `vertical_scheme`. We should get rid of `WENOVectorInvariant` though if it doesn't help much...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3449#issuecomment-1915260615:289,reduce,reduces,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3449#issuecomment-1915260615,1,['reduce'],['reduces']
Energy Efficiency,"Well, might be that the reconstruction is incorrect because it adds spurious kinetic energy. (It does not consider the spherical geometry). If you look at the kinetic energy of the above simulation that is exactly what happens; (sorry now the two cases are inverted). https://user-images.githubusercontent.com/33547697/235359276-11713879-4470-4267-a459-eae5db49e033.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529041690:85,energy,energy,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529041690,2,['energy'],['energy']
Energy Efficiency,"Well, that explains some of my flailing!. Ok, I agree with what you're saying. . Should we anticipate that functions should mutate some output array, so function signatures will generally be something like `operation!(out, in, otherargs...)`?. Anticipating the basic code pattern will reduce work later, and it'll still be possible to write `operation!` quick and dirty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437370488:285,reduce,reduce,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437370488,1,['reduce'],['reduce']
Energy Efficiency,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:242,reduce,reduce,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524,2,"['power', 'reduce']","['power', 'reduce']"
Energy Efficiency,"Welp, it's a minor difference at 8m resolution here:. https://user-images.githubusercontent.com/15271942/164351531-dae7cec6-de9a-43a7-a60f-29f6bbeeb060.mp4. ""new"" is this PR. The results are expected though I think: when we put the diffusivity at cell interfaces (holding everything else the same / all parameters constant), the mixing rate is slightly reduced. @navidcy @simone-silvestri @adelinehillier shall we merge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829:353,reduce,reduced,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829,1,['reduce'],['reduced']
Energy Efficiency,What are you trying to simulate?. It looks like you're trying to simulate a Gaussian surface cooling in a tiny 4 x 4 x 0.1 m box with a Coriolis parameter of f = 0.5 and beta = 3.75e-3?. Not sure if it makes sense to use a beta plane approximation on a domain that's only 4 meters long...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755309800:274,meter,meters,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755309800,1,['meter'],['meters']
Energy Efficiency,"What if we add this feature to `Callback`? I.e. ```julia; struct Callback{P, F, S, I}; func :: F; schedule :: S; parameters :: P; initialize :: I; end; ```. Then by default we set. ```julia; Callback(; ..., initialize=call_at_iteration_0); ```. where. ```julia; call_at_iteration_0(callback, simulation) = iteration(simulation) == 0 && callback(simulation); ```. so the default ""initialization"" is simply to ""call"" the callback at iteration 0 (as we currently do). Users can cancel this by setting `initialize=nothing` or providing some alternative function. Finally, rather than calling all the callbacks at iteration 0, we instead call `Callback.initialize!` for every callback inside `initalize_simulation!`:. https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Simulations/run.jl#L166. For ""finalization"" we need a bit more work, since I think we want to add the concept of finalizing a simulation as well, so we might need `Simulation.finalized`. That's probably a nice idea too though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501:98,schedul,schedule,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501,1,['schedul'],['schedule']
Energy Efficiency,What is the source of energy? (Of course it's unexpected for a simulation to blow up --- unless you like simulating NaNs??),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442101185:22,energy,energy,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442101185,1,['energy'],['energy']
Energy Efficiency,"What's needed is something like. ```julia; struct ContinuousDiffusionFunction{F, P}; func :: F; parameters :: P; end. @inline (K::ContinuousDiffusionFunction)(x, y, z, t) = K.func(x, y, z, t, K.parameters). @inline function convert_diffusivity(FT, κ; discrete_form=false, loc=(nothing, nothing, nothing), parameters=nothing) ; if discrete_form; return DiscreteDiffusionFunction(κ; loc, parameters); elseif isnothing(parameters); return ContinuousDiffusionFunction(κ, parameters); else; return κ ; end ; end ; ```. I think anyways. reduced dimensionality grids may be different",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401073362:531,reduce,reduced,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401073362,1,['reduce'],['reduced']
Energy Efficiency,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:307,power,powerful,307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729,1,['power'],['powerful']
Energy Efficiency,"When `StepRangeLen` is adapted to GPU it goes through this `adapt_structure`:. https://github.com/JuliaGPU/Adapt.jl/blob/5ef7c5329609df7ffb5b19942d6747b3dcc162c2/src/base.jl#L79-L80. This is invalid though, because it does not preserve the type of the range. It calls this constructor in Julia's base:. https://github.com/JuliaLang/julia/blob/9850a3881221a57a382e98c9b9ae2bf97ac3966d/base/range.jl#L524-L525. specifically we get a range of type `typeof(ref+zero(step))`, which is `Float64` if `step isa Float64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630:23,adapt,adapted,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630,2,"['Adapt', 'adapt']","['Adapt', 'adapted']"
Energy Efficiency,"When a shock occurs, the function becomes multivalued and the equation is no longer valid. That's why discussing energy conservation after the shock is a bit weird. People usually have to add in other physics. This is an extreme case and I wonder if a smooth solution would be easier to understand?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185604762:113,energy,energy,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185604762,1,['energy'],['energy']
Energy Efficiency,When you reduce the averaging window do differences diminish? What if your averaging window is a dt?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809484323:9,reduce,reduce,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809484323,1,['reduce'],['reduce']
Energy Efficiency,"When you turn off closure you reduce the order of the differential equations and therefore no longer have the freedom to impose anything else but no-normal flow. It is due entirely to the order of the differential equations and not do to whether the boundary conditiosn are flux, gradient or value. Does that make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831593723:30,reduce,reduce,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831593723,1,['reduce'],['reduce']
Energy Efficiency,Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007:229,adapt,adapted,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007,1,['adapt'],['adapted']
Energy Efficiency,"Which document are you referring to @Yixiao-Zhang ? . I think its important to enable Float32 for science applications. It's important enough that I think this could be the subject of a paper, especially since it does not seem trivially achievable. Multi-GPU is the safe solution right now. Single precision may also accelerate multi-GPU simulations though, because it reduces the amount of information that has to be communicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389494160:369,reduce,reduces,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389494160,1,['reduce'],['reduces']
Energy Efficiency,"Why do model tests have to be long runs? Surely a few timesteps is enough; to see if anything is broken. On Tue, Dec 17, 2019, 7:26 PM Ali Ramadhan <notifications@github.com> wrote:. > This issue is cropping up now that we regularly timeout on Travis (max; > runtime is 50 minutes) and we almost always time out on GitLab GPU CI (max; > runtime is 60 minutes, @maleadt <https://github.com/maleadt> might be; > able to increase that but it's a shared resource and we probably shouldn't; > be hogging it up). Surprisingly Appveyor is always fast now. I think free; > CI servers are just generally underpowered.; >; > Unfortunately it seems like paying for CI will never happen but we; > definitely want to keep our tests and make them even more comprehensive so; > here are some ideas we can discuss (probably in January):; >; > 1. See if we can move Travis CI pipelines onto Azure DevOps. They seem; > to give out more runtime (up to 360 minutes I think) although they might; > always reduce that in the future if they get more users. CliMA and; > @simonbyrne <https://github.com/simonbyrne> seem to be having a good; > experience with Azure.; > 2. Split tests into a fast smaller test set (regression only?) and the; > full comprehensive test set. But we still need a place to run the; > comprehensive test set (maybe Azure runs the comprehensive tests?). We'll; > probably have to do this at some point.; > 3. Split up the tests into jobs that run in <50 minutes each. You can; > have unlimited jobs on Travis. But this feels like a lot of work to set up; > and the tests would still take long as you can't have that many parallel; > builds.; >; > We'll have to test Oceananigans + MPI pretty soon but we can worry about; > that later. Slurm CI or setting something up with our 4xTitan V server; > might be a good option here.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceana",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566848638:984,reduce,reduce,984,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566848638,1,['reduce'],['reduce']
Energy Efficiency,Why does the test allocate so much memory? Is it possible to design an inexpensive test? It's important that CI is absolutely as cheap as possible.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748:18,allocate,allocate,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748,1,['allocate'],['allocate']
Energy Efficiency,Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Current Temp : 44 C; Memory Max Operating Temp : 85 C; Power Readings; Power Management : Supported; Power Draw : 44.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:22253,Power,Power,22253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,3,['Power'],['Power']
Energy Efficiency,"With no background diffusivity I also find the energy increases slowly. This is with WENO advection scheme. https://user-images.githubusercontent.com/15271942/221060649-86deb92a-45c3-401d-96ac-3dceabacc686.mp4. Perhaps one could compute the discrete conservation laws for the linear wave equations here given our staggered discretization of buoyancy / hydrostatic pressure + nonhydrostatic pressure... I'm not sure what we would find. It's not that simple, because nonhydrostatic pressure is treated implicitly / with a fractional step. Our hydrostatic pressure scheme is not the only possible scheme one might use. Perhaps other schemes have different numerical properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442609489:47,energy,energy,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442609489,1,['energy'],['energy']
Energy Efficiency,"With part 2 (#628) merged I merged master into this branch to resolve conflicts which also reduced the number of changes but it's still a pretty big and complicated PR. @glwagner We should probably make sure that the changes and design choices in this PR make sense. Once this PR is merged, I think we should release v0.23.0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589078151:91,reduce,reduced,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589078151,1,['reduce'],['reduced']
Energy Efficiency,"Would `ReducedField` be part of the `AbstractOperations` module?. I think the bare-bones implementation makes a lot of sense for reduced averaged fields needed for computations like ; ```julia; TKE = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```; which can then be built up as we encounter new things we want to compute (or reduce?). I'm guessing you're suggesting the bare-bones implementation for something like `ReducedField(::Average, ...)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-674790297:7,Reduce,ReducedField,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-674790297,4,"['Reduce', 'reduce']","['ReducedField', 'reduce', 'reduced']"
Energy Efficiency,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1031,energy,energy,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['energy'],['energy']
Energy Efficiency,"WxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `19.23% <0%> (-4.58%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `48.38% <0%> (-1.62%)` | :arrow_down: |; | [...lence\_closure\_implementations/smagorinsky\_lilly.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3NtYWdvcmluc2t5X2xpbGx5Lmps) | `92.85% <100%> (-0.76%)` | :arrow_down: |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `80% <100%> (+10%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `66.66% <100%> (ø)` | :arrow_up: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `81.81% <88.23%> (+1.17%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520?src=pr&el=footer). Last update [6f40796...c53227c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548763706:3963,Power,Powered,3963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548763706,1,['Power'],['Powered']
Energy Efficiency,"XJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100.00% <ø> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `76.19% <ø> (+4.76%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <ø> (-32.36%)` | :arrow_down: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `100.00% <ø> (+25.00%)` | :arrow_up: |; | ... and [95 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765?src=pr&el=footer). Last update [3f491e7...c789ec6](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/765#issuecomment-637790496:3262,Power,Powered,3262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/765#issuecomment-637790496,1,['Power'],['Powered']
Energy Efficiency,"Y29uc3RhbnRfZGlmZnVzaXZpdHlfY2xvc3VyZXMuamw=) | `100% <100%> (+40.54%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `75.97% <100%> (-0.61%)` | :arrow_down: |; | [...closures/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvcm96ZW1hX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `23.95% <23.95%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `53.33% <53.33%> (ø)` | |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <67.79%> (ø)` | |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `69.72% <69.72%> (ø)` | |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=footer). Last update [5a12ab6...7e7449e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135941:3808,Power,Powered,3808,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135941,1,['Power'],['Powered']
Energy Efficiency,"Y29uc3RhbnRfZGlmZnVzaXZpdHlfY2xvc3VyZXMuamw=) | `100% <100%> (+40.54%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `75.97% <100%> (-0.61%)` | :arrow_down: |; | [...closures/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvcm96ZW1hX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `23.95% <23.95%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `53.33% <53.33%> (ø)` | |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <67.79%> (ø)` | |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `69.72% <69.72%> (ø)` | |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=footer). Last update [5a12ab6...be136c3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135943:3804,Power,Powered,3804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135943,1,['Power'],['Powered']
Energy Efficiency,"Y2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `35.84% <0%> (-2.45%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | [src/Solvers/triply\_periodic\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvdHJpcGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | ... and [41 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=footer). Last update [4ed3660...2610b13](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589657940:3746,Power,Powered,3746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589657940,1,['Power'],['Powered']
Energy Efficiency,"Y3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `50.00% <ø> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <ø> (ø)` | |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <ø> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <ø> (ø)` | |; | [src/BoundaryConditions/show\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <ø> (ø)` | |; | ... and [41 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=footer). Last update [417e890...73a6798](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002:3509,Power,Powered,3509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002,1,['Power'],['Powered']
Energy Efficiency,Yeah I saw that comment. My understanding is that `-O1` is a good compromise between performance and latency but in our case we just want to reduce latency as performance during testing doesn't matter. But I guess `-O0` didn't really do much. Perhaps the optimizations (might only be in Julia 1.6+) mostly affect compilation when loading/importing packages. Should we still consider merging this? Once tests run I can do a comparison to see how many minutes (or seconds?) `-O0` saves us?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-712840423:141,reduce,reduce,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-712840423,1,['reduce'],['reduce']
Energy Efficiency,"Yeah I think the current time stepping algorithm (essentially what the MITgcm does) is pretty custom so it's probably not shared by other equations/methods, but the pressure correction step is pretty common to finite volume Navier-Stokes solvers and it should be possible to generalize it. I'm thinking it might be good to tackle ""generic time stepping"" in two steps. 1. Getting the current version of the time stepping algorithm running efficiently on GPUs for milestone v0.4 and then 2. we can redesign for v0.5 and include more generic time stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463036545:438,efficient,efficiently,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463036545,1,['efficient'],['efficiently']
Energy Efficiency,Yeah so Adapt v3.0.0 is blocked by CUDA.jl right now: https://github.com/JuliaGPU/CUDA.jl/pull/626. I think we just need to wait for a new tagged release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971:8,Adapt,Adapt,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971,1,['Adapt'],['Adapt']
Energy Efficiency,"Yeah so this should be ok. ; The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced.; Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid; In this way a reduced field will have a ""position"" with respect to the full 3D grid. Reductions and reduced fields without a specified position are located at `index = 1` by default. I am still bugfixing a bit though. ; A problem that I am foreseeing is that the `GPU` has no information about either indices or reduced locations but only the data structure, maybe we should ship the indices with the data on the GPU? ; Also, since the underlying data is also offset we could retrieve the information on the GPU although it will probably get a bit wonky",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736:55,Reduce,ReducedField,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736,6,"['Reduce', 'reduce']","['ReducedField', 'reduced']"
Energy Efficiency,"Yeah that would be cool. Might also not be a bad idea to just use coolFFT.jl as it's <40 lines and seems to work (if we restrict ourselves to powers of 2 for `Nx`, `Ny`, `Nz`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/552#issuecomment-562177414:142,power,powers,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/552#issuecomment-562177414,1,['power'],['powers']
Energy Efficiency,"Yeah that would work but might be worth spending the extra work to support checkpointing and pickup for schedules (and time averages). I guess we will have to pass the `simulation` when constructing a `Checkpointer` but then we're stuck with the `write_output!(output_writer, model)` function signature. We could just fully switch to passing the simulation to output writers and diagnostics?. I think we also need to nuke `restore_from_checkpoint`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498:104,schedul,schedules,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749594498,1,['schedul'],['schedules']
Energy Efficiency,"Yeah, but the `ILU` preconditioner doesn't seem to be tested, which I remember was quite good to reduce the number of iterations. So in case of a large time step that would be quite efficient even if we have to solver two triangular linear systems each iteration. but anyways, maybe it's not faster, it was just I was wondering how it would compare",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064:97,reduce,reduce,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064,2,"['efficient', 'reduce']","['efficient', 'reduce']"
Energy Efficiency,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:38,adapt,adaptive,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450,2,['adapt'],"['adapt', 'adaptive']"
Energy Efficiency,"Yeah.. I am not yet sure how this would work embedded. By now, what I have is just some functions that the user has to add as callbacks.; e.g.; https://github.com/iuryt/Bioceananigans.jl/blob/ab35a7235fea532fe7ed283ce6e06ac12f378dae/test/NNP.jl#L109-L117; btw.. this test script is not yet fully developed 😄. Thinking more, it would be so the function automatically adds the callbacks to the simulation?. ```julia; const Δb=(g/ρₒ) * 0.03; h = Field{Center, Center, Nothing}(grid) ; MixedLayerDepth(simulation, h, Δb). # constants for the NP model; const μ₀ = 1/day # surface growth rate; const m = 0.015/day # mortality rate due to virus and zooplankton grazing; const Kw = 0.059 # meter^-1; const kn = 0.75; const kr = 0.5. # https://doi.org/10.1029/2017GB005850; const chl2c = 0.06 # average value for winter in North Atlantic. const α = 0.0538/day. const average = :growth; const shading = true. light_growth = Field{Center, Center, Center}(grid). # time evolution of shortwave radiation (North Atlantic); @inline Lₒ(t) = 116.5 * sin( 2π * ( t / days + 50 ) / 375.7 + 1.3 ) + 132.3; # evolution of the available light at the surface; @inline light_function(t, z) = 0.43 * Lₒ(t) * exp( z * Kw ); # light profile; @inline light_growth_function(light) = μ₀ * ( light * α ) / sqrt( μ₀^2 + ( light * α )^2 ). phytoplankton = (""P"",) # list of phytoplankton tracers ; LightGrowth(light_growth, h, simulation, phytoplankton, light_function, light_growth_function, time(simulation), average, shading, chl2c); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657:682,meter,meter,682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657,1,['meter'],['meter']
Energy Efficiency,"Yes - that makes sense. On Mon, Apr 29, 2019 at 9:45 AM Ali Ramadhan <notifications@github.com>; wrote:. > @christophernhill <https://github.com/christophernhill> Was wondering if; > your stretched vertical grid spacing 3D elliptic solver would be efficient; > enough to use for the case where *Δz* is constant.; >; > If it is, then we can make do with a single solver. And if there are no; > DCTs, then we can merge the CPU and GPU Poisson solvers!; >; > Just had this thought so leaving the issue open to discuss in the future.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/211>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AA27DYAHOUZSRNBFW5VFYADPS33WPANCNFSM4HJDOFMQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/211#issuecomment-487585763:248,efficient,efficient,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/211#issuecomment-487585763,1,['efficient'],['efficient']
Energy Efficiency,"Yes! Make sure to work from `main` because remember we changed how `TimeInterval` works recently. `TimeInterval` actuates on this criteria:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L65-L79. when `t` exceeds or is equal to `next_actuation_time`:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L58-L63. The first actuation time and number of actuations have to be initialized:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L50-L56. I think `WindowedTimeAverage` works differently and looks at `previous_stop_time`, plus the `interval` of the time-averaging. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/OutputWriters/windowed_time_average.jl#L90. and `previous_stop_time` is recorded here:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/OutputWriters/windowed_time_average.jl#L91. which in turn is called here:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/OutputWriters/windowed_time_average.jl#L280. So there's something about using the previous stop time, rather than the _number_ of actuations, which incurs a floating point error issue. I think `AveragedTimeInterval` should somehow use a _number_ of actuations as a criteria. Not sure actually how that would work, need to study the flow of information in detail. It will probably help to sketch out a diagram / make a cartoon on a piece of paper so that you understand precisely the flow of information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2285111141:238,schedul,schedules,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2285111141,3,['schedul'],['schedules']
Energy Efficiency,"Yes! The `HydrostaticFreeSurfaceModel` constructor permits the kwarg `velocities = PrescribedVelocities()`. This can be used to prescribe velocity fields rather than solving for them directly. when `velocities isa PrescribedVelocities`, then neither prognostic fields nor tendencies are allocated the velocity fields or free surface. With the addition kwarg `tracer_advection=nothing`, then advection can be omitted, permitting the solution of a diffusion equation. This feature is not documented; it can only be found in a few `validation` cases such as. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/curvilinear_diffusion/spot_tracer_diffusion.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924:287,allocate,allocated,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924,1,['allocate'],['allocated']
Energy Efficiency,"Yes, I’m happy to include general comments. We shouldn’t write too much on the topic. I think our advice will change when we have time stepping methods that are more appropriate for adaptive time stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520910773:182,adapt,adaptive,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520910773,1,['adapt'],['adaptive']
Energy Efficiency,"Yes, except that we don't allocate memory for vorticity at all; we compute it on the fly. The prognostic fields are velocity components and tracers. For hydrostatic, w is diagnostic and free surface is prognostic. For nonhydrostatic, w is prognostic. The diagnostic fields include pressure, w if hydrostatic, and any diagnostics fields associated with the closure. We will also have a user interface for closure prognoetic fields at some point too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502:26,allocate,allocate,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502,1,['allocate'],['allocate']
Energy Efficiency,"Yes, if we are dealing with the conservative form, `1.` is the one that I am suggesting, and iut does ensure that kinetic energy is disispated by viscosity. I don't believe that `2.` and `3.` have that property.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090218750:122,energy,energy,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090218750,1,['energy'],['energy']
Energy Efficiency,"Yes, it seems there is some bad interaction between KernelAbstractions and the debugger. It seems likely that fixing it will requiring some development of the debugger (but possibly also KernelAbstractions). Once that's resolved, I think it's likely the debugger will work with Oceananigans. Hopefully you can still have a productive development workflow in the meantime! Let us know if there is any way we can help. I think the bright side of this situation is that Julia has a lot of powerful built-in features for code introspection and interactive usage, a lot of which overlap with the features provided by a traditional debugger (as I understand it). Are you planning to contribute to Oceananigans development or just to interact with Oceananigans as a user?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624350568:486,power,powerful,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624350568,1,['power'],['powerful']
Energy Efficiency,"Yes, most containers are ""adapted"" on the GPU. We adapt `field` to `field.data`:. https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/src/Fields/field.jl#L394. And note that `field.data` will be further adapted. For example, `CuArray` becomes `CuDeviceArray`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395:26,adapt,adapted,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395,3,['adapt'],"['adapt', 'adapted']"
Energy Efficiency,"Yes, that is pretty much what I had in mind but for a different physical problem. . There are a variety of ways one can do this. Below are a few that come to mind. 1. Power method: worked well for Kelvin-Helmholtz instability and should work well for other problems. Two nice features are that it's pretty simple, and it's already coded up for one example so should be easy to adapt. One not so nice feature is that it only tells us the most unstable mode (spatial structure, growth rates and phase speed) but it doesn't tell us about any other unstable modes. 2. Arnoldi Method: A quick google search came across this [library](https://haampie.github.io/ArnoldiMethod.jl/stable/). I have not tried it but could try adapting it to the above mentioned KH problem. . 3. Standard eigenvals: If we assume periodicity in two directions it boils down to a 1D eigenvalue problem that should be easy to solve using eigenvals. There should be a direct solver that forms a full matrix and gives you all the eigenfunctions but the indirect uses Arnoldi and gives you some. . As for where they appera I don't kown but at some point, after I get a ShallowWaterModel off the ground, I will play around with different solvers and see what looks promising. This won't happen this week I'm pretty sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044:167,Power,Power,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044,3,"['Power', 'adapt']","['Power', 'adapt', 'adapting']"
Energy Efficiency,"Yes, that will be great. I will dive in into the schedule over the next few days!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000038293:49,schedul,schedule,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000038293,1,['schedul'],['schedule']
Energy Efficiency,"Yes, this is interesting!. To clarify: we identify a field as ""reduced"" if one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:63,reduce,reduced,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044,4,['reduce'],['reduced']
Energy Efficiency,"Yes, xc is a PencilArray object. Right now it looks like each process calculates the eigenvalues on the global grid and then the code on line 42 attempts to reduce the size to the local grid. One approach would be to calculate the eigenvalues on the local grid. I think that this would be more generalizable to other distributed domain decompositions (right now line 42 assumes that the domain is decomposed in one direction) but this approach would require a re-write of poisson_eigenvalues.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067792174:157,reduce,reduce,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067792174,1,['reduce'],['reduce']
Energy Efficiency,"Yes. To be honest after your comments I'm completely lost. I thought I was getting a grasp on how structs and multiple dispatch worked, but now I'm 100% sure that I am 0% about everything :laughing: . I've defined something like this:. ```julia; struct SpatialWindowAverage{X, Y, Z, A, G, F, S, D} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) =; SpatialWindowAverage(field.data, field.grid, field, field_slicer, dims); ```. But of course, it's missing `X, Y, Z`. But to get them I need those `drop_averaged_dims` functions and I'm not sure how to work them on reduced fields. . So far I've been looking at how `AveragedField` is defined, but that's exactly what @glwagner recommended I not do, since apparently it's difficult to adapt it for what I want... And in the mean time I'm computing these averages offline, which is taking a very long time haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675:679,reduce,reduced,679,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675,2,"['adapt', 'reduce']","['adapt', 'reduced']"
Energy Efficiency,"Yesterday we discussed solving the SW model in conservative form, which is a perfectly good approach. However, I remembered that there another formulation in terms of the velocity where we use the vorticity and the Bernouli function. This is also very nice and this approach shows there are the different finite difference formulations that ensure either energy or enstrophy conservation. I don't know how Finite Volume would compare, but I'm tempted to start with this for simplicity. http://www.aos.wisc.edu/~aos718/sadourny.pdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726852193:355,energy,energy,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726852193,1,['energy'],['energy']
Energy Efficiency,"You are correct @navidcy , this is to reduce the number of halo points from 3 to 0, which reduces the storage by a factor of 6.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1659#issuecomment-842497759:38,reduce,reduce,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1659#issuecomment-842497759,2,['reduce'],"['reduce', 'reduces']"
Energy Efficiency,You can probably also omit the `shape` component. That just reduces the noise to zero at the top and the bottom.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268575815:60,reduce,reduces,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268575815,1,['reduce'],['reduces']
Energy Efficiency,"You can start by allowing the coefficient to be an array as in AMD:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L143. Then with a callback you can implement any model, including dynamic Smagorinsky. So this provides unlimited flexibility in developing a new closure. I think its possible you will find that its more efficient to precompute (eg in a callback) the coefficient rather than compute it on the fly with a function, especially because the computation of the different filters is a bit non-local, eg you have to average over a few grid points, which could involve relatively expensive memory fetches. A function-based interface could be nice too, but note that they are relatively complicated. Do we expect a lot of users to experiment with custom coefficient functions? @tomchor if this feature is just for you to experiment with dynamic Smagorinsky implementations then I think experimenting in the source code is an even quicker and easier option than designing a function-based interface... @simone-silvestri and @xkykai have talked about dynamic Smagorinsky too but I think their main conclusion is that it is not a gimme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674:453,efficient,efficient,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674,1,['efficient'],['efficient']
Energy Efficiency,"You changed the initial condition for h. Can you try using the old one? The SWM is quite sensitive to `h` ; this is because `h` is the depth minus the bathymetry, or better `H = h + hB` where `H` is the total height. ; So you have to initialize with `maximum(bathymetry) .- bathymetry)` (where we assume that `H = maximum(bathymetry)`).; To this specific example I have added 10 just to make sure that `h>0` everywhere (maybe a smaller value is also ok). Edit: what you see in the video above is the _total_ height `H = h + hB`, about 10km everywhere with a `ΔH` of roughly 40 meters, quite large for the ocean, but still this is all barotropic so we cannot expect realistic values",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1476028985:577,meter,meters,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1476028985,1,['meter'],['meters']
Energy Efficiency,"You could maybe form a conservative estimate using. ```; uhmax = maximum(abs, uh); vhmax = maximum(abs, vh); hmax = maximum(abs, h). umax = max(uhmax / hmax, vhmax / hmax); ```. but this would be overly conservative for very nonlinear problems, I suppose. One issue is that writing `uh ./ h` will allocate memory. Note that you need `./` (with the `.`), not just `/`. You'll also need to dispatch on `model::ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762898249:297,allocate,allocate,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762898249,1,['allocate'],['allocate']
Energy Efficiency,"You had me at ""powerful and elegant""... As for automation, do we still need a webhook?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1088#issuecomment-713732023:15,power,powerful,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088#issuecomment-713732023,1,['power'],['powerful']
Energy Efficiency,"You have to define `A` as a `SparseMatrix` before iterating, otherwise the memory gets allocated anyways. The same goes for the vectors `e`, Try this. ```; using OffsetArrays; using SparseArrays. Lx = 2; Ly = 3; Nx = 12; Ny = 18; H = 1; δx = Lx/Nx; δy = Ly/Ny. poisson(f::OffsetMatrix, i, j) = (f[i+1, j] - 2*f[i, j] + f[i-1, j])/δx^2 + (f[i, j+1] - 2*f[i, j] + f[i, j-1])/δy^2. interior(f::OffsetMatrix) = f[1:Nx, 1:Ny]. function fill_halos!(f::OffsetMatrix); f[0, :] = f[Nx, :]; f[Nx+1, :] = f[1, :]. f[:, 0] = f[:, Ny]; f[:, Ny+1] = f[:, 1]. return nothing; end. A = spzeros(Float64, Nx*Ny, Nx*Ny). make_column(f::OffsetMatrix) = reshape(interior(f), (Nx*Ny, 1)). for j in 1:Ny, i in 1:Nx; eᵢⱼ = OffsetArray(spzeros((Nx+2H), (Ny+2H)), -H, -H); eᵢⱼ[i, j] = 1; fill_halos!(eᵢⱼ); ∇²eᵢⱼ = 0 * eᵢⱼ. for j in 1:Ny, i in 1:Nx; ∇²eᵢⱼ[i, j] = poisson(eᵢⱼ, i, j); end. A[:, Nx*(j-1)+i] = make_column(∇²eᵢⱼ); end; ```. then I suggest you to extract the constructors and just deal with those from here on out:; ```; using Oceananigans.Solvers: constructors, arch_sparse_matrix. matrix_constructors = constructors(arch, A); ```; whenever you want to write the matrix explicitly. ```; A = arch_sparse_matrix(arch, matrix_constructors); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1110447124:87,allocate,allocated,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1110447124,1,['allocate'],['allocated']
Energy Efficiency,"You mean have a GitHub action in the Docs repo and every week clear up all accumulated previews?; That's great! That would work amazingly. Do you know how to do this weekly schedule?; (Then we can also do it for ClimaOcean Docs repo, etc!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308648418:173,schedul,schedule,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308648418,1,['schedul'],['schedule']
Energy Efficiency,You should be able to load any NetCDF file using xarray and it gives you a nice and powerful interface for analyzing and manipulating the data. Probably not the best example as it's a little old and messy (I've started using Makie more often) but here's one example: https://github.com/CliMA/LESbrary.jl/blob/3595ff2e1db6d5e6898b6ea84335fdb9dbd23b15/src/make_lesbrary_plots.py,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432:84,power,powerful,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432,1,['power'],['powerful']
Energy Efficiency,"You start with a very unstable stratification so you set up Rayleigh-Taylor instability. The reason you get inf temp is because simulation blows up. If I reduce the time-step I can integrate up to the final time of `t=80sec` that you chose, but if you need to integrate further probably you need to reduce the time-step further or add a time-step wizard... I enhanced your script a bit with a log message to keep track of the CFL... I also added RK3 time-step. I also reduced the resolution to 128^3 so I can experiment as my laptop cannot casually run 256^3 simulations :) . ```Julia; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(128, 128, 128), y=(-500, 500), x=(-500, 500), z=(-500, 0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3), timestepper = :RungeKutta3,; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1)). @inline thermoc(x, y, z) = 16-12*tanh((z+250)/10)+rand(Float64); @inline sal(x, y, z) = 16+12*tanh((z+250)/10)+rand(Float64); set!(model1, u=-0.05, v=0, T=thermoc, S=sal). using Oceananigans.Diagnostics: AdvectiveCFL. CFL = AdvectiveCFL(wizard). start_time = time_ns(). progress(sim) = @printf(""i: % 6d, sim time: % 10s, wall time: % 10s, Δt: % 10s, CFL: %.2e\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - start_time)),; prettytime(sim.Δt),; CFL(sim.model)). simulation = Simulation(model1, Δt=2., stop_time=80second, iteration_interval=4, progress=progress). function init_save_some_metadata!(file, model); file[""author""] = ""oofs""; return nothing; end. simulation.output_writers[:tracers] = JLD2OutputWriter(model1, model1.tracers,; prefix = ""Temp Data"",; schedule = TimeInterv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730997277:154,reduce,reduce,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730997277,3,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"You're correct about the CPU method. We also opened an earlier issue to discuss this: #102 . Regarding what the GPU does differently: as cuFFT does not have a DCT function, we have to compute the type-II DCT using the FFT (and the type-III DCT using the IFFT). The relevant reference for how to do this efficiently (i.e. no padding or extra memory usage required) is:. Makhoul, [_A fast cosine transform in one and two dimensions_](https://ieeexplore.ieee.org/document/1163351?arnumber=1163351&tag=1), IEEE Transactions on Acoustics, Speech, and Signal Processing 28(1) (1980). but this DSP StackExchange post is probably more useful: https://dsp.stackexchange.com/questions/2807/fast-cosine-transform-via-fft",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/240#issuecomment-496223540:303,efficient,efficiently,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/240#issuecomment-496223540,1,['efficient'],['efficiently']
Energy Efficiency,"Yup it should be flexible enough to adapt it for ocean modeling. Might be worth thinking whether we need any additional abstractions. One important point is that the numerical method used does not time step pressure, it is instead diagnosed from potential temperature or entropy. May require some thought if we want to modify the speed of sound.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579990039:36,adapt,adapt,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579990039,1,['adapt'],['adapt']
Energy Efficiency,"ZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0%> (-6.67%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32% <0%> (-2.1%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | ... and [37 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=footer). Last update [2019cb7...c627f48](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591088313:3762,Power,Powered,3762,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591088313,1,['Power'],['Powered']
Energy Efficiency,[da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2; [ab4f0b2a] BFloat16s v0.2.0; [6e4b80f9] BenchmarkTools v1.3.2; [d1d4a3ce] BitFlags v0.1.7; [fa961155] CEnum v0.4.2; [179af706] CFTime v0.1.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [49dc2e85] Calculus v0.5.1; [7057c7e9] Cassette v0.3.10; [d360d2e6] ChainRulesCore v1.15.0; [9e997f8a] ChangesOfVariables v0.1.3; [944b1d66] CodecZlib v0.7.1; [35d6a980] ColorSchemes v3.20.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.9.10; [5ae59095] Colors v0.12.10; [34da2185] Compat v3.43.0; [a216cea6] CompoundPeriods v0.5.1; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [9a962f9c] DataAPI v1.10.0; [124859b0] DataDeps v0.7.10; [864edb3b] DataStructures v0.18.12; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.11.0; [ffbed154] DocStringExtensions v0.8.6; [fa6b7ba4] DualNu,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:1917,Adapt,Adapt,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Energy Efficiency,"](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/c1f4c3363201d16a872617cca6dc0f180b9ef82e?src=pr&el=desc) will **increase** coverage by `0.41%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #264 +/- ##; ==========================================; + Coverage 70.73% 71.14% +0.41% ; ==========================================; Files 23 23 ; Lines 868 870 +2 ; ==========================================; + Hits 614 619 +5 ; + Misses 254 251 -3; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `71.42% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.47% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `78.78% <0%> (+11.04%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=footer). Last update [c1f4c33...32fc894](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/264#issuecomment-498487184:1907,Power,Powered,1907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/264#issuecomment-498487184,1,['Power'],['Powered']
Energy Efficiency,"_bfft plan_ifft! plan_bfft! plan_irfft plan_brfft; >; >; >; > plan_fft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf); >; >; >; > Pre-plan an optimized FFT along given dimensions (dims) of arrays matching the shape and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; >; > represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly.; >; >; >; > To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; >; > the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; >; > array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; >; > \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â).; >; >; >; > The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; >; > different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; >; > the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation.; >; >; >; > plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; >; > but produce plans that perform the equivalent of the inverse transforms ifft and so on.; >; >; >; > help?> plan_fft!;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341:1445,allocate,allocated,1445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341,1,['allocate'],['allocated']
Energy Efficiency,"_diffusivity\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfZGlmZnVzaXZpdHlfY2xvc3VyZXMuamw=) | `59.45% <100%> (ø)` | |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `83.33% <100%> (ø)` | |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.65% <100%> (-58.53%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `85.71% <100%> (-3.58%)` | :arrow_down: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `52.77% <27.27%> (ø)` | |; | [src/turbulence\_closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY2xvc3VyZV9vcGVyYXRvcnMuamw=) | `42.62% <42.85%> (ø)` | |; | ... and [12 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312?src=pr&el=footer). Last update [c961d39...a40de27](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-510662216:3584,Power,Powered,3584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-510662216,1,['Power'],['Powered']
Energy Efficiency,"_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40% <ø> (-57.62%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `30% <0%> (-29.71%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `68.33% <100%> (-1.67%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.68% <100%> (-1.9%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `37.5% <19.44%> (-6.41%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `46.83% <50%> (-15.19%)` | :arrow_down: |; | ... and [6 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=footer). Last update [848edd9...25cf2da](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164877:3136,Power,Powered,3136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164877,1,['Power'],['Powered']
Energy Efficiency,"`91.42% <ø> (-0.24%)` | :arrow_down: |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `94.35% <ø> (+0.75%)` | :arrow_up: |; | [test/runtests\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0c191dGlscy5qbA==) | `67.56% <73.33%> (+42.56%)` | :arrow_up: |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `100.00% <100.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `92.06% <100.00%> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <100.00%> (ø)` | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `76.66% <100.00%> (-9.34%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=footer). Last update [8198ca7...871b448](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397:3202,Power,Powered,3202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397,1,['Power'],['Powered']
Energy Efficiency,"`NaNChecker` will also have to be moved from `diagnostics` to `callbacks`, see discussion on #1198. We also may want to make the list of `callbacks` an `OrderedDict`, so that we can write something like. ```julia; simulation.callbacks[:NaNChecker].schedule = IterationInterval(1); ```. If can overload `getproperty` for these custom OrderedDict we can also support the syntax. ```julia; simulation.callbacks.NaNChecker.schedule = IterationInterval(1); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-738797584:248,schedul,schedule,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-738797584,2,['schedul'],['schedule']
Energy Efficiency,"`PartialCellBottom` has a couple of bugs in the implementation that make it crash in simple cases like the `internal_tide.jl` example. @jm-c is working on fixing the implementation and should open a PR soon to fix the bugs.; However, it is indeed a problem in the adapt. ; I can it in a PR, still if you use PartialCellBottom know that probably it will lead to a crashing simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138:264,adapt,adapt,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138,1,['adapt'],['adapt']
Energy Efficiency,"`Periodic` boundary conditions should fill the whole halos, while flux, value and gradient BC should fill only the first because advection schemes have reduced order approaching boundaries. Did you notice this in a bounded direction or a periodic direction? In the latter case it is definitely a bug",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1181990838:152,reduce,reduced,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1181990838,1,['reduce'],['reduced']
Energy Efficiency,"```Julia; using Oceananigans; using Oceananigans.MultiRegion: getregion; using GLMakie. Nx, Ny = 5, 5; H = 3. range_with_offset(N, H, offset::Int) = (-H + 1 + offset*N):(N + H + offset*N). grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, 1), z = (0, 1), horizontal_direction_halo = H). j_index = 2; i_index = Nx+1 - j_index. fig = Figure(resolution=(2200, 600), fontsize=30); ax = Axis(fig[1, 1]); lines!(ax, range_with_offset(Nx, H, 0), parent(getregion(grid, 1).Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:green, 0.9), label=""panel 1""); lines!(ax, range_with_offset(Nx, H, 1), parent(getregion(grid, 2).Δxᶜᶜᵃ)[:, j_index+H], linewidth=8, color = (:red, 0.5), label=""panel 2""); lines!(ax, range_with_offset(Ny, H, 2), parent(getregion(grid, 4).Δyᶜᶜᵃ)[i_index+H, :], linewidth=4, color = (:blue, 0.5), label=""panel 4""); vlines!(ax, [1, Nx+1, 2Nx+1, 3Nx+1], linewidth=8, color=(:black, 0.3)); fig[1, 2] = Legend(fig, ax, framevisible = false); fig; save(""metrictest.png"", fig); ```. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/c9e2f210-a407-4e06-b3c4-0996b5ea8759). while **BEFORE THIS PR**:. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/9ed5be14-05b9-4f83-81f5-2d92def37ff5)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1711700565:514,green,green,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1711700565,1,['green'],['green']
Energy Efficiency,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:21,Adapt,Adapt,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Energy Efficiency,"```julia; mutable struct Clock{T}; time :: T; iteration :: Int; end; ```; Ah right so mutable structs are not `isbits` and so they cannot be passed into GPU kernels... We might have to roll back to using `time, iteration` in kernel and forcing/boundary function signatures instead of `clock`. But maybe it's simple enough that it could be adapted to the GPU...?. @vchuravy @maleadt Would it be possible to adapt a very simple `mutable struct` like `Clock{T}` to work in GPU kernels with Adapt.jl? It's never modified in a GPU kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071:339,adapt,adapted,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071,3,"['Adapt', 'adapt']","['Adapt', 'adapt', 'adapted']"
Energy Efficiency,"```julia; using Random, Printf; using Oceananigans, Oceananigans.Utils. Nx = 25 # Number of grid points in x and y; Nz = 50 # Number of grid points in z; Δz = 4.0 # Grid spacing in x, y, z (meters); Qᵀ = 1e-5 # Temperature flux at surface; ∂T∂z = 0.005 # Initial vertical temperature gradient; f = 1e-4 # Coriolis parameter; α = 2e-4 # Thermal expansion coefficient; β = 8e-4 # Haline contraction coefficient. grid = RegularCartesianGrid(size=(Nx, Nx, Nz), extent=(Δz*Nx, Δz*Nx, Δz*Nz)); T_bcs = TracerBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵀ), bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ). ## Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. ## Temperature initial condition: a stable density tradient with random noise superposed.; T₀(x, y, z) = 20 + ∂T∂z * z + ∂T∂z * model.grid.Lz * 1e-6 * Ξ(z). set!(model, T=T₀); ```; That's the setup I'm using now. Should we start from this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629369389:190,meter,meters,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629369389,1,['meter'],['meters']
Energy Efficiency,"```julia> using Pkg; pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.7; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.4.3; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.5; [d360d2e6] ChainRulesCore v0.9.38; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.12.0; [3da002f7] ColorTypes v0.10.12; [5ae59095] Colors v0.12.7; [34da2185] Compat v3.27.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.3+0; [0c68f7d7] GPUArrays v6.2.2; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.57.4; [d2c73de3] GR_jll v0.57.2+0; [5c1252a2] GeometryBasics v0.3.12; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.9.5; [615f187c] IfElse v0.1.0; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [c8e1da08] IterTools v1.3.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.3; [692b3bcd] JLLWrappers v1.3.0; [682c06a0] JSON v0.21.1; [0f8b85d8] JSON3 v1.8.0; [aacddb02] JpegTurbo_jll v2.0.1+3; [63c18a36] KernelAbstractions v0.5.5; [c1c5ebd",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115:135,Adapt,Adapt,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115,1,['Adapt'],['Adapt']
Energy Efficiency,"`time_step_precomputations!` is. ```julia; function time_step_precomputations!(diffusivities, pressures, velocities, tracers, model). fill_halo_regions!(merge(velocities, tracers), model.boundary_conditions.solution, model.architecture,; model.grid, boundary_condition_function_arguments(model)...). calculate_diffusivities!(diffusivities, model.architecture, model.grid, model.closure, model.buoyancy,; velocities, tracers). fill_halo_regions!(diffusivities, model.boundary_conditions.diffusivities, model.architecture, model.grid). @launch(device(model.architecture), config=launch_config(model.grid, :xy),; update_hydrostatic_pressure!(pressures.pHY′, model.grid, model.buoyancy, tracers)). fill_halo_regions!(pressures.pHY′, model.boundary_conditions.pressure, model.architecture, model.grid). return nothing; end; ```. To implement the optimizations discussed in this issue, we need to also consider the calculation of hydrostatic pressure and nonlinear diffusivities to intertwine communication with interior tendency computation. Can this be done abstractly perhaps via some combination of launch configurations and macro specifications to `@loop_xyz`? This would allow us to exert control over the ""region"" of interior source term computation from the ""outside"", while keeping our kernels intact. Notice that the ""pre-computation"" of nonlinear diffusivities and the isolation of the hydrostatic pressure both add communication steps. We should monitor whether these become significantly suboptimal algorithms in the presence of expensive communication. We can easily combine hydrostatic pressure with nonhydrostatic pressure with no loss of performance (probably a small performance increase, in fact). We can also in principle calculate nonlinear diffusivities ""in-line"", though when we tried this previously we were unable to achieve good performance. Also, ""in-line"" calculation of diffusivities makes the application of diffusivity boundary conditions much more difficult (or impossible).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290:2932,monitor,monitor,2932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290,1,['monitor'],['monitor']
Energy Efficiency,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:758,energy,energy,758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618,3,['energy'],['energy']
Energy Efficiency,"aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [test/test\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3NvbHZlcnMuamw=) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [test/test\_dynamics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2R5bmFtaWNzLmps) | | |; | [docs/citations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZG9jcy9jaXRhdGlvbnMuamw=) | | |; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | | |; | ... and [60 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=footer). Last update [0fe0d15...c70ed0e](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822:3141,Power,Powered,3141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822,1,['Power'],['Powered']
Energy Efficiency,"ably too deep for a github issue. After many discussions with Jim McWilliams he managed to convince me that the only difference between the modeling of eddy versus molecular diffusion is scale separation between processes. The issue about always keeping a more rigorous set of equations and including the molecular diffusivity by default (even though it's probably not important in the vast majority of cases) is one of many modeling philosophies. I highly recommend the paper by [Kerry Emanuel](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2019AV000129). It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's mo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:1063,energy,energy,1063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802,2,['energy'],['energy']
Energy Efficiency,"acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; └── coriolis: BetaPlane{Float64}. julia> simulation; Simulation{typename(HydrostaticFreeSurfaceModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 20 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: 30 days; ├── Stop iteration : Inf; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 6 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ ├── nan_checker => typename(Callback); │ ├── wizard => typename(Callback); │ └── print_progress => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── fields => typename(JLD2OutputWriter); └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.output_writers[:fields]; JLD2OutputWriter scheduled on TimeInterval(1 hour):; ├── filepath: ./baroclinic_adjustment.jld2; ├── 3 outputs: (:ζ, :b, :c); ├── field slicer: FieldSlicer(:, :, 16, with_halos=false); ├── array type: Array{Float32}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB. julia> horizontal_closure; ScalarBiharmonicDiffusivity: (ν=8.623357172365541e10, κ=8.623357172365541e10), isotropy: Horizontal. julia> diffusive_closure; ScalarDiffusivity:; ν=0.01, κ=0.01; time discretization: VerticallyImplicit(); isotropy: Vertical; ```. # This PR. ```julia; julia> model; HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (b, c); ├── closure: Tuple with 2 closures:; │ ├── ScalarBiharmonicDiffusivity{Horizontal}(ν=8.62336e10, κ=(b=8.62336e10, c=8.62336e10)); │ └── ScalarDiffusivity{VerticallyImplicit, Ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2274#issuecomment-1050197529:1598,schedul,scheduled,1598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2274#issuecomment-1050197529,1,['schedul'],['scheduled']
Energy Efficiency,"ace_model_state.jl:59; │ [22] update_state!; │ @ ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:34 [inlined]; │ [23] update_state!; │ @ ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:31 [inlined]; │ [24] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32, 1, CUDA.DeviceMemory}}, Float32, Float32, Float32, Float32, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, GPU}, clock::Clock{Float32, Float32}, momentum_advection::VectorInvariant{1, Float64, false, EnstrophyConserving{Float64}, Oceananigans.Advection.VelocityStencil, EnergyConserving{Float64}, EnergyConserving{Float64}, EnergyConserving{Float64}, Oceananigans.Advection.OnlySelfUpwinding{EnergyConserving{Float64}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.u_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.v_smoothness)}}}, tracer_advection::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, buoyancy::BuoyancyTracer, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{Nothing, Nothing, Nothing, Float64, Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings{Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float32, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}, Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme}}, tracers::Tuple{Symbol, Symbol",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:153842,Energy,EnergyConserving,153842,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,3,['Energy'],['EnergyConserving']
Energy Efficiency,"ackages\GPUArrays\Hd5Sk\src\host\indexing.jl:17 [inlined]; [8] getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:15 [inlined]; [9] getindex; @ .\subarray.jl:290 [inlined]; [10] macro expansion; @ .\multidimensional.jl:917 [inlined]; [11] macro expansion; @ .\cartesian.jl:64 [inlined]; [12] macro expansion; @ .\multidimensional.jl:912 [inlined]; [13] _unsafe_getindex!; @ .\multidimensional.jl:925 [inlined]; [14] _unsafe_getindex(::IndexCartesian, ::SubArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::Base.Slice{Base.OneTo{Int64}}, ::Int64, ::Base.Slice{Base.OneTo{Int64}}); @ Base .\multidimensional.jl:903; [15] _getindex; @ .\multidimensional.jl:889 [inlined]; [16] getindex(::SubArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::Function, ::Int64, ::Function); @ Base .\abstractarray.jl:1291; [17] estimate_growth_rate(simulation::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, @NamedTuple{u::Field{Face, Center, Center, Nothing....; ```. To solve this error, I tried to add the same comment ```CUDA.@allowscalar``` to the last line of the code below. Now, the code is running without any errors. ```; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); #CUDA.allowscalar(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = CUDA.@allowscalar estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. Thank you. I genuinely appreciate your support. Please let me know about your suggestion about the added comment line (whether it is correct or not).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2022273164:3500,Power,Power,3500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2022273164,1,['Power'],['Power']
Energy Efficiency,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2028,Adapt,Adapt,2028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Energy Efficiency,"age 78.23% 78.28% +0.05% ; ==========================================; Files 118 118 ; Lines 2375 2390 +15 ; ==========================================; + Hits 1858 1871 +13 ; - Misses 517 519 +2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.61% <0%> (-1.93%)` | :arrow_down: |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.44% <0%> (-0.44%)` | :arrow_down: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100% <0%> (ø)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=footer). Last update [e90c52a...d614833](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/665#issuecomment-594938926:2437,Power,Powered,2437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665#issuecomment-594938926,1,['Power'],['Powered']
Energy Efficiency,"age Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | |; | [src/Models/show\_models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9zaG93X21vZGVscy5qbA==) | `0% <ø> (ø)` | |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `88.88% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `100% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0% <0%> (ø)` | |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.75% <100%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.78% <88.88%> (ø)` | |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `84.21% <90.9%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=footer). Last update [c417701...9187570](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-586666059:2659,Power,Powered,2659,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-586666059,1,['Power'],['Powered']
Energy Efficiency,"aged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); ```. Makes. ```julia; julia> @time compute!(averaged_c); 1.576736 seconds (1.81 M allocations: 123.040 MiB, 99.63% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.450573 seconds (150.91 k allocations: 10.220 MiB, 7.82% gc time, 99.15% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.403323 seconds (150.90 k allocations: 10.217 MiB, 98.63% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearG",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959:1295,reduce,reduced,1295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959,1,['reduce'],['reduced']
Energy Efficiency,"agree with Greg. I would prefer we get w by stepping forward for w because; then there are no concerns about rigid lids etc. We ended up using; continuity because the elliptic inversion was missing a div.v/delt source; term. When that problem got fixed I believe integrating forward for w works; just fine. Ali, can you confirm?. On Wed, Aug 7, 2019 at 8:16 AM Gregory L. Wagner <notifications@github.com>; wrote:. > We originally did the recompilation of w from continuity partly because we; > thought this may prevent an accumulation of error that could otherwise; > occur, and partly because @sandreza <https://github.com/sandreza>; > convinced us this was more correct. But I would argue that because we; > haven't done model verification we aren't sure whether this is correct or; > not.; >; > Another issue, or annoyance, with recomputing w from continuity is that it; > is only valid in the case of rigid lids on top and bottom.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/336?email_source=notifications&email_token=AKXUEQUD4TCBCCFDIMAPNC3QDK4KXA5CNFSM4IJ2G5UKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD3YGJQY#issuecomment-519070915>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQPFPDDHQ2JSNTPR3TQDK4KXANCNFSM4IJ2G5UA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-519073694:1498,Green,Green,1498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-519073694,1,['Green'],['Green']
Energy Efficiency,"al reflection; zₚ = reshape(repeat(z₀, 5), size(xₚ)) # Vertical direction isn't periodic, so we just need to repeat and reshape things . resolved_noise(x, y, z) = sum(@. 1e-6 * exp(-(x-xₚ)^2/σx^2 -(z-zₚ)^2/σz^2)). constant_stratification(x, y, z) = 1e-5 * z; set!(model, u=resolved_noise, b=constant_stratification). u, v, w = model.velocities. simulation = Simulation(model, Δt=20.0, stop_iteration=1e4); progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)). e = (u^2 + w^2) / 2; E = Field(Integral(e, dims=:)); outputs = merge(model.velocities, model.tracers, (; e, E)). filename = ""test.jld2""; simulation.output_writers[:fields] = JLD2OutputWriter(model, outputs;; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); et = FieldTimeSeries(filename, ""e""); bt = FieldTimeSeries(filename, ""b""); Et = FieldTimeSeries(filename, ""E""); times = wt.times; Nt = length(times). using GLMakie; fig = Figure(resolution=(900, 450)). axw = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)"", title=""Vertical velocity""); axe = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)"", title=""Kinetic energy""); axb = Axis(fig[1, 3], xlabel=""x (m)"", ylabel=""z (m)"", title=""Buoyancy""); axE = Axis(fig[2, 1:3], xlabel=""Time (s)"", ylabel=""Volume averaged kinetic energy""). n = Observable(1). wn = @lift interior(wt[$n], :, 1, :); en = @lift interior(et[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). x, y, z = nodes(et). wlim = maximum(abs, wt); elim = maximum(abs, et). heatmap!(axw, x, z, wn, colorrange=(-wlim, wlim), colormap=:balance); heatmap!(axe, x, z, en, colorrange=(0, elim), colormap=:solar); heatmap!(axb, x, z, bn, colorrange=(0, 1e-3), colormap=:thermal). t = @lift times[$n]; lines!(axE, times, Et[:]); vlines!(axE, t). display(fig). record(fig, ""test.mp4"", 1:Nt) do nn; @info ""Recording frame $nn of $Nt""; n[] = nn; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462391476:2095,energy,energy,2095,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462391476,2,['energy'],['energy']
Energy Efficiency,"ally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily specifiable. If we want an easy default, then maybe it could do some version of the unique directories? Or maybe have `overwrite_existing = false` (the default) just rename existing files?. I'm not sure of the best approach but as someone who's conservative about overwriting by default I'm tempted to err on the side of caution. > Another abstraction I think would be useful is a utility for building multiple outputs. Imagine this:; > ; > ```julia; > indices = (xy=(:, :, k), xz=(:, 1, :), yz=(1, :, :)); > sliced_outputs!(simulation, outputs, indices; schedule=TimeInterval(1), filename=""sliced""); > ```; > ; > this would append `filename` with the keys of `indices`, eg we would get 3 outputs titled `""sliced_xy""`, `""sliced_xz""`, and `""sliced_yz""`. Love this idea! Hoping that you can also pass e.g. `(surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :))` to get `sliced_surface`, `sliced_zonal`, and `sliced_meridional`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:2551,schedul,schedule,2551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,1,['schedul'],['schedule']
Energy Efficiency,"alo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `98.07% <100.00%> (+0.21%)` | :arrow_up: |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.21% <100.00%> (-0.25%)` | :arrow_down: |; | [src/Simulations/simulation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3NpbXVsYXRpb24uamw=) | `68.75% <0.00%> (-6.25%)` | :arrow_down: |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `92.30% <0.00%> (+0.47%)` | :arrow_up: |; | [src/Buoyancy/seawater\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L3NlYXdhdGVyX2J1b3lhbmN5Lmps) | `74.07% <0.00%> (+3.48%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984?src=pr&el=footer). Last update [d80be8c...f384f90](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/984#issuecomment-699495385:3267,Power,Powered,3267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/984#issuecomment-699495385,1,['Power'],['Powered']
Energy Efficiency,"also worth checking out . https://github.com/rafaqz/DimensionalData.jl. the `Time` object is a ""selector"" in their terminology. IF we have something similar here, we could eventually consider sub typing `AbstractDimArray` (which has been proposed before), which gives us a lot of powerful functionality. Someone passionate about that stuff has to take that on for a full implementation but at least we are consistent with it, which helps",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696136206:280,power,powerful,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696136206,1,['power'],['powerful']
Energy Efficiency,"ananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | `94.73% <ø> (ø)` | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | `85.33% <77.55%> (-14.67%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9mX3BsYW5lLmps) | `80.00% <80.00%> (ø)` | |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `82.60% <82.60%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | ... and [20 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=footer). Last update [eeb62d1...d5dfc74](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480:3289,Power,Powered,3289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480,1,['Power'],['Powered']
Energy Efficiency,"anigans.jl/pull/130?src=pr&el=h1) Report; > Merging [#130](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/0947ba57b9f35a5ee721c951da8f6def89db0d70?src=pr&el=desc) will **decrease** coverage by `0.42%`.; > The diff coverage is `72.72%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #130 +/- ##; ==========================================; - Coverage 57.29% 56.87% -0.43% ; ==========================================; Files 19 19 ; Lines 644 647 +3 ; ==========================================; - Hits 369 368 -1 ; - Misses 275 279 +4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `83.33% <ø> (-4.91%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `69.28% <72.72%> (-1.07%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=footer). Last update [0947ba5...f31e0b3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/130#issuecomment-473474188:1757,Power,Powered,1757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/130#issuecomment-473474188,1,['Power'],['Powered']
Energy Efficiency,"ans do we want sprinkled throughout the domain?; x₀ = grid.Lx * rand(N); z₀ = grid.Lz * rand(N) # Locations of the Gaussians. xₚ = x₀ .+ (grid.Lx .* [-2;;-1;;0;;1;;2]) # Make that noise periodic by ""infinite"" horizontal reflection; zₚ = reshape(repeat(z₀, 5), size(xₚ)) # Vertical direction isn't periodic, so we just need to repeat and reshape things . resolved_noise(x, y, z) = sum(@. 1e-6 * exp(-(x-xₚ)^2/σx^2 -(z-zₚ)^2/σz^2)). constant_stratification(x, y, z) = 1e-5 * z; set!(model, u=resolved_noise, b=constant_stratification). u, v, w = model.velocities. simulation = Simulation(model, Δt=20.0, stop_iteration=1e4); progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)). e = (u^2 + w^2) / 2; E = Field(Integral(e, dims=:)); outputs = merge(model.velocities, model.tracers, (; e, E)). filename = ""test.jld2""; simulation.output_writers[:fields] = JLD2OutputWriter(model, outputs;; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); et = FieldTimeSeries(filename, ""e""); bt = FieldTimeSeries(filename, ""b""); Et = FieldTimeSeries(filename, ""E""); times = wt.times; Nt = length(times). using GLMakie; fig = Figure(resolution=(900, 450)). axw = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)"", title=""Vertical velocity""); axe = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)"", title=""Kinetic energy""); axb = Axis(fig[1, 3], xlabel=""x (m)"", ylabel=""z (m)"", title=""Buoyancy""); axE = Axis(fig[2, 1:3], xlabel=""Time (s)"", ylabel=""Volume averaged kinetic energy""). n = Observable(1). wn = @lift interior(wt[$n], :, 1, :); en = @lift interior(et[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). x, y, z = nodes(et). wlim = maximum(abs, wt); elim = maximum(abs, et). heatmap!(axw, x, z, wn, colorrange=(-wlim, wlim), colormap=:balance); heatmap!(axe, x, z, en, colorrange=(0, elim), colormap=:solar); heatmap!(axb, x, z, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462391476:1625,schedul,schedule,1625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462391476,1,['schedul'],['schedule']
Energy Efficiency,"ans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `70% <0%> (ø)` | :arrow_up: |; | [...closures/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvcm96ZW1hX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `23.95% <0%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `52.54% <0%> (ø)` | |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `69.72% <0%> (ø)` | |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <0%> (ø)` | |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `88.7% <0%> (+1.2%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380?src=pr&el=footer). Last update [8c1c776...ee0b40e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/380#issuecomment-525911444:3708,Power,Powered,3708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380#issuecomment-525911444,1,['Power'],['Powered']
Energy Efficiency,"ans; using Oceananigans.Utils; using Oceananigans.Units. grid = RegularRectilinearGrid(size=(4, 4, 4), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); coriolis = FPlane(f=1e-4) # [s⁻¹]. model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = coriolis,; tracers = NamedTuple(),; buoyancy = nothing,; closure = nothing,; ); set!(model, u=0.4). using Oceanostics: SingleLineProgressMessenger; Δt = 20minutes; simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days,; progress = SingleLineProgressMessenger()). using Oceananigans.Fields: ComputedField; using Oceanostics: KineticEnergy. u, v, w = model.velocities # unpack velocity `Field`s. # Vertical vorticity [s⁻¹]; tke_k = KineticEnergy(model, u, v, w); tke_c = ComputedField(@at (Center, Center, Center) (u^2+v^2+w^2)/2). outputs = (tke_c=tke_c, u=u,). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(2Δt),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:1277,schedul,schedule,1277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633,1,['schedul'],['schedule']
Energy Efficiency,"ask=sponge_mask, target=0.0); forcing_sponge = (; u=uvw_sponge, v=uvw_sponge, w=uvw_sponge). model = HydrostaticFreeSurfaceModel(grid=grid, boundary_conditions=bcs,; momentum_advection=nothing, # Linear to compare with analytical solution.; closure=turbulence_closure,; forcing=forcing_sponge,; buoyancy=nothing,; coriolis=FPlane(f=f)). simulation = Simulation(model; Δt=Δt, stop_time=te). start_time = time_ns(); function log_message(sim); prog = 100*time(sim)/sim.stop_time; @printf(""[%05.2f%%] t: %1.1f Ti, Δt: %s, max|u, v, w|: %1.2f, %1.2f, %1.1e m s⁻¹, walltime: %s\n"",; prog, time(sim)/Ti, prettytime(sim.Δt),; maximum(abs, sim.model.velocities.u), maximum(abs, sim.model.velocities.v), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); end. simulation.callbacks[:progress] = Callback(log_message, IterationInterval(1)); outputs = (; u=model.velocities.u, v=model.velocities.v); simulation.output_writers[:fields2D] = NetCDFOutputWriter(model, outputs,; schedule=TimeInterval(outdt),; filename=fout,; overwrite_existing=true). run!(simulation). # Compare equilibrated numerical solution to the steady analytical solution. # Analytical solution to the steady problem (Estrade et al., 2008, Equation 15):; # u + i*v = (u₀ + i*v₀) * sinh(c*(z + h))/cosh(c*h) + 2*i*v₀ * ((1 - S₁) / (γ*T₁ - T₂)) * (1 - cosh(c*z)/cosh(c*h)). ds = Dataset(fout, ""r""); x, z = Array(ds[""xC""]), Array(ds[""zC""]). nl = size(ds[""u""])[end] - laststeps_avg; unum = mean(ds[""u""][:, 1, :, nl:end], dims=3)[:, : , 1]; vnum = mean(ds[""v""][:, 1, :, nl:end], dims=3)[:, : , 1]; unum = 0.5*(unum[2:end, :] + unum[1:end-1, :]) # Move u from xF to xC. h = @. hmin - slope*x. ɣ = f/abs(f); c = (1 + im*ɣ) * π/D; nz, nx = length(z), length(x). honD = h/D; hD = π*honD; honDmi = 0. α = @. (cosh(hD) * cos(hD))^2 + (sinh(hD) * sin(hD))^2; S₁ = @. cosh(hD) * cos(hD) * 1/α; S₂ = @. sinh(hD) * sin(ɣ * hD) * 1/α; T₁ = @. cosh(hD) * sinh(hD) * 1/α; T₂ = @. cos(hD) * sin(ɣ * hD) * 1/α. # Estrade et al.'s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2254094925:5145,schedul,schedule,5145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2254094925,1,['schedul'],['schedule']
Energy Efficiency,"aster](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/232aab2b8c3dc5cf6bc59931a197fde588d6be57?el=desc) will **increase** coverage by `0.28%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1078 +/- ##; ==========================================; + Coverage 56.91% 57.20% +0.28% ; ==========================================; Files 162 162 ; Lines 3811 3881 +70 ; ==========================================; + Hits 2169 2220 +51 ; - Misses 1642 1661 +19 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `59.75% <0.00%> (+2.61%)` | :arrow_up: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `68.08% <0.00%> (+3.79%)` | :arrow_up: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `82.22% <0.00%> (+4.44%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=footer). Last update [232aab2...96e4113](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-711070198:1903,Power,Powered,1903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-711070198,1,['Power'],['Powered']
Energy Efficiency,"at, Bounded));. julia> bottom(x) = - underlying_grid.Lz + 500 * exp(-x^2 / (2*(20e3)^2));. julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom));. julia> c = Field{Center, Nothing, Nothing}(grid); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand()); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.952381, min=0.952381, mean=0.952381. julia> lines(c). julia> c; 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=NaN, min=NaN, mean=NaN; ```. After plotting a field then it has NaNs. Is this OK?; Of course, we expect that because we masked it in immersed regions. Is the issue here the show me",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749:1002,reduce,reduced,1002,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749,1,['reduce'],['reduced']
Energy Efficiency,"averaged_c); 0.404525 seconds (150.90 k allocations: 10.221 MiB, 98.74% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.412531 seconds (150.90 k allocations: 10.219 MiB, 98.85% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.007040 seconds (204 allocations: 44.438 KiB); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959:3997,reduce,reduced,3997,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959,1,['reduce'],['reduced']
Energy Efficiency,"b3BpY19kaWZmdXNpdml0eS5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `0% <0%> (ø)` | |; | [src/TurbulenceClosures/closure\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX3R1cGxlcy5qbA==) | `50% <100%> (-50%)` | :arrow_down: |; | [...mplementations/constant\_anisotropic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2NvbnN0YW50X2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `33.33% <26.31%> (-66.67%)` | :arrow_down: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `66.66% <33.33%> (-13.59%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518?src=pr&el=footer). Last update [8666964...7a765f2](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/518#issuecomment-548737546:3192,Power,Powered,3192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/518#issuecomment-548737546,1,['Power'],['Powered']
Energy Efficiency,"b3JzLmps) | `100.00% <0.00%> (ø)` | |; | [...urbulenceClosures/viscous\_dissipation\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92aXNjb3VzX2Rpc3NpcGF0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `100.00% <0.00%> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100.00% <0.00%> (ø)` | |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `100.00% <0.00%> (ø)` | |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `37.93% <0.00%> (+1.08%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782?src=pr&el=footer). Last update [f18daed...0358145](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/782#issuecomment-652577566:3749,Power,Powered,3749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/782#issuecomment-652577566,1,['Power'],['Powered']
Energy Efficiency,"bG93V2F0ZXJNb2RlbHMvc2V0X3NoYWxsb3dfd2F0ZXJfbW9kZWwuamw=) | `0.00% <0.00%> (ø)` | |; | [...c/Models/ShallowWaterModels/shallow\_water\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvc2hhbGxvd193YXRlcl9tb2RlbC5qbA==) | `0.00% <0.00%> (ø)` | |; | [...els/ShallowWaterModels/show\_shallow\_water\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvc2hvd19zaGFsbG93X3dhdGVyX21vZGVsLmps) | `0.00% <0.00%> (ø)` | |; | [...allowWaterModels/solution\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvc29sdXRpb25fYW5kX3RyYWNlcl90ZW5kZW5jaWVzLmps) | `0.00% <0.00%> (ø)` | |; | [src/Models/ShallowWaterModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvdXBkYXRlX3N0YXRlLmps) | `0.00% <0.00%> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `75.00% <ø> (ø)` | |; | ... and [10 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188?src=pr&el=footer). Last update [7c8c0cf...6112c6c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729133987:3724,Power,Powered,3724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729133987,1,['Power'],['Powered']
Energy Efficiency,"bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=10.0, max_change=1.1, max_Δt=1minute,cell_advection_timescale = accurate_cell_advection_timescale). start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=wizard, stop_time=40minutes, iteration_interval=10,; progress=progress_message); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586:3674,schedul,schedule,3674,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586,1,['schedul'],['schedule']
Energy Efficiency,"best to avoid lowercase `l` I think. Why don't we just keep capital `N` for now. I think we could have some changes coming down the pipe that would greatly facilitate this change (macro that pastes our triple loop, so reduce that massive amount of boilerplate and can change syntax in single place rather than 30 different locations). I thought `RegularCartesianGrid(FT, nx, ny, nz; length) ` could dispatch on its 4 positional args. What is the conflicting function `RegularCartesianGrid` that has 4 positional args, and why can't dispatch be used there?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-544204333:218,reduce,reduce,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-544204333,1,['reduce'],['reduce']
Energy Efficiency,"bstractOperations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <0.00%> (-33.34%)` | :arrow_down: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `61.11% <0.00%> (-23.10%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `66.66% <0.00%> (-22.23%)` | :arrow_down: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <0.00%> (-20.00%)` | :arrow_down: |; | ... and [37 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720?src=pr&el=footer). Last update [6502f07...e778d2d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/720#issuecomment-605402183:3576,Power,Powered,3576,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/720#issuecomment-605402183,1,['Power'],['Powered']
Energy Efficiency,"c, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}}, outputs::NamedTuple{(:a_field,), Tuple{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, array_type::Type, max_filesize::Float64, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{Symbol}, verbose::Bool, part::Int64, jld2_kw::Dict{Symbol, Any}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/jld2_output_writer.jl:179; [13] top-level scope; @ REPL[17]:1; [14] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:65055,schedul,schedule,65055,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061,1,['schedul'],['schedule']
Energy Efficiency,"c/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `86.11% <ø> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `71.56% <0%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `52.74% <0%> (-0.59%)` | :arrow_down: |; | [src/TurbulenceClosures/closure\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX3R1cGxlcy5qbA==) | `100% <100%> (ø)` | |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `60.39% <100%> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `70% <100%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517?src=pr&el=footer). Last update [2803ace...590f224](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/517#issuecomment-548111479:2771,Power,Powered,2771,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/517#issuecomment-548111479,1,['Power'],['Powered']
Energy Efficiency,"c3NpcGF0aW9uX29wZXJhdG9ycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/Operators/laplacian\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9sYXBsYWNpYW5fb3BlcmF0b3JzLmps) | `100% <ø> (+85.71%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.61% <ø> (ø)` | :arrow_up: |; | [src/Operators/momentum\_advection\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9tb21lbnR1bV9hZHZlY3Rpb25fb3BlcmF0b3JzLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/Diagnostics/cfl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | ... and [40 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543?src=pr&el=footer). Last update [9fbbc93...8e51fdc](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/543#issuecomment-560540863:3641,Power,Powered,3641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/543#issuecomment-560540863,1,['Power'],['Powered']
Energy Efficiency,"c3RydWN0aW9uLmps) | `0.00% <0.00%> (-60.00%)` | :arrow_down: |; | [src/Coriolis/beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2JldGFfcGxhbmUuamw=) | `0.00% <0.00%> (-58.83%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `0.00% <0.00%> (-58.07%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `0.00% <0.00%> (-54.17%)` | :arrow_down: |; | [src/Fields/reduced\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9yZWR1Y2VkX2ZpZWxkLmps) | `28.94% <0.00%> (-50.01%)` | :arrow_down: |; | [src/Advection/weno\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX2ZpZnRoX29yZGVyLmps) | `0.00% <0.00%> (-44.28%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `47.36% <0.00%> (-32.64%)` | :arrow_down: |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=footer). Last update [03a6f85...c717dd5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894:3598,Power,Powered,3598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894,1,['Power'],['Powered']
Energy Efficiency,"c=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `71.42% <0%> (+4.76%)` | :arrow_up: |; | [src/Operators/interpolation\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9pbnRlcnBvbGF0aW9uX29wZXJhdG9ycy5qbA==) | `64.28% <0%> (+4.76%)` | :arrow_up: |; | [src/Operators/derivative\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9kZXJpdmF0aXZlX29wZXJhdG9ycy5qbA==) | `90.62% <0%> (+32%)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `100% <0%> (+50%)` | :arrow_up: |; | [...ure\_implementations/leith\_enstrophy\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2xlaXRoX2Vuc3Ryb3BoeV9kaWZmdXNpdml0eS5qbA==) | `98.38% <0%> (+66.12%)` | :arrow_up: |; | [src/Operators/laplacian\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9sYXBsYWNpYW5fb3BlcmF0b3JzLmps) | `100% <0%> (+85.71%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556?src=pr&el=footer). Last update [a511fdd...e187583](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-562859953:3263,Power,Powered,3263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-562859953,1,['Power'],['Powered']
Energy Efficiency,"c=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `69% <100%> (-2.98%)` | :arrow_down: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `88.57% <100%> (+37.14%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (+0.37%)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `66.66% <61.29%> (+7.51%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40% <71.42%> (-0.66%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `83.33% <75%> (+20.83%)` | :arrow_up: |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=footer). Last update [a26da9c...db0165c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942485:3456,Power,Powered,3456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942485,1,['Power'],['Powered']
Energy Efficiency,"ceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3dpdGhfdHJhY2Vycy5qbA==) | `69.23% <0.00%> (-30.77%)` | :arrow_down: |; | [src/Advection/weno\_reconstruction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX3JlY29uc3RydWN0aW9uLmps) | `63.15% <0.00%> (-27.17%)` | :arrow_down: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `40.00% <0.00%> (-26.67%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `5.40% <0.00%> (-21.63%)` | :arrow_down: |; | [src/Models/Models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `83.33% <0.00%> (-16.67%)` | :arrow_down: |; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `65.00% <0.00%> (-1.67%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | ... and [92 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000?src=pr&el=footer). Last update [e808a82...ba06f1a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1000#issuecomment-700426227:3452,Power,Powered,3452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1000#issuecomment-700426227,1,['Power'],['Powered']
Energy Efficiency,"ceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `74.19% <0%> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77.71% <100%> (+0.24%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.61% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.85% <100%> (+0.17%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `83.05% <86.36%> (+18.76%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.14% <90%> (+3.86%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `75.33% <91.66%> (-0.8%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389?src=pr&el=footer). Last update [e65a74a...379df34](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527186190:3007,Power,Powered,3007,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527186190,1,['Power'],['Powered']
Energy Efficiency,"chine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.94% <0%> (-56.72%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `49.35% <0%> (-15.59%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <0%> (-12.5%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `78.26% <0%> (-7.32%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.02% <0%> (-2.1%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <0%> (-1.64%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `82.05% <0%> (+1.09%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `82.38% <0%> (+2.27%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425?src=pr&el=footer). Last update [d32cf20...db00c29](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-533606372:2990,Power,Powered,2990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-533606372,1,['Power'],['Powered']
Energy Efficiency,"chine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `84.37% <ø> (ø)` | :arrow_up: |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `75.86% <0%> (+10.34%)` | :arrow_up: |; | [src/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2Nsb2NrLmps) | `50% <0%> (-50%)` | :arrow_down: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `79.31% <0%> (-4.33%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `61.05% <0%> (-2.78%)` | :arrow_down: |; | [src/coriolis.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2NvcmlvbGlzLmps) | `51.85% <0%> (-9.02%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `71.81% <100%> (+0.25%)` | :arrow_up: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `88% <0%> (+1.04%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570?src=pr&el=footer). Last update [d27ab4f...30319ec](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570#issuecomment-566756764:2817,Power,Powered,2817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570#issuecomment-566756764,1,['Power'],['Powered']
Energy Efficiency,"ckages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKerne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2099,Adapt,Adapt,2099,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Energy Efficiency,"climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `85.71% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `87.5% <ø> (+3.12%)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `0% <0%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.96% <100%> (+0.34%)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `9.09% <0%> (-13.64%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.98% <0%> (-5.8%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101?src=pr&el=footer). Last update [b6b27af...6d0b6d5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/101#issuecomment-468943943:2836,Power,Powered,2836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/101#issuecomment-468943943,2,['Power'],['Powered']
Energy Efficiency,"climate-machine/Oceananigans.jl/pull/382?src=pr&el=h1) Report; > Merging [#382](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/8c1c776b50df17ff10735e57488f22b20d455303?src=pr&el=desc) will **increase** coverage by `0.13%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #382 +/- ##; =========================================; + Coverage 78.37% 78.5% +0.13% ; =========================================; Files 22 22 ; Lines 1244 1247 +3 ; =========================================; + Hits 975 979 +4 ; + Misses 269 268 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77% <100%> (+0.5%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `98.4% <0%> (+0.78%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=footer). Last update [8c1c776...424d943](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-525955144:1736,Power,Powered,1736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-525955144,1,['Power'],['Powered']
Energy Efficiency,"climate-machine/Oceananigans.jl/pull/475?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #475 +/- ##; ==========================================; - Coverage 72.07% 69.12% -2.95% ; ==========================================; Files 26 26 ; Lines 1418 1490 +72 ; ==========================================; + Hits 1022 1030 +8 ; - Misses 396 460 +64; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `83.51% <ø> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `48.83% <0%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `59.34% <20%> (-25.91%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `60.18% <29.41%> (-29.96%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.97% <95.23%> (+0.94%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=footer). Last update [211e18c...9a622f0](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/475#issuecomment-541976850:2277,Power,Powered,2277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/475#issuecomment-541976850,1,['Power'],['Powered']
Energy Efficiency,"climate-machine/Oceananigans.jl/pull/613?src=pr&el=h1) Report; > Merging [#613](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/f080635b93bdab9da7d1189ed21f27523c0ff810?src=pr&el=desc) will **not change** coverage.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #613 +/- ##; =======================================; Coverage 74.55% 74.55% ; =======================================; Files 117 117 ; Lines 2209 2209 ; =======================================; Hits 1647 1647 ; Misses 562 562; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/BoundaryConditions/BoundaryConditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=footer). Last update [f080635...e714993](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/613#issuecomment-581647856:1736,Power,Powered,1736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/613#issuecomment-581647856,1,['Power'],['Powered']
Energy Efficiency,"cmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <0.00%> (-16.67%)` | :arrow_down: |; | [src/Diagnostics/cfl.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `66.66% <0.00%> (-13.34%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `48.38% <0.00%> (-3.54%)` | :arrow_down: |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | | |; | [...mpressibleModels/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | | |; | [...vection/topologically\_conditional\_interpolation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90b3BvbG9naWNhbGx5X2NvbmRpdGlvbmFsX2ludGVycG9sYXRpb24uamw=) | | |; | ... and [184 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590?src=pr&el=footer). Last update [0fb5286...ab3e539](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-571334236:3499,Power,Powered,3499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-571334236,1,['Power'],['Powered']
Energy Efficiency,"codecov.io/gh/CliMA/Oceananigans.jl/commit/80fb511ff5a5bb641481b6209ca101ea8c4b8149&el=desc) will **decrease** coverage by `0.11%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #807 +/- ##; ==========================================; - Coverage 71.15% 71.04% -0.12% ; ==========================================; Files 186 186 ; Lines 4839 4824 -15 ; ==========================================; - Hits 3443 3427 -16 ; - Misses 1396 1397 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `90.74% <100.00%> (-0.49%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <100.00%> (-5.32%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=footer). Last update [80fb511...7e95ea6](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/807#issuecomment-660647101:1917,Power,Powered,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/807#issuecomment-660647101,1,['Power'],['Powered']
Energy Efficiency,"codecov.io/gh/climate-machine/Oceananigans.jl/commit/cde6246ac753b206d81167dbc024521e8c7276c7?src=pr&el=desc) will **decrease** coverage by `0.08%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #172 +/- ##; ==========================================; - Coverage 68.79% 68.71% -0.09% ; ==========================================; Files 18 18 ; Lines 657 652 -5 ; ==========================================; - Hits 452 448 -4 ; + Misses 205 204 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.04% <100%> (+0.02%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=footer). Last update [cde6246...c3a3c3d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481421290:1917,Power,Powered,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481421290,1,['Power'],['Powered']
Energy Efficiency,"codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #352 +/- ##; ==========================================; + Coverage 72.86% 72.89% +0.03% ; ==========================================; Files 22 22 ; Lines 1157 1214 +57 ; ==========================================; + Hits 843 885 +42 ; - Misses 314 329 +15; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `12.9% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `43.9% <0%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `61.42% <100%> (+1.72%)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `50% <47.56%> (+37.5%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=footer). Last update [7a4142c...5bbb71e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223462:2263,Power,Powered,2263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223462,1,['Power'],['Powered']
Energy Efficiency,"commit/e83d621859dd660e4576024ab461dafa46ff45bc?src=pr&el=desc) will **increase** coverage by `0.26%`.; > The diff coverage is `78.57%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #490 +/- ##; ==========================================; + Coverage 73.22% 73.48% +0.26% ; ==========================================; Files 27 27 ; Lines 1505 1516 +11 ; ==========================================; + Hits 1102 1114 +12 ; + Misses 403 402 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/coriolis.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/diff?src=pr&el=tree#diff-c3JjL2NvcmlvbGlzLmps) | `68.18% <78.57%> (+8.18%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `68.53% <0%> (+4.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=footer). Last update [e83d621...de5764b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/490#issuecomment-544486641:1963,Power,Powered,1963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/490#issuecomment-544486641,1,['Power'],['Powered']
Energy Efficiency,"complex geometries in the 1980s. That also would not require us to change; the solver. You carry out Green's function calculations in a rectangular; region where the delta-functions vorticities are placed at the positions of; the irregular boundary within the larger rectangular region. I will look; them out. John. On Sat, Mar 28, 2020 at 11:20 AM Gregory L. Wagner <notifications@github.com>; wrote:. > @johncmarshall54 <https://github.com/johncmarshall54> agreed, that's a; > challenge we have to confront.; >; > If we implement immersed boundaries using the ""continuous forcing; > technique"", then a boundary may be defined essentially by a masking; > function. In this case, we might be able to ""label"" each boundary / masking; > function with a name or number.; >; > The boundary condition objects we then give to fields would have to define; > a condition to be applied both at the boundaries of the numerical grid; > (which we currently support), as well as any immersed boundaries, where; > immersed boundaries are referenced by name or number.; >; > By the way, if we use a continuous forcing technique, we do not have to; > change the pressure solver. This is a major simplification. Recent work; > suggests there is no disadvantage in terms of accuracy in using the; > continuous forcing technique, either. I'm not sure if this is too good to; > believe or not --- we should discuss and take a deeper look at the; > literature.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605461456>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQHGXSSKOU7EIXSLBTRJYIVFANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623:1924,Green,Green,1924,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623,1,['Green'],['Green']
Energy Efficiency,"convert_diffusivity(FT, κ), strain_rate); end; end; ```. where `strain_rate = Traceless()` would inform the turbulence closure to use the traceless rate of strain. Stress divergences are computed here:. https://github.com/climate-machine/Oceananigans.jl/blob/042f8cf12928b53b36cfa2a61a6b6a8ec7dc71bc/src/TurbulenceClosures/closure_operators.jl#L38. For example, one component of the stress divergence is:. ```julia; @inline ∂x_2ν_Σ₁₁(i, j, k, grid, closure, U, diffusivities) =; 2 * ∂xᶠᵃᵃ(i, j, k, grid, ν_σᶜᶜᶜ, diffusivities.νₑ, Σ₁₁, U.u, U.v, U.w); ```. We can thus *extend* functionality via dispatch:. ```julia; @inline ∂x_2ν_Σ₁₁(i, j, k, grid, ::TracelessStrainRateClosure, U, diffusivities) =; 2 * ∂xᶠᵃᵃ(i, j, k, grid, ν_σᶜᶜᶜ, diffusivities.νₑ, traceless_Σ₁₁, U.u, U.v, U.w); ```. where `TracelessStrainRateClosure` is an alias for a closure that requires the traceless strain rate. > A turbulence closure can define ∂ⱼτᵢⱼ directly to elide or short circuit computations or in case the SGS stress tensor is not of the form ∂ⱼτᵢⱼ = νˢᵍˢSᵢⱼ. This is how the system already works for closures that don't have eddy diffusivities. Is something different from the current system being proposed?. > @thabbott suggested that νˢᵍˢ might have to dispatch on the thermodynamic variable as well. Is this true for the viscosity or only the diffusivities κˢᵍˢ? I.e. do we have to treat SGS fluxes of moisture and energy in a special way?. Currently, the `calculate_diffusivities!` functions receives `buoyancy`, `velocities`, and `tracers`, as arguments:. https://github.com/climate-machine/Oceananigans.jl/blob/042f8cf12928b53b36cfa2a61a6b6a8ec7dc71bc/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L176. If a different abstraction is needed we can change the `calculate_diffusivities` function appropriately. As for ensuring that compressible models always use the correct strain rate, this can be handled within the `CompressibleModel` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592732479:2428,energy,energy,2428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592732479,1,['energy'],['energy']
Energy Efficiency,"coriolis = FPlane(f=1e-4) # [s⁻¹]. model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = coriolis,; tracers = NamedTuple(),; buoyancy = nothing,; closure = nothing,; ); set!(model, u=0.4). using Oceanostics: SingleLineProgressMessenger; Δt = 20minutes; simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days,; progress = SingleLineProgressMessenger()). using Oceananigans.Fields: ComputedField; using Oceanostics: KineticEnergy. u, v, w = model.velocities # unpack velocity `Field`s. # Vertical vorticity [s⁻¹]; tke_k = KineticEnergy(model, u, v, w); tke_c = ComputedField(@at (Center, Center, Center) (u^2+v^2+w^2)/2). outputs = (tke_c=tke_c, u=u,). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(2Δt),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in the list of outputs changes the average result for `u`! Below is a list of what works and doesn't work (for `u`) when setting the list of outp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:1419,schedul,schedule,1419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633,1,['schedul'],['schedule']
Energy Efficiency,"cov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=h1) Report; > Merging [#1161](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=desc) (8124ad7) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/0c2b51293d324836846f31ab93c7515b05e797b5?el=desc) (0c2b512) will **increase** coverage by `0.38%`.; > The diff coverage is `66.66%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1161 +/- ##; ==========================================; + Coverage 57.01% 57.39% +0.38% ; ==========================================; Files 162 162 ; Lines 3913 3962 +49 ; ==========================================; + Hits 2231 2274 +43 ; - Misses 1682 1688 +6 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `85.54% <66.66%> (-2.62%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `86.30% <0.00%> (+2.64%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=footer). Last update [0c2b512...8124ad7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1161#issuecomment-724397486:1744,Power,Powered,1744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1161#issuecomment-724397486,1,['Power'],['Powered']
Energy Efficiency,"cov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/92d77b028d39014e2818d2d1fe56038fd1810256&el=desc) will **increase** coverage by `0.05%`.; > The diff coverage is `84.61%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #745 +/- ##; ==========================================; + Coverage 77.05% 77.10% +0.05% ; ==========================================; Files 123 124 +1 ; Lines 2462 2477 +15 ; ==========================================; + Hits 1897 1910 +13 ; - Misses 565 567 +2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/Forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvRm9yY2luZy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Forcing/relaxation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcmVsYXhhdGlvbi5qbA==) | `84.61% <84.61%> (ø)` | |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `80.00% <0.00%> (+5.00%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=footer). Last update [92d77b0...63f9f11](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/745#issuecomment-622493232:1838,Power,Powered,1838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/745#issuecomment-622493232,1,['Power'],['Powered']
Energy Efficiency,"cov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/7f957d7762b61ee4e51b360944428d5b660d50bf&el=desc) will **increase** coverage by `0.04%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #772 +/- ##; ==========================================; + Coverage 77.65% 77.70% +0.04% ; ==========================================; Files 165 165 ; Lines 4404 4413 +9 ; ==========================================; + Hits 3420 3429 +9 ; Misses 984 984 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `100.00% <ø> (ø)` | |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `84.61% <100.00%> (+4.61%)` | :arrow_up: |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=footer). Last update [7f957d7...c19f69c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/772#issuecomment-641394370:1838,Power,Powered,1838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/772#issuecomment-641394370,1,['Power'],['Powered']
Energy Efficiency,"cov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=h1) Report; > Merging [#794](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/d383b6a27fc95837b591bd1e68e1aaca50f97da6&el=desc) will **decrease** coverage by `0.62%`.; > The diff coverage is `0.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #794 +/- ##; ==========================================; - Coverage 71.67% 71.05% -0.63% ; ==========================================; Files 184 186 +2 ; Lines 4781 4823 +42 ; ==========================================; Hits 3427 3427 ; - Misses 1354 1396 +42 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | `0.00% <0.00%> (ø)` | |; | [docs/citations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/diff?src=pr&el=tree#diff-ZG9jcy9jaXRhdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [docs/make.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/diff?src=pr&el=tree#diff-ZG9jcy9tYWtlLmps) | `0.00% <ø> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=footer). Last update [d383b6a...c6d7bbe](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/794#issuecomment-657608828:1746,Power,Powered,1746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794#issuecomment-657608828,1,['Power'],['Powered']
Energy Efficiency,"cov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=h1) Report; > Merging [#228](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/ca03838d46fd4905379a1bc08697be5bcfcf99ef?src=pr&el=desc) will **increase** coverage by `0.29%`.; > The diff coverage is `50%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #228 +/- ##; ==========================================; + Coverage 67.25% 67.55% +0.29% ; ==========================================; Files 18 18 ; Lines 675 675 ; ==========================================; + Hits 454 456 +2 ; + Misses 221 219 -2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.04% <50%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.35% <0%> (+3.5%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=footer). Last update [ca03838...0f59662](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220658:1709,Power,Powered,1709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220658,1,['Power'],['Powered']
Energy Efficiency,"cov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=h1) Report; > Merging [#228](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/ca03838d46fd4905379a1bc08697be5bcfcf99ef?src=pr&el=desc) will **increase** coverage by `0.29%`.; > The diff coverage is `50%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #228 +/- ##; ==========================================; + Coverage 67.25% 67.55% +0.29% ; ==========================================; Files 18 18 ; Lines 675 675 ; ==========================================; + Hits 454 456 +2 ; + Misses 221 219 -2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.04% <50%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.35% <0%> (+3.5%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=footer). Last update [ca03838...4bb6f50](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220644:1709,Power,Powered,1709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220644,1,['Power'],['Powered']
Energy Efficiency,"coverage by `0.03%`.; > The diff coverage is `85.36%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #464 +/- ##; ==========================================; - Coverage 73.34% 73.31% -0.04% ; ==========================================; Files 27 27 ; Lines 1508 1525 +17 ; ==========================================; + Hits 1106 1118 +12 ; - Misses 402 407 +5; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `47.67% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `79.54% <66.66%> (ø)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `83.33% <86.84%> (-10.22%)` | :arrow_down: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `80.64% <0%> (+3.22%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=footer). Last update [41a2b55...cab311e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-545240667:2045,Power,Powered,2045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-545240667,1,['Power'],['Powered']
Energy Efficiency,"cted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #237 +/- ##; ==========================================; + Coverage 73.92% 74.04% +0.12% ; ==========================================; Files 23 23 ; Lines 859 863 +4 ; ==========================================; + Hits 635 639 +4 ; Misses 224 224; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `83.33% <ø> (+16.66%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `83.72% <50%> (-0.99%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `67.74% <86.95%> (+12.56%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.54% <0%> (-5.41%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=footer). Last update [1e693f8...f7eb047](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/237#issuecomment-495868818:2107,Power,Powered,2107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/237#issuecomment-495868818,2,['Power'],['Powered']
Energy Efficiency,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1787,Adapt,Adapt,1787,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,1,['Adapt'],['Adapt']
Energy Efficiency,"d = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.00276553 -0.00220933 -0.00157462 -0.00105926 -0.000692536 -0.000446557 -0.00028606 … 0.00062928 0.000993307 0.0015715 0.00249751 0.00400184 0.00649",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6102,adapt,adapt,6102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['adapt'],['adapt']
Energy Efficiency,"d specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case,. For `GridFittedImmersedBoundary` the normal direction can be easily and efficiently inferred from the masking function by evaluating it at offset `i`, `j`, `k`. If fluid is adjacent to solid in any of those directions, you are on a boundary with a normal in the `x, y, z` direction (respectively), and the sign of the normal direction can be inferred from the offset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517:2081,efficient,efficiently,2081,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517,1,['efficient'],['efficiently']
Energy Efficiency,"d]; [4] getindex; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:541 [inlined]; [5] Δzᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:115 [inlined]; [6] Δzᶜᶠᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:141 [inlined]; [7] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/grid_metrics.jl:138 [inlined]; [8] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:101 [inlined]; [9] _getindex; @ ./abstractarray.jl:1341 [inlined]; [10] getindex; @ ./abstractarray.jl:1291 [inlined]; [11] macro expansion; @ ./reducedim.jl:317 [inlined]; [12] macro expansion; @ ./simdloop.jl:77 [inlined]; [13] _mapreducedim!(f::typeof(identity), op::typeof(Base.add_sum), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:316; [14] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:324; [15] sum!(f::Function, r::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:1034; [16] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}; condition::Nothing, mask::Int64, kwargs::@Kwargs{}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:696; [17] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:690; [18] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitAuxiliaryFields(grid::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, CPU}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:237; [19] materialize_free_surface(free_surface::SplitExplicitFreeSurface{…}, velocities::@NamedTuple{…}, grid::ImmersedBoundaryGrid{…})",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266:2632,reduce,reducedim,2632,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266,1,['reduce'],['reducedim']
Energy Efficiency,"decov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvZmllbGRfc2xpY2VyLmps) | `69.69% <0.00%> (-6.97%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `51.92% <0.00%> (-5.53%)` | :arrow_down: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `40.00% <ø> (ø)` | |; | [src/Utils/output\_writer\_diagnostic\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL291dHB1dF93cml0ZXJfZGlhZ25vc3RpY191dGlscy5qbA==) | `83.33% <ø> (+1.19%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.31% <33.33%> (-6.26%)` | :arrow_down: |; | [src/Utils/schedules.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3NjaGVkdWxlcy5qbA==) | `45.45% <45.45%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `85.29% <66.66%> (-0.22%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `82.65% <72.22%> (-10.38%)` | :arrow_down: |; | ... and [27 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1070?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-712120955:2456,schedul,schedules,2456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-712120955,1,['schedul'],['schedules']
Energy Efficiency,"decov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=h1) Report; > Merging [#302](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/c3428825442f8d155b3128a0f79797ba8f070f68?src=pr&el=desc) will **increase** coverage by `0.84%`.; > The diff coverage is `92.53%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #302 +/- ##; ==========================================; + Coverage 71.8% 72.64% +0.84% ; ==========================================; Files 24 24 ; Lines 1000 1031 +31 ; ==========================================; + Hits 718 749 +31 ; Misses 282 282; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `20% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `81.3% <92.42%> (+3.16%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=footer). Last update [c342882...a0e8a14](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302#issuecomment-506989260:1724,Power,Powered,1724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302#issuecomment-506989260,1,['Power'],['Powered']
Energy Efficiency,"decov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=h1) Report; > Merging [#915](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/6d349e1d85d61ff997f249881cd58232de865996?el=desc) will **increase** coverage by `0.07%`.; > The diff coverage is `96.07%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #915 +/- ##; ==========================================; + Coverage 72.60% 72.67% +0.07% ; ==========================================; Files 191 191 ; Lines 5610 5622 +12 ; ==========================================; + Hits 4073 4086 +13 ; + Misses 1537 1536 -1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `77.63% <91.66%> (-0.15%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `93.62% <100.00%> (+0.31%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=footer). Last update [6d349e1...22e9b04](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/915#issuecomment-687316456:1727,Power,Powered,1727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915#issuecomment-687316456,1,['Power'],['Powered']
Energy Efficiency,"define multiple times:; 1. Slices (`xy_surface`, `xy_subsurface`, `xy_middepth`, `xy_bottom`, `xz`, `yz`).; 2. Sets of computed fields (`horizontal_averages`, `volume_averages`). # Saving collections of slices. For number 1, I can imagine an abstraction, perhaps a collection of output writers like `NetCDFOutputWriters`, that allows you to specify a number of slice outputs for all fields:. ```julia; slices = (all = FieldSlicer(),; xy_surface = FieldSlicer(k=grid.Nz),; xy_subsurface = FieldSlicer(k=k_subsurface),; xy_middepth = FieldSlicer(k=round(Int, grid.Nz/2)),; xy_bottom = FieldSlicer(k=1),; xz = FieldSlicer(j=1),; yz = FieldSlicer(i=1)). simulation.output_writers[:slices] = NetCDFOutputWriters(filepath_prefix=""eady_turbulence"", slices=slices, ...); ```. This would save all fields in `merge(model.velocities, model.tracers)` to `eady_turbulence_all.nc`, `eady_turbulence_xy_surface.nc`, etc. with appropriate slicing. You could pass in one schedule for all slices, or a named tuple of schedules if you want different schedules for different output writers. I think it makes sense to have a `filepath_prefix` for the collection of output writers, e.g. `NetCDFOutputWriters`, while just `filepath` for individual output writers, e.g. `NetCDFOutputWriter`. I thought about adding this functionality to the `Simulation` constructor with kwargs like `output=:netcdf` or `output=:jld2` but felt like the number of extra kwargs would just make it messy. # Saving collections of computed fields. For number 2, we could perhaps automate some of this to avoid boilerplate like https://github.com/glwagner/EadyTurbulence/blob/6581af1cd867d8ad69dac7ea09deb3078c505c24/initial_value_problem/eady_initial_value_problem.jl#L149-L163. Not sure if we want yet another super-constructor but one idea is to add something like `AveragedNetCDFOutputWriter`. ```julia; averages = (u=u, v=v, b=b, ζ²=ζ², b²=b², bz=∂z(b)). simulations.output_writers[:horizontal_averages] = AveragedNetCDFOutputWriter(model, ave",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1171#issuecomment-726162256:1143,schedul,schedule,1143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1171#issuecomment-726162256,3,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"del = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; coarse_u,), coarse_grid;; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. Throws the following error:. ```; ERROR: LoadError: DimensionMismatch: new dimensions (1, 1, 8, 1) must be consistent with array size 4; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing, Missing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:1098,schedul,schedule,1098,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['schedul'],['schedule']
Energy Efficiency,"delT is the timestep, not something one chooses, isn't it?; Before squaring this away as done we need to discuss together and include; J-M and Chris in the discussions.; John. On Thu, May 23, 2019 at 9:32 AM Ali Ramadhan <notifications@github.com>; wrote:. > Never mind, think I figured it out. You were right: the div(u) is supposed; > to be divided by Δt.; >; > Not sure I understand what the MITgcm manual §2.9 is saying, but now the; > velocity field is indeed incompressible for Δt ≠ 1 (I tested Δt = 0.05 and; > Δt = 5).; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/228?email_source=notifications&email_token=AKXUEQQ2YLNKD6G7F7623W3PW2MGHA5CNFSM4HOZAKC2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWCHHII#issuecomment-495219617>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQWMDGLIY7UABLVET4DPW2MGHANCNFSM4HOZAKCQ>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495369875:1084,Green,Green,1084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495369875,1,['Green'],['Green']
Energy Efficiency,"dencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2=c2_forcing)). set!(model, c1=1, c2=1). Δt = .01 #1/64 # Nice floating-point number; simulation = Simulation(model, Δt=Δt, stop_time=150Δt). ∫c1_dxdy = Field(Average(model.tracers.c1, dims=(1, 2))); ∫c2_dxdy = Field(Average(model.tracers.c2, dims=(1, 2))); ; nc_outputs = Dict(""c1"" => ∫c1_dxdy, ""c2"" => ∫c2_dxdy); nc_dimensions = Dict(""c1"" => (""zC"",), ""c2"" => (""zC"",)). single_time_average_nc_filepath = ""single_decay_windowed_time_average_test.nc""; window_nΔt = 3; window = window_nΔt*Δt; interval_nΔt = 5; interval = interval_nΔt*Δt; stride = 1. single_nc_output = Dict(""c1"" => ∫c1_dxdy); single_nc_dimension = Dict(""c1"" => (""zC"",)). simulation.output_writers[:single_output_time_average] =; NetCDFOutputWriter(model, single_nc_output,; array_type = Array{Float64},; verbose = true,; filename = single_time_average_nc_filepath,; schedule = AveragedTimeInterval(interval, window = window, stride = stride),; dimensions = single_nc_dimension,; overwrite_existing = true); run!(simulation). ##### For each λ, horizontal average should evaluate to; #####; ##### c̄(z, t) = ∫₀¹ ∫₀¹ exp{- λ(x, y, z) * t} dx dy; ##### = 1 / (Nx*Ny) * Σᵢ₌₁ᴺˣ Σⱼ₌₁ᴺʸ exp{- λ(i, j, k) * t}; #####; ##### which we can compute analytically. # ds = NCDataset(horizontal_average_nc_filepath). Nx, Ny, Nz = size(grid); xs, ys, zs = nodes(model.tracers.c1). c̄1(z, t) = 1 / (Nx * Ny) * sum(exp(-λ1(x, y, z) * t) for x in xs for y in ys); c̄2(z, t) = 1 / (Nx * Ny) * sum(exp(-λ2(x, y, z) * t) for x in xs for y in ys). rtol = 1e-5 # need custom rtol for isapprox because roundoff errors accumulate (?). # Compute time averages...; c̄1(ts) = 1/length(ts) * sum(c̄1.(zs, t) for t in ts); c̄2(ts) = 1/length(ts) * sum(c̄2.(zs, t) for t in ts). #####; ##### Test strided windowed time average against analytic solution; ##### for *single* NetCDF output;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378113073:3125,schedul,schedule,3125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378113073,1,['schedul'],['schedule']
Energy Efficiency,"diff coverage is `66.66%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #401 +/- ##; ==========================================; - Coverage 71.74% 71.46% -0.28% ; ==========================================; Files 23 23 ; Lines 1412 1416 +4 ; ==========================================; - Hits 1013 1012 -1 ; - Misses 399 404 +5; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77.47% <ø> (-0.25%)` | :arrow_down: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `95.12% <100%> (+0.12%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `82.97% <64.28%> (-9.88%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=footer). Last update [f77d3e6...0408059](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/401#issuecomment-531079520:2073,Power,Powered,2073,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401#issuecomment-531079520,1,['Power'],['Powered']
Energy Efficiency,"diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/store\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9zdG9yZV90ZW5kZW5jaWVzLmps) | `72.72% <0.00%> (ø)` | |; | [src/TimeSteppers/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9jbG9jay5qbA==) | | |; | [...dels/IncompressibleModels/non\_dimensional\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9ub25fZGltZW5zaW9uYWxfbW9kZWwuamw=) | | |; | [...ncompressibleModels/update\_hydrostatic\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | | |; | [.../Models/ShallowWaterModels/calculate\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvY2FsY3VsYXRlX3RlbmRlbmNpZXMuamw=) | | |; | [.../IncompressibleModels/show\_incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9zaG93X2luY29tcHJlc3NpYmxlX21vZGVsLmps) | | |; | ... and [28 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120?src=pr&el=footer). Last update [3108501...8043370](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-719683146:3374,Power,Powered,3374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-719683146,1,['Power'],['Powered']
Energy Efficiency,"diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <0.00%> (-5.00%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/tuple\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3R1cGxlX3V0aWxzLmps) | `44.44% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <0.00%> (ø)` | |; | ... and [35 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993?src=pr&el=footer). Last update [24e9c2c...c9ed348](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/993#issuecomment-700294566:3231,Power,Powered,3231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/993#issuecomment-700294566,1,['Power'],['Powered']
Energy Efficiency,"diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | | |; | [...erification/lid\_driven\_cavity/lid\_driven\_cavity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2xpZF9kcml2ZW5fY2F2aXR5L2xpZF9kcml2ZW5fY2F2aXR5Lmps) | | |; | [test/test\_surface\_waves.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3N1cmZhY2Vfd2F2ZXMuamw=) | | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | | |; | [...regression\_tests/thermal\_bubble\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3RoZXJtYWxfYnViYmxlX3JlZ3Jlc3Npb25fdGVzdC5qbA==) | | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | | |; | ... and [58 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=footer). Last update [ee14f8a...1b1dbba](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991:3159,Power,Powered,3159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991,1,['Power'],['Powered']
Energy Efficiency,"down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `83.56% <0%> (-4.68%)` | :arrow_down: |; | [src/Operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `81.25% <0%> (-2.97%)` | :arrow_down: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `67.77% <0%> (-0.77%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.21% <0%> (+0.12%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.47% <0%> (+0.19%)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `84.37% <0%> (+1.04%)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `84.61% <0%> (+4.01%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503?src=pr&el=footer). Last update [7bbdd3d...d50e02d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/503#issuecomment-546029136:2933,Power,Powered,2933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/503#issuecomment-546029136,1,['Power'],['Powered']
Energy Efficiency,"driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436; [8] global_gl_screen; @ ~/.julia/packages/GLMakie/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1683,Monitor,Monitor,1683,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['Monitor'],['Monitor']
Energy Efficiency,"ds = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ # output; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ di",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:1916,schedul,schedule,1916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130,1,['schedul'],['schedule']
Energy Efficiency,"e 72.07% 69.12% -2.95% ; ==========================================; Files 26 26 ; Lines 1418 1490 +72 ; ==========================================; + Hits 1022 1030 +8 ; - Misses 396 460 +64; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `83.51% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `81.57% <0%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `48.83% <0%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `59.34% <20%> (-25.91%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `60.18% <29.41%> (-29.96%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.97% <95.23%> (+0.94%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=footer). Last update [211e18c...8eae176](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/476#issuecomment-541986378:2441,Power,Powered,2441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/476#issuecomment-541986378,1,['Power'],['Powered']
Energy Efficiency,"e function b_initial(x::R, y::R, z::R) where {R<:Real}; ϵ = 100 * eps(R); return (Δb / Ly) * y + randn() * ϵ; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (-Lx / 2, Lx / 2),; y = (0.0, Ly),; z = (0.0, Lz),; topology = (Periodic, Bounded, Bounded),; halo = (4, 4, 4),; ). @inline function is_ib(x::R, y::R, z::R) where {R<:Real}; return z > z_top(y); end. ImmersedBoundaryGrid(; underlying_grid,; GridFittedBoundary(is_ib); ); end. # Coriolis; coriolis = FPlane(f₀). # Buoyancy; buoyancy = BuoyancyTracer(). # Closure; closure = ScalarDiffusivity(ν = viscosity, κ = diffusivity). # Pressure Solver; pressure_solver = ImmersedPoissonSolver(; ib_grid,; solver_method = :HeptadiagonalIterativeSolver,; reltol = 1e-8,; verbose = false; ). # Model; model = NonhydrostaticModel(;; grid = ib_grid,; timestepper = time_stepper,; advection = advection,; tracers = (:b, ),; coriolis = coriolis,; buoyancy = buoyancy,; closure = closure,; pressure_solver = pressure_solver,; ). # Initial Value; set!(model, b = b_initial). # Simulation; simulation = Simulation(model; Δt = Δt, stop_iteration = 1000). # Set Output; output_fields = merge(model.velocities, model.tracers). simulation.output_writers[:output_3d] = NetCDFOutputWriter(; model,; output_fields,; filename = ""output.nc"",; schedule = IterationInterval(output_interval),; overwrite_existing = true,; deflatelevel = deflatelevel,; ). # Set Progress Function; function print_simulation_progress(simulation). model = simulation.model; i, t = model.clock.iteration, model.clock.time. @info Printf.@sprintf(""Iteration: %d, Time: %.2f Earth Days"", i, t / 86400.0). return nothing; end. simulation.callbacks[:progress] = Callback(; print_simulation_progress,; IterationInterval(100),; ). # ---------------------------------------------------------------------- #; # Run the Simulation; run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2070993577:3127,schedul,schedule,3127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2070993577,1,['schedul'],['schedule']
Energy Efficiency,"e the time step is too large, or because the physical problem cannot be resolved on the specified grid, which can cause energy to accumulate at the grid scale, eventually leading to blow up. This example may be exhibiting both. As @navidcy demonstrates, reducing the time-step allows for a few time-steps to be taken without blowing up. However, the scale of the physics --- a [Rayleigh-Taylor-type gravitational instability](https://en.wikipedia.org/wiki/Rayleigh%E2%80%93Taylor_instability) --- still appears to be quite small. The characteristic scale of the turbulent motions that result from your initial condition depends on the diffusivities that are prescribed. > Taking a look at my textbook, both the diffusivities look too small for the real world, especially the horizontal κh, as you mentioned. If I'm not mistaken, eddy diffusivity is much greater in magnitude than molecular diffusivity (and therefore more important), with typical vertical values of 10^-5 m^2/s, and horizontal eddy diffusivities range anywhere from 1m^2/sec to 10^4 m^2/sec. The turbulent eddy diffusivity is a property of turbulence, and thus of the physical scenario being simulated. So we can't say whether certain values are too large or too small, especially for an initial value problem like this. The numbers you've cited are typical numbers used for large-scale oceanographic problems (motions with scales of 10s of kilometers or more). However, the problem you are trying to simulate is very small scale, with a domain just 500 meters in each direction. and grid spacing down to 2 meters. In addition, its unlikely that putting this problem on a beta plane will change your results, because the domain is too small and the velocities too large for the effect of beta to influence your dynamics. . What kind of problem would you like to simulate? Perhaps we can help define a mathematical problem that is both simulate-able, and serves as a reasonable approximation for the physics you would like to explore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-731116328:2015,meter,meters,2015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-731116328,2,['meter'],['meters']
Energy Efficiency,"e v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able to create a MWE this time:. ```julia; using Printf; using Oceananigans; using Oceananigans: Utils, Units; using Oceananigans.OutputWriters; using Oceanostics: SingleLineProgressMessenger. grid = RegularRectilinearGrid(size=(4, 4, 4), extent=(1,1,1)); model = IncompressibleModel(architecture = CPU(), grid = grid). start_time = 1e-9*time_ns(); simulation = Simulation(model, Δt=1, stop_time=50, iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; ); println(""\n"", simulation,""\n"",). @info ""Setting up chk writer""; simulation.output_writers[:chk_writer] = Checkpointer(model; dir=""."",; prefix = ""chk.test"",; schedule = TimeInterval(5),; force = true, cleanup = true,; ); ; println(""\n"", simulation,""\n"",) . @printf(""---> Starting run!\n""); run!(simulation, pickup=true); ```. This results in the following output:. ```julia. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:2666,schedul,schedule,2666,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260,1,['schedul'],['schedule']
Energy Efficiency,"e-machine/Oceananigans.jl/pull/385?src=pr&el=h1) Report; > Merging [#385](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/a2b7c0e59c2f224f4fc978668cb2b85b45543981?src=pr&el=desc) will **increase** coverage by `0.01%`.; > The diff coverage is `80%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #385 +/- ##; ==========================================; + Coverage 70.57% 70.58% +0.01% ; ==========================================; Files 23 23 ; Lines 1383 1387 +4 ; ==========================================; + Hits 976 979 +3 ; - Misses 407 408 +1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.12% <100%> (+0.15%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `86.27% <66.66%> (-1.23%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=footer). Last update [a2b7c0e...0c07933](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/385#issuecomment-526284168:1742,Power,Powered,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/385#issuecomment-526284168,1,['Power'],['Powered']
Energy Efficiency,"e-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/Solvers/poisson\_solver\_gpu.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcG9pc3Nvbl9zb2x2ZXJfZ3B1Lmps) | `0% <0%> (ø)` | |; | [src/Grids/Grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `100% <100%> (ø)` | |; | [src/Solvers/poisson\_solver\_cpu.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcG9pc3Nvbl9zb2x2ZXJfY3B1Lmps) | `100% <100%> (ø)` | |; | [src/Diagnostics/Diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100% <100%> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `74.35% <100%> (ø)` | :arrow_up: |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <100%> (ø)` | |; | ... and [36 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512?src=pr&el=footer). Last update [4b8ff03...9060a5f](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/512#issuecomment-548115284:3495,Power,Powered,3495,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/512#issuecomment-548115284,1,['Power'],['Powered']
Energy Efficiency,"e.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::Val{true}, ::CuDeviceArray{Float64, 4, 1}, ::CuDeviceArray{Float64, 3, 1}; call_kwargs::Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:threads, :blocks, :shmem), Tuple{Int64, Int64, Int64}}}); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:171; [7] (::CUDA.HostKernel{typeof(CUDA.partial_mapreduce_grid), Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 1, CuDeviceArray{Float64, 3, 1}, Tuple{Int64, Int64, UnitRange{Int64}}, true}, Tuple{}}, CuDeviceArray{Float64, 3, 1}}})(::Function, ::Vararg{Any, N} where N; threads::Int64, blocks::Int64, kwargs::Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:shmem,), Tuple{Int64}}}); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:367; [8] mapreducedim!(f::typeof(identity), op::typeof(Base.add_sum), R::SubArray{Float64, 1, CuArray{Float64, 3}, Tuple{Int64, Int64, UnitRange{Int64}}, true}, A::CuArray{Float64, 3}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/mapreduce.jl:228; [9] mapreducedim!; @ ~/.julia/packages/CUDA/3VnCC/src/mapreduce.jl:142 [inlined]; [10] mapreducedim!; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/mapreduce.jl:10 [inlined]; [11] #sum!#699; @ ./reducedim.jl:895 [inlined]; [12] #sum!#700; @ ./reducedim.jl:897 [inlined]; [13] mean!(R::SubArray{Float64, 1, CuArray{Float64, 3}, Tuple{Int64, Int64, UnitRange{Int64}}, true}, A::CuArray{Float64, 3}); @ Statistics /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Statistics/src/Statistics.jl:131; [14] top-level scope; @ REPL[19]:1; [15] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845617107:4409,reduce,reducedim,4409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845617107,2,['reduce'],['reducedim']
Energy Efficiency,"e/Oceananigans.jl/pull/623?src=pr&el=h1) Report; > Merging [#623](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/73bea229721624d65d4e2b2b79810622cf221993?src=pr&el=desc) will **increase** coverage by `0.09%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #623 +/- ##; ==========================================; + Coverage 74.49% 74.58% +0.09% ; ==========================================; Files 118 118 ; Lines 2227 2231 +4 ; ==========================================; + Hits 1659 1664 +5 ; + Misses 568 567 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Models/model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `100% <ø> (+8.33%)` | :arrow_up: |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `93.93% <100%> (+0.6%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=footer). Last update [73bea22...7014037](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/623#issuecomment-585468829:1750,Power,Powered,1750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/623#issuecomment-585468829,1,['Power'],['Powered']
Energy Efficiency,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:15694,schedul,schedule,15694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,1,['schedul'],['schedule']
Energy Efficiency,"eans that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this chan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1395,meter,meter,1395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,1,['meter'],['meter']
Energy Efficiency,"ection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <ø> (ø)` | |; | [src/Advection/Advection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9BZHZlY3Rpb24uamw=) | `50.00% <ø> (ø)` | |; | [src/Advection/tracer\_advection\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `80.00% <ø> (ø)` | |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `76.92% <0.00%> (-6.42%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `96.55% <0.00%> (-1.70%)` | :arrow_down: |; | ... and [22 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014?src=pr&el=footer). Last update [d274364...d03718b](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1014#issuecomment-704467105:3268,Power,Powered,3268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014#issuecomment-704467105,1,['Power'],['Powered']
Energy Efficiency,"ence = -2.008467701332351 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:48:50.076] INFO 2D diffusion (Periodic, Periodic, Bounded) L₁ rate of convergence = -2.0083073827620237 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:48:50.193] INFO 2D diffusion (Periodic, Periodic, Bounded) L∞ rate of convergence = -1.947766867108851 (expected ≈ -2.0, atol = 0.06); [2020/09/01 13:48:50.194] INFO 2D diffusion (Periodic, Bounded, Bounded) L₁ rate of convergence = -2.003208945092345 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:48:50.194] INFO 2D diffusion (Periodic, Bounded, Bounded) L∞ rate of convergence = -1.965491374875283 (expected ≈ -2.0, atol = 0.06); [2020/09/01 13:48:50.194] INFO 2D diffusion (Bounded, Bounded, Bounded) L₁ rate of convergence = -1.9995730043199613 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:48:50.194] INFO 2D diffusion (Bounded, Bounded, Bounded) L∞ rate of convergence = -1.984678368453777 (expected ≈ -2.0, atol = 0.06); [2020/09/01 13:52:28.324] INFO Taylor-Green L₁ rate of convergence = -2.0004700529312727 (expected ≈ -2.0, atol = 0.001); [2020/09/01 13:52:28.369] INFO Taylor-Green L∞ rate of convergence = -1.95032035517191 (expected ≈ -2.0, atol = 0.05); [2020/09/01 14:11:26.553] INFO Forced flow free slip (x, y) L₁ rate of convergence = -1.999738241539891 (expected ≈ -2.0, atol = 0.001); [2020/09/01 14:11:26.598] INFO Forced flow free slip (x, y) L∞ rate of convergence = -1.9992989311721168 (expected ≈ -2.0, atol = 0.001); [2020/09/01 14:11:26.611] INFO Forced flow free slip (x, z) L₁ rate of convergence = -1.999738243255539 (expected ≈ -2.0, atol = 0.001); [2020/09/01 14:11:26.611] INFO Forced flow free slip (x, z) L∞ rate of convergence = -1.999298932806858 (expected ≈ -2.0, atol = 0.001); [2020/09/01 14:15:04.586] INFO Forced flow fixed slip (x, y) L₁ rate of convergence = -1.9978175950101218 (expected ≈ -2.0, atol = 0.05); [2020/09/01 14:15:04.627] INFO Forced flow fixed slip (x, y) L∞ rate of convergence = -1.935360007296416 (expected ≈ -2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-685075187:9233,Green,Green,9233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-685075187,1,['Green'],['Green']
Energy Efficiency,"ently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. * A very important usage of `Average`, however, is using it to reduce ""lazily evaluated data"". This is the case of taking an average of a ""`Computation`"". To take the average of a `Computation`, we have to trigger the generation of the data to be averaged. To support this functionality we have permitted `Average.field` to be defined as a `Computation`, and dispatched on this special case to ensure that the data is generated before the average is invoked. * One way to normalize these user-interfaces is to generalize the concept of an `AbstractField` to be ""lazy"" in general. There is one special case that does *not* require computation --- the ordinary case of a `Field`. But we can create an infrastructure where all `AbstractField`s are expected to have a function like `compute!` (or perhaps `evaluate!`). In that framework, we would always call `evaluate!` on `Average.field` before averaging it. Because `evaluate!(::Field) = nothing`, we preserve the basic functionality of `Average` when it acts on a basic `Field` and its data does not need to be generated. * Note that currently `Computation` data is stored in bare `Array`s. However, it should probably be stored as `Field`, and interacting with a `Computation` should feel the same as interacting with a field (with functions like `data`, `interior`, `getindex`, etc). We may also want to change the name of `Computation` to something that reflects its behavior a little more clearly. Perhaps `ComputedField`, or something. * `Average` itself should *also* subtype `AbstractField` within this framework. An `Average` is just a special type of computation that requires evaluation, and also reduces a field along a certain dimension. For this to work well, we need a `ReducedField` type (eg #525)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391:2019,reduce,reduces,2019,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391,2,"['Reduce', 'reduce']","['ReducedField', 'reduces']"
Energy Efficiency,"er(; grid;; preconditioner = fft_poisson_solver(grid.underlying_grid),; maxiter = 100; ); ). simulation = Simulation(model; Δt=0.1, stop_time=600). function progress(sim); model = sim.model; @printf(; ""iteration: %d, time: %.4f, U_max=(%.2e, %.2e, %.2e)\n"",; iteration(sim),; time(sim),; maximum(abs, model.velocities.u),; maximum(abs, model.velocities.v),; maximum(abs, model.velocities.w); ). @printf(; "" reltol=%.2e, abstol=%.2e, solver iterations: %d, residual: (mean=%.2e, abs(max)=%.2e)\n"",; model.pressure_solver.conjugate_gradient_solver.reltol,; model.pressure_solver.conjugate_gradient_solver.abstol,; iteration(model.pressure_solver),; mean(model.pressure_solver.conjugate_gradient_solver.residual),; maximum(abs, model.pressure_solver.conjugate_gradient_solver.residual); ); end. simulation.callbacks[:progress] = Callback(progress, IterationInterval(1)). nan_checker = NaNChecker(fields=model.velocities, erroring=true); simulation.callbacks[:nan_checker] = Callback(nan_checker, IterationInterval(1)). simulation.output_writers[:fields] =; JLD2OutputWriter(model, model.velocities; filename=""3831.jld2"", schedule=TimeInterval(10), overwrite_existing=true). run!(simulation). using CairoMakie. ds = FieldDataset(""3831.jld2""). times = ds[""u""].times; xu, yu, zu = nodes(ds[""u""][1]). n = Observable(1). fig = Figure(size=(1000, 500)). title = @lift @sprintf(""time = %s"", prettytime(times[$n])). u_surface = @lift interior(ds[""u""][$n], :, :, 16); u_slice = @lift interior(ds[""u""][$n], :, 8, :). ax1 = Axis(fig[1, 1]; title = ""u (surface)"", xlabel=""x"", ylabel=""y""); hm1 = heatmap!(ax1, xu, yu, u_surface, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 2], hm1, label=""m/s""). ax2 = Axis(fig[1, 3]; title = ""u (xz-slice)"", xlabel=""x"", ylabel=""z""); hm2 = heatmap!(ax2, xu, yu, u_slice, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 4], hm2, label=""m/s""). fig[0, :] = Label(fig, title). record(fig, ""3831.mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412606395:2256,schedul,schedule,2256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412606395,1,['schedul'],['schedule']
Energy Efficiency,"er.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:1426,adapt,adapts,1426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,1,['adapt'],['adapts']
Energy Efficiency,"er](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/716356088a610da1fe75f00b38e3646f046edbb4?src=pr&el=desc) will **increase** coverage by `9.94%`.; > The diff coverage is `78.94%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #140 +/- ##; ==========================================; + Coverage 56.03% 65.97% +9.94% ; ==========================================; Files 19 19 ; Lines 605 629 +24 ; ==========================================; + Hits 339 415 +76 ; + Misses 266 214 -52; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `80% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.78% <78.94%> (+79.78%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.72% <0%> (+0.63%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=footer). Last update [7163560...371af73](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633131:1905,Power,Powered,1905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633131,1,['Power'],['Powered']
Energy Efficiency,"er_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression | 4 2 6; Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. julia> versioninfo(); Julia Version 1.6.7; Commit 3b76b25b64* (2022-07-19 15:11 UTC); Platform Info:; OS: L",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:17669,Adapt,Adapt,17669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Energy Efficiency,"eral. In this case, there are other issues that compiler might encounter that are not related to recursive calls to `identity`. We identified two additional issues on https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2267,Reduce,ReducedField,2267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,1,['Reduce'],['ReducedField']
Energy Efficiency,"erators.identity4), CPU, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Float64}, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{Array{Float32, N} where N}, field_slicer::FieldSlicer{Colon, Colon, Colon}, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, mode::String, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/Research/OC2/src/OutputWriters/netcdf_output_writer.jl:319; [4] top-level scope; @ REPL[34]:1; ```. seems like this has something to do with. https://github.com/CliMA/Oceananigans.jl/blob/6df3e36f0bc8b0cbf7c075b235da678b8d035055/src/OutputWriters/netcdf_output_writer.jl#L39-L45. That's because of the z dimension. It follows that . https://github.com/CliMA/Oceananigans.jl/blob/6df3e36f0bc8b0cbf7c075b235da678b8d035055/src/Grids/grid_utils.jl#L162. returns a range and then `.parent()` is problematic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920:24640,schedul,schedule,24640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920,1,['schedul'],['schedule']
Energy Efficiency,"erging [#612](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/88a4f8f08d976bb0029ea337202bf94fe292374d?src=pr&el=desc) will **increase** coverage by `0.04%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #612 +/- ##; ==========================================; + Coverage 74.51% 74.55% +0.04% ; ==========================================; Files 117 117 ; Lines 2209 2209 ; ==========================================; + Hits 1646 1647 +1 ; + Misses 563 562 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `93.33% <100%> (ø)` | :arrow_up: |; | [src/Buoyancy/nonlinear\_equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L25vbmxpbmVhcl9lcXVhdGlvbl9vZl9zdGF0ZS5qbA==) | `75% <0%> (+4.16%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=footer). Last update [88a4f8f...7d4e5b6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/612#issuecomment-581598656:1802,Power,Powered,1802,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612#issuecomment-581598656,1,['Power'],['Powered']
Energy Efficiency,"ersedBoundaries/partial_cell_bottom.jl:115 [inlined]; [6] Δzᶜᶠᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:141 [inlined]; [7] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/grid_metrics.jl:138 [inlined]; [8] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:101 [inlined]; [9] _getindex; @ ./abstractarray.jl:1341 [inlined]; [10] getindex; @ ./abstractarray.jl:1291 [inlined]; [11] macro expansion; @ ./reducedim.jl:317 [inlined]; [12] macro expansion; @ ./simdloop.jl:77 [inlined]; [13] _mapreducedim!(f::typeof(identity), op::typeof(Base.add_sum), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:316; [14] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:324; [15] sum!(f::Function, r::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:1034; [16] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}; condition::Nothing, mask::Int64, kwargs::@Kwargs{}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:696; [17] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:690; [18] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitAuxiliaryFields(grid::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, CPU}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:237; [19] materialize_free_surface(free_surface::SplitExplicitFreeSurface{…}, velocities::@NamedTuple{…}, grid::ImmersedBoundaryGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/split_ex",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266:2759,reduce,reducedim,2759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266,1,['reduce'],['reducedim']
Energy Efficiency,"es A b,c. ; 2. **Naming convention**: The prognostic MEKE equation is used to inform the GM coefficient via `kappa_GM = c * sqrt(2 MEKE) * L_mix` with a mixing length `L_mix`, but also to energetically constrain the backscatter in the momentum equation. See this schematic, modified from Figure 1, Jansen et al. (2019):; ![MEKE_schematic](https://user-images.githubusercontent.com/23617395/167711268-23732094-80aa-476e-8f13-fd6cd8659e8c.png); So how about `PrognosticMEKEDiffusivity` and `PrognosticMEKEBackscatter`? Probably good to keep these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:1563,energy,energy,1563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['energy'],['energy']
Energy Efficiency,"es because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:1140,schedul,schedule,1140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,1,['schedul'],['schedule']
Energy Efficiency,"es](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `12.9% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.09% <ø> (+2.49%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `88.7% <ø> (+2.43%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `73.39% <100%> (-2.74%)` | :arrow_down: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `74.19% <61.11%> (-9.6%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <88.23%> (+5.54%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `90.9% <0%> (-9.1%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=footer). Last update [2749d07...770125d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/386#issuecomment-526924398:2653,Power,Powered,2653,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/386#issuecomment-526924398,2,['Power'],['Powered']
Energy Efficiency,f2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig; INFOPATH = :/glade/u/apps/casper/23.10/opt/view/share/info:/usr/local/share/info:/usr/share/info; NCAR_LDFLAGS_JULIA = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/lib; NCAR_LDFLAGS_HDF5 = /glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib; NCAR_WRAPPER_MPI_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi; __LMOD_STACK_LMOD_PACKAGE_PATH = L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==:L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==; ```; and the status check message gave me:; ```; Status `~/.julia/environments/v1.9/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; [79e6a3ab] Adapt v4.0.4; ⌅ [4fba245c] ArrayInterface v7.7.1; [a9b6321e] Atomix v0.1.0; [ab4f0b2a] BFloat16s v0.5.0; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.4.3; [1af6417a] CUDA_Runtime_Discovery v0.3.4; [d360d2e6] ChainRulesCore v1.24.0; [3da002f7] ColorTypes v0.11.5; [5ae59095] Colors v0.12.11; [1fbeeb36] CommonDataModel v0.3.6; [34da2185] Compat v4.15.0; [187b0558] ConstructionBase v1.5.5; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.20; [e2d170a0] DataValueInterfaces v1.0.0; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.10; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.3; [53c48c17] FixedPointNumbers v0.8.5; [0c68f7d7] GPUArrays v10.2.3; [46192b85] GPUArraysCore v0.1.6; [61eb1bfa] GPUCompiler v0.26.7; [c27321d9] Glob v1.3.1; [615f187c] IfElse v0.1.1;,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:16102,Adapt,Adapt,16102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Adapt'],['Adapt']
Energy Efficiency,"f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11070,Adapt,Adapt,11070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Energy Efficiency,"f?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9mX3BsYW5lLmps) | `0.00% <0.00%> (-62.50%)` | :arrow_down: |; | [src/Advection/weno\_reconstruction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX3JlY29uc3RydWN0aW9uLmps) | `0.00% <0.00%> (-60.00%)` | :arrow_down: |; | [src/Coriolis/beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2JldGFfcGxhbmUuamw=) | `0.00% <0.00%> (-58.83%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `0.00% <0.00%> (-58.07%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `0.00% <0.00%> (-54.17%)` | :arrow_down: |; | [src/Fields/reduced\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9yZWR1Y2VkX2ZpZWxkLmps) | `28.94% <0.00%> (-50.01%)` | :arrow_down: |; | [src/Advection/weno\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX2ZpZnRoX29yZGVyLmps) | `0.00% <0.00%> (-44.28%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `47.36% <0.00%> (-32.64%)` | :arrow_down: |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powere",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894:2615,reduce,reduced,2615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894,1,['reduce'],['reduced']
Energy Efficiency,"ff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `60.86% <0.00%> (ø)` | |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.71% <ø> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `100.00% <ø> (ø)` | |; | [src/Models/show\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9zaG93X21vZGVscy5qbA==) | `0.00% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `100.00% <ø> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100.00% <ø> (ø)` | |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799?src=pr&el=footer). Last update [03f1aa5...586529d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/799#issuecomment-658184692:3398,Power,Powered,3398,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799#issuecomment-658184692,1,['Power'],['Powered']
Energy Efficiency,"ffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}); @ GPUArrays ~/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; [22] #maximum!#803; @ ./reducedim.jl:1018 [inlined]; [23] maximum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:16605,reduce,reducedim,16605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806,1,['reduce'],['reducedim']
Energy Efficiency,"field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model), pd.units); end; ```. with this design, the user can pass a list of `PrintableDiagnostics` to `ProgressPrinter`, which are then evaluated and the results turned into a string via the function `pretty_diagnostic`. As for option 1 of using a logging package, perhaps it could be nice to use some logging functionality that's configurable with global variables (?) rather than manually creating a `ProgressPrinter` that does ""brute force"" printing as I have described above. However I think that it would require some customization of existing logging packages, since the typical `info` or `debug` settings are not sufficient for the purposes of logging simulation output (right?) Instead, we would need more options, and it'd be nice to obtain the ability to also print the output of diagnostics / monitoring functions, as we do in the example script. And I think doing it this way might involve adding some lines to our time stepping loop. Perhaps @ali-ramadhan has more to say. Another thing we have talked about is somehow having the ability to live-update messages in the terminal (rather than printing a stream of message). This would be nice because it could dramatically reduce the text-noise that a stream of messages invokes, allowing the user to much more easily read and interpret the output of a simulation progress (in addition to creating the possibility for nice pseudo-animations via `UnicodePlots.jl`). I'm not 100% sure how to do this; one places to start could be https://github.com/ronisbr/TextUserInterfaces.jl. Any work on any of these ideas could be useful! I'd be happy to Skype to talk more and clarify any questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:3738,monitor,monitoring,3738,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,2,"['monitor', 'reduce']","['monitoring', 'reduce']"
Energy Efficiency,"file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #803 +/- ##; ==========================================; + Coverage 71.05% 71.24% +0.18% ; ==========================================; Files 186 186 ; Lines 4823 4854 +31 ; ==========================================; + Hits 3427 3458 +31 ; Misses 1396 1396 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [examples/one\_dimensional\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb25lX2RpbWVuc2lvbmFsX2RpZmZ1c2lvbi5qbA==) | `0.00% <0.00%> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `79.54% <0.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `94.11% <0.00%> (+3.37%)` | :arrow_up: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `69.64% <0.00%> (+10.66%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=footer). Last update [b022627...2572835](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/803#issuecomment-660244336:2094,Power,Powered,2094,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/803#issuecomment-660244336,1,['Power'],['Powered']
Energy Efficiency,"fsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, Nothing, Nothing, Nothing, NamedTuple{(), Tuple{}}}, outputs::NamedTuple{(:u, :v, :w), Tuple{typeof(subsample_u), typeof(subsample_v), typeof(subsample_w)}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Nothing, deflatelevel::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/netcdf_output_writer.jl:422; [4] top-level scope; @ In[8]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594:24796,schedul,schedule,24796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594,1,['schedul'],['schedule']
Energy Efficiency,"gans.jl/pull/402?src=pr&el=h1) Report; > Merging [#402](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/f77d3e6ef455fa3b7ed177c1af0e6a163b048a83?src=pr&el=desc) will **increase** coverage by `0.09%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #402 +/- ##; ==========================================; + Coverage 71.74% 71.83% +0.09% ; ==========================================; Files 23 23 ; Lines 1412 1413 +1 ; ==========================================; + Hits 1013 1015 +2 ; + Misses 399 398 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `84.74% <100%> (+1.69%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.63% <0%> (+0.01%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=footer). Last update [f77d3e6...77a2c9a](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/402#issuecomment-531193966:1760,Power,Powered,1760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/402#issuecomment-531193966,1,['Power'],['Powered']
Energy Efficiency,"gans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `71.11% <0%> (-9.85%)` | :arrow_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.94% <0%> (-56.72%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `49.35% <0%> (-15.59%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <0%> (-12.5%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `78.26% <0%> (-7.32%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.02% <0%> (-2.1%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <0%> (-1.64%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.54% <0%> (-0.57%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421?src=pr&el=footer). Last update [d32cf20...3ce561b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/421#issuecomment-532807303:2833,Power,Powered,2833,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/421#issuecomment-532807303,1,['Power'],['Powered']
Energy Efficiency,"ge by `0.43%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #685 +/- ##; ==========================================; - Coverage 77.99% 77.56% -0.44% ; ==========================================; Files 120 120 ; Lines 2413 2478 +65 ; ==========================================; + Hits 1882 1922 +40 ; - Misses 531 556 +25 ; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/BoundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `53.84% <0.00%> (-29.49%)` | :arrow_down: |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `71.42% <0.00%> (-28.58%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `75.17% <0.00%> (-0.73%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=footer). Last update [74cfb85...6eb8db9](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/685#issuecomment-595584245:2044,Power,Powered,2044,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685#issuecomment-595584245,1,['Power'],['Powered']
Energy Efficiency,"gence\_tests/point\_exponential\_decay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL3BvaW50X2V4cG9uZW50aWFsX2RlY2F5Lmps) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | | |; | [...ts/one\_dimensional\_gaussian\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9nYXVzc2lhbl9hZHZlY3Rpb25fZGlmZnVzaW9uLmps) | | |; | [...ests/one\_dimensional\_cosine\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9jb3NpbmVfYWR2ZWN0aW9uX2RpZmZ1c2lvbi5qbA==) | | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | | |; | [test/test\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X29wZXJhdG9ycy5qbA==) | | |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=footer). Last update [d383b6a...ad6a215](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/792#issuecomment-657511230:3305,Power,Powered,3305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/792#issuecomment-657511230,1,['Power'],['Powered']
Energy Efficiency,"gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=h1) Report; > Merging [#585](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/588890004e69cfc7db10472b12a9840b8a9ad7b6?src=pr&el=desc) will **increase** coverage by `0.97%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #585 +/- ##; ==========================================; + Coverage 72.17% 73.14% +0.97% ; ==========================================; Files 70 70 ; Lines 2016 2011 -5 ; ==========================================; + Hits 1455 1471 +16 ; + Misses 561 540 -21; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `61.05% <0%> (ø)` | :arrow_up: |; | [src/logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585/diff?src=pr&el=tree#diff-c3JjL2xvZ2dlci5qbA==) | `76.19% <0%> (+76.19%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=footer). Last update [5888900...01ec7b4](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/585#issuecomment-568143084:1733,Power,Powered,1733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/585#issuecomment-568143084,1,['Power'],['Powered']
Energy Efficiency,"go with constant time step because ```TimeStepWizard``` was not working with stretched grid. I am pasting the code where I am using Time wizard-; ```; using Random; using Printf; using Oceananigans; using Oceananigans.Units: minute, minutes, hour; Lz=32; Nz=32; S = 1.1 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (32, 32, 32), ; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=8e-4)); Qʰ = 200 # W m⁻², surface _heat_ flux; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; cᴾ = 3991 # J K⁻¹ s⁻¹, typical heat capacity for seawater; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m⁻¹ s⁻¹, surface _temperature_ flux; dTdz = 0.01 # K m⁻¹; T_bcs = TracerBoundaryConditions(computational_grid,; top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); u₁₀ = 10 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²; u_bcs = UVelocityBoundaryConditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.gri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586:1369,meter,meters,1369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586,1,['meter'],['meters']
Energy Efficiency,"h/climate-machine/Oceananigans.jl/pull/326?src=pr&el=h1) Report; > Merging [#326](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/66670ad782b66db7906d407ab9217ec0f26a7bb2?src=pr&el=desc) will **increase** coverage by `1.31%`.; > The diff coverage is `81.1%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #326 +/- ##; ==========================================; + Coverage 74.74% 76.06% +1.31% ; ==========================================; Files 22 22 ; Lines 1176 1224 +48 ; ==========================================; + Hits 879 931 +52 ; + Misses 297 293 -4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `75.93% <81.1%> (+11.18%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=footer). Last update [66670ad...4e72d35](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974978:1734,Power,Powered,1734,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974978,1,['Power'],['Powered']
Energy Efficiency,"h1) Report; > Merging [#992](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/e808a821d78949b0482b8372533e992cabb5d65f?el=desc) will **not change** coverage.; > The diff coverage is `66.66%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #992 +/- ##; =======================================; Coverage 72.04% 72.04% ; =======================================; Files 218 218 ; Lines 6379 6379 ; =======================================; Hits 4596 4596 ; Misses 1783 1783 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `57.14% <ø> (ø)` | |; | [src/Fields/new\_data.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9uZXdfZGF0YS5qbA==) | `76.92% <50.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `88.88% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=footer). Last update [e808a82...9054b82](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/992#issuecomment-700346993:1797,Power,Powered,1797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/992#issuecomment-700346993,1,['Power'],['Powered']
Energy Efficiency,"h](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #183 +/- ##; ===========================================; - Coverage 68.81% 57.86% -10.96% ; ===========================================; Files 18 19 +1 ; Lines 651 776 +125 ; ===========================================; + Hits 448 449 +1 ; - Misses 203 327 +124; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/dst3fl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9kc3QzZmwuamw=) | `0% <0%> (ø)` | |; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `10% <0%> (-23.34%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `55.17% <0%> (-1.98%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=footer). Last update [6c272ad...63f7bb2](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975517:2123,Power,Powered,2123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975517,1,['Power'],['Powered']
Energy Efficiency,"h](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #183 +/- ##; ===========================================; - Coverage 68.81% 57.86% -10.96% ; ===========================================; Files 18 19 +1 ; Lines 651 776 +125 ; ===========================================; + Hits 448 449 +1 ; - Misses 203 327 +124; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/dst3fl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9kc3QzZmwuamw=) | `0% <0%> (ø)` | |; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `10% <0%> (-23.34%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `55.17% <0%> (-1.98%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=footer). Last update [6c272ad...7ff5f20](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975519:2123,Power,Powered,2123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975519,1,['Power'],['Powered']
Energy Efficiency,"halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `81.25% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `43.9% <ø> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.61% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `59.7% <ø> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `70% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.58% <100%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `62.02% <50%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349?src=pr&el=footer). Last update [848edd9...7e48630](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/349#issuecomment-520158094:2732,Power,Powered,2732,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/349#issuecomment-520158094,2,['Power'],['Powered']
Energy Efficiency,"hat I'm introducing new notation! Both `=` and approx have unambiguous meaning. Let me elaborate on ""why approx"":; > ; > Oceananigans solves the full N-S with nonlinear terms. The script's power method algorithm will fail if the eigenmode to grow too much --- this is a real pitfall of the power method. The purpose of the approx symbol is to concisely illustrate why this can happen. This is crucial to explain for users who want to experiment with the script, change parameters, and adapt it for new problems.; > ; > We can explain this all in words, but I thought the approx is _visual_ which is helpful. Even just scanning the document you see, this equation involves an _approximation_. The approx is, in fact, a more precise and correct representation of the problem. We can in fact regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:1077,power,power,1077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['power'],['power']
Energy Efficiency,"have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2269,energy,energy,2269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,1,['energy'],['energy']
Energy Efficiency,"hine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.85% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `83.05% <100%> (+1.69%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.48% <100%> (+1.14%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77.71% <0%> (+0.54%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <0%> (+14.44%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `62.02% <0%> (+15.18%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <0%> (+16.66%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.61% <0%> (+57.61%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395?src=pr&el=footer). Last update [079cb53...bd0ce51](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/395#issuecomment-530062190:2819,Power,Powered,2819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/395#issuecomment-530062190,1,['Power'],['Powered']
Energy Efficiency,"https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/fbbb5f81b851bb838c8796efba36a3021cb89f0e?el=desc) will **increase** coverage by `0.01%`.; > The diff coverage is `80.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #889 +/- ##; ==========================================; + Coverage 70.99% 71.00% +0.01% ; ==========================================; Files 188 188 ; Lines 5230 5229 -1 ; ==========================================; Hits 3713 3713 ; + Misses 1517 1516 -1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `75.00% <ø> (+3.57%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `65.07% <66.66%> (-0.55%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `88.42% <100.00%> (+0.24%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=footer). Last update [fbbb5f8...1db3d80](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/889#issuecomment-684069273:1826,Power,Powered,1826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/889#issuecomment-684069273,1,['Power'],['Powered']
Energy Efficiency,"https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `92.00% <80.00%> (+3.57%)` | :arrow_up: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.79% <100.00%> (+0.74%)` | :arrow_up: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `71.42% <100.00%> (+8.09%)` | :arrow_up: |; | [src/Utils/kernel\_launching.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2tlcm5lbF9sYXVuY2hpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.36% <100.00%> (+0.05%)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | ... and [17 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=footer). Last update [f0c2821...60fd8ea](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687186898:3479,Power,Powered,3479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687186898,1,['Power'],['Powered']
Energy Efficiency,"https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `80.33% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `84.37% <100%> (-1.34%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `71.56% <100%> (-1.58%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <100%> (ø)` | |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `60.39% <60.39%> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `74.35% <74.35%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=footer). Last update [cacb753...059d826](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/505#issuecomment-546596353:2655,Power,Powered,2655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/505#issuecomment-546596353,1,['Power'],['Powered']
Energy Efficiency,"iMA/Oceananigans.jl/pull/1090?src=pr&el=desc) (ca40ce0) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165?el=desc) (5aafe8e) will **decrease** coverage by `0.38%`.; > The diff coverage is `0.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1090 +/- ##; ==========================================; - Coverage 57.39% 57.01% -0.39% ; ==========================================; Files 161 162 +1 ; Lines 3887 3913 +26 ; ==========================================; Hits 2231 2231 ; - Misses 1656 1682 +26 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `25.00% <ø> (ø)` | |; | [src/Fields/interpolate.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9pbnRlcnBvbGF0ZS5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `73.80% <0.00%> (+1.71%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=footer). Last update [5aafe8e...ca40ce0](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1090#issuecomment-713241303:1850,Power,Powered,1850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090#issuecomment-713241303,1,['Power'],['Powered']
Energy Efficiency,"iMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `82.50% <30.00%> (-4.78%)` | :arrow_down: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `60.37% <83.33%> (+7.43%)` | :arrow_up: |; | [src/BoundaryConditions/zero\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy96ZXJvX2hhbG9fcmVnaW9ucy5qbA==) | `78.94% <87.50%> (+2.47%)` | :arrow_up: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `94.44% <94.44%> (ø)` | |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.79% <100.00%> (ø)` | |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `96.42% <100.00%> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.33% <100.00%> (-0.01%)` | :arrow_down: |; | ... and [10 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930?src=pr&el=footer). Last update [0f33c1d...69d5cd7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/930#issuecomment-690826704:3276,Power,Powered,3276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/930#issuecomment-690826704,1,['Power'],['Powered']
Energy Efficiency,"icFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:34 [inlined]; │ [23] update_state!; │ @ ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:31 [inlined]; │ [24] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32, 1, CUDA.DeviceMemory}}, Float32, Float32, Float32, Float32, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, GPU}, clock::Clock{Float32, Float32}, momentum_advection::VectorInvariant{1, Float64, false, EnstrophyConserving{Float64}, Oceananigans.Advection.VelocityStencil, EnergyConserving{Float64}, EnergyConserving{Float64}, EnergyConserving{Float64}, Oceananigans.Advection.OnlySelfUpwinding{EnergyConserving{Float64}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.u_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.v_smoothness)}}}, tracer_advection::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, buoyancy::BuoyancyTracer, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{Nothing, Nothing, Nothing, Float64, Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings{Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float32, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}, Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme}}, tracers::Tuple{Symbol, Symbol}, forcing::@NamedTuple{}, closure::CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretizat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:153964,Energy,EnergyConserving,153964,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['Energy'],['EnergyConserving']
Energy Efficiency,"ich is kind of similar to #73 #85. I suppose we can interpret every term in the momentum equation as an ""arbitrary function"". The design I've been using is to define a type that represents part of the governing equation to make the equation modular and changeable by the user. Definitely suggest alternative designs if good alternatives come to mind. > Is a closure always meant to replace the viscous dissipation (𝜈∇²u) operators? Will Smag/AMD replace the Laplacian diffusion operators (e.g. κ∇²T) as well?. I am proposing that we consider using this conceptual model for a ""closure"". Perhaps a better name than ""closure"" is `Dissipation`... ? All of the turbulent closures we are considering introduce a ""turbulent"" viscosity and diffusivity which is typically much larger than the molecular value. Thus a ""molecular"" isotropic diffusivity can be interpreted as the limiting case of a turbulent closure. The reason it might be good design is because turbulent closures can modify boundary conditions (which depend on viscosity/diffusivity), and because we may want to use common implicit time-stepping methods for the turbulent diffusivity in addition to a ""molecular"" diffusivity. > Out of curiousity, can these closures be framed as ODEProblems using DifferentialEquations.jl?. A subgrid turbulent kinetic energy variable in a typical turbulence closure obeys a three-dimensional PDE and is advected, diffused, dissipated, and interacts with terms in the momentum and tracer equation via nonlinear terms. It is a first-class solution variable similar to the velocity field or active tracers. See equation 12 in [Moeng 1984](https://journals.ametsoc.org/doi/pdf/10.1175/1520-0469%281984%29041%3C2052%3AALESMF%3E2.0.CO%3B2). > Sounds like #115 (and #59 (comment)) should be resolved before this closure abstraction is merged in?. I think it makes sense to resolve #107, #115, and #59 before implementing anything; especially #59 because this affects the function signature we use for the closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222089:1424,energy,energy,1424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222089,1,['energy'],['energy']
Energy Efficiency,idia-smi -q. ==============NVSMI LOG==============. Timestamp : Tue Feb 21 07:30:33 2023; Driver Version : 525.60.13; CUDA Version : 12.0. Attached GPUs : 1; GPU 00000000:3D:00.0; Product Name : Tesla V100-SXM2-32GB; Product Brand : Tesla; Product Architecture : Volta; Display Mode : Enabled; Display Active : Disabled; Persistence Mode : Enabled; MIG Mode; Current : N/A; Pending : N/A; Accounting Mode : Disabled; Accounting Mode Buffer Size : 4000; Driver Model; Current : N/A; Pending : N/A; Serial Number : 1562019007305; GPU UUID : GPU-afa33ac3-cef0-ac1a-9dfd-491463f321e9; Minor Number : 0; VBIOS Version : 88.00.80.00.01; MultiGPU Board : No; Board ID : 0x3d00; Board Part Number : 900-2G503-0010-000; GPU Part Number : 1DB5-896-A1; Module ID : 0; Inforom Version; Image Version : G503.0203.00.05; OEM Object : 1.1; ECC Object : 5.0; Power Management Object : N/A; GPU Operation Mode; Current : N/A; Pending : N/A; GSP Firmware Version : N/A; GPU Virtualization Mode; Virtualization Mode : None; Host VGPU Mode : N/A; IBMNPU; Relaxed Ordering Mode : N/A; PCI; Bus : 0x3D; Device : 0x00; Domain : 0x0000; Device Id : 0x1DB510DE; Bus Id : 00000000:3D:00.0; Sub System Id : 0x124910DE; GPU Link Info; PCIe Generation; Max : 3; Current : 3; Device Current : 3; Device Max : 3; Host Max : 3; Link Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:19856,Power,Power,19856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Power'],['Power']
Energy Efficiency,"ields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/output_construction.jl:50; [8] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [9] iterate; @ ./generator.jl:47 [inlined]; [10] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:364; [11] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:151; [12] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::TimeInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/github/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:190; [13] top-level scope; @ ~/github/Oceananigans.jl/test.jl:19; [14] include(fname::String); @ Base.MainInclude ./client.jl:489; [15] top-level scope; @ REPL[1]:1; in expression starting at /Users/jmtzmo/github/Oceananigans.jl/test.jl:19; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:5563,schedul,schedule,5563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['schedul'],['schedule']
Energy Efficiency,"iff-dmVyaWZpY2F0aW9uL3BlcmlvZGljX2FkdmVjdGlvbi9wZXJpb2RpY19hZHZlY3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/Advection/upwind\_biased\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX2ZpZnRoX29yZGVyLmps) | `65.00% <65.00%> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <0.00%> (-5.00%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/tuple\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3R1cGxlX3V0aWxzLmps) | `44.44% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | ... and [27 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994?src=pr&el=footer). Last update [24e9c2c...c4faf06](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/994#issuecomment-700312179:3212,Power,Powered,3212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/994#issuecomment-700312179,1,['Power'],['Powered']
Energy Efficiency,"iff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <100.00%> (ø)` | |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.71% <100.00%> (+0.18%)` | :arrow_up: |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `90.00% <100.00%> (-1.67%)` | :arrow_down: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `96.07% <100.00%> (-0.54%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `96.15% <0.00%> (+0.15%)` | :arrow_up: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (+3.33%)` | :arrow_up: |; | [src/AbstractOperations/grid\_validation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9ncmlkX3ZhbGlkYXRpb24uamw=) | `75.00% <0.00%> (+8.33%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757?src=pr&el=footer). Last update [ae33e4c...94c13c7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/757#issuecomment-632822673:3183,Power,Powered,3183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/757#issuecomment-632822673,1,['Power'],['Powered']
Energy Efficiency,"iff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0.00%> (-6.67%)` | :arrow_down: |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0.00%> (-5.89%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32.00% <0.00%> (-2.10%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `85.10% <0.00%> (-0.61%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100.00% <0.00%> (ø)` | |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100.00% <0.00%> (ø)` | |; | ... and [43 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704?src=pr&el=footer). Last update [bff7abc...ec426ad](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704#issuecomment-599780254:3507,Power,Powered,3507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704#issuecomment-599780254,1,['Power'],['Powered']
Energy Efficiency,"igans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings{Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float32, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}, Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme}}, LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32, 1, CUDA.DeviceMemory}}, Float32, Float32, Float32, Float32, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, GPU}, Float32, @NamedTuple{momentum::VectorInvariant{1, Float64, false, EnstrophyConserving{Float64}, Oceananigans.Advection.VelocityStencil, EnergyConserving{Float64}, EnergyConserving{Float64}, EnergyConserving{Float64}, Oceananigans.Advection.OnlySelfUpwinding{EnergyConserving{Float64}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.u_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.v_smoothness)}}}, b::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, e::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, Nothing, @NamedTuple{u::typeof(Oceananigans.Forcings.zeroforcing), v::typeof(Oceananigans.Forcings.zeroforcing), η::typeof(Oceananigans.Forcings.zeroforcing), b::typeof(Oceananigans.Forcings.zeroforcing), e::typeof(Oceananigans.Forcings.zeroforcing)}, Nothing, Nothing, @NamedTuple{u::Field{Face, Center, Center, Nothing, LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:28497,Energy,EnergyConserving,28497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,4,['Energy'],['EnergyConserving']
Energy Efficiency,"igans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100.00% <ø> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `46.15% <ø> (-39.57%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `70.37% <100.00%> (-3.71%)` | :arrow_down: |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `100.00% <100.00%> (ø)` | |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (-30.01%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-15.79%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `83.33% <0.00%> (-11.67%)` | :arrow_down: |; | ... and [92 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798?src=pr&el=footer). Last update [cec16b0...5cbac0d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-657840369:3040,Power,Powered,3040,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-657840369,1,['Power'],['Powered']
Energy Efficiency,"iguration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise we cannot launch `mpiexec` with 4 tasks (1 for each GPU). It's helpful to have the maximum number of CPUs for precompilation. Otherwise precompilation is very slow. I also set. ```; export JULIA_NUM_PRECOMPILE_TASKS=64; ```. (half the total) --- adapt for your system. Here is also a small test script for debuggin Oceananigans:. ```julia; using Oceananigans; arch = Distributed(GPU()); @show arch; ```. as a side note, it would be nice if we could print to the screen from different ranks without them talking over one another. It makes it hard to read the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:2248,adapt,adapt,2248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,1,['adapt'],['adapt']
Energy Efficiency,"iles](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (+0.37%)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `71.7% <100%> (-0.28%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `52.3% <56%> (-6.85%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `58.06% <58.06%> (-41.94%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `66% <0%> (+26%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=footer). Last update [ac7dc2a...a473fee](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942484:2650,Power,Powered,2650,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942484,1,['Power'],['Powered']
Energy Efficiency,"imestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). return simula",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1447,schedul,schedule,1447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2180,adapt,adaptive,2180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['adapt'],['adaptive']
Energy Efficiency,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1960,adapt,adaptive,1960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['adapt'],['adaptive']
Energy Efficiency,"ine/Oceananigans.jl/pull/288?src=pr&el=h1) Report; > Merging [#288](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/40dbd96fd45a30867063c476b3eecbe13db1fb5c?src=pr&el=desc) will **decrease** coverage by `0.07%`.; > The diff coverage is `42.85%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #288 +/- ##; ==========================================; - Coverage 68.36% 68.29% -0.08% ; ==========================================; Files 22 22 ; Lines 882 880 -2 ; ==========================================; - Hits 603 601 -2 ; Misses 279 279; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `80.64% <100%> (-1.18%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.09% <33.33%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=footer). Last update [40dbd96...51bc9e0](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-504026989:1748,Power,Powered,1748,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-504026989,1,['Power'],['Powered']
Energy Efficiency,"ine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.94% <0%> (-56.72%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `49.35% <0%> (-15.59%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <0%> (-12.5%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `78.26% <0%> (-7.32%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.02% <0%> (-2.1%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <0%> (-1.64%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.54% <0%> (-0.57%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `82.05% <0%> (+1.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435?src=pr&el=footer). Last update [d32cf20...d88b63f](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/435#issuecomment-536922587:2827,Power,Powered,2827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/435#issuecomment-536922587,1,['Power'],['Powered']
Energy Efficiency,"ing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Symbol}, Float32, Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings{Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float32, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}, Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme}}, LatitudeLongitudeGrid{Float32, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{Float32, CUDA.CuArray{Float32, 1, CUDA.DeviceMemory}}, Float32, Float32, Float32, Float32, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, GPU}, Float32, @NamedTuple{momentum::VectorInvariant{1, Float64, false, EnstrophyConserving{Float64}, Oceananigans.Advection.VelocityStencil, EnergyConserving{Float64}, EnergyConserving{Float64}, EnergyConserving{Float64}, Oceananigans.Advection.OnlySelfUpwinding{EnergyConserving{Float64}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.divergence_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.u_smoothness)}, Oceananigans.Advection.FunctionStencil{typeof(Oceananigans.Advection.v_smoothness)}}}, b::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, e::Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, Nothing, @NamedTuple{u::typeof(Oceananigans.Forcings.zeroforcing), v::typeof(Oceananigans.Forcings.zeroforcing), η::typeof(Oceananigans.Forcings.zeroforcing), b::typeof(Oceananigans.Forcings.zeroforcing), e::typeof(Oceananigans.Forcings.zeroforcing)}, Nothing, Nothing, @NamedTuple{u::Field{Face, Center, Center, Nothing, LatitudeLongitudeGri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:28375,Energy,EnergyConserving,28375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,12,['Energy'],['EnergyConserving']
Energy Efficiency,"io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <ø> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <ø> (ø)` | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `91.78% <69.23%> (-6.70%)` | :arrow_down: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `92.06% <85.71%> (+0.99%)` | :arrow_up: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `89.18% <100.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <100.00%> (+5.31%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=footer). Last update [994eae3...a77b356](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839#issuecomment-670153251:2625,Power,Powered,2625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839#issuecomment-670153251,1,['Power'],['Powered']
Energy Efficiency,"io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | | |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | | |; | [src/Operators/derivative\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9kZXJpdmF0aXZlX29wZXJhdG9ycy5qbA==) | | |; | [src/Operators/tracer\_advection\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | | |; | [...ure\_implementations/leith\_enstrophy\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2xlaXRoX2Vuc3Ryb3BoeV9kaWZmdXNpdml0eS5qbA==) | | |; | [...nce\_closure\_implementations/blasius\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2JsYXNpdXNfc21hZ29yaW5za3kuamw=) | | |; | ... and [75 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280?src=pr&el=footer). Last update [91e5626...45bf8a8](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/280#issuecomment-500250532:3522,Power,Powered,3522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280#issuecomment-500250532,1,['Power'],['Powered']
Energy Efficiency,"iodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=0.5. julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN. julia> using Statistics: norm. julia> norm(f1); 2.29128784747",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998:1028,reduce,reduced,1028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998,1,['reduce'],['reduced']
Energy Efficiency,"iodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, typeof(condition_greater_3), Int64, Float64}); @ GPUArrays ~/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; [17] #sum!#796; @ ./reducedim.jl:1018 [inlined]; [18] sum!(f::Function, r::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCond",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:17303,reduce,reducedim,17303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568,1,['reduce'],['reducedim']
Energy Efficiency,"ion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | `71.42% <0.00%> (ø)` | |; | [.../IncompressibleModels/show\_incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9zaG93X2luY29tcHJlc3NpYmxlX21vZGVsLmps) | `0.00% <ø> (ø)` | |; | [...ncompressibleModels/update\_hydrostatic\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | `40.00% <ø> (ø)` | |; | [src/Models/IncompressibleModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfc3RhdGUuamw=) | `87.50% <0.00%> (ø)` | |; | [...mpressibleModels/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `60.00% <ø> (ø)` | |; | [src/Models/Models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <ø> (ø)` | |; | ... and [8 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174?src=pr&el=footer). Last update [03a6f85...0386f31](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1174#issuecomment-727277449:3743,Power,Powered,3743,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1174#issuecomment-727277449,1,['Power'],['Powered']
Energy Efficiency,it blows up at some point... . https://github.com/CliMA/Oceananigans.jl/assets/7112768/b8396af4-810e-4584-85d6-18431deb4bc4. I even reduced the tilmestep but not sure if it's that or corner-related artifacts,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747335909:132,reduce,reduced,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1747335909,1,['reduce'],['reduced']
Energy Efficiency,"itions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.identity3), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; [6] top-level scope; @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:30922,schedul,schedule,30922,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784,1,['schedul'],['schedule']
Energy Efficiency,"jL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `30.00% <0.00%> (-4.10%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `61.53% <0.00%> (+2.56%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <0.00%> (+6.34%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `66.66% <0.00%> (+11.11%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <0.00%> (+32.35%)` | :arrow_up: |; | [src/Solvers/plan\_transforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `100.00% <0.00%> (+33.33%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758?src=pr&el=footer). Last update [9b9e8e2...1c31ca5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/758#issuecomment-632044290:3478,Power,Powered,3478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/758#issuecomment-632044290,1,['Power'],['Powered']
Energy Efficiency,"jL2dyaWRzLmps) | `94.59% <ø> (ø)` | :arrow_up: |; | [src/turbulence\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `0% <0%> (ø)` | |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.9% <100%> (+0.43%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `86.86% <100%> (+2.81%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `12.5% <40%> (+12.5%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `38.46% <50%> (+1.61%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=footer). Last update [7e29af4...c863622](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127823:3239,Power,Powered,3239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127823,1,['Power'],['Powered']
Energy Efficiency,"jl/pull/922/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #922 +/- ##; ==========================================; + Coverage 72.78% 72.79% +0.01% ; ==========================================; Files 192 192 ; Lines 5643 5649 +6 ; ==========================================; + Hits 4107 4112 +5 ; - Misses 1536 1537 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.36% <ø> (ø)` | |; | [src/AbstractOperations/multiary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9tdWx0aWFyeV9vcGVyYXRpb25zLmps) | `86.36% <100.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `85.71% <0.00%> (-3.18%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `96.29% <0.00%> (+0.14%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=footer). Last update [01b2481...ba87adc](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/922#issuecomment-689771084:2154,Power,Powered,2154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/922#issuecomment-689771084,1,['Power'],['Powered']
Energy Efficiency,"jl/pull/932/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb25lX2RpbWVuc2lvbmFsX2RpZmZ1c2lvbi5qbA==) | `0.00% <ø> (ø)` | |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `66.66% <ø> (ø)` | |; | [src/Diagnostics/Diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <ø> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `93.61% <ø> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.25% <ø> (-0.08%)` | :arrow_down: |; | [...ests/ConvergenceTests/DoublyPeriodicTaylorGreen.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRG91Ymx5UGVyaW9kaWNUYXlsb3JHcmVlbi5qbA==) | `0.00% <0.00%> (ø)` | |; | ... and [10 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932?src=pr&el=footer). Last update [3b45ce5...82d362a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/932#issuecomment-691237401:3389,Power,Powered,3389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932#issuecomment-691237401,1,['Power'],['Powered']
Energy Efficiency,"just a comment: pressure correction (as done now) is just one piece of an implicit in time; component of the time stepping. The more general form would be: explicit part (AB or RK or just ; simple forward) then implicit part (including: pressure correction, implicit vertical for ; diffusion/viscosity or/and advection, implicit relaxation/damping). On Tue, Feb 12, 2019 at 06:58:27PM -0800, Ali Ramadhan wrote:; > Yeah I think the current time stepping algorithm (essentially what the MITgcm does) is pretty custom so it's probably not shared by other equations/methods, but the pressure correction step is pretty common to finite volume Navier-Stokes solvers and it should be possible to generalize it.; > ; > I'm thinking it might be good to tackle ""generic time stepping"" in two steps. 1. Getting the current version of the time stepping algorithm running efficiently on GPUs for milestone v0.4 and then 2. we can redesign for v0.5 and include more generic time stepping.; > ; > ; > -- ; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly or view it on GitHub:; > https://github.com/ali-ramadhan/Oceananigans.jl/issues/49#issuecomment-463036545",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463042259:860,efficient,efficiently,860,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463042259,1,['efficient'],['efficiently']
Energy Efficiency,"l/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/Forcing/parameterized\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcGFyYW1ldGVyaXplZF9mb3JjaW5nLmps) | `100.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/apply\_no\_penetration\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9ub19wZW5ldHJhdGlvbl9iY3Muamw=) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `92.30% <0.00%> (+3.41%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=footer). Last update [7a47b92...a20cf39](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522:3694,Power,Powered,3694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522,1,['Power'],['Powered']
Energy Efficiency,"l/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jb25zdGFudF9pc290cm9waWNfZGlmZnVzaXZpdHkuamw=) | `100% <100%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92ZXJzdGFwcGVuX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [...ulenceClosures/constant\_anisotropic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jb25zdGFudF9hbmlzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100% <100%> (ø)` | |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `85.43% <100%> (+1.92%)` | :arrow_up: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `23.8% <25%> (-1.2%)` | :arrow_down: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `77.41% <68.42%> (-10.09%)` | :arrow_down: |; | ... and [8 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452?src=pr&el=footer). Last update [99b1a70...5d796b5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-541188654:3715,Power,Powered,3715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-541188654,1,['Power'],['Powered']
Energy Efficiency,"l/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Advection/upwind\_biased\_advective\_fluxes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX2FkdmVjdGl2ZV9mbHV4ZXMuamw=) | `100.00% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [src/Advection/weno\_nth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX250aF9vcmRlci5qbA==) | `53.19% <53.19%> (ø)` | |; | [src/Advection/centered\_fourth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9mb3VydGhfb3JkZXIuamw=) | `64.28% <57.14%> (ø)` | |; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `66.66% <66.66%> (+1.66%)` | :arrow_up: |; | [src/Advection/weno\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX2ZpZnRoX29yZGVyLmps) | `80.46% <80.46%> (ø)` | |; | ... and [69 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592?src=pr&el=footer). Last update [d80be8c...7612a01](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-573978399:3428,Power,Powered,3428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-573978399,1,['Power'],['Powered']
Energy Efficiency,"l/pull/933/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `75.86% <0.00%> (-10.81%)` | :arrow_down: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `53.84% <0.00%> (-5.13%)` | :arrow_down: |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `90.00% <0.00%> (-3.75%)` | :arrow_down: |; | [src/Fields/function\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9mdW5jdGlvbl9maWVsZC5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `0.00% <0.00%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `82.35% <0.00%> (+1.10%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933?src=pr&el=footer). Last update [e9583ce...19cd67a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/933#issuecomment-691108830:3524,Power,Powered,3524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/933#issuecomment-691108830,1,['Power'],['Powered']
Energy Efficiency,"l=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/54d8aa1ee1218ffed70232a277cc8cff5b72dc5b?src=pr&el=desc) will **decrease** coverage by `0.07%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #303 +/- ##; ==========================================; - Coverage 71.8% 71.72% -0.08% ; ==========================================; Files 24 24 ; Lines 1000 1001 +1 ; ==========================================; Hits 718 718 ; - Misses 282 283 +1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `58.33% <0%> (-1.67%)` | :arrow_down: |; | [src/time\_step\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcF91dGlscy5qbA==) | `0% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=footer). Last update [54d8aa1...4ac5bb2](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/303#issuecomment-506990525:1887,Power,Powered,1887,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/303#issuecomment-506990525,1,['Power'],['Powered']
Energy Efficiency,"lZF9maWVsZC5qbA==) | `94.44% <ø> (ø)` | |; | [src/Fields/function\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9mdW5jdGlvbl9maWVsZC5qbA==) | `23.07% <0.00%> (ø)` | |; | [src/AbstractOperations/unary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `76.47% <50.00%> (-10.20%)` | :arrow_down: |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `66.66% <66.66%> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <75.00%> (-4.87%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `89.47% <76.92%> (-6.83%)` | :arrow_down: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `77.77% <77.77%> (ø)` | |; | ... and [9 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931?src=pr&el=footer). Last update [e9583ce...ba8fc61](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-690822059:3453,Power,Powered,3453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-690822059,1,['Power'],['Powered']
Energy Efficiency,"l](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2RpYWdub3N0aWNzX2tlcm5lbHMuamw=) | `0.00% <0.00%> (-100.00%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `36.36% <0.00%> (+1.06%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `75.00% <ø> (ø)` | |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `36.84% <ø> (ø)` | |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `75.00% <0.00%> (-25.00%)` | :arrow_down: |; | ... and [80 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=footer). Last update [ecc0fda...8a9755b](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660540378:3396,Power,Powered,3396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660540378,1,['Power'],['Powered']
Energy Efficiency,"l](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `100% <100%> (+43.75%)` | :arrow_up: |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <100%> (ø)` | :arrow_up: |; | [...bulence\_closures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdHVyYnVsZW5jZV9jbG9zdXJlX2RpYWdub3N0aWNzLmps) | `20% <20%> (ø)` | |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `70.21% <25%> (+5.76%)` | :arrow_up: |; | [...rc/turbulence\_closures/turbulence\_closure\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdHVyYnVsZW5jZV9jbG9zdXJlX3V0aWxzLmps) | `62.5% <62.5%> (ø)` | |; | ... and [4 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407?src=pr&el=footer). Last update [dd122e9...17e7f14](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/407#issuecomment-531510704:3698,Power,Powered,3698,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/407#issuecomment-531510704,1,['Power'],['Powered']
Energy Efficiency,"lc3RzL0NvbnZlcmdlbmNlVGVzdHMvYW5hbHlzaXMuamw=) | | |; | [test/test\_verification.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ZlcmlmaWNhdGlvbi5qbA==) | | |; | [...nvergence\_tests/ConvergenceTests/file\_wrangling.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvZmlsZV93cmFuZ2xpbmcuamw=) | | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | | |; | [test/test\_pressure\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ByZXNzdXJlX3NvbHZlcnMuamw=) | | |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | | |; | [...\_tests/ConvergenceTests/TwoDimensionalDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvVHdvRGltZW5zaW9uYWxEaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=footer). Last update [162159d...a538a52](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968:3345,Power,Powered,3345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968,1,['Power'],['Powered']
Energy Efficiency,"lcy92ZWxvY2l0eV90cmFjZXJfZ3JhZGllbnRzLmps) | `69.72% <ø> (ø)` | |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100% <ø> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `25% <ø> (ø)` | |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `64.44% <0%> (ø)` | |; | [src/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL2Nsb2NrLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.12% <100%> (-0.18%)` | :arrow_down: |; | ... and [11 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412?src=pr&el=footer). Last update [a9e34a7...7fe8a47](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532091518:3543,Power,Powered,3543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532091518,1,['Power'],['Powered']
Energy Efficiency,"lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1669,monitor,monitor,1669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['monitor'],['monitor']
Energy Efficiency,"licitTimeDiscretization(); ν, κ=(; b=κᵇ)); ```. _Then_, you need to compute `Ri` in a `Simulation.callback` (you also need to fill it's halo regions, which is a bit annoying but we show you how below). This is pretty advanced usage (and there are subtleties as I mention below) so I'll write a script that implements Pacanowski-Philander as an example. Note that it is currently a limitation of our turbulence closures that viscosities diffusivities must be defined at `(Center, Center, Center)`. #2295 makes some changes that will permit this restriction to be relaxed in the future, but we aren't quite there yet. ## Solution 2: precreate `velocities` and `tracers`. Another solution is to pre-create `velocities` and `tracers` by pre-creating a ""fake model"". Then, the viscosity / diffusivities can be defined directly as abstract operations of `fake_model.velocities` and `fake_model.tracers`, and these named tuples can be passed on to a ""true"" model. This _could_ be slightly more efficient than computing and storing `Ri` every time-step. This would look something like. ```julia; grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = NonhydrostaticModel(; grid, tracers=:b, buoyancy=nothing). velocities = fake_model.velocities; tracers = fake_model.tracers; Ri = ∂z(b) / (∂z(u)^2 + ∂z(v)^2). ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. ν = @at (Center, Center, Center) ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = @at (Center, Center, Center) κ₀ + κ₁ / (1 + c * Ri^(n+1)); closure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdams",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:2158,efficient,efficient,2158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186,1,['efficient'],['efficient']
Energy Efficiency,"limate-machine/Oceananigans.jl/pull/519?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #519 +/- ##; ==========================================; - Coverage 64.61% 64.15% -0.47% ; ==========================================; Files 68 69 +1 ; Lines 1950 1964 +14 ; ==========================================; Hits 1260 1260 ; - Misses 690 704 +14; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | [src/SurfaceWaves.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL1N1cmZhY2VXYXZlcy5qbA==) | `0% <0%> (ø)` | |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `84.37% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `74.35% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `60.39% <100%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=footer). Last update [08294f7...972fbd1](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/519#issuecomment-548595850:2278,Power,Powered,2278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/519#issuecomment-548595850,1,['Power'],['Powered']
Energy Efficiency,"limate-machine/Oceananigans.jl/pull/584?src=pr&el=h1) Report; > Merging [#584](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/588890004e69cfc7db10472b12a9840b8a9ad7b6?src=pr&el=desc) will **increase** coverage by `0.65%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #584 +/- ##; ==========================================; + Coverage 72.17% 72.82% +0.65% ; ==========================================; Files 70 70 ; Lines 2016 2050 +34 ; ==========================================; + Hits 1455 1493 +38 ; + Misses 561 557 -4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `62.5% <0%> (+1.44%)` | :arrow_up: |; | [src/logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584/diff?src=pr&el=tree#diff-c3JjL2xvZ2dlci5qbA==) | `59.25% <0%> (+59.25%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=footer). Last update [5888900...b7cae54](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/584#issuecomment-568103734:1737,Power,Powered,1737,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/584#issuecomment-568103734,1,['Power'],['Powered']
Energy Efficiency,"ll/1047/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <0.00%> (ø)` | |; | [...ests/ConvergenceTests/DoublyPeriodicTaylorGreen.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRG91Ymx5UGVyaW9kaWNUYXlsb3JHcmVlbi5qbA==) | `0.00% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | `85.33% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.21% <0.00%> (ø)` | |; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | `0.00% <0.00%> (ø)` | |; | [...ergence\_tests/ConvergenceTests/ConvergenceTests.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvQ29udmVyZ2VuY2VUZXN0cy5qbA==) | `0.00% <0.00%> (ø)` | |; | ... and [95 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=footer). Last update [d100853...116f81c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1047#issuecomment-707893132:3420,Power,Powered,3420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1047#issuecomment-707893132,1,['Power'],['Powered']
Energy Efficiency,"llect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ┌───────────────┬─────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Schemes │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Stretched │ 7.122 s │ 7.122 s │ 7.122 s │ 7.122 s │ 949.91 KiB │ 1716 │ 1 │; │ CPU │ StretchedSmoothness │ 11.042 s │ 11.042 s │ 11.042 s │ 11.042 s │ 956.47 KiB │ 1716 │ 1 │; │ CPU │ Uniform │ 6.373 s │ 6.373 s │ 6.373 s │ 6.373 s │ 945.38 KiB │ 1706 │ 1 │; │ CPU │ ZFormulation │ 7.725 s │ 7.725 s │ 7.725 s │ 7.725 s │ 945.38 KiB │ 1706 │ 1 │; │ GPU │ Stretched │ 25.646 ms │ 25.920 ms │ 26.501 ms │ 32.101 ms │ 2.15 MiB │ 30442 │ 10 │; │ GPU │ StretchedSmoothness │ 109.080 ms │ 109.493 ms │ 109.676 ms │ 111.118 ms │ 3.78 MiB │ 134069 │ 10 │; │ GPU │ Uniform │ 25.133 ms │ 25.394 ms │ 25.468 ms │ 26.710 ms │ 2.06 MiB │ 27799 │ 10 │; │ GPU │ ZFormulation │ 30.554 ms │ 32.780 ms │ 32.569 ms │ 32.922 ms │ 2.20 MiB │ 37382 │ 10 │; └───────────────┴─────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; ```; Apparently on a much larger grid than what I tested, StretchedSmoothness is much less efficient, another reason to try to avoid it if not strictly necessary!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:5463,efficient,efficient,5463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,1,['efficient'],['efficient']
Energy Efficiency,"lliptic]]; git-tree-sha1 = ""71c79e77221ab3a29918aaf6db4f217b89138608""; uuid = ""b305315f-e792-5b7a-8f41-49f472929428""; version = ""1.0.1"". [[ExprTools]]; git-tree-sha1 = ""10407a39b87f29d47ebaca8edbc75d7c302ff93e""; uuid = ""e2ba6199-217a-4e67-a87a-7c52f15ade04""; version = ""0.1.3"". [[FFTW]]; deps = [""AbstractFFTs"", ""FFTW_jll"", ""IntelOpenMP_jll"", ""Libdl"", ""LinearAlgebra"", ""MKL_jll"", ""Reexport""]; git-tree-sha1 = ""1b48dbde42f307e48685fa9213d8b9f8c0d87594""; uuid = ""7a1cc6ca-52ef-59f5-83cd-3a7055c09341""; version = ""1.3.2"". [[FFTW_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""5a0d4b6a22a34d17d53543bd124f4b08ed78e8b0""; uuid = ""f5851436-0d7a-5f13-b9de-f02708fd171a""; version = ""3.3.9+7"". [[FileIO]]; deps = [""Pkg"", ""Requires"", ""UUIDs""]; git-tree-sha1 = ""b647ed22f176a4f12eabe2afd90d19a95af2e8ca""; uuid = ""5789e2e9-d7fb-5bc7-8068-2c6fae9b9549""; version = ""1.8.0"". [[GPUArrays]]; deps = [""AbstractFFTs"", ""Adapt"", ""LinearAlgebra"", ""Printf"", ""Random"", ""Serialization""]; git-tree-sha1 = ""9c95b2fd5c16bc7f97371e9f92f0fef77e0f5957""; uuid = ""0c68f7d7-f131-5f86-a1c3-88cf8149b2d7""; version = ""6.2.2"". [[GPUCompiler]]; deps = [""DataStructures"", ""InteractiveUtils"", ""LLVM"", ""Libdl"", ""Scratch"", ""Serialization"", ""TimerOutputs"", ""UUIDs""]; git-tree-sha1 = ""c853c810b52a80f9aad79ab109207889e57f41ef""; uuid = ""61eb1bfa-7361-4325-ad38-22787b887f55""; version = ""0.8.3"". [[Glob]]; git-tree-sha1 = ""4df9f7e06108728ebf00a0a11edee4b29a482bb2""; uuid = ""c27321d9-0574-5035-807b-f59d2c89b15c""; version = ""1.3.0"". [[HDF5_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""LibCURL_jll"", ""Libdl"", ""OpenSSL_jll"", ""Pkg"", ""Zlib_jll""]; git-tree-sha1 = ""fd83fa0bde42e01952757f01149dd968c06c4dba""; uuid = ""0234f1f7-429e-5d53-9886-15a909be8d59""; version = ""1.12.0+1"". [[IfElse]]; git-tree-sha1 = ""28e837ff3e7a6c3cdb252ce49fb412c8eb3caeef""; uuid = ""615f187c-cbe4-4ef1-ba3b-2fcf58d6d173""; version = ""0.1.0"". [[IntelOpenMP_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""d979e54b71da82f3a65",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:5373,Adapt,Adapt,5373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Energy Efficiency,"lse` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`), and the `mask` (which at the moment is just a number). You can construct it with `condition_operand(field, condition, mask)`. But most of the time you probably won't need it (reductions automatically construct a `ConditionalOperation` when specifying a condition through the keyword argument). @glwagner `condition_operand` is used because we needed to define it in `Fields.jl` which is added before `AbstractOperations.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:1865,reduce,reduce,1865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235,1,['reduce'],['reduce']
Energy Efficiency,"lux\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `21.21% <0.00%> (-34.35%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `56.00% <0.00%> (-30.67%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `75.00% <0.00%> (-21.56%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `71.42% <0.00%> (-20.24%)` | :arrow_down: |; | [src/Solvers/index\_permutations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaW5kZXhfcGVybXV0YXRpb25zLmps) | `0.00% <0.00%> (-20.00%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-16.85%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `65.62% <0.00%> (-16.73%)` | :arrow_down: |; | ... and [172 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870?src=pr&el=footer). Last update [17f8cc6...19f23f1](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/870#issuecomment-681312161:3598,Power,Powered,3598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/870#issuecomment-681312161,1,['Power'],['Powered']
Energy Efficiency,"machine/Oceananigans.jl/pull/418?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #418 +/- ##; ==========================================; + Coverage 73.28% 76.87% +3.59% ; ==========================================; Files 25 25 ; Lines 1426 1427 +1 ; ==========================================; + Hits 1045 1097 +52 ; + Misses 381 330 -51; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `86.88% <0%> (+1.63%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `85.57% <0%> (+12.76%)` | :arrow_up: |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `86.23% <0%> (+16.51%)` | :arrow_up: |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `84.74% <0%> (+32.2%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=footer). Last update [a9e34a7...2dff13a](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/418#issuecomment-532833457:2282,Power,Powered,2282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/418#issuecomment-532833457,1,['Power'],['Powered']
Energy Efficiency,"machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9zbWFnb3JpbnNreS5qbA==) | `77.33% <100%> (ø)` | :arrow_up: |; | [src/forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL2ZvcmNpbmcuamw=) | `53.84% <100%> (ø)` | :arrow_up: |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92ZXJzdGFwcGVuX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <16.66%> (ø)` | |; | [src/AbstractOperations/function\_fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9mdW5jdGlvbl9maWVsZHMuamw=) | `25% <25%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <33.33%> (ø)` | |; | ... and [26 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463?src=pr&el=footer). Last update [7bbdd3d...f61dbc6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-541339268:3602,Power,Powered,3602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-541339268,1,['Power'],['Powered']
Energy Efficiency,"macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7089,Adapt,Adapt,7089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,2,['Adapt'],['Adapt']
Energy Efficiency,"model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0.00%> (-5.89%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `61.53% <0.00%> (+2.56%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <0.00%> (+6.34%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `66.66% <0.00%> (+11.11%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <0.00%> (+32.35%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742?src=pr&el=footer). Last update [533abcd...45c9255](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/742#issuecomment-622097623:3337,Power,Powered,3337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/742#issuecomment-622097623,1,['Power'],['Powered']
Energy Efficiency,"more like are the arguments of the constructors of the respective types `CuSparseMatrixCSC` and `SparseMatrixCSC`, which are also the fields of the respective types. (respectively, the dimensions, the integer vector of column pointers, the integer vector of row position and the float vector of nonzero elements) . you should be able to manipulate those efficiently",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109796895:354,efficient,efficiently,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109796895,1,['efficient'],['efficiently']
Energy Efficiency,"n . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= CFL, Δt = initial_timestep, max_change = max_allowable_change_in_Δt, max_Δt = maximum_Δt). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:4483,adapt,adaptive,4483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['adapt'],['adaptive']
Energy Efficiency,"n=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #662 +/- ##; =========================================; + Coverage 78.06% 78.2% +0.14% ; =========================================; Files 118 118 ; Lines 2362 2368 +6 ; =========================================; + Hits 1844 1852 +8 ; + Misses 518 516 -2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <100%> (+3.17%)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `96.29% <100%> (+3.7%)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.07% <100%> (-0.31%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `91.17% <88.88%> (+5.46%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=footer). Last update [042f8cf...90e9560](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/662#issuecomment-592911845:2222,Power,Powered,2222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/662#issuecomment-592911845,1,['Power'],['Powered']
Energy Efficiency,"nBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); reduced_precision_grid = with_number_type(Float32, grid.underlying_grid); preconditioner = fft_poisson_solver(reduced_precision_grid); pressure_solver = ConjugateGradientPoissonSolver(grid; preconditioner, maxiter=20). model = NonhydrostaticModel(; grid, boundary_conditions, pressure_solver); simulation = Simulation(model; Δt=0.1, stop_iteration=1000); conjure_time_step_wizard!(simulation, cfl=0.5). u, v, w = model.velocities; δ = ∂x(u) + ∂y(v) + ∂z(w). function progress(sim); model = sim.model; u, v, w = model.velocities; @printf(""Iter: %d, time: %.1f, Δt: %.2e, max|δ|: %.2e"",; iteration(sim), time(sim), sim.Δt, maximum(abs, δ)). r = model.pressure_solver.conjugate_gradient_solver.residual; @printf("", solver iterations: %d, max|r|: %.2e\n"",; iteration(model.pressure_solver), maximum(abs, r)); end. add_callback!(simulation, progress). simulation.output_writers[:fields] =; JLD2OutputWriter(model, model.velocities; filename=""3831.jld2"", schedule=IterationInterval(10), overwrite_existing=true). run!(simulation). using GLMakie. ds = FieldDataset(""3831.jld2""); fig = Figure(size=(1000, 500)). n = Observable(1); times = ds[""u""].times; title = @lift @sprintf(""time = %s"", prettytime(times[$n])). Nx, Ny, Nz = size(grid); j = round(Int, Ny/2); k = round(Int, Nz/2); u_surface = @lift view(ds[""u""][$n], :, :, k); u_slice = @lift view(ds[""u""][$n], :, j, :). ax1 = Axis(fig[1, 1]; title = ""u (xy)"", xlabel=""x"", ylabel=""y""); hm1 = heatmap!(ax1, u_surface, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 2], hm1, label=""m/s""). ax2 = Axis(fig[1, 3]; title = ""u (xz)"", xlabel=""x"", ylabel=""z""); hm2 = heatmap!(ax2, u_slice, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 4], hm2, label=""m/s""). fig[0, :] = Label(fig, title). record(fig, ""3831.mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426:3224,schedul,schedule,3224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426,1,['schedul'],['schedule']
Energy Efficiency,"nditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); cfl=AdvectiveCFL(0.1); start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, cfl: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; cfl(model), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=0.1, stop_time=40minutes, iteration_interval=10,; progress=progress_message,parameters=(;cfl)); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:3310,schedul,schedule,3310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['schedul'],['schedule']
Energy Efficiency,"nditions/fill\_halo\_regions\_flat.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc19mbGF0Lmps) | `0.00% <0.00%> (-100.00%)` | :arrow_down: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `8.77% <0.00%> (-87.78%)` | :arrow_down: |; | [src/TimeSteppers/runge\_kutta\_3.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9ydW5nZV9rdXR0YV8zLmps) | `0.00% <0.00%> (-85.08%)` | :arrow_down: |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `0.00% <0.00%> (-84.00%)` | :arrow_down: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `0.00% <0.00%> (-79.17%)` | :arrow_down: |; | ... and [121 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025?src=pr&el=footer). Last update [7687ab6...616ee5f](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1025#issuecomment-707938629:3887,Power,Powered,3887,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1025#issuecomment-707938629,1,['Power'],['Powered']
Energy Efficiency,"ndom""]; git-tree-sha1 = ""6a8a2a625ab0dea913aba95c11370589e0239ff0""; uuid = ""1914dd2f-81c6-5fcd-8719-6d5c9610ff09""; version = ""0.5.6"". [[Markdown]]; deps = [""Base64""]; uuid = ""d6f4376e-aef5-505a-96c1-9c027394607a"". [[MbedTLS_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""0eef589dd1c26a3ac9d753fe1a8bcad63f956fa6""; uuid = ""c8ffd9c3-330d-5841-b78e-0817d7145fa1""; version = ""2.16.8+1"". [[MicrosoftMPI_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""e5c90234b3967684c9c6f87b4a54549b4ce21836""; uuid = ""9237b28f-5490-5468-be7b-bb81f5f5e6cf""; version = ""10.1.3+0"". [[Mmap]]; uuid = ""a63ad114-7e13-5084-954f-fe012c677804"". [[NCDatasets]]; deps = [""CFTime"", ""DataStructures"", ""Dates"", ""NetCDF_jll"", ""Printf""]; git-tree-sha1 = ""b71d83c87d80f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:10403,Adapt,Adapt,10403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Energy Efficiency,"necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore ─ v1.7.2; Installed Tables ───────── v1.6.0; Installed Parsers ──────── v2.0.5; Installed StaticArrays ─── v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] +",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:1041,Adapt,Adapt,1041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237,1,['Adapt'],['Adapt']
Energy Efficiency,"nes 676 754 +78 ; ==========================================; + Hits 449 523 +74 ; - Misses 227 231 +4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcGVyYXRvcnMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `86.86% <100%> (+2.81%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.9% <100%> (+0.43%)` | :arrow_up: |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `86.71% <86.11%> (+0.84%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=footer). Last update [7e29af4...ac6ed18](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127822:2526,Power,Powered,2526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127822,1,['Power'],['Powered']
Energy Efficiency,"ng. John; >; > On Tue, Jun 25, 2019, 7:49 PM Gregory L. Wagner <notifications@github.com>; > wrote:; >; > > Adaptive time-stepping is useful for a wide class of problems. The general; > > strategy is to use the CFL number to compute a stable time-step. This is; > > especially useful in problems with lots of time variability --- for; > > example, LES of a seasonal cycle. In addition, the CFL computation can be; > > used to stabilize the spin-up of a model, during which a transition to; > > turbulence occurs.; > >; > > Some complexity is introduced by the fact that we use Adams-Bashforth time; > > stepping (as opposed to a RK-method, which is more common and more stable),; > > since it means we need to re-initialize the ""previous source terms"" with a; > > forward Euler step when the time step is changed.; > >; > > I have been using adaptive time-stepping in my work, which along with a; > > strategy for handling model spinup / transition to turbulence, has proven; > > to be an important practical feature that makes running experimental; > > simulations under different conditions much easier, since all I need to do; > > is set my boundary conditions, and let the model run. I am then able to; > > start dozens of LES per day (if I want to) without having to choose my time; > > step size through a mistake-prone and time-consuming trial-and-error; > > process --- and I am guaranteed not to waste resources with a too-short; > > time-step.; > >; > > —; > > You are receiving this because you commented.; > > Reply to this email directly, view it on GitHub; > > <https://github.com/climate-machine/Oceananigans.jl/pull/297?email_source=notifications&email_token=AKXUEQVQYODJTMVZ46AOA3TP4JLCFA5CNFSM4H3I7NT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODYRBT7Q#issuecomment-505551358>,; > > or mute the thread; > > <https://github.com/notifications/unsubscribe-auth/AKXUEQS54XWGGG7MKQWZZELP4JLCFANCNFSM4H3I7NTQ>; > > .; > >; >; > —; > You are receiving this because you are ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637:1141,adapt,adaptive,1141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637,1,['adapt'],['adaptive']
Energy Efficiency,"ng_grid.Lz + 500 * exp(-x^2 / (2*(20e3)^2));. julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom));. julia> c = Field{Center, Nothing, Nothing}(grid); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand()); 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=0.952381, min=0.952381, mean=0.952381. julia> lines(c). julia> c; 250×1×1 Field{Center, Nothing, Nothing} reduced over dims = (2, 3) on ImmersedBoundaryGrid on CPU; ├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 258×1×1 OffsetArray(::Array{Float64, 3}, -3:254, 1:1, 1:1) with eltype Float64 with indices -3:254×1:1×1:1; └── max=NaN, min=NaN, mean=NaN; ```. After plotting a field then it has NaNs. Is this OK?; Of course, we expect that because we masked it in immersed regions. Is the issue here the show method? Should it be ignoring immersed regions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749:1563,reduce,reduced,1563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308671749,1,['reduce'],['reduced']
Energy Efficiency,"nigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9uZXdfZGF0YS5qbA==) | `66.66% <66.66%> (ø)` | |; | [src/TurbulenceClosures/diffusivity\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9kaWZmdXNpdml0eV9maWVsZHMuamw=) | `100.00% <100.00%> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `25.00% <0.00%> (-8.34%)` | :arrow_down: |; | [src/Utils/kernel\_launching.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2tlcm5lbF9sYXVuY2hpbmcuamw=) | `100.00% <0.00%> (ø)` | |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `94.93% <0.00%> (+2.30%)` | :arrow_up: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `74.54% <0.00%> (+3.49%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914?src=pr&el=footer). Last update [6d349e1...bbb2e4c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/914#issuecomment-688933336:3150,Power,Powered,3150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/914#issuecomment-688933336,1,['Power'],['Powered']
Energy Efficiency,"ns, you could try using arrays to set the initial conditions instead. Your script contains these lines:. ```julia; rng = MersenneTwister(1234); Random.seed!(rng, 1414); Ξ(z) = randn(rng) * z / model.grid.Lz * (1 + z / model.grid.Lz) ; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); ```. You can try replacing these lines with something like. ```julia; Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) *. shape; Ξu = randn(size(u)...) *. shape; Ξw = randn(size(w)...) *. shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35); ```. I'd be curious to know if this works. Here are a few more tips and best practices for raising issues here:. * Please reduce your code to minimum working examples. The script that was linked contains a lot of extraneous code (including comments copy/pasted from an example) that is irrelevant to the issue we are discussing. Reducing your code to a minimum example is kind to the community and will help people answer your questions faster. * If you can, avoid linking to code and instead paste your code directly into the issue. * Use [github's markdown formatting](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) (such as triple backticks, ""```"") to format code and julia prompt instructions. * Finally, I strongly recommend using environments to manage the Oceananigans version (though I don't think this is intrinsic to the issue, it will help us rule out a lot of possible issues if we can focus on one Oceananigans version). We have written some tips in our wiki: https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092:1516,reduce,reduce,1516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092,1,['reduce'],['reduce']
Energy Efficiency,"ns/solution\_and\_model\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zb2x1dGlvbl9hbmRfbW9kZWxfYm91bmRhcnlfY29uZGl0aW9ucy5qbA==) | `94.59% <0%> (+5.4%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.68% <0%> (+6.55%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `88.88% <0%> (+22.22%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `61.76% <0%> (+26.47%)` | :arrow_up: |; | [src/Solvers/plan\_transforms.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `100% <0%> (+33.33%)` | :arrow_up: |; | [...c/Solvers/horizontally\_periodic\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaG9yaXpvbnRhbGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `98.11% <0%> (+56.6%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=footer). Last update [0f1f5ab...99f7404](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/626#issuecomment-586645797:3611,Power,Powered,3611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/626#issuecomment-586645797,1,['Power'],['Powered']
Energy Efficiency,"nteresting that the code will still be called `Oceananigans` :-D. I'm not sure I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1009,reduce,reduce,1009,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['reduce'],['reduce']
Energy Efficiency,"nto [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/47b46131e951c906dc38c29125395792762de57e?src=pr&el=desc) will **increase** coverage by `3.21%`.; > The diff coverage is `77.77%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #140 +/- ##; ========================================; + Coverage 56.78% 60% +3.21% ; ========================================; Files 19 19 ; Lines 597 620 +23 ; ========================================; + Hits 339 372 +33 ; + Misses 258 248 -10; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `80% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `37.64% <77.77%> (+37.64%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.72% <0%> (+0.63%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=footer). Last update [47b4613...b880a9b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633129:1896,Power,Powered,1896,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633129,1,['Power'],['Powered']
Energy Efficiency,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2859,energy,energy,2859,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,2,['energy'],['energy']
Energy Efficiency,"o the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people sugge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2116,adapt,adapt,2116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,1,['adapt'],['adapt']
Energy Efficiency,"o/gh/CliMA/Oceananigans.jl/commit/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251?el=desc) will **increase** coverage by `0.36%`.; > The diff coverage is `90.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1082 +/- ##; ==========================================; + Coverage 56.79% 57.16% +0.36% ; ==========================================; Files 161 161 ; Lines 3796 3838 +42 ; ==========================================; + Hits 2156 2194 +38 ; - Misses 1640 1644 +4 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `83.01% <80.00%> (-1.30%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `88.15% <86.36%> (+0.22%)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `87.77% <95.65%> (+2.48%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=footer). Last update [e1026b0...d018eae](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1082#issuecomment-712562035:1927,Power,Powered,1927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082#issuecomment-712562035,1,['Power'],['Powered']
Energy Efficiency,"o/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=h1) Report; > Merging [#205](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/7f03edacd8acbded7bb1377c80b6995fc6c925b1?src=pr&el=desc) will **decrease** coverage by `0.09%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #205 +/- ##; =========================================; - Coverage 66.51% 66.42% -0.1% ; =========================================; Files 18 18 ; Lines 675 676 +1 ; =========================================; Hits 449 449 ; - Misses 226 227 +1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `55.17% <0%> (-1.98%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=footer). Last update [7f03eda...899ef72](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/205#issuecomment-485808891:1731,Power,Powered,1731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/205#issuecomment-485808891,2,['Power'],['Powered']
Energy Efficiency,"oc.org/view/journals/atsc/64/12/2007jas2226.1.xml>.; >; > This is figure 3 from the paper:; >; > [image: i1520-0469-64-12-4270-f03]; > <https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif>; >; > and this is the analytic formula I'm using to mimic it:; >; > [image: image]; > <https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png>; >; > We integrate τ to obtain a streamfunction for the wind stress which we; > then use to diagnose the surface; > momentum fluxes on the cubed sphere. *I think I got the magnitude wrong; > so I fixed it with a scaling factor...*; >; > I tried adding a lot of noise to the initial velocities but the wind; > stress smoothed it away.; > cubed_sphere_eddying_aquaplanet.mp4; >; > @christophernhill <https://github.com/christophernhill> suggested adding; > some random noise to the wind stress as well. And we probably also need a; > mechanism to remove energy otherwise the wind stress keeps accelerating the; > fluid until the model blows up. Maybe we need some bottom drag even though; > we only have one vertical level?; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1602; > Commit Summary; >; > - Regularize cubed sphere boundary conditions; > - First draft of eddying aquaplanet; > - Run with diffusion for 7 days and copy paste plotting script; >; > File Changes; >; > - *M* src/CubedSpheres/CubedSpheres.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1602/files#diff-20a2fde3ffb57dacaf2440040602aa34df63d347b81a5f18153845e523173d85>; > (16); > - *A*; > validation/cubed_sphere_eddying_aquaplanet/animate_on_map_projection.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1602/files#diff-3e851a92e09dfbd624c25fc1b1788c34f3dcd632f708d910b8c4825d3d77fc37>; > (98); > - *A*; > validation/cubed_sphere_eddying_aquaplanet/cubed_sphere_eddying_aquaplanet.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767:1439,energy,energy,1439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767,1,['energy'],['energy']
Energy Efficiency,"ode; > will still be called Oceananigans :-D; >; > I'm not sure I understand point 4 completely. The ocean model also has the; > concept of a model ""state""; for example, ghost cell values and nonlinear; > diffusivities depend on the velocity and tracer fields, in general. We; > currently handle this only during time-stepping --- there is no guarantee,; > for example, that the diffusivities or ghost cell values are consistent; > with the velocity field if the velocity field is set by the function set!; > (in fact, the diffusivities are *always* inconsistent with the current; > velocity field due to the fact that they are calculated *prior* to taking; > a time-step). If we want to guarantee such a consistency, we can develop; > the concept of a model ""state"" and apply it to both ocean and atmospheric; > models (eg a function update_state!(model), or something similar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:1200,reduce,reduce,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['reduce'],['reduce']
Energy Efficiency,"odecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=h1) Report; > Merging [#249](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/b746a0bce63642a8beb9e6771b4b43cd17368ba6?src=pr&el=desc) will **decrease** coverage by `0.73%`.; > The diff coverage is `28.57%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #249 +/- ##; ==========================================; - Coverage 74.71% 73.97% -0.74% ; ==========================================; Files 23 24 +1 ; Lines 866 876 +10 ; ==========================================; + Hits 647 648 +1 ; - Misses 219 228 +9; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (+16.66%)` | :arrow_up: |; | [src/architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249/diff?src=pr&el=tree#diff-c3JjL2FyY2hpdGVjdHVyZXMuamw=) | `28.57% <28.57%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=footer). Last update [b746a0b...b40c347](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496661941:1723,Power,Powered,1723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496661941,1,['Power'],['Powered']
Energy Efficiency,"odecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=h1) Report; > Merging [#381](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/289b1e3f8bb0012bfee30f1d8eb12f75179c2c4b?src=pr&el=desc) will **increase** coverage by `0.42%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #381 +/- ##; ==========================================; + Coverage 71.65% 72.07% +0.42% ; ==========================================; Files 26 26 ; Lines 1418 1418 ; ==========================================; + Hits 1016 1022 +6 ; + Misses 402 396 -6; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `79.66% <0%> (+3.38%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `83.51% <0%> (+4.39%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=footer). Last update [289b1e3...55ae7b1](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/381#issuecomment-525894779:1706,Power,Powered,1706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/381#issuecomment-525894779,1,['Power'],['Powered']
Energy Efficiency,"odel::NonhydrostaticModel{…}, callbacks::Vector{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:31; > [11] #apply_regionally!#56; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:121 [inlined]; > [12] apply_regionally!; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:118 [inlined]; > [13] macro expansion; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:206 [inlined]; > [14] update_state!(model::NonhydrostaticModel{…}, callbacks::Vector{…}; compute_tendencies::Bool); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:47; > [15] update_state!; > @ ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19 [inlined]; > [16] update_state!(model::NonhydrostaticModel{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19; > [17] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{…}, closure::Nothing, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::@NamedTuple{}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:198; > [18] top-level scope; > @ REPL[5]:1; > Some type information was truncated. Use `show(err)` to see complete types.; > ```. Ok I fixed that. Probably we should use a `Field` rather than `ones` for the test and examples, because it automatically adapts to GPU, distributed, etc, so its a bit better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708:5212,adapt,adapts,5212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708,1,['adapt'],['adapts']
Energy Efficiency,"ogy=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; #",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1260,schedul,schedule,1260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"ok, then we shift the bathymetry as a pressure term in the momentum and initialize ; `h = bathymetry` in the global simulation. for the NaNs, it might be a problem of implementation, changing `h` to total depth might fix it... ; I'll change it now. @francispoulin you can try; ```; simulation.output_writers[:surface_fields] = JLD2OutputWriter(model, merge(model.solution, (; ζ)),; schedule = TimeInterval(save_interval),; filename = output_prefix * ""_surface"",; overwrite_existing = true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129071864:382,schedul,schedule,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129071864,1,['schedul'],['schedule']
Energy Efficiency,"ology=(Periodic, Periodic, Flat));; c = CenterField(grid);; summed_c = Field(Reduction(sum!, c, dims=1)); @time compute!(summed_c); @time compute!(summed_c); ```. which produces. ```julia; julia> @time compute!(summed_c); 0.103867 seconds (153.65 k allocations: 10.584 MiB, 13.85% gc time, 99.78% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(summed_c); 0.000114 seconds (60 allocations: 3.000 KiB); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:1084,reduce,reduced,1084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643,1,['reduce'],['reduced']
Energy Efficiency,"ommit/27493f3682e4996af2e2abf4be240abe6384a3fd?src=pr&el=desc) will **increase** coverage by `0.37%`.; > The diff coverage is `76.19%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #438 +/- ##; ==========================================; + Coverage 73.46% 73.83% +0.37% ; ==========================================; Files 27 27 ; Lines 1515 1525 +10 ; ==========================================; + Hits 1113 1126 +13 ; + Misses 402 399 -3; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/coriolis.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/diff?src=pr&el=tree#diff-c3JjL2NvcmlvbGlzLmps) | `76.19% <76.19%> (+16.19%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `68.53% <0%> (+4.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=footer). Last update [27493f3...88427a6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537980716:1964,Power,Powered,1964,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537980716,1,['Power'],['Powered']
Energy Efficiency,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:2303,reduce,reduces,2303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,1,['reduce'],['reduces']
Energy Efficiency,"on to dispatch on the `advection` ""scheme"" / form if we need to. After looking into the details (see below), it would appear that the implementation we are using is correct if. 1. The horizontal grid is regular; 2. The horizontal grid is curvilinear and we are using `momentum_advection=VectorInvariant()`. Because these are the only two possible cases, I believe the current Coriolis implementation is sufficient. However when/if we support curvilinear horizontal grids with flux form advection terms, we will (if we follow the MITgcm implementation) need to dispatch the evaluation of the Coriolis term on `momentum_advection` scheme. Another question is whether it even makes sense / is physically consistent to support `FPlane` and `BetaPlane` on grids that are sectors of the sphere. Perhaps there's no point at all in implementing a curvilinear-friendly version of `FPlane` and `BetaPlane`. If this is true, we can revert back to the prior implementation of both for Rectilinear grids, and focus on a energy/enstrophy - conserving Coriolis scheme for curvilinear grids on the surface of the sphere. # Some notes on Coriolis implementations for vector-invariant and flux form momentum schemes . Focusing on the x-component, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8) writes that with a vector-invariant advection scheme, the Coriolis term that preserve potential enstrophy is. <img width=""228"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/108606976-94430280-738b-11eb-8e29-a30f25c33ab6.png"">. Note that all `h_* = 1` for the purposes of our discussion, and that in Oceananigans notation we have `Δx_g = Δxᶜᶠᶜ` (the grid length at the location of the y-velocity) and `Δx_c = Δxᶠᶜᶜ`. For a flux-form advection scheme, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#coriolis-terms) states that for a hydrostatic implementation we would have. <img width=""253"" alt=""image"" src=""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799:1514,energy,energy,1514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799,1,['energy'],['energy']
Energy Efficiency,"onvergenceTests/ForcedFlowFreeSlip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRm9yY2VkRmxvd0ZyZWVTbGlwLmps) | | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | | |; | [...vergence\_tests/analyze\_single\_forced\_fixed\_slip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL2FuYWx5emVfc2luZ2xlX2ZvcmNlZF9maXhlZF9zbGlwLmps) | | |; | [test/test\_regression.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3JlZ3Jlc3Npb24uamw=) | | |; | [examples/ocean\_convection\_with\_plankton.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | | |; | [...tion/convergence\_tests/analyze\_forced\_free\_slip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL2FuYWx5emVfZm9yY2VkX2ZyZWVfc2xpcC5qbA==) | | |; | ... and [50 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793?src=pr&el=footer). Last update [d383b6a...76c651a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/793#issuecomment-657517751:3403,Power,Powered,3403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/793#issuecomment-657517751,1,['Power'],['Powered']
Energy Efficiency,"ore generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor so that. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L176. becomes. ```julia; filepath = joinpath(dir, filename) ; update_schedule!(schedule, filepath); ```. Make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:1372,schedul,schedules,1372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,6,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"ot a problem conceptually. But it might indeed lead to big velocities that they may require smaller dt to tame the CFL. That's not a problem of the code though... It's something the user should be aware. A similar issue comes up, e.g., if you set up a highly unstable stratification. In that case the code will blow up unless you choose your dt appropriately (see, e.g., #1190). Now, in an attempt to show that having `z` periodic is not an issue, I tried to simulate the rising bubble with periodic boundary conditions. I got this puzzling result. Did I do anything wrong?. ```Julia; using Oceananigans, Oceananigans.Grids, Plots. grid = RegularCartesianGrid(size = (1, 64, 64),; x = (0, 1), y = (-4, 4), z = (-4, 4),; topology = (Periodic, Periodic, Periodic)). model = IncompressibleModel(grid = grid,; architecture = CPU(),; advection = Oceananigans.Advection.WENO5(),; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = IsotropicDiffusivity(ν=1e-3, κ=1e-3)). @info ""Simulating a rising buoyant bubble with"" model. set!(model, b = (x, y, z) -> exp(-y^2 - z^2)). simulation = Simulation(model, Δt=0.01, stop_iteration=1000). using Oceananigans.OutputWriters. simulation.output_writers[:fields] = JLD2OutputWriter(model, (model.tracers.b,),; schedule = TimeInterval(0.1),; prefix = ""bubble"",; force = true). run!(simulation). using JLD2. file = jldopen(simulation.output_writers[:fields].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). b = model.tracers.b. y, z = ynodes(b), znodes(b). # Analyze the data. anim = @animate for (i, iteration) in enumerate(iterations); b_snapshot = file[""timeseries/1/$iteration""][1, :, :]. plt = contourf(y, z, b_snapshot',; xlabel = ""y"", ylabel = ""z"", title = ""Buoyancy"",; xlim = (grid.yF[1], grid.yF[end]), ylim = (grid.zF[1], grid.zF[end]),; aspectratio = :equal, linewidth = 0); end. gif(anim, ""bubble.gif"", fps = 8) # hide; ```. ![bubble](https://user-images.githubusercontent.com/7112768/100959619-cd30bf80-3572-11eb-84a7-89f304ef7ccc.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737639915:1307,schedul,schedule,1307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737639915,1,['schedul'],['schedule']
Energy Efficiency,"oundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `21.87% <100.00%> (ø)` | |; | [src/BoundaryConditions/fill\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `86.20% <100.00%> (+0.49%)` | :arrow_up: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `91.22% <100.00%> (+0.15%)` | :arrow_up: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `77.08% <100.00%> (+3.61%)` | :arrow_up: |; | [...ions/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3ZlcnN0YXBwZW5fYW5pc290cm9waWNfbWluaW11bV9kaXNzaXBhdGlvbi5qbA==) | `88.05% <100.00%> (+0.18%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820?src=pr&el=footer). Last update [847d446...9220221](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/820#issuecomment-663134610:3197,Power,Powered,3197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/820#issuecomment-663134610,1,['Power'],['Powered']
Energy Efficiency,"ov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X2RpZmZ1c2l2aXR5X2Nsb3N1cmVzLmps) | `65.62% <100%> (+2.29%)` | :arrow_up: |; | [src/closures/turbulence\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `76.66% <22.22%> (-18.79%)` | :arrow_down: |; | [src/closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2Nsb3N1cmVfb3BlcmF0b3JzLmps) | `51.63% <40.54%> (-6.81%)` | :arrow_down: |; | [src/closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X3NtYWdvcmluc2t5Lmps) | `52.77% <51.61%> (+34.59%)` | :arrow_up: |; | [src/closures/anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `96.96% <96.96%> (ø)` | |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `39.16% <0%> (-60.01%)` | :arrow_down: |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309?src=pr&el=footer). Last update [8fdff75...11e3043](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508958002:3396,Power,Powered,3396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508958002,2,['Power'],['Powered']
Energy Efficiency,"ov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `91.66% <ø> (ø)` | |; | [...c/Solvers/horizontally\_periodic\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaG9yaXpvbnRhbGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `98.11% <ø> (+56.6%)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `73.68% <ø> (ø)` | :arrow_up: |; | [src/Solvers/channel\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvY2hhbm5lbF9wcmVzc3VyZV9zb2x2ZXIuamw=) | `98.63% <ø> (+68.49%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.61% <ø> (ø)` | :arrow_up: |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <ø> (ø)` | :arrow_up: |; | ... and [137 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=footer). Last update [77a22ef...4b78751](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/589#issuecomment-573490335:3574,Power,Powered,3574,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589#issuecomment-573490335,1,['Power'],['Powered']
Energy Efficiency,"overage by `0.29%`.; > The diff coverage is `55%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #444 +/- ##; =========================================; - Coverage 71.85% 71.55% -0.3% ; =========================================; Files 25 26 +1 ; Lines 1400 1417 +17 ; =========================================; + Hits 1006 1014 +8 ; - Misses 394 403 +9; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `81.57% <ø> (-0.48%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `47.67% <45.45%> (-1.68%)` | :arrow_down: |; | [src/forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL2ZvcmNpbmcuamw=) | `66.66% <66.66%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=footer). Last update [4b7e5bc...5a6c772](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-539584456:2046,Power,Powered,2046,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-539584456,1,['Power'],['Powered']
Energy Efficiency,"ow to go about fully incorporating a vertically; > stretched grid, true finite volume operators, and the new FFT+tridiagonal; > Poisson solvers needed to solve for the pressure on a stretched grid.; >; > Seems like a good idea to split it up into steps with one pull request per; > step:; >; > 1. Reverse the k index. Currently PR #462; > <https://github.com/climate-machine/Oceananigans.jl/pull/462>.; > 2. Revise the RegularCartesianGrid struct so we're happy with it.; > Currently PR #464; > <https://github.com/climate-machine/Oceananigans.jl/pull/464>.; > 3. Add finite volume operators as a separate piece of code.; > Technically they won't be tested in this PR and could have mistakes.; > Currently PR #283; > <https://github.com/climate-machine/Oceananigans.jl/pull/283>; > 4. Nuke the old operators and start using the same set of finite; > volume operators for both Oceananigans.Operators and; > closure_operators.jl. This will test that the finite volume operators; > reduce down to the operators that currently work, but doesn't test them on; > a stretched grid.; > 5. Implement a VerticallyStretchedCartesianGrid. Might have to iterate; > bit to figure out what we need, e.g. I think we'll want ΔzC to include the; > distance between the first cell center and the halo cell center, etc.; > 6. Implement CPU and GPU pressure solvers for vertically stretched; > grids with tests. There will be two: one for horizontally periodic domains; > and another for channel models. I've figured most of this stuff out in; > Jupyter notebooks.; > 7. Ensure that models with vertically stretched grids pass basic; > tests: e.g. incompressibility, tracer conservation, etc. This will test the; > finite volume operators.; > 8. Run a model with a VerticallyStretchedCartesianGrid but with; > uniform grid spacing and make sure it produces the same numbers as a model; > with RegularCartesianGrid. This is a sanity check.; > 9. Run additional tests for vertically stretched grids: e.g. vertical; > diffusi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363187:1622,reduce,reduce,1622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363187,1,['reduce'],['reduce']
Energy Efficiency,"ow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `86.07% <100%> (+6.28%)` | :arrow_up: |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `94.59% <100%> (+1.49%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `34.78% <25%> (+1.44%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `36.84% <48.57%> (-6.71%)` | :arrow_down: |; | ... and [6 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147?src=pr&el=footer). Last update [bbc8643...387aeda](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-475444615:3277,Power,Powered,3277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-475444615,1,['Power'],['Powered']
Energy Efficiency,"pInfo]]; > git-tree-sha1 = ""2e5c102cfc41f48ae4740c7eca7743cc7e7b75ea""; > uuid = ""8b046642-f1f6-4319-8d3c-209ddc03c586""; > version = ""1.0.0""; 412c431; < git-tree-sha1 = ""f2355693d6778a178ade15952b7ac47a4ff97996""; ---; > git-tree-sha1 = ""50901ebc375ed41dbf8058da26f9de442febbbec""; 414c433; < version = ""1.3.0""; ---; > version = ""1.3.1""; 499c518; < git-tree-sha1 = ""781916a2ebf2841467cda03b6f1af43e23839d85""; ---; > git-tree-sha1 = ""8f6af051b9e8ec597fa09d8885ed79fd582f33c9""; 501c520; < version = ""0.1.9""; ---; > version = ""0.1.10""; 526c545; < git-tree-sha1 = ""a7023883872e52bc29bcaac74f19adf39347d2d5""; ---; > git-tree-sha1 = ""b01beb91d20b0d1312a9471a36017b5b339d26de""; 528c547; < version = ""10.1.4+0""; ---; > version = ""10.1.4+1""; 570a590,601; > [[deps.Oceananigans]]; > deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""Distances"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays""]; > path = ""/Users/gregorywagner/Projects/Oceananigans.jl""; > uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; > version = ""0.90.1""; >; > [deps.Oceananigans.extensions]; > OceananigansEnzymeCoreExt = ""EnzymeCore""; >; > [deps.Oceananigans.weakdeps]; > EnzymeCore = ""f151be2c-9106-41f4-ab19-57ee4f262869""; >; 588,589c619,620; < deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""TOML""]; < git-tree-sha1 = ""e25c1778a98e34219a00455d6e4384e017ea9762""; ---; > deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""Hwloc_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""PMIx_jll"", ""TOML"", ""Zlib_jll"", ""libevent_jll"", ""prrte_jll""]; > git-tree-sha1 = ""694458ae803b684f09c07f90459cb79655fb377d""; 591c622; < version = ""4.1.6+0""; ---; > versi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:7871,Adapt,Adapt,7871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,1,['Adapt'],['Adapt']
Energy Efficiency,"paced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=0.5. julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN. julia> using Statistics: norm. julia> norm(f1); 2.29128784747792. julia> norm(f2); 0.0; ```. Maybe we have not set correctly the index of the residuals?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998:1647,reduce,reduced,1647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998,1,['reduce'],['reduced']
Energy Efficiency,"pbWVfc3RlcHBpbmcuamw=) | `92.59% <0.00%> (-2.65%)` | :arrow_down: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `87.50% <0.00%> (-1.39%)` | :arrow_down: |; | [src/Utils/with\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3dpdGhfdHJhY2Vycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [...bulence\_closure\_implementations/nothing\_closure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL25vdGhpbmdfY2xvc3VyZS5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/TimeSteppers/quasi\_adams\_bashforth\_2.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9xdWFzaV9hZGFtc19iYXNoZm9ydGhfMi5qbA==) | `84.84% <0.00%> (ø)` | |; | [src/TimeSteppers/runge\_kutta\_3.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9ydW5nZV9rdXR0YV8zLmps) | `85.07% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `94.44% <0.00%> (+0.82%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948?src=pr&el=footer). Last update [10949b0...369c7ba](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/948#issuecomment-694124632:3524,Power,Powered,3524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/948#issuecomment-694124632,1,['Power'],['Powered']
Energy Efficiency,"pen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3ZlcnN0YXBwZW5fYW5pc290cm9waWNfbWluaW11bV9kaXNzaXBhdGlvbi5qbA==) | `86.81% <0.00%> (-1.07%)` | :arrow_down: |; | [src/BoundaryConditions/fill\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `85.00% <0.00%> (-0.72%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `90.54% <0.00%> (-0.54%)` | :arrow_down: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `75.00% <0.00%> (+1.53%)` | :arrow_up: |; | [src/BoundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `23.63% <0.00%> (+1.76%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817?src=pr&el=footer). Last update [847d446...d0e01fa](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/817#issuecomment-663198061:3085,Power,Powered,3085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/817#issuecomment-663198061,1,['Power'],['Powered']
Energy Efficiency,"pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `92.00% <100.00%> (+8.00%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL0xvZ2dlci5qbA==) | `79.16% <0.00%> (-9.73%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0.00%> (-6.67%)` | :arrow_down: |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0.00%> (-5.89%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32.00% <0.00%> (-2.10%)` | :arrow_down: |; | ... and [46 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699?src=pr&el=footer). Last update [bff7abc...b83618c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599283973:3756,Power,Powered,3756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599283973,1,['Power'],['Powered']
Energy Efficiency,"ps://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | `83.33% <0.00%> (ø)` | |; | [...odels/IncompressibleModels/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `77.77% <0.00%> (ø)` | |; | [...ncompressibleModels/update\_hydrostatic\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | `50.00% <0.00%> (ø)` | |; | [...odels/IncompressibleModels/IncompressibleModels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9jbG9jay5qbA==) | `53.84% <0.00%> (ø)` | |; | [src/Models/IncompressibleModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfc3RhdGUuamw=) | `100.00% <0.00%> (ø)` | |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184?src=pr&el=footer). Last update [03a6f85...f307336](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1184#issuecomment-727480160:3699,Power,Powered,3699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1184#issuecomment-727480160,1,['Power'],['Powered']
Energy Efficiency,"ps://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `71.42% <0%> (-11.91%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `81.17% <100%> (ø)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `95% <100%> (+0.4%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.47% <100%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `26.08% <45.45%> (+13.58%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `41.53% <45.61%> (+6.75%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `81.11% <57.14%> (-2.61%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `57.57% <90.9%> (+11.62%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250?src=pr&el=footer). Last update [b746a0b...e4ae7bd](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-496941099:2793,Power,Powered,2793,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-496941099,1,['Power'],['Powered']
Energy Efficiency,"ps://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.3% <ø> (ø)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.14% <100%> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `56.25% <100%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.65% <100%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <100%> (ø)` | :arrow_up: |; | ... and [9 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406?src=pr&el=footer). Last update [5cd0e33...e5556a7](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/406#issuecomment-531502548:3524,Power,Powered,3524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406#issuecomment-531502548,1,['Power'],['Powered']
Energy Efficiency,"pull/815/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0cy5qbA==) | `77.77% <ø> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `73.46% <57.14%> (ø)` | |; | [src/Advection/Advection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9BZHZlY3Rpb24uamw=) | `100.00% <100.00%> (ø)` | |; | [src/Advection/centered\_second\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9zZWNvbmRfb3JkZXIuamw=) | `100.00% <100.00%> (ø)` | |; | [src/Advection/momentum\_advection\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9tb21lbnR1bV9hZHZlY3Rpb25fb3BlcmF0b3JzLmps) | `100.00% <100.00%> (ø)` | |; | [src/Advection/tracer\_advection\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <100.00%> (ø)` | |; | ... and [7 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815?src=pr&el=footer). Last update [1dbe86c...d42428d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/815#issuecomment-662674506:3329,Power,Powered,3329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/815#issuecomment-662674506,1,['Power'],['Powered']
Energy Efficiency,"pull/945/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `75.00% <ø> (ø)` | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | `94.73% <ø> (ø)` | |; | [...ce\_tests/ConvergenceTests/PointExponentialDecay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvUG9pbnRFeHBvbmVudGlhbERlY2F5Lmps) | `0.00% <ø> (ø)` | |; | [...ation/convergence\_tests/point\_exponential\_decay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL3BvaW50X2V4cG9uZW50aWFsX2RlY2F5Lmps) | `0.00% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `91.83% <66.66%> (-1.79%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `83.33% <81.81%> (+13.33%)` | :arrow_up: |; | ... and [11 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945?src=pr&el=footer). Last update [10949b0...0b7899a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692734129:3416,Power,Powered,3416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692734129,1,['Power'],['Powered']
Energy Efficiency,"r * v; @inline immersed_drag_u(x, z, t, u, p) = - p.r * u; @inline immersed_drag_v(x, z, t, v, p) = - p.r * v. wind_stress_bc_u = FluxBoundaryCondition(wind_stress_u, parameters=(; τx₀, Twind)); wind_stress_bc_v = FluxBoundaryCondition(wind_stress_v, parameters=(; τy₀, Twind)). drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u), parameters=(; r)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:v), parameters=(; r)); immersed_drag_bc_u = FluxBoundaryCondition(immersed_drag_u, field_dependencies=(:u), parameters=(; r)); immersed_drag_bc_v = FluxBoundaryCondition(immersed_drag_v, field_dependencies=(:v), parameters=(; r)). u_bcs = FieldBoundaryConditions(top=wind_stress_bc_u, bottom=drag_bc_u, immersed=immersed_drag_bc_u); v_bcs=FieldBoundaryConditions(top=wind_stress_bc_v, bottom=drag_bc_v, immersed=immersed_drag_bc_v); bcs = (; u=u_bcs, v=v_bcs). turbulence_closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(), ν=Av). model = HydrostaticFreeSurfaceModel(grid=grid, boundary_conditions=bcs,; momentum_advection=nothing, # Linear to compare with analytical solution.; closure=turbulence_closure,; buoyancy=nothing,; coriolis=FPlane(f=f)). g = 0.01; cgw = dx/sqrt(g*hmin); Δt₀ = cgw*maxcfl/5; simulation = Simulation(model; Δt=Δt₀, stop_time=te). start_time = time_ns(); function log_message(sim); prog = 100*time(sim)/sim.stop_time; @printf(""[%05.2f%%] t: %1.1f Ti, Δt: %s, max|u, v, w|: %1.2f, %1.2f, %1.1e m s⁻¹, walltime: %s\n"",; prog, time(sim)/Ti, prettytime(sim.Δt),; maximum(abs, sim.model.velocities.u), maximum(abs, sim.model.velocities.v), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); end. simulation.callbacks[:progress] = Callback(log_message, TimeInterval(logdt)); outputs = (; u=model.velocities.u, v=model.velocities.v); simulation.output_writers[:fields2D] = NetCDFOutputWriter(model, outputs,; schedule=TimeInterval(outdt),; filename=fout,; overwrite_existing=true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2132214906:4079,schedul,schedule,4079,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2132214906,1,['schedul'],['schedule']
Energy Efficiency,"r&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/3f3ef52eaa68d8e28901d7acbed5d99960798307?src=pr&el=desc) will **increase** coverage by `0.15%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #496 +/- ##; ==========================================; + Coverage 73.31% 73.46% +0.15% ; ==========================================; Files 27 27 ; Lines 1525 1515 -10 ; ==========================================; - Hits 1118 1113 -5 ; + Misses 407 402 -5; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `79.31% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `88.23% <ø> (+8.68%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=footer). Last update [3f3ef52...2373483](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/496#issuecomment-545579286:1884,Power,Powered,1884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/496#issuecomment-545579286,1,['Power'],['Powered']
Energy Efficiency,"r&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `39.28% <0%> (-35.3%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `77.24% <0%> (-1.68%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `60.29% <100%> (+0.61%)` | :arrow_up: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `52.77% <66.66%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.65% <0%> (-58.55%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `16.21% <0%> (-16.22%)` | :arrow_down: |; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `9.67% <0%> (-3.23%)` | :arrow_down: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315?src=pr&el=footer). Last update [16c363e...4738b6b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515218612:3293,Power,Powered,3293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515218612,1,['Power'],['Powered']
Energy Efficiency,"r.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `84% <0%> (-1.72%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `65% <0%> (-1.67%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.89% <0%> (+0.22%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `90% <0%> (+4.28%)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80% <0%> (+30%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=footer). Last update [2ae1cbb...9ceb221](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/652#issuecomment-592508860:3208,Power,Powered,3208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/652#issuecomment-592508860,1,['Power'],['Powered']
Energy Efficiency,"r/package_linux64/build/usr/share/julia/stdlib/v1.6/Statistics/src/Statistics.jl:131; [14] compute!; @ ~/Oceananigans.jl/src/Fields/averaged_field.jl:62 [inlined]; [15] compute!(avg::AveragedField{Nothing, Nothing, Center, Oceananigans.Fields.FieldStatus{Float64}, GPU, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, 2, Field{Center, Center, Center, GPU, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/averaged_field.jl:61; [16] top-level scope; @ REPL[35]:1; [17] top-level scope; @ ~/.julia/dev/CUDA/src/initialization.jl:50; ```. using. ```diff; diff --git a/src/mapreduce.jl b/src/mapreduce.jl; index f9489dcf..11c0aee0 100644; --- a/src/mapreduce.jl; +++ b/src/mapreduce.jl; @@ -209,6 +209,10 @@ function GPUArrays.mapreducedim!(f::F, op::OP, R::AnyCuArray{T},; shmem = reduce_shmem; blocks = reduce_blocks*other_blocks; ; + @show threads; + @show blocks; + @show reduce_blocks; +; # perform the actual reduction; if reduce_blocks == 1; # we can cover the dimensions to reduce using a single block; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845602157:10476,reduce,reduce,10476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845602157,1,['reduce'],['reduce']
Energy Efficiency,"rations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `64.51% <0.00%> (-6.92%)` | :arrow_down: |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <ø> (ø)` | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `90.33% <ø> (-0.75%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `92.30% <100.00%> (+0.20%)` | :arrow_up: |; | [src/Fields/pressure\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9wcmVzc3VyZV9maWVsZC5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/OutputWriters/windowed\_time\_average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvd2luZG93ZWRfdGltZV9hdmVyYWdlLmps) | `97.05% <100.00%> (+3.51%)` | :arrow_up: |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.38% <100.00%> (+0.04%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964?src=pr&el=footer). Last update [d6ce0fe...98b825f](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/964#issuecomment-695015162:2749,Power,Powered,2749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/964#issuecomment-695015162,1,['Power'],['Powered']
Energy Efficiency,"rc=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-15.79%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `70.00% <0.00%> (-11.82%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `78.37% <0.00%> (-10.82%)` | :arrow_down: |; | [src/AbstractOperations/function\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9mdW5jdGlvbl9maWVsZHMuamw=) | `25.00% <0.00%> (-8.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `85.13% <0.00%> (-8.29%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `60.86% <0.00%> (-8.10%)` | :arrow_down: |; | ... and [90 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829?src=pr&el=footer). Last update [681fa0b...3a08525](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/829#issuecomment-668439380:3484,Power,Powered,3484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/829#issuecomment-668439380,1,['Power'],['Powered']
Energy Efficiency,"rc=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-15.79%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `70.00% <0.00%> (-11.82%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `78.37% <0.00%> (-10.82%)` | :arrow_down: |; | [src/AbstractOperations/function\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9mdW5jdGlvbl9maWVsZHMuamw=) | `25.00% <0.00%> (-8.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `85.13% <0.00%> (-8.29%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `60.86% <0.00%> (-8.10%)` | :arrow_down: |; | ... and [89 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832?src=pr&el=footer). Last update [8fe4d65...89b7350](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/832#issuecomment-668891485:3484,Power,Powered,3484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/832#issuecomment-668891485,1,['Power'],['Powered']
Energy Efficiency,"rc=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `21.87% <0.00%> (+0.66%)` | :arrow_up: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Buoyancy/linear\_equation\_of\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L2xpbmVhcl9lcXVhdGlvbl9vZl9zdGF0ZS5qbA==) | `29.41% <0.00%> (+1.63%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `95.83% <0.00%> (+1.95%)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `79.72% <0.00%> (+2.09%)` | :arrow_up: |; | [src/Fields/reduced\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9yZWR1Y2VkX2ZpZWxkLmps) | `87.87% <0.00%> (+2.58%)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.80% <0.00%> (+2.91%)` | :arrow_up: |; | [src/OutputWriters/windowed\_time\_average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvd2luZG93ZWRfdGltZV9hdmVyYWdlLmps) | `100.00% <0.00%> (+2.94%)` | :arrow_up: |; | ... and [30 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/995?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/995#issuecomment-700325228:2520,reduce,reduced,2520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/995#issuecomment-700325228,1,['reduce'],['reduced']
Energy Efficiency,"rcing(Fc1, field_dependencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2=c2_forcing)). Nx, Ny, Nz = size(grid); xs, ys, zs = nodes(model.tracers.c1). c̄1(z, t) = 1 / (Nx * Ny) * sum(exp(-λ1(x, y, z) * t) for x in xs for y in ys); c̄2(z, t) = 1 / (Nx * Ny) * sum(exp(-λ2(x, y, z) * t) for x in xs for y in ys). rtol = 1e-5 # need custom rtol for isapprox because roundoff errors accumulate (?). # Compute time averages...; c̄1(ts) = 1/length(ts) * sum(c̄1.(zs, t) for t in ts); c̄2(ts) = 1/length(ts) * sum(c̄2.(zs, t) for t in ts). #####; ##### Test strided windowed time average against analytic solution; ##### for *single* NetCDF output; #####; single_time_average_nc_filepath = ""single_decay_windowed_time_average_test.nc""; single_ds = NCDataset(single_time_average_nc_filepath). attribute_names = (""schedule"", ""interval"", ""output time interval"",; ""time_averaging_window"", ""time averaging window"",; ""time_averaging_stride"", ""time averaging stride""). for name in attribute_names; @test haskey(single_ds.attrib, name) && !isnothing(single_ds.attrib[name]); end. window_size = window_nΔt; window = window_size*Δt. time = single_ds[""time""][:]; data_plot = single_ds[""c1""][1:4, :]; c̄1_timeaverage = zeros(4,length(time[1:end])); for (n, t) in enumerate(time[1:end]); averaging_times = [t - n*Δt for n in 0:stride:window_size-1 if t - n*Δt >= 0]; # @info n,t,averaging_times, c̄1(averaging_times); c̄1_timeaverage[:,n] = c̄1(averaging_times); # @test all(isapprox.(single_ds[""c1""][:, n+1], c̄1(averaging_times), rtol=rtol)); end. # Plot each of the four lines; pl = plot(); plot!(time, data_plot[1, :], label=""1"", color=:blue, legend=:topright); plot!(time, data_plot[2, :], label=""2"", color=:red); plot!(time, data_plot[3, :], label=""3"", color=:orange); plot!(time, data_plot[4, :], label=""4"", color=:green). plot!(time[1:end],c̄1_timeaverage[1,:], color=:black, lines",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:5543,schedul,schedule,5543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,1,['schedul'],['schedule']
Energy Efficiency,"ree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #107 +/- ##; ==========================================; + Coverage 52.71% 53.15% +0.44% ; ==========================================; Files 19 19 ; Lines 645 649 +4 ; ==========================================; + Hits 340 345 +5 ; + Misses 305 304 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `93.1% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `69.15% <100%> (+1.19%)` | :arrow_up: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `85.71% <88.88%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `81.81% <0%> (+9.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=footer). Last update [3cd4ae3...998ee38](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/107#issuecomment-469743151:2117,Power,Powered,2117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/107#issuecomment-469743151,1,['Power'],['Powered']
Energy Efficiency,"riodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(int_c); 0.000061 seconds (60 allocations: 4.938 KiB); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. But I get similar numbers for `Average`. I think the compilation path may depend on the machine you're using (which could make sense)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:2651,reduce,reduced,2651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643,1,['reduce'],['reduced']
Energy Efficiency,"row_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `42.85% <100%> (+6.01%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `85% <100%> (-1.37%)` | :arrow_down: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `95.23% <100%> (+0.64%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `52.94% <33.33%> (-28.24%)` | :arrow_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.9% <44.82%> (+6.12%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `82.24% <76.47%> (-1.78%)` | :arrow_down: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167?src=pr&el=footer). Last update [9260f02...dc2a79c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/167#issuecomment-483002596:3270,Power,Powered,3270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/167#issuecomment-483002596,1,['Power'],['Powered']
Energy Efficiency,"rray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:422 [inlined]; [4] getindex; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:541 [inlined]; [5] Δzᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:115 [inlined]; [6] Δzᶜᶠᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:141 [inlined]; [7] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/grid_metrics.jl:138 [inlined]; [8] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:101 [inlined]; [9] _getindex; @ ./abstractarray.jl:1341 [inlined]; [10] getindex; @ ./abstractarray.jl:1291 [inlined]; [11] macro expansion; @ ./reducedim.jl:317 [inlined]; [12] macro expansion; @ ./simdloop.jl:77 [inlined]; [13] _mapreducedim!(f::typeof(identity), op::typeof(Base.add_sum), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:316; [14] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:324; [15] sum!(f::Function, r::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ Base ./reducedim.jl:1034; [16] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}; condition::Nothing, mask::Int64, kwargs::@Kwargs{}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:696; [17] sum!(r::Field{…}, a::Oceananigans.AbstractOperations.GridMetricOperation{…}); @ Oceananigans.Fields ~/atdepth/Oceananigans.jl/src/Fields/field.jl:690; [18] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitAuxiliaryFields(grid::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, CPU}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/split_explicit_fr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266:2482,reduce,reducedim,2482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266,1,['reduce'],['reducedim']
Energy Efficiency,"rrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, typeof(Oceananigans.Operators.identity3), typeof(∂x), RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/Research/OC.jl/src/OutputWriters/netcdf_output_writer.jl:349; [4] top-level scope; @ REPL[113]:1; ```. I think it's coming from . https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/src/OutputWriters/netcdf_output_writer.jl#L349",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:25011,schedul,schedule,25011,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508,1,['schedul'],['schedule']
Energy Efficiency,"rsed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing normal"" --- one of the complications of the user API for this... The corresponding code for no-slip would be. ```julia; u_immersed_bc = ValueBoundaryCondition(0); v_immersed_bc = ValueBoundaryCondition(0); w_immersed_bc = ValueBoundaryCondition(0); ```. Should we work on adapting this PR in the direction of implementing such a user API? What do you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:2389,adapt,adapting,2389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624,1,['adapt'],['adapting']
Energy Efficiency,"rsion? If the version is 0.58.2, can you please post the full code?. I got the code below from a slack message and it ran with no problems:. ```julia; using Random; using Printf; using Oceananigans; using Oceananigans.Units: minute, minutes, hour; Lz=32; Nz=32; S = 1.1 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (32, 32, 32), ; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=8e-4)); Qʰ = 200 # W m⁻², surface _heat_ flux; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; cᴾ = 3991 # J K⁻¹ s⁻¹, typical heat capacity for seawater; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m⁻¹ s⁻¹, surface _temperature_ flux; dTdz = 0.01 # K m⁻¹; T_bcs = TracerBoundaryConditions(computational_grid,; top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); u₁₀ = 10 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²; u_bcs = UVelocityBoundaryConditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.gri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:1179,meter,meters,1179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['meter'],['meters']
Energy Efficiency,"runcation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 3.20, Expected = 3; Method = Center4ᵗʰ, Rate of Convergence = 3.98, Expected = 4; Method = CenteredFourthOrder(), Rate of Convergence = 2.45, Expected = 4; Method = Upwind5ᵗʰ, Rate of Convergence = 4.97, Expected = 5; Method = UpwindBiasedFifthOrder(), Rate of Conv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:1255,reduce,reduces,1255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595,1,['reduce'],['reduces']
Energy Efficiency,"ry\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.46% <ø> (ø)` | |; | [src/BoundaryConditions/boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9jb25kaXRpb24uamw=) | `72.72% <78.57%> (+16.47%)` | :arrow_up: |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <90.69%> (+6.95%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `90.00% <93.33%> (+6.00%)` | :arrow_up: |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <100.00%> (ø)` | |; | ... and [13 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=footer). Last update [fbbb5f8...1503288](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190:3611,Power,Powered,3611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190,1,['Power'],['Powered']
Energy Efficiency,"s). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m⁻¹; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Qᵘ=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(α=alpha, β=beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 12minutes,; iteration_interval = 1,; progress = progress_message; ); fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""TestSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:3100,schedul,schedule,3100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166,1,['schedul'],['schedule']
Energy Efficiency,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17032,schedul,schedule,17032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,1,['schedul'],['schedule']
Energy Efficiency,"s.jl/pull/234?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/closures/turbulence\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `100% <100%> (ø)` | |; | [src/closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X3NtYWdvcmluc2t5Lmps) | `100% <100%> (ø)` | |; | [src/closures/constant\_diffusivity\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X2RpZmZ1c2l2aXR5X2Nsb3N1cmVzLmps) | `100% <100%> (ø)` | |; | [src/closures/velocity\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3ZlbG9jaXR5X2dyYWRpZW50cy5qbA==) | `73.68% <73.68%> (ø)` | |; | [src/closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2Nsb3N1cmVfb3BlcmF0b3JzLmps) | `93.38% <93.38%> (ø)` | |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234?src=pr&el=footer). Last update [1bd2036...62af7d5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495651029:2708,Power,Powered,2708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495651029,1,['Power'],['Powered']
Energy Efficiency,"s://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #863 +/- ##; ==========================================; - Coverage 70.90% 70.81% -0.09% ; ==========================================; Files 187 187 ; Lines 5180 5171 -9 ; ==========================================; - Hits 3673 3662 -11 ; - Misses 1507 1509 +2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `95.23% <ø> (-0.12%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `92.78% <ø> (-0.18%)` | :arrow_down: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `80.51% <0.00%> (-1.30%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=footer). Last update [810a3a1...e05c400](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/863#issuecomment-682492954:2113,Power,Powered,2113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/863#issuecomment-682492954,1,['Power'],['Powered']
Energy Efficiency,"salinity could be put in as a passive tracer, perhaps, with zero flux at; the top and bottom. Should be conserved. On Wed, May 29, 2019 at 5:20 PM Ali Ramadhan <notifications@github.com>; wrote:. > Does linear stratification count as *non-trivially stratified*?; >; > But yeah, adding a bit of salinity in there would be good for the test,; > maybe not so much for the example.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/220?email_source=notifications&email_token=AKXUEQVL36NP3PVX5LIWX2LPX3XTTA5CNFSM4HM5MOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWQVUCQ#issuecomment-497113610>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQTN73LJYCI4JDUXTYLPX3XTTANCNFSM4HM5MOYA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/220#issuecomment-497114228:957,Green,Green,957,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/220#issuecomment-497114228,1,['Green'],['Green']
Energy Efficiency,"sb3N1cmVfb3BlcmF0b3JzLmps) | `95.34% <100%> (+0.3%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `83.13% <100%> (+2.02%)` | :arrow_up: |; | [src/closures/constant\_diffusivity\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X2RpZmZ1c2l2aXR5X2Nsb3N1cmVzLmps) | `63.33% <38.88%> (-36.67%)` | :arrow_down: |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `0% <0%> (-100%)` | :arrow_down: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `65.59% <0%> (-20.58%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `12.5% <0%> (-13.59%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `45.94% <0%> (-11.63%)` | :arrow_down: |; | ... and [5 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245?src=pr&el=footer). Last update [22b7121...1fdaf74](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496324424:3476,Power,Powered,3476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496324424,1,['Power'],['Powered']
Energy Efficiency,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747?src=pr&el=footer). Last update [9ef95e7...0e304f4](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/747#issuecomment-628274090:3430,Power,Powered,3430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/747#issuecomment-628274090,1,['Power'],['Powered']
Energy Efficiency,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752?src=pr&el=footer). Last update [92d77b0...8c02fb5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/752#issuecomment-629570073:3430,Power,Powered,3430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/752#issuecomment-629570073,1,['Power'],['Powered']
Energy Efficiency,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753?src=pr&el=footer). Last update [1e8704c...ad40bb1](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/753#issuecomment-629586678:3430,Power,Powered,3430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753#issuecomment-629586678,1,['Power'],['Powered']
Energy Efficiency,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754?src=pr&el=footer). Last update [57f633e...a320923](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/754#issuecomment-629587934:3475,Power,Powered,3475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/754#issuecomment-629587934,1,['Power'],['Powered']
Energy Efficiency,"should be ready to go, the last details to address (but it's an easy change I can make quickly) are; 1) the location of the free surface; 2) the location and type of the right-hand side; 3) the location and type of the internal fields for the PCG. From what I understood we agreed on; 1) located at `Face`s on `grid.Nz+1` (I am a bit worried that this will give a problem in the outputs when we want to save the surface files with `indices = (:, :, grid.Nz)`; 2) `ReducedField` (location `Nothing`); 2) `ReducedField`s (location `Nothing`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258192897:464,Reduce,ReducedField,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258192897,2,['Reduce'],['ReducedField']
Energy Efficiency,"simulation = Simulation(model, Δt=10.0, stop_iteration=1000); progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). u, v, w = model.velocities; e = (u^2 + w^2) / 2; E = Field(Integral(e, dims=:)); outputs = merge(model.velocities, model.tracers, (; e, E)). filename = ""test.jld2""; simulation.output_writers[:fields] = JLD2OutputWriter(model, outputs;; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); et = FieldTimeSeries(filename, ""e""); bt = FieldTimeSeries(filename, ""b""); Et = FieldTimeSeries(filename, ""E""); times = wt.times; Nt = length(times). fig = Figure(resolution=(1800, 900)). axw = Axis(fig[2, 1], xlabel=""x (m)"", ylabel=""z (m)"", title=""Vertical velocity""); axe = Axis(fig[2, 2], xlabel=""x (m)"", ylabel=""z (m)"", title=""Kinetic energy""); axb = Axis(fig[2, 3], xlabel=""x (m)"", ylabel=""z (m)"", title=""Buoyancy""); axE = Axis(fig[3, 1:3], xlabel=""Time (s)"", ylabel=""Volume averaged kinetic energy""). slider = Slider(fig[1, 1:2], range=1:Nt, startvalue=1); n = slider.value. wn = @lift interior(wt[$n], :, 1, :); en = @lift interior(et[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). x, y, z = nodes(et). wlim = maximum(abs, wt); elim = maximum(abs, et). heatmap!(axw, x, z, wn, colorrange=(-wlim, wlim), colormap=:balance); heatmap!(axe, x, z, en, colorrange=(0, elim), colormap=:solar); heatmap!(axb, x, z, bn, colorrange=(0, 1e-3), colormap=:thermal). t = @lift times[$n]; lines!(axE, times, Et[:]); vlines!(axE, t). display(fig). record(fig, ""test.mp4"", 1:Nt) do nn; @info ""Recording frame $nn of $Nt""; n[] = nn; end; ```. github won't let me attach the movie or image but basically at first energy decreases, then there is a lot of grid scale noise with wave dynamics. So nothing is resolved, and the energy oscillates around. Perhaps later it increases. This might need a background diffusivity?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442576976:2287,energy,energy,2287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442576976,2,['energy'],['energy']
Energy Efficiency,"so one way to do this is to say `adapt(Array, A)` which then requires no knowledge where A was an Array or a CuArray or a complicated model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/171#issuecomment-481430614:33,adapt,adapt,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/171#issuecomment-481430614,1,['adapt'],['adapt']
Energy Efficiency,"some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version is up and running.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1610,efficient,efficient,1610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,1,['efficient'],['efficient']
Energy Efficiency,"src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/22d76926a9a3687e58de4a36568d55c7e3ca73ba&el=desc) will **increase** coverage by `0.11%`.; > The diff coverage is `85.71%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #744 +/- ##; ==========================================; + Coverage 77.16% 77.28% +0.11% ; ==========================================; Files 125 125 ; Lines 2483 2487 +4 ; ==========================================; + Hits 1916 1922 +6 ; + Misses 567 565 -2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/Forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvRm9yY2luZy5qbA==) | `100.00% <ø> (+50.00%)` | :arrow_up: |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `75.00% <60.00%> (+8.33%)` | :arrow_up: |; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `100.00% <100.00%> (+16.66%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=footer). Last update [22d7692...f1dea29](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/744#issuecomment-622618325:1879,Power,Powered,1879,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/744#issuecomment-622618325,1,['Power'],['Powered']
Energy Efficiency,"ster](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/5c573ea1e8038c7cd7023e6675c9f3270ffa8f58?src=pr&el=desc) will **increase** coverage by `1.88%`.; > The diff coverage is `61.53%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #350 +/- ##; ==========================================; + Coverage 72.86% 74.74% +1.88% ; ==========================================; Files 22 22 ; Lines 1157 1176 +19 ; ==========================================; + Hits 843 879 +36 ; + Misses 314 297 -17; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `57.14% <0%> (-2.56%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `64.74% <84.21%> (+20.84%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=footer). Last update [5c573ea...cc18413](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164879:1903,Power,Powered,1903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164879,1,['Power'],['Powered']
Energy Efficiency,"suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. And yeah sorry for the lack of clarity, I meant pass as required for buoyancy b/T/S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:1960,reduce,reduce,1960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457,1,['reduce'],['reduce']
Energy Efficiency,"t always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behind the default, that expensive simulations are rare so it doesn't make sense to default it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364:1306,schedul,schedule,1306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364,1,['schedul'],['schedule']
Energy Efficiency,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1042,efficient,efficient,1042,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,1,['efficient'],['efficient']
Energy Efficiency,"t regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But would you expect users to infer all these just from the ≈ symbol?. Reading your post made me think. I now suggest the following restructure (I'll present here a skeleton). - first discuss linear instabilities... the fact that Oceananigans.jl won't give you the linear operator but will evolve the full nonlinear system and the ""hack"" to get _approximately linear dynamics_ (I'll use ≈ here ;)) by utilizing `BackgroundFields`+**small amplitude**; - next discuss how we do eigenanalysis of the linear operator (without having the `L` in hand in the first place): here describe the power method and how we use the `simulation` of the ""approximately linear dynamics"" for `Δτ`described above as a way to ""apply `L`... How do you like this? (I'll work on this refactoring tomorrow probably.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:2704,power,power,2704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['power'],['power']
Energy Efficiency,"t the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as you wouldn't have to change the Fields module. Also, the NonhydrostaticModel will become ""agnostic"" to the architecture in this way. Actually maybe this direction is much better (I will change the PR to reflect this option)... In the end, what do you think? How should we solve this `grid` vs `architecture` conundrum avoiding the definition of a `DistributedModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:3084,allocate,allocate,3084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,2,['allocate'],['allocate']
Energy Efficiency,"t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1375,schedul,schedule,1375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"ta3,; closure = ScalarDiffusivity(ν=1e-6, κ=1e-6),; tracers = :b,; buoyancy = BuoyancyTracer(),; background_fields = (; b=B)) # `background_fields` is a `NamedTuple`. A = 0.01; u_ic(x, y, z) = A * randn(); w_ic(x, y, z) = A * randn(). set!(model, u=u_ic, w=w_ic). simulation = Simulation(model, Δt=0.01, stop_iteration=200). wizard = TimeStepWizard(cfl=0.3, diffusive_cfl=0.3, max_change=1.2, max_Δt=1); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(1)). progress(sim) = @printf(""i: % 6d, sim time: % 1.3f, wall time: % 10s, Δt: % 1.4f, advective CFL: %.2e, diffusive CFL: %.2e\n"",; iteration(sim), time(sim), prettytime(sim.run_wall_time),; sim.Δt,; AdvectiveCFL(sim.Δt)(sim.model),; DiffusiveCFL(sim.Δt)(sim.model)). simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""background_field_test.jld2""; simulation.output_writers[:velocities] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),; filename = filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). wt = FieldTimeSeries(filename, ""w""); bt = FieldTimeSeries(filename, ""b""); t = wt.times; Nt = length(t); n = Observable(1). wn = @lift interior(wt[$n], :, 1, :); bn = @lift interior(bt[$n], :, 1, :). fig = Figure(resolution=(1500, 700)); axw = Axis(fig[1, 1]); axb = Axis(fig[1, 2]). heatmap!(axw, wn); heatmap!(axb, bn). topostr = string(Oceananigans.Grids.topology(grid, 3)). record(fig, ""vertically_$topostr.mp4"", 1:Nt, framerate=12) do nn; @info ""Drawing frame $nn of $Nt...""; n[] = nn; end; ```. # `vertically_Bounded.mp4`. https://github.com/CliMA/Oceananigans.jl/assets/15271942/8b63ae62-1a44-47c2-931b-9db154adddc2. # `vertically_Periodic.mp4`. https://github.com/CliMA/Oceananigans.jl/assets/15271942/8af44a0f-451e-4f58-a6f0-e204a4e65bd3. The easiest fix is to eliminate the pressure separation. Another solution is to fix the hydrostatic pressure algorithm. We should also note that the vertical tridiagonal solve is not corr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782230866:1376,schedul,schedule,1376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782230866,1,['schedul'],['schedule']
Energy Efficiency,"take up a lot of space. ```; (base) fpoulin@vortex2:~/software/Oceananigans.jl$ julia --project=docs/ docs/make.jl; [ Info: generating markdown page from `~/software/Oceananigans.jl/examples/one_dimensional_diffusion.jl`; [ Info: writing result to `~/software/Oceananigans.jl/docs/src/generated/one_dimensional_diffusion.md`; [ Info: SetupBuildDirectory: setting up build directory.; [ Info: Doctest: running doctests.; ┌ Error: doctest failure in src/model_setup/output_writers.md:55-76; │ ; │ ```jldoctest netcdf1; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ # output; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ```; │ ; │ Subexpression:; │ ; │ using Oceananigans, Oceananigans.OutputWriters; │ ; │ grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));; │ ; │ model = IncompressibleModel(grid=grid);; │ ; │ simulation = Simulation(model, Δt=12, stop_time=3600);; │ ; │ fields = Dict(""u"" => model.velocities.u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:1130,schedul,schedule,1130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"te-machine/Oceananigans.jl/pull/621/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #621 +/- ##; ==========================================; + Coverage 74.53% 74.87% +0.34% ; ==========================================; Files 117 118 +1 ; Lines 2246 2277 +31 ; ==========================================; + Hits 1674 1705 +31 ; Misses 572 572 ; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Diagnostics/nan\_checker.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL25hbl9jaGVja2VyLmps) | `33.33% <0.00%> (-46.67%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `40.00% <0.00%> (-13.34%)` | :arrow_down: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100.00% <0.00%> (ø)` | :arrow_up: |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.75% <0.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=footer). Last update [eb9b07f...397c15d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-584907682:2146,Power,Powered,2146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-584907682,1,['Power'],['Powered']
Energy Efficiency,"th 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=Inf. julia> set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN; ```. I am still struggling with the `mean` though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247524383:1023,reduce,reduced,1023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247524383,2,['reduce'],['reduced']
Energy Efficiency,"that should be ; ```; julia> ∫ᶻ_Axᶠᶜᶜ = Field{Face, Center, Nothing}(with_halo((3, 3, 1), grid), indices = (:, :, grid.Nz)); 4×4×1 Field{Face, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.0, min=0.0, mean=0.0; ```. there are a couple of things to smooth out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247523200:160,reduce,reduced,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247523200,1,['reduce'],['reduced']
Energy Efficiency,"these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows wh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2054,energy,energy,2054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['energy'],['energy']
Energy Efficiency,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2476,reduce,reduced,2476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,2,"['adapt', 'reduce']","['adapt', 'reduced']"
Energy Efficiency,"time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1200,adapt,adaptive,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['adapt'],['adaptive']
Energy Efficiency,"to calculate `Ub` you can probably use a global reduction. Before that you probably want to have a field to store the flux at edge of the domain:; ```julia; function get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow{Nothing}}, ::Val{:west}, size, offset, loc, arch, grid, Δt, clock, fields, args...; kwargs...); u = fields.u; F₁ = bc.condition.boundary_flux; launch!(arch, grid, :yz, _update_boundary_flux!, F₁, grids, u, Val(:west)); Uᵇ = sum(F₁) / (grid.Ly * grid.Lz). return (Uᵇ, ); end. @kernel function _update_boundary_velocity(F₁, grid, u, ::Val{:west}); j, k = @index(Global, NTuple); @inbounds F₁[1, j, k] = u[1, j, k] * Axᶜᶜᶠ(1, j, k, grid); end; ```; I am not sure about the `(grid.Ly * grid.Lz)` part. We would like to reduce over the active cells in case there is some bathymetry on the outflow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977332894:740,reduce,reduce,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977332894,1,['reduce'],['reduce']
Energy Efficiency,"tput writers you need; > ; > ```julia; > u_subsampled = XFaceField(subset_grid); > ; > function subsample_u(model); > u = model.velocities.u; > interpolate!(u_subsampled, u); > return u_subsampled; > end; > ; > outputs = (; u=subsample_u); > ```. I tried. ```julia; subset_grid = RectilinearGrid(arch,; size = (grid.Nx, grid.Ny, div(grid.Nz, 20)),; extent = (grid.Lx, grid.Ly, grid.Lz); ). u_subsampled = XFaceField(subset_grid); v_subsampled = YFaceField(subset_grid); w_subsampled = ZFaceField(subset_grid). function subsample_u(model); u = model.velocities.u; interpolate!(u_subsampled, u); return u_subsampled; end. function subsample_v(model); v = model.velocities.v; interpolate!(v_subsampled, v); return v_subsampled; end. function subsample_w(model); w = model.velocities.w; interpolate!(w_subsampled, w); return w_subsampled; end. subset_outputs = (; u = subsample_u, v = subsample_v, w = subsample_w); ```. and. ```julia; simulation.output_writers[:xyz] = NetCDFOutputWriter(model, subset_outputs,; schedule = TimeInterval(300),; filename = ""test.nc"",; with_halos = false,; array_type = Array{Float32},; ); ```. is returning the following error. ```julia; Custom output v needs dimensions!. Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] define_output_variable!(dataset::NCDatasets.NCDataset{Nothing}, output::Function, name::String, array_type::Type, deflatelevel::Int64, output_attributes::Dict{String, String}, dimensions::Dict{Any, Any}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/netcdf_output_writer.jl:448; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594:1050,schedul,schedule,1050,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594,1,['schedul'],['schedule']
Energy Efficiency,"tree#diff-c3JjL0ZpZWxkcy96ZXJvX2ZpZWxkLmps) | `50.00% <0.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `79.09% <0.00%> (+0.96%)` | :arrow_up: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `96.87% <0.00%> (+1.63%)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `85.71% <0.00%> (+2.38%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `96.15% <0.00%> (+2.40%)` | :arrow_up: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `42.85% <0.00%> (+2.85%)` | :arrow_up: |; | [src/AbstractOperations/unary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `82.35% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038?src=pr&el=footer). Last update [d274364...253bb6e](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1038#issuecomment-707642154:3483,Power,Powered,3483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1038#issuecomment-707642154,1,['Power'],['Powered']
Energy Efficiency,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:2015,reduce,reduce,2015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['reduce'],['reduce']
Energy Efficiency,"ts) * sum(c̄2.(zs, t) for t in ts). #####; ##### Test strided windowed time average against analytic solution; ##### for *single* NetCDF output; #####; single_time_average_nc_filepath = ""single_decay_windowed_time_average_test.nc""; single_ds = NCDataset(single_time_average_nc_filepath). attribute_names = (""schedule"", ""interval"", ""output time interval"",; ""time_averaging_window"", ""time averaging window"",; ""time_averaging_stride"", ""time averaging stride""). for name in attribute_names; @test haskey(single_ds.attrib, name) && !isnothing(single_ds.attrib[name]); end. window_size = window_nΔt; window = window_size*Δt. time = single_ds[""time""][:]; data_plot = single_ds[""c1""][1:4, :]; c̄1_timeaverage = zeros(4,length(time[1:end])); for (n, t) in enumerate(time[1:end]); averaging_times = [t - n*Δt for n in 0:stride:window_size-1 if t - n*Δt >= 0]; # @info n,t,averaging_times, c̄1(averaging_times); c̄1_timeaverage[:,n] = c̄1(averaging_times); # @test all(isapprox.(single_ds[""c1""][:, n+1], c̄1(averaging_times), rtol=rtol)); end. # Plot each of the four lines; pl = plot(); plot!(time, data_plot[1, :], label=""1"", color=:blue, legend=:topright); plot!(time, data_plot[2, :], label=""2"", color=:red); plot!(time, data_plot[3, :], label=""3"", color=:orange); plot!(time, data_plot[4, :], label=""4"", color=:green). plot!(time[1:end],c̄1_timeaverage[1,:], color=:black, linestyle=:dash, label=""1-analytic""); plot!(time[1:end],c̄1_timeaverage[2,:], color=:black, linestyle=:dash, label=""2-analytic""); plot!(time[1:end],c̄1_timeaverage[3,:], color=:black, linestyle=:dash, label=""3-analytic""); plot!(time[1:end],c̄1_timeaverage[4,:], color=:black, linestyle=:dash, label=""4-analytic""); ; tt = 0:window:T2; for i in 1:length(tt); plot!([tt[i], tt[i]],[0,1],color=:grey,label=""""); end; title!(pl, string(""Δt="",Δt,"", average window="",window_nΔt,""Δt"")) # Add the title to the plot; ylims!(pl,(minimum(c̄1_timeaverage[4,:]),maximum(c̄1_timeaverage[4,:]))); xlims!(pl,(0,T2)); close(single_ds); display(pl); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:6540,green,green,6540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,1,['green'],['green']
Energy Efficiency,"u, ""T"" => model.tracers.T);; │ ; │ simulation.output_writers[:field_writer] =; │ NetCDFOutputWriter(model, fields, filepath=""more_fields.nc"", schedule=TimeInterval(60)); │ ; │ Evaluated output:; │ ; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ Expected output:; │ ; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; │ ; │ diff =; │ ┌ Warning: more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; │ └ @ Oceananigans.OutputWriters ~/software/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:289; │ NetCDFOutputWriter scheduled on TimeInterval(1 minute):; │ ├── filepath: more_fields.nc; │ ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); │ ├── 2 outputs: [""T"", ""u""]; │ ├── field slicer: FieldSlicer(:, :, :, with_halos=false); │ └── array type: Array{Float32}; └ @ Documenter.DocTests ~/.julia/packages/Documenter/lul8Y/src/DocTests.jl:369; ┌ Error: doctest failure in src/model_setup/output_writers.md:78-90; │ . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130:3350,schedul,scheduled,3350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796846130,1,['schedul'],['scheduled']
Energy Efficiency,"u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt))",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1426,schedul,schedule,1426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `94.20% <0.00%> (-1.04%)` | :arrow_down: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/fill\_halo\_regions\_value\_gradient.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc192YWx1ZV9ncmFkaWVudC5qbA==) | `28.30% <0.00%> (ø)` | |; | ... and [14 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=footer). Last update [f13a0a2...a40305f](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714:3664,Power,Powered,3664,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714,1,['Power'],['Powered']
Energy Efficiency,"ull/325?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #325 +/- ##; ==========================================; - Coverage 60.71% 60.33% -0.38% ; ==========================================; Files 24 22 -2 ; Lines 1255 1243 -12 ; ==========================================; - Hits 762 750 -12 ; Misses 493 493; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `77.41% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.3% <100%> (+6.59%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `71.98% <66.66%> (-0.27%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40% <66.66%> (-2%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=footer). Last update [aa601c7...f7894de](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517482768:2309,Power,Powered,2309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517482768,1,['Power'],['Powered']
Energy Efficiency,"ull/671?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/BoundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `53.84% <0.00%> (-29.49%)` | :arrow_down: |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `71.42% <0.00%> (-28.58%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `75.17% <0.00%> (-0.73%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `66.66% <0.00%> (+2.56%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `96.22% <0.00%> (+11.61%)` | :arrow_up: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `75.00% <0.00%> (+12.50%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671?src=pr&el=footer). Last update [74cfb85...ef8f0a3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/671#issuecomment-595367281:2711,Power,Powered,2711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/671#issuecomment-595367281,1,['Power'],['Powered']
Energy Efficiency,"up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `80.11% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `72.81% <ø> (ø)` | :arrow_up: |; | [src/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2Nsb2NrLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `64.93% <ø> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <100%> (+1.37%)` | :arrow_up: |; | ... and [5 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410?src=pr&el=footer). Last update [cf55bcd...1dfa8a6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/410#issuecomment-531594177:3382,Power,Powered,3382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/410#issuecomment-531594177,1,['Power'],['Powered']
Energy Efficiency,"uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:1327,schedul,schedule,1327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['schedul'],['schedule']
Energy Efficiency,"v.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `30.00% <0.00%> (-4.10%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `96.42% <0.00%> (-3.58%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `84.90% <0.00%> (+0.29%)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `37.93% <0.00%> (+1.08%)` | :arrow_up: |; | ... and [14 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767?src=pr&el=footer). Last update [e5c7aaf...d063105](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/767#issuecomment-636191089:3619,Power,Powered,3619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767#issuecomment-636191089,1,['Power'],['Powered']
Energy Efficiency,"v.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=h1) Report; > Merging [#571](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/70a9308e59cb620632e3539ba4e0f2cab2aeab29?src=pr&el=desc) will **decrease** coverage by `0.06%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #571 +/- ##; ==========================================; - Coverage 69.42% 69.35% -0.07% ; ==========================================; Files 71 71 ; Lines 2054 2056 +2 ; ==========================================; Hits 1426 1426 ; - Misses 628 630 +2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `61.53% <ø> (ø)` | :arrow_up: |; | [src/SurfaceWaves.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571/diff?src=pr&el=tree#diff-c3JjL1N1cmZhY2VXYXZlcy5qbA==) | `0% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=footer). Last update [70a9308...2e8228e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/571#issuecomment-565757907:1728,Power,Powered,1728,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/571#issuecomment-565757907,1,['Power'],['Powered']
Energy Efficiency,"vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | `50.00% <0.00%> (ø)` | |; | [...dels/IncompressibleModels/non\_dimensional\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9ub25fZGltZW5zaW9uYWxfbW9kZWwuamw=) | `0.00% <0.00%> (ø)` | |; | [...odels/IncompressibleModels/IncompressibleModels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy5qbA==) | `100.00% <0.00%> (ø)` | |; | [...mpressibleModels/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...Models/IncompressibleModels/pressure\_correction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | `83.33% <0.00%> (ø)` | |; | [src/Models/IncompressibleModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfc3RhdGUuamw=) | `100.00% <0.00%> (ø)` | |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187?src=pr&el=footer). Last update [03a6f85...f933fbd](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1187#issuecomment-727718192:3783,Power,Powered,3783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1187#issuecomment-727718192,1,['Power'],['Powered']
Energy Efficiency,"vbGlzLmps) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [test/test\_verification.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ZlcmlmaWNhdGlvbi5qbA==) | | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | | |; | [examples/netcdf\_ouput\_example.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvbmV0Y2RmX291cHV0X2V4YW1wbGUuamw=) | | |; | [...sts/ocean\_large\_eddy\_simulation\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL29jZWFuX2xhcmdlX2VkZHlfc2ltdWxhdGlvbl9yZWdyZXNzaW9uX3Rlc3Quamw=) | | |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZpZWxkcy5qbA==) | | |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=footer). Last update [162159d...17a22a9](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/795#issuecomment-657824854:3111,Power,Powered,3111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/795#issuecomment-657824854,1,['Power'],['Powered']
Energy Efficiency,"vbnMuamw=) | `16.66% <ø> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `42.85% <ø> (ø)` | :arrow_up: |; | [src/Diagnostics/cfl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `86.53% <ø> (ø)` | :arrow_up: |; | [src/Solvers/solver\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVyX3V0aWxzLmps) | `100% <ø> (+17.39%)` | :arrow_up: |; | ... and [148 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=footer). Last update [18428b0...9288c58](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/577#issuecomment-579406744:3558,Power,Powered,3558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/577#issuecomment-579406744,1,['Power'],['Powered']
Energy Efficiency,"veUtils]]; deps = [""Markdown""]; uuid = ""b77e0a4c-d291-57a0-90e8-8db25a27a240"". [[IteratorInterfaceExtensions]]; git-tree-sha1 = ""a3f24677c21f5bbe9d2a714f95dcd58337fb2856""; uuid = ""82899510-4779-5014-852e-03e436cf321d""; version = ""1.0.0"". [[JLD2]]; deps = [""DataStructures"", ""FileIO"", ""MacroTools"", ""Mmap"", ""Pkg"", ""Printf"", ""Reexport"", ""Requires"", ""TranscodingStreams"", ""UUIDs""]; git-tree-sha1 = ""d4962712594ec5d39e0b10745e44e3a06abec0d2""; uuid = ""033835bb-8acc-5ee8-8aae-3f567f8a3819""; version = ""0.4.4"". [[JLLWrappers]]; deps = [""Preferences""]; git-tree-sha1 = ""642a199af8b68253517b80bd3bfd17eb4e84df6e""; uuid = ""692b3bcd-3c85-4b1f-b108-f13ce0eb3210""; version = ""1.3.0"". [[JSON3]]; deps = [""Dates"", ""Mmap"", ""Parsers"", ""StructTypes"", ""UUIDs""]; git-tree-sha1 = ""65798ad6ddb0d7068f2b1885e0b0d876efca16f5""; uuid = ""0f8b85d8-7281-11e9-16c2-39a750bddbf1""; version = ""1.8.1"". [[KernelAbstractions]]; deps = [""Adapt"", ""CUDA"", ""Cassette"", ""InteractiveUtils"", ""MacroTools"", ""SpecialFunctions"", ""StaticArrays"", ""UUIDs""]; git-tree-sha1 = ""f16c8dfdd75ae4fa927fcf3aa71e1dbbd195befb""; uuid = ""63c18a36-062a-441e-b654-da1e3ab1ce7c""; version = ""0.5.5"". [[LLVM]]; deps = [""CEnum"", ""Libdl"", ""Printf"", ""Unicode""]; git-tree-sha1 = ""b616937c31337576360cb9fb872ec7633af7b194""; uuid = ""929cbde3-209d-540e-8aea-75f648917ca0""; version = ""3.6.0"". [[LazyArtifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""4bb5499a1fc437342ea9ab7e319ede5a457c0968""; uuid = ""4af54fe1-eca0-43a8-85a7-787d91b784e3""; version = ""1.3.0"". [[LibCURL_jll]]; deps = [""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""897d962c20031e6012bba7b3dcb7a667170dad17""; uuid = ""deac9b47-8bc7-5906-a0fe-35ac56dc84c0""; version = ""7.70.0+2"". [[LibGit2]]; deps = [""Printf""]; uuid = ""76f85450-5226-5b5a-8eaa-529ad045b433"". [[LibSSH2_jll]]; deps = [""Libdl"", ""MbedTLS_jll"", ""Pkg""]; git-tree-sha1 = ""717705533148132e5466f2924b9a3657b16158e8""; uuid = ""29816b5a-b9ab-546f-933c-edad1886dfa8""; version = ""1.9.0+3"". [[Libdl]]; uuid = ""8f399da",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:7453,Adapt,Adapt,7453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Energy Efficiency,"verdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.002765",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6088,Adapt,Adapt,6088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['Adapt'],['Adapt']
Energy Efficiency,"w=) | `25% <0%> (-8.34%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `63.33% <0%> (-6.67%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.7% <0%> (-1.3%)` | :arrow_down: |; | [src/Operators/interpolation\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9pbnRlcnBvbGF0aW9uX29wZXJhdG9ycy5qbA==) | `59.01% <0%> (-0.51%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.35% <0%> (-0.34%)` | :arrow_down: |; | [src/Coriolis/no\_rotation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vX3JvdGF0aW9uLmps) | `0% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | ... and [9 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622?src=pr&el=footer). Last update [1f4465d...d25abdb](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/622#issuecomment-584704187:3742,Power,Powered,3742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/622#issuecomment-584704187,1,['Power'],['Powered']
Energy Efficiency,"w_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `93.54% <100%> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `64.44% <100%> (ø)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `79.31% <50%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `80.59% <72.72%> (ø)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.27% <87.23%> (+0.13%)` | :arrow_up: |; | [src/Operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `84.21% <92.3%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.08% <92.85%> (-0.13%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462?src=pr&el=footer). Last update [5114a22...419f176](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542464744:3234,Power,Powered,3234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542464744,1,['Power'],['Powered']
Energy Efficiency,"why wouldn't they be just defined at cell centers?; Suggest make that assumption.; John. On Mon, Oct 21, 2019 at 2:29 PM Ali Ramadhan <notifications@github.com>; wrote:. > Title sounds ridiculous but @jm-c <https://github.com/jm-c> mentioned; > that for stretched grids, models (e.g. WRF) usually place the cell center; > halfway between the two cell faces, but some models relax this choice so; > that you can specify cell centers to be slightly offset from the true; > center.; >; > I guess they won't be ""cell centers"" anymore, but just opening an issue in; > case there's anything to discuss.; >; > Without assuming cell centers are halfway between the two faces then; > interpolation operators are a bit more complicated; >; > @inline ℑz_aac(i, j, k, grid::VerticallyStretchedCartesianGrid, f) =; >; > @inbounds ((grid.zC[k] - grid.zF[k]) * f[k, j, i] + (grid.zF[k+1] - grid.zC[k]) * f[k+1, j, i]) / grid.ΔzF[k]; >; > and if we assume e.g. grid.zC[k] - grid.zF[k] = grid.ΔzF[k]/2 then the; > interpolation operators simplify.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/491?email_source=notifications&email_token=AKXUEQROF3YBCYTVKZUUNMLQPXYINA5CNFSM4JDC6IX2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HTI3OWQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQAZQL25R7ZQ4S7J63QPXYINANCNFSM4JDC6IXQ>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-544660984:1572,Green,Green,1572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-544660984,1,['Green'],['Green']
Energy Efficiency,"width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #109 +/- ##; =======================================; Coverage 52.71% 52.71% ; =======================================; Files 19 19 ; Lines 645 645 ; =======================================; Hits 340 340 ; Misses 305 305; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `0% <0%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `46.45% <25%> (ø)` | |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `87.5% <50%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.96% <50%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=footer). Last update [3cd4ae3...08d8495](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/109#issuecomment-470193436:2199,Power,Powered,2199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/109#issuecomment-470193436,1,['Power'],['Powered']
Energy Efficiency,"wn: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `57.14% <0.00%> (-0.86%)` | :arrow_down: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `77.77% <ø> (+7.77%)` | :arrow_up: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `64.28% <0.00%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `82.35% <0.00%> (-5.89%)` | :arrow_down: |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Operators/laplacian\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9sYXBsYWNpYW5fb3BlcmF0b3JzLmps) | `9.09% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <ø> (ø)` | |; | ... and [21 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057?src=pr&el=footer). Last update [c5f47e0...c35af73](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057#issuecomment-708214357:3393,Power,Powered,3393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057#issuecomment-708214357,1,['Power'],['Powered']
Energy Efficiency,"y spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25; > ; > julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); > 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; > ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); > ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25; > ; > julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); > 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; > ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── boundary conditions: FieldBoundaryConditions; > │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; > └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; > └── max=0.875, min=0.125, mean=0.5; > ; > julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); > 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; > ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── boundary conditions: FieldBoundaryConditions; > │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; > └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; > └── max=-Inf, min=Inf, mean=NaN; > ; > julia> using Statistics: no",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248088689:1072,reduce,reduced,1072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248088689,1,['reduce'],['reduced']
Energy Efficiency,"y}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2426,adapt,adapt,2426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Energy Efficiency,"z, t) = - 1 / 2k * A′′(x - cᵍ * t) * ûˢ(z); @inline ∂t_wˢ(x, z, t) = + cᵍ / 2k * A′′(x - cᵍ * t) * ûˢ(z). stokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂t_wˢ, ∂x_wˢ). grid = RectilinearGrid(size = (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). ut = FieldTimeSeries(filename, ""u""); wt = FieldTimeSeries(filename, ""w""). times = ut.times; Nt = length(times). n = Observable(1). un = @lift interior(ut[$n], :, 1, :); wn = @lift interior(wt[$n], :, 1, :). xu, yu, zu = nodes(ut); xw, yw, zw = nodes(wt). fig = Figure(resolution=(800, 300)). axu = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)""); axw = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)""). heatmap!(axu, xu, zu, un); heatmap!(axw, xw, zw, wn). record(fig, ""surface_wave_induced_flow.mp4"", 1:Nt, framerate=12) do nn; n[] = nn; end; ```. The result is. https://github.com/CliMA/Oceananigans.jl/assets/15271942/643ca8b4-0943-461d-8016-08bbba24faad. where the left panel is `u` and the right panel is `w`. @BrodiePearson I don't think we should add a new example for this feature (examples are expensive, because they have to run every time we run CI / build the documentation). However, another avenue to ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:2039,schedul,schedule,2039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085,1,['schedul'],['schedule']
Energy Efficiency,"zation=nothing` yields. ```julia; julia> include(""mwe.jl""); [ Info: Initializing simulation...; Iter: 0, time: 0.0, Δt: 1.10e-01, max|d|: 0.00e+00, mean(p): 0.00e+00, solver iterations: 0, max|r|: 0.00e+00; [ Info: ... simulation initialization complete (2.973 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (17.534 ms).; Iter: 1, time: 0.1, Δt: 1.10e-01, max|d|: 4.30e-04, mean(p): -1.22e-16, solver iterations: 10, max|r|: 1.17e-02; Iter: 2, time: 0.2, Δt: 1.10e-01, max|d|: 2.24e-04, mean(p): 3.78e-17, solver iterations: 10, max|r|: 6.10e-03; Iter: 3, time: 0.3, Δt: 1.10e-01, max|d|: 1.16e-04, mean(p): 8.26e-17, solver iterations: 10, max|r|: 3.15e-03; ```. So in conclusion:. * regularization stabilizes the CG iteration for our current example. Without regularization, CG is unstable and diverges if we take too many iterations; * Interestingly however, the solver converges more quickly for a small number of iterations (eg `maxiter=10`) without regularization (where we apply the constraint that mean(p) = 0 instead); * My current recommendation is to cap `maxiter` at a small number, or to use `regularization` if not capping it. I think there is probably more work to do. First, I am not sure that the regularization is applied correctly; the rather bland results suggest there could be improvement. Second, and separately, I am wondering if there is another way to stabilize the non-regularized CG iteration by applying the linear constraint _within_ the CG solver (eg to the search direction). It seems that the solver may be more efficient if we apply the linear constraint directly (setting mean(p)=0) rather than modifying the linear operator. This does make sense to me, because when we modify the linear operator the CG algorithm is also tasked with finding mean(p) whereas when we apply the constraint, we insert our desired solution for mean(p) directly. Feedback welcome, I think we should merge this PR and continue work in future PRs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420098775:5760,efficient,efficient,5760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420098775,1,['efficient'],['efficient']
Energy Efficiency,"{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #340",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:8826,reduce,reducedim,8826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,1,['reduce'],['reducedim']
Energy Efficiency,"{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[9]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types. julia> maximum(abs, v); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:5172,reduce,reducedim,5172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,1,['reduce'],['reducedim']
Energy Efficiency,"| :arrow_up: |; | [...vection/topologically\_conditional\_interpolation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90b3BvbG9naWNhbGx5X2NvbmRpdGlvbmFsX2ludGVycG9sYXRpb24uamw=) | `60.00% <60.00%> (ø)` | |; | [src/Advection/centered\_fourth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9mb3VydGhfb3JkZXIuamw=) | `64.28% <62.50%> (+64.28%)` | :arrow_up: |; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `65.00% <65.00%> (ø)` | |; | [src/Advection/centered\_advective\_fluxes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9hZHZlY3RpdmVfZmx1eGVzLmps) | `100.00% <100.00%> (ø)` | |; | [src/Advection/upwind\_biased\_advective\_fluxes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX2FkdmVjdGl2ZV9mbHV4ZXMuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | ... and [6 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972?src=pr&el=footer). Last update [7260ce8...5f6a3a0](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/972#issuecomment-699121507:3299,Power,Powered,3299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972#issuecomment-699121507,1,['Power'],['Powered']
Energy Efficiency,"| :arrow_up: |; | [src/closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2Nsb3N1cmVfb3BlcmF0b3JzLmps) | `58.44% <100%> (-34.82%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `80.68% <100%> (+0.44%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `45.76% <28%> (-13.07%)` | :arrow_down: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `64.51% <66.66%> (-1.45%)` | :arrow_down: |; | [src/closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X3NtYWdvcmluc2t5Lmps) | `18.18% <0%> (-81.82%)` | :arrow_down: |; | [src/closures/velocity\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3ZlbG9jaXR5X2dyYWRpZW50cy5qbA==) | `0% <0%> (-73.69%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253?src=pr&el=footer). Last update [9204afe...5f743c1](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/253#issuecomment-498649321:3308,Power,Powered,3308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253#issuecomment-498649321,1,['Power'],['Powered']
Energy Efficiency,"| [test/test\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3NvbHZlcnMuamw=) | `51.06% <ø> (ø)` | |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `95.23% <100.00%> (+0.23%)` | :arrow_up: |; | [...sts/ocean\_large\_eddy\_simulation\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL29jZWFuX2xhcmdlX2VkZHlfc2ltdWxhdGlvbl9yZWdyZXNzaW9uX3Rlc3Quamw=) | `100.00% <100.00%> (ø)` | |; | [...egression\_tests/rayleigh\_benard\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3JheWxlaWdoX2JlbmFyZF9yZWdyZXNzaW9uX3Rlc3Quamw=) | `100.00% <100.00%> (ø)` | |; | [...regression\_tests/thermal\_bubble\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3RoZXJtYWxfYnViYmxlX3JlZ3Jlc3Npb25fdGVzdC5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_regression.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3JlZ3Jlc3Npb24uamw=) | `100.00% <100.00%> (ø)` | |; | ... and [26 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943?src=pr&el=footer). Last update [0f33c1d...8fe7c2a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/943#issuecomment-692271816:3536,Power,Powered,3536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/943#issuecomment-692271816,1,['Power'],['Powered']
Energy Efficiency,"| |; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | | |; | [test/test\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2J1b3lhbmN5Lmps) | | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | | |; | [...ests/one\_dimensional\_cosine\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9jb3NpbmVfYWR2ZWN0aW9uX2RpZmZ1c2lvbi5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=footer). Last update [b444acf...639be06](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202:3199,Power,Powered,3199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202,1,['Power'],['Powered']
Energy Efficiency,"|; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <81.81%> (-1.59%)` | :arrow_down: |; | [src/Solvers/discrete\_eigenvalues.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvZGlzY3JldGVfZWlnZW52YWx1ZXMuamw=) | `85.71% <83.33%> (ø)` | |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `96.61% <96.49%> (-3.39%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.52% <98.18%> (+0.31%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `84.00% <100.00%> (ø)` | |; | [src/Grids/Grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `71.42% <100.00%> (+7.79%)` | :arrow_up: |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733?src=pr&el=footer). Last update [7e22384...d72cde3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/733#issuecomment-618603846:3558,Power,Powered,3558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/733#issuecomment-618603846,1,['Power'],['Powered']
Energy Efficiency,"|; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `74.57% <ø> (-6.82%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `89.28% <100%> (-4.47%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `66.12% <100%> (-1.22%)` | :arrow_down: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `39.16% <0%> (-60.01%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `26.08% <0%> (-26.09%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.17% <0%> (-7.14%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282?src=pr&el=footer). Last update [8fdff75...d8da673](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/282#issuecomment-508952011:2954,Power,Powered,2954,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/282#issuecomment-508952011,2,['Power'],['Powered']
Energy Efficiency,"|; |---|---|---|; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <ø> (ø)` | |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `52.94% <50.00%> (ø)` | |; | [src/OutputWriters/fetch\_output.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvZmV0Y2hfb3V0cHV0Lmps) | `60.00% <60.00%> (ø)` | |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `90.90% <96.00%> (-0.62%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `93.91% <100.00%> (+0.28%)` | :arrow_up: |; | [src/Utils/output\_writer\_diagnostic\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL291dHB1dF93cml0ZXJfZGlhZ25vc3RpY191dGlscy5qbA==) | `100.00% <0.00%> (+8.69%)` | :arrow_up: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `87.50% <0.00%> (+12.50%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927?src=pr&el=footer). Last update [0f33c1d...8d7f82e](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/927#issuecomment-690372678:2713,Power,Powered,2713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/927#issuecomment-690372678,1,['Power'],['Powered']
Energy Efficiency,"}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/mapreduce.jl:169; [21] mapreducedim!(f::Function, op::Function, R::SubArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, A::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Float64, typeof(Oceananigans.Grids.zspacing), Tuple{Center, Center, Center}}); @ GPUArrays /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/mapreduce.jl:10; [22] #minimum!#808; @ ./reducedim.jl:1018 [inlined]; [23] minimum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, a::KernelFunctionOperation{Center, Center, Center, Rectilinear",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457:8839,reduce,reducedim,8839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457,1,['reduce'],['reducedim']
Energy Efficiency,"}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, FieldSlicer{UnitRange{Int64}, Colon, Colon}, Tuple{Int64, Int64, Int64}}(4×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 4×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; └── data: 6×3×3 OffsetArray(::Array{Float64, 3}, 0:5, 0:2, 0:2) with eltype Float64 with indices 0:5×0:2×0:2; └── max=4.0, min=1.0, mean=2.5, FieldSlicer{UnitRange{Int64}, Colon, Colon}(3:4, Colon(), Colon(), false), (1, 2, 3)); ```. One can apparently do the following and get the right result:. ```julia; julia> av2 = Field(Average(field, dims=(1,2,3), condition=(i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] > 0.5)); 1×1×1 Field{Nothing, Nothing, Nothing} reduced over dims = (1, 2, 3) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: 4×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── operand: mean! over dims (1, 2, 3) of Conditioned Field at (Center, Center, Center); └── status: time=0.0. julia> compute!(av2); interior(av2). julia> interior(av2); 1×1×1 view(::Array{Float64, 3}, 1:1, 1:1, 1:1) with eltype Float64:; [:, :, 1] =; 3.5; ```. Let me know if I'm not missing anything and I'll open a PR to remove `WindowedSpatialAverage`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022373316:3394,reduce,reduced,3394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022373316,1,['reduce'],['reduced']
Energy Efficiency,"~~I think I have two remaining problems to get all of the existing tests working:~~; - ~~Hydrostatic regression tests: these still failed locally when I restored the `fill_halo_region!` behaviour for hydrostatic models so I'm not sure why they're failing. I will investigate more.~~; - ~~Multi region grids: these give `update_boundary_conditions!` a `MultiRegionObject` which I am not familiar with. Can I just call `update_boundary_conditions!` on each `regional_object`? (cc: @simone-silvestri)~~. ~~Hopefully, the other tests now pass and I've reduced the changes that we need to make to them here.~~. I think these are solved now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150072166:548,reduce,reduced,548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150072166,1,['reduce'],['reduced']
Energy Efficiency,~~~; (Oceananigans) pkg> status; Project Oceananigans v0.40.0; Status `/gpfs7kw/linkhome/rech/genbes01/use25mx/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics. shell> module list; Currently Loaded Modulefiles:; 1) cuda/10.2 2) julia/1.5.2 ; ~~~,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707688295:153,Adapt,Adapt,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707688295,1,['Adapt'],['Adapt']
Energy Efficiency,"ø)` | |; | [examples/netcdf\_ouput\_example.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvbmV0Y2RmX291cHV0X2V4YW1wbGUuamw=) | `0.00% <ø> (ø)` | |; | [examples/ocean\_convection\_with\_plankton.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | `0.00% <ø> (ø)` | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <ø> (ø)` | |; | [examples/one\_dimensional\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb25lX2RpbWVuc2lvbmFsX2RpZmZ1c2lvbi5qbA==) | `0.00% <ø> (ø)` | |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `81.81% <ø> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `100.00% <ø> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `86.00% <ø> (ø)` | |; | ... and [27 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836?src=pr&el=footer). Last update [66ddeb7...81d21f3](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/836#issuecomment-669319153:3242,Power,Powered,3242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/836#issuecomment-669319153,1,['Power'],['Powered']
Energy Efficiency,"└── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.403323 seconds (150.90 k allocations: 10.217 MiB, 98.63% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.404525 seconds (150.90 k allocations: 10.221 MiB, 98.74% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.412531 seconds (150.90 k allocations: 10.219 MiB, 98.85% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearG",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959:2661,reduce,reduced,2661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959,1,['reduce'],['reduced']
Energy Efficiency,"└── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.404525 seconds (150.90 k allocations: 10.221 MiB, 98.74% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.412531 seconds (150.90 k allocations: 10.219 MiB, 98.85% compilation time); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├── status: time=0.0; └── data: 1000×1×100 OffsetArray(::Array{Float64, 3}, 1:1000, 1:1, 1:100) with eltype Float64 with indices 1:1000×1:1×1:100; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(averaged_c); 0.007040 seconds (204 allocations: 44.438 KiB); 1000×1×100 Field{Center, Nothing, Center} reduced over dims = (2,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1000, 1, 100); ├── grid: 1000×64×100 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: Average of 1000×64×100 Field{Center, Center, Center} on RectilinearGrid on CPU over dims (2,); ├──",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959:3344,reduce,reduced,3344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176741959,1,['reduce'],['reduced']
Energy Efficiency,🕵️ https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138:31,Adapt,Adapt,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138,1,['Adapt'],['Adapt']
Integrability," &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. </div></div><div class=""JobLogComponent__Footer pt2"" style=""box-sizing: border-box; display: flex; padding-top: 10px; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-size: 13px;""><br class=""Apple-interchange-newline""></d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:6223,wrap,wrappers,6223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['wrap'],['wrappers']
Integrability," (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedThirdOrder`, `UpwindBiasedFifthOrder`, `WENO5`), the symmetric interpolation for advecting velocities is a symmetric scheme of order `n-1`. So that's `CenteredSecondOrder`, `CenteredFourthOrder`, and `CenteredF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:1215,interface,interface,1215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724,1,['interface'],['interface']
Integrability," A hydrostatic Boussinesq model would be super useful too of course. I think we should talk. We are working on a similar model using discontinuous Galerkin numerics over at [ClimateMachine.jl](https://github.com/CliMA/ClimateMachine.jl) and these projects would have overlapping goals. Nevertheless I would personally find it extremely useful to be able to run `Oceananigans.IncompressibleModel`s with a `HydrostaticPressureSolver` and `ExplicitFreeSurface` since I could use it to benchmark / compare with the DG functionality that I'm working on for `ClimateMachine`, and the relative advantages of high-order finite volume methods compared with DG may still be in question, at least for structured grids (meaning that an Oceananigans development effort is not a waste of time). Perhaps a zoom conversation on that topic is in order. I agree with the framework / level-of-difficulty that you've laid out for student projects!. As for deciding FourierFlows vs Oceananigans, that's up to you for sure and depends basically on whether you are okay staying with doubly-periodic systems (what FourierFlows currently supports) or whether you want to do problems with boundaries (what Oceananigans promises). FourierFlows is a nice tool for idealized problems and theoretical work (and you can run pretty large problems these days since it has GPU support); Oceananigans is evolving more towards a tool for ocean modeling that is capable of doing idealized problems, but flexible enough to use for large eddy simulation and realistic non-hydrostatic modeling, in bounded domains and hopefully irregular domains as well, eventually, using immersed boundaries. Switching between the two would be a dream... ! I'm afraid this is too futuristic for Oceananigans. It may be possible to build FV functionality into FourierFlows (which is generally more flexible than Oceananigans, but has fewer features for the specific problem of the nonhydrostatic Boussinesq equations), but that's not a small piece of work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226:1211,depend,depends,1211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226,1,['depend'],['depends']
Integrability," Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1535,depend,dependencies,1535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['depend'],['dependencies']
Integrability," LaTeXStrings; ✓ InvertedIndices; ✓ ExprTools; ✓ DataAPI; ✓ Requires; ✓ CompilerSupportLibraries_jll; ✓ OrderedCollections; ✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.v",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:4378,depend,dependencies,4378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['depend'],['dependencies']
Integrability," `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI>; > .; > You are receiving this because you commented.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:2056,Message,Message,2056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,1,['Message'],['Message']
Integrability," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:2128,interface,interface,2128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,1,['interface'],['interface']
Integrability," get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor so that. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L176. becomes. ```julia; filepath = joinpath(dir, fil",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:1086,interface,interface,1086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,1,['interface'],['interface']
Integrability," how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either including a y-gradient in v, a z-gradient in w to balance the x-gradient of u or by removing the x-gradient in u (not sure what pressure decides to do here, but I suspect it will add lateral flow components). In principle, this is a different dynamical case because if you introduce lateral velocity then tendencies will not be null anymore and the flow is not steady anymore. In this case, the flow can experience numerical instabilities when `CFL > 1`. The out-of-bounds issue is not the problem of the CFL being larger than the grid size, it's a problem of the CFL being larger than the size of the halo. You see this issue when the CFL is larger than the grid size because you initialize your particles at `x = 0`. If you initialize your particles at `x = Lx` you will have out-of-bounds problems with a much lower CFL (still larger than 1). This said we have a couple of ways to tackle this problem; - we issue a warning when CFL > 1 (in theory we should not run a simulation with CFL > 1 but that might be desired when we prescribe the velocity); - we wrap around the particle location if it falls outside of the domain in the periodic direction. The issue of CPU vs GPU sounds quite concerning, I ll try to investigate what is going on in your script",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:3052,wrap,wrap,3052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277,1,['wrap'],['wrap']
Integrability," macro expansion at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:406 [inlined]; │ [11] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:410 [inlined]; │ [12] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1539,synchroniz,synchronize,1539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronize']
Integrability," model = NonhydrostaticModel(grid = grid); ```. Running this on a CPU works, but on a GPU is throws me this error:. ```; ERROR: TaskFailedException. nested task error: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(2, 4)}, typeof(Oceananigans.BoundaryConditions.gpu__fill_bottom_and_top_halo!)})(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, U",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261:1691,depend,dependencies,1691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261,1,['depend'],['dependencies']
Integrability," mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal in both the schemes. the `zweno = true` flag just switches between these two formulations. Now, I believe that `stretched_smoothness` does not have a such big impact because if you assure that the reconstruction is correct, then all stencil correctly interpolate to the face and weights will still be between 0 and 1. This might be more impactful for grids that are much more non-uniform (or ""irregular"") than what we usually use.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:3053,depend,depends,3053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,1,['depend'],['depends']
Integrability," motions are “resolved”, so; that near the wall the SGS diffusivities should vanish. This is because the; near wall motions are nearly laminar (very strongly sheared) with only; small turbulence fluctuations. The interaction of the flow with the wall is; not part of the AMD model, which means that this part of the flow must; either be resolved or modeled with a “wall model”, which somehow accounts; for the effect of wall effects on the nonlinear subgrid scale; diffusivities. When the nonlinear diffusivities are calculated in Oceananigans, the; constant molecular contribution is added so that the resulting diffusivity; field is the sum of the nonlinear and molecular components. Therefore to; calculate the nonlinear part correctly from a saved diffusivity field, the; molecular value must subtracted. This behavior is identical between; RozemaAnisotropicMinimumDissipation and; VerstappenAnisotropicMinimimDissipation. Because of the fact that this experiment requires near wall motions to be; resolved to be correct, the results should depend strongly on resolution. On Sun, Aug 18, 2019 at 7:11 AM Ali Ramadhan <notifications@github.com>; wrote:. > Temperature and velocity profiles look qualitatively correct which is; > promising but the sub-grid-scale viscosity and diffusivity don't match. At; > least the order of magnitude on each is roughly correct.; >; > Most notably their version of AMD allows the SGS ν and κ to go below the; > background values, which seems essential for ν, although not sure what that; > physically means. Seems that the VerstappenAnisotropicMinimumDissipation; > closure in the new-closures branch allows for this so I'll try rerunning; > with it.; >; > The SGS profiles seem kind of noisy but maybe I just need to bump up the; > resolution.; >; > The SGS/turbulent Prandtl number is still too low but this should get; > fixed if the SGS ν and κ profiles are right.; >; > The wall velocity Uw=1 so the x-axis is U/Uw.; > [image: plots_stratified_couette_flow_u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-522322493:1588,depend,depend,1588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-522322493,1,['depend'],['depend']
Integrability," same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in the general case a call to `zspacings(::ImmersedBoundaryGrid)` _must_ return a 3D array (or `Field`, or `AbstractOp`...)).; - if we wanna keep the user-interface consistent (i.e. always return the same type of object) then we lose on simplicity (e.g. a call to `zspacings(::RectilinearGrid)` would always return _something_ 3D, even if the grid is regular). @navidcy @glwagner is this a fair assessment of the situation? Feel free to edit the text above if not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:2409,interface,interface,2409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041,2,['interface'],['interface']
Integrability," volume method. We evolve the average value of fields, integrated over a cell volume. In this integral formulation there are two contributions to the tendency of a field: fluxes across cell interfaces (advective and diffusive usually, but also possibly others via user-defined forcing), and interior ""sources"" (such as pressure gradients, Coriolis forces, gravitational forces). When users invoke `Gradient` or `Value` boundary conditions, then the same model is used for fluxes across interior cell interfaces as for ""exterior"" interfaces (domain boundaries). Thus if users set `closure=nothing` and zero out diffusive fluxes, boundary fluxes are _always_ zero regardless of what `Gradient` or `Value` are specified. More specifically, we enforce `Gradient` or `Value` boundary conditions by filling halo regions and then calculating exterior fluxes using the same kernel that's evaluated in the interior. As @francispoulin points out this is not some quirk of our algorithm or numerics; this follows from the properties of the underlying PDE. Something different happens when `Flux` boundary conditions are specified and this is where I was wrong above. With `Flux` boundary conditions, users are really specifying two _different_ models for fluxes: one across ""interior"" cell interfaces, and another for fluxes across domain boundaries. Setting `closure=nothing` in this case only nullifies _interior_ diffusive fluxes. But since boundary fluxes are explicitly specified in this case, they still do have an impact on interior tendency values. . A further subtlety is that `Value` and `Gradient` boundary conditions do actually have an impact if there is non-zero `NormalFlow` advecting the field across a boundary; in this case the flux is _advective_ (first-order) and thus mathematically consistent with the underlying PDE. So we should probably amend the warning to read:. > `Value` and `Gradient` boundary conditions are not enforced across `Impenetrable` boundaries when `isnothing(closure)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191:1603,interface,interfaces,1603,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191,1,['interface'],['interfaces']
Integrability," we could also omit `Flat` dimensions from the size display, eg. ```julia; ""3-element RectilinearGrid{Float64} on CPU with topology (Flat, Flat, Bounded) and 1-element halo""; ```. ```julia; ""128×128 RectilinearGrid{Float64} on CPU with topology (Periodic, Periodic, Flat) and 1×1 halo""; ```. If we also change `interior` to drop `Flat` dimensions then I think this makes sense (otherwise it might not). In addition to type information, `show` also gives information about _values_. Here this is the extent of the domain and the grid spacings. For example:. ```julia; julia> rand(3, 3); 3×3 Matrix{Float64}:; 0.460633 0.134952 0.0366328; 0.6353 0.0632607 0.0657011; 0.339457 0.720342 0.0417144; ```. for this we can use a tabular display like `domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]`. However, I think a better possibility is to explicitly show the locations of the faces using a strategy similar to how `julia` shows row vectors:. ```julia; julia> collect(reshape(0:0.1:10, 1, 101)); 1×101 Matrix{Float64}:; 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 … 8.9 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0; ```. so we might have, depending on the width of the display:. ```julia; 1×1×101 RectilinearGrid{Float64} on CPU with topology (Flat, Flat, Bounded) and 0×0×1 halo; z faces: [0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 … 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0]; ```. etc. Or, putting a ""domain summary"" out front, something like. ```julia; 1×1×101 RectilinearGrid{Float64} on CPU with topology (Flat, Flat, Bounded) and 0×0×1 halo; z ∈ [0.0, 10.0] with faces [0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 … 9.4 9.5 9.6 9.7 9.8 9.9 10.0]; ```. We can do something similar for spacings, though as others have noted I think it is useful to show _statistics_ rather than list all the values for that case. We probably want to indicate whether we are talking about spacings at Center or Face, so. ```julia; z spacings: stretched with minimum(Δzᵃᵃᶜ) = 0.2, maximum(Δzᵃᵃᶜ) = 0.5; ```. is an option.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971870818:1881,depend,depending,1881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971870818,1,['depend'],['depending']
Integrability,"# Progress update. I decided to take a stab at the simplest case: triply-periodic on the CPU. Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:440,depend,dependencies,440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,2,"['depend', 'inject']","['dependencies', 'injects']"
Integrability,"#1654 is still open so you'll need to merge that branch into yours to use it. To use an immersed boundary you wrap your `grid` in `ImmersedBoundaryGrid`. For the internal tide example this looks like. ```julia; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-842551645:110,wrap,wrap,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-842551645,1,['wrap'],['wrap']
Integrability,"(Oceananigans.BoundaryConditions.gpu_fill_periodic_south_and_north_halo!)})(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, ::Tuple{Int64, Int64}, ::typeof(Oceananigans.BoundaryConditions.fill_periodic_south_and_north_halo!), ::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{Int64}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Utils/kernel_launching.jl:95; [7] fill_south_and_north_halo!(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, ::Tuple{Int64, Int64}, ::Tuple{Int64, Int64}, ::Tuple{Center, Center, Nothing}, ::GPU, ::CUDAKernels.CudaEvent, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRange",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185:1783,depend,dependencies,1783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185,1,['depend'],['dependencies']
Integrability,"(c, bc, size, offset, loc, arch, grid, args...; kwargs...)` etc. but couldn't work out how to stop it tupel-ing them. So instead I made it so that boundary condition kernels can have arguments which are computed before their kernel is launched:; ```julia; function fill_west_and_east_halo!(c, west_bc, east_bc, size, offset, loc, arch, grid, args...; kwargs...); west_bc_args = get_boundary_arguments(west_bc, Val(:west), size, offset, loc, arch, grid, args...; kwargs...); east_bc_args = get_boundary_arguments(east_bc, Val(:east), size, offset, loc, arch, grid, args...; kwargs...). return launch!(arch, grid, KernelParameters(size, offset),; _fill_west_and_east_halo!, c, west_bc, east_bc, loc, grid, west_bc_args, east_bc_args, Tuple(args); kwargs...); end; ```. Where the default behaviour is:; ```; get_boundary_arguments(args...; kwargs...) = (); get_boundary_arguments(bcs::Tuple, args...; kwargs...) = Tuple(get_boundary_arguments(bc, args...; kwargs...) for bc in BCS); ```; But we can add methods like this:; ```; get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow}, side, size, offset, loc, arch, grid, args...; kwargs...) = (@info typeof(bc); (bc.classification.bulk_speed, )) # fallback. function get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow{Nothing}}, ::Val{:west}, size, offset, loc, arch, grid, Δt, clock, fields, args...; kwargs...); u = fields.u. # THIS WILL NOT BE GPU FRIENDLY; Uᵇ = sum([u[1, j, k] * Axᶜᶜᶠ(1, j, k, grid) for j=1:grid.Ny, k=1:grid.Nz]) / (grid.Ly * grid.Lz). return (Uᵇ, ); end; ```. If everyone is happy with this my next issue is working out how to calculate $U^b$ in a way that will work on GPU since boundary conditions are defined before Fields so I can't use `Average`. . I also made a subdirectory for these boundary conditions but then I realised it would be easiest to not have different classifications depending on where $U^b$ is coming from so I didn't have to make as many different things so I'll move them back at some point.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977320058:2090,depend,depending,2090,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977320058,1,['depend'],['depending']
Integrability,", Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); > @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; > [6] top-level scope; > @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > ```. Huh, that error seems unrelated but I'm not sure. In particular, it looks like you cannot create a netcdf file in the first place (this takes place before any code is executed that has to do specifically with this PR). Does your code work on `main`? You could also try using `JLD2OutputWriter` to see if you still get an error. It also could help to see what code you're running. PS I changed you single ticks ""`"" to block ticks ""```"" to make your message more readable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:32010,message,message,32010,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839,1,['message'],['message']
Integrability,", moving it an ocean; direction. This would lead to some interesting research papers. John. On Wed, Jan 29, 2020, 9:57 PM Ali Ramadhan <notifications@github.com> wrote:. > Over at JULES.jl <https://github.com/thabbott/JULES.jl> @thabbott; > <https://github.com/thabbott>, @RaphaelRR <https://github.com/RaphaelRR>,; > and I have been building a compressible non-hydrostatic model on top of; > Oceananigans.jl for atmospheric simulations. It follows the numerics of the; > Advanced Research WRF Model as described in Klemp et al. (2007) and; > Skamarock et al. (2019).; >; > With three qualitative verification experiments I think it's ready to be; > tagged as v0.1.; >; > I'm opening this issue to discuss the possibility of merging JULES.jl into; > Oceananigans.jl which would add a CompressibleModel type (discussed a bit; > in #566 <https://github.com/climate-machine/Oceananigans.jl/issues/566>).; > The two models share a lot of the infrastructure we've already built for; > Oceananigans, and in integrating the two we will readily get a GPU-ready; > research-grade compressible atmosphere model.; >; > Verification experiments:; >; > 1. Hydrostatic adjustment in an isothermal atmosphere [very; > qualitative, see Bannon (1995)]; > 2. Dry rising thermal bubble: thabbott/JULES.jl#31; > <https://github.com/thabbott/JULES.jl/pull/31>; > 3. Nonlinear density current (PR incoming); >; > Dry rising thermal bubble can be compared with figure 5 of Wicker and; > Skamarock (1998), figure 7 of Jahn et al. (2015), and; > https://faculty.nps.edu/fxgirald/projects/mesoscale/rtb_movie.html.; >; > Nonlinear density current can be compared with figure 1 of Straka et al.; > (1993) and; > https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html.; >; > Things we can hopefully share between IncompressibleModel and; > `CompressibleModel:; >; > 1. Operators; > 2. Grids; > 3. Coriolis; > 4. Forcing functions; > 5. Boundary conditions; > 6. Turbulence closures; > 7. Diagnostics; > 8. Output write",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579977300:1122,integrat,integrating,1122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579977300,1,['integrat'],['integrating']
Integrability,".jl:211; [5] view(f::Field{…}, i::CartesianIndices{…}, j::Function, k::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:308; [6] view(f::Field{…}, i::CartesianIndices{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:339; [7] _reverse!(A::Field{…}, dims::Tuple{…}); @ Base ./arraymath.jl:95; [8] _reverse!; @ ./arraymath.jl:71 [inlined]; [9] #reverse!#274; @ ./arraymath.jl:70 [inlined]; [10] _reverse(A::Field{…}, dims::Function); @ Base ./arraymath.jl:60; [11] reverse(A::Field{Face, Center, Center, Nothing, ZRegOrthogonalSphericalShellGrid{…}, Tuple{…}, OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}); @ Base ./arraymath.jl:59; [12] top-level scope; @ REPL[199]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; If the vector is formed by extracting multiple elements from the first dimension of the field on the RHS (as opposed to the second dimension as above), e.g.,; ```julia; julia> u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; no error message pops up but `u[region][Nc+1, 1-Hc:0, k]` is filled with junk values as shown below:; ```julia; 1×4×1 Field{Face, Center, Center} on OrthogonalSphericalShellGrid on CPU; ├── grid: 4×4×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 4×4×1 halo and with precomputed metrics; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (5:5, -3:0, 1:1); └── data: 1×4×1 OffsetArray(view(::Array{Float64, 3}, 9:9, 1:4, 2:2), 5:5, -3:0, 1:1) with eltype Float64 with indices 5:5×-3:0×1:1; └── max=2.1234e-314, min=5.0e-324, mean=5.30853e-315; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721:3213,message,message,3213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721,1,['message'],['message']
Integrability,"/Pkg/src/Operations.jl:1578; &nbsp; | [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2578/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. </div></div><div class=""JobLogComponent__Footer pt2"" style=""box-sizing: border-box; display: flex; padding-top: 10px; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:5719,wrap,wrappers,5719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['wrap'],['wrappers']
Integrability,"00207786 -0.000570261 -0.00113736 -0.0011126 -0.00095512 -0.000668289 0.000187081 -2.50371e-5 -0.000234227 -3.30057e-5 7.37231e-5 4.74698e-5 0.0; 0.0 3.44085e-5 6.01794e-5 0.000160129 -5.71002e-5 -0.000251935 -0.000348341 0.000175676 0.000452654 0.000757255 0.000292256 1.47004e-5 -4.29739e-5 0.0; 0.0 0.000127176 0.000354777 0.000538542 0.000684584 0.000355887 0.000248227 0.000121747 -8.66234e-5 -5.15146e-5 0.000247927 0.000267242 0.000177876 0.0; 0.0 -0.000112676 -0.000247409 -0.000271409 -0.00044693 0.000199694 0.000249875 -0.000585559 -0.00072856 -0.000851675 -0.000696049 -0.000430978 -0.00022939 0.0; 0.0 -6.48691e-5 -0.0002854 -0.0005231 -0.000241099 -0.000523152 -0.000253047 … 0.000609541 0.0009479 0.000772055 0.000367521 0.000193174 8.25992e-5 0.0. julia> ds[""wτ2_yavg""] == ds[""wτ1_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ3_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ4_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ5_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ6_yavg""]; true; ```. So seems that all is good? So the problem comes when I continue the integration longer?; But why do the `info` statements appear in this order?. ```Julia; [ Info: Initializing simulation...; [ Info: Writing to NetCDF: ./test.nc...; [ Info: Computing NetCDF outputs for time index 1: [""wτ3"", ""wτ2_yavg"", ""wτ6_yavg"", ""wτ1"", ""wτ5_yavg"", ""wτ6"", ""wτ2"", ""wτ5"", ""wτ4"", ""wτ1_yavg"", ""wτ4_yavg"", ""wτ3_yavg""]...; [ Info: Computing wτ3 done: time=439.823 ms; [ Info: Computing wτ2_yavg done: time=3.404 seconds; [ Info: Computing wτ6_yavg done: time=3.018 seconds; [ Info: Computing wτ1 done: time=225.326 ms; [ Info: Computing wτ5_yavg done: time=2.950 seconds; [ Info: Computing wτ6 done: time=292.708 μs; [ Info: Computing wτ2 done: time=192.674 ms; [ Info: Computing wτ5 done: time=190.263 ms; [ Info: Computing wτ4 done: time=193.185 ms; [ Info: Computing wτ1_yavg done: time=1.210 seconds; [ Info: Computing wτ4_yavg done: time=2.954 seconds; [ Info: Computing wτ3_yavg done: time=2.953 seconds; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387:7736,integrat,integration,7736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387,1,['integrat'],['integration']
Integrability,"1. Yes you're right. Currently Oceananigans.jl is only non-hydrostatic. We've considered adding a hydrostatic mode (shouldn't be hard to implement) but haven't really needed it yet so we've stuck with non-hydrostatic mode as we mostly do small-scale simulations (also see issue #72). Do you need to run in hydrostatic mode?. 2. Ah interesting. Like on a regular Cartesian grid but with some grid cells cut out so you effectively have a cylindrical domain but with jagged walls (that get smoother as you increase the resolution)? It's not a built-in feature but you could use the forcing functions to add topography via an immersed boundary method (basically damping the velocity to zero inside the boundary). For an example of this, see PR #693: Viscous flow around a cylinder verification experiment. We're happy to help with setting up this kind of stuff too. 3. No we don't have any mesoscale eddy parameterizations. Actually we don't really have any parameterizations in Oceananigans.jl besides turbulent diffusivity/viscosity closures as we've been mostly focused on running small-scale simulations that resolve the turbulence and trying to figure out the best parameterization from the data. Depending on what you need though, it might not be too hard to implement. It's worth discussing if you need something like GM Redi. 4. Hmmm, this isn't something that we've done as adding topography isn't really a built-in feature yet but it should be possible to impose a no-slip boundary condition at a cylindrical wall using a custom forcing function though, not an Oceananigans.jl boundary condition. I'm not 100% sure but if you want no-slip my guess is that you probably want to use a Value/Dirchlet boundary condition. I think @glwagner would know more about whether it's possible to properly implement a no-slip Value/Dirchlet BC on a curved boundary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640688002:1198,Depend,Depending,1198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640688002,1,['Depend'],['Depending']
Integrability,"2e807a80-d36d-11eb-924a-074ca0ad127c.png). ### Tracer Conservation; We can also look at tracer conservation. The initial concentration is sinusoidal, so the area integrated concentration is zero over the domain initially. I've plotted both the IBM and non-IBM (lighter colors) results to see the differences. This one is on a log plot. You can see that leakage is happening in the IBM versions. It's hard to say how bad the leakage is here, and it'll probably be better to consider an initial constant concentration rather than sinusoidal to see how much leakage is occurring due to the immersed solid. ![volint_Concentration_log](https://user-images.githubusercontent.com/67593861/122986580-a058c400-d36d-11eb-9a7c-e3e8d2a7367e.png). It might be easier to see what is going on in the IBM cases without the log scaling:. ![volint_Concentration](https://user-images.githubusercontent.com/67593861/122989251-984e5380-d370-11eb-88cc-ccf4444fb331.png). ### Integrated Boundary Stress; Finally, I looked at the integrated boundary stress along the top wall. The error between the nonIBM and IBM versions at these same grid sizes are below. Unfortunately this is not getting better with increased resolution. This could be due to base state changes causing the stress to change and not necessarily something wrong with the method. It might take better refinement than 256 x 256 to really see a trend here. ![Bickley_dudy_diff](https://user-images.githubusercontent.com/67593861/122987679-dc405900-d36e-11eb-895a-0f66daf9a473.png). Any thought on these results would be greatly appreciated, or if there is something else that might be good to look at with this particular test case. Further refinements to the grid are taking quite a long time to run on my PC, but they can be done. These were run with a viscosity of 0 for the isotropic closure. I want to look at the viscous cases of these to see if the results change at all with added viscosity. I'm also working on some cylinder validation metrics for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588:1544,Integrat,Integrated,1544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588,2,"['Integrat', 'integrat']","['Integrated', 'integrated']"
Integrability,"4+1, Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₁ = φnode(3Nx÷4+1, Ny÷4+1, getregion(grid, panel), Center(), Center()). panel = 4; λ₂ = λnode(Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₂ = φnode(Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()). panel = 3; λ₃ = λnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₃ = φnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()). panel = 6; λ₄ = λnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()); φ₄ = φnode(3Nx÷4+1, 3Ny÷4+1, getregion(grid, panel), Center(), Center()). δR = 2; θ₀ = 1. θᵢ(λ, φ, z) = θ₀ * exp(-((λ - λ₁)^2 + (φ - φ₁)^2) / 2δR^2) +; θ₀ * exp(-((λ - λ₂)^2 + (φ - φ₂)^2) / 2δR^2) +; θ₀ * exp(-((λ - λ₃)^2 + (φ - φ₃)^2) / 2δR^2) + ; θ₀ * exp(-((λ - λ₄)^2 + (φ - φ₄)^2) / 2δR^2). set!(model, θ = θᵢ). θ = model.tracers.θ; fill_halo_regions!(θ). Δt = 0.0015; stop_iteration = 8000. simulation = Simulation(model; Δt, stop_iteration). # Print a progress message; using Printf. progress_message(sim) = @printf(""Iteration: %04d, time: %s, Δt: %s, wall time: %s\n"",; iteration(sim), prettytime(sim), prettytime(sim.Δt),; prettytime(sim.run_wall_time)). simulation.callbacks[:progress] = Callback(progress_message, IterationInterval(100)). tracer_fields = Field[]. function save_tracer(sim); push!(tracer_fields, deepcopy(sim.model.tracers.θ)); end. simulation.callbacks[:save_tracer] = Callback(save_tracer, IterationInterval(20)). run!(simulation). @info ""Making an animation from the saved data..."". n = Observable(1). Θₙ = []; for region in 1:6; push!(Θₙ, @lift parent(getregion(tracer_fields[$n], region)[:, :, grid.Nz])); end. function where_to_plot(region); region == 1 && return (3, 1); region == 2 && return (3, 2); region == 3 && return (2, 2); region == 4 && return (2, 3); region == 5 && return (1, 3); region == 6 && return (1, 4); end. function heatlatlon!(ax::Axis, field, k=1; kwargs...). LX, LY, LZ = location(field). grid = field.grid; _, (λ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1717770543:3301,message,message,3301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1717770543,1,['message'],['message']
Integrability,"67.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) = prettytime(Δt); pretty_Δt(Δt::TimeStepWizard) = prettytime(wizard.Δt). function Base.print(progress::ProgressMessenger); @printf(""i: %04d, t: %s, Δt: %s, ; progress.model.clock.iteration, prettytime(progress.model.clock.time), pretty_Δt(progress.Δt)) ; return nothing; end; ```. One could then expand on this design by setting up the `diagnostics` field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: Str",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1818,message,messages,1818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['message'],['messages']
Integrability,"70 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 17 _advective_momentum_flux_Vw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1970 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 17 overdub; 1970 0 @Oceananigans/src/Operators/difference_operators.jl 23 δyᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 2094 0 @Oceananigans/src/Advection/weno_fifth_order.jl 226 overdub; 2183 0 @Base/operators.jl 560 +(::Float64, ::Float64, ::Float64); 2262 0 @Base/operators.jl 560 overdub; 2381 0 @Oceananigans/src/Advection/weno_fifth_order.jl 216 overdub; 2395 0 @Oceananigans/src/Advection/weno_fifth_order.jl 211 overdub; 2471 0 @Oceananigans/src/Advection/weno_fifth_order.jl 231 overdub; 3033 3033 @KernelAbstractions/src/compiler/contract.jl 18 add_float_contract; 3033 0 @KernelAbstractions/src/compiler.jl 45 overdub; 3688 0 @Oceananigans/src/Operators/difference_operators.jl 26 overdub; 4069 0 @Oceananigans/src/Advection/tracer_advection_operators.jl 28 div_Uc(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twic...; 4069 0 @Oceananigans/src/Advection/tracer_advection_operators.jl 28 overdub; 4202 0 @Oceananigans/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl 186 overdub; 4469 4469 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl ? overdub; 4570 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 57 div_𝐯u(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twic...; 4570 0 @Oce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:41498,contract,contract,41498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['contract'],['contract']
Integrability,"<img width=""356"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/170514466-0fe28fcd-def6-4034-abf6-9c794b4c42f7.png"">. Depends on who ""we"" is",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2577#issuecomment-1138666471:139,Depend,Depends,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2577#issuecomment-1138666471,1,['Depend'],['Depends']
Integrability,"= VectorInvariant(),; free_surface = free_surface,; coriolis = coriolis,; tracers = :c,; tracer_advection = WENO(),; buoyancy = nothing,; closure = nothing). g = model.free_surface.gravitational_acceleration; R = grid.radius; Ω = model.coriolis.rotation_rate. uᵢ(λ, φ, z) = 0.1 * cosd(φ) * sind(λ); ηᵢ(λ, φ, z) = (0.1 * Ω * R + 0.1^2 / 2) * sind(φ)^2 / g * sind(λ); cᵢ(λ, φ, z) = Gaussian(λ - 1, φ - 5, 10). set!(model, u=uᵢ, η=ηᵢ, c=cᵢ). Δt = 0.1 * Δ_min(grid) / sqrt(g * grid.Lz) . for _ in 1:20; time_step!(model, Δt); end. return merge(model.velocities, model.tracers, (; η = model.free_surface.η)); end. Nx = 32; Ny = 32. grid = LatitudeLongitudeGrid(CPU(), size = (Nx, Ny, 1),; halo = (3, 3, 3),; latitude = (-80, 80),; longitude = (-160, 160),; z = (-1, 0),; radius = 1,; topology=(Bounded, Bounded, Bounded)). us, vs, ws, cs, ηs = solid_body_rotation_test(grid). regions = 2; P = XPartition. @info "" Testing $regions $(P)s on $(typeof(grid).name.wrapper) on the $arch""; u, v, w, c, η = solid_body_rotation_test(grid; P=P, regions=regions). u = reconstruct_global_field(u); v = reconstruct_global_field(v); w = reconstruct_global_field(w); c = reconstruct_global_field(c); η = reconstruct_global_field(η). using GLMakie. function plot_to_compare(field1, field2). λ, φ, z = nodes(field1). fig = Figure(fontsize=30); ax1 = Axis(fig[1, 1]); ax2 = Axis(fig[1, 2]); ax3 = Axis(fig[1, 3]). heatmap!(ax1, λ, φ, interior(field1, :, :, 1)); heatmap!(ax2, λ, φ, interior(field2, :, :, 1)); heatmap!(ax3, λ, φ, interior(field1, :, :, 1) .- interior(field2, :, :, 1)). return fig; end. @show @test all(isapprox(u, us, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(v, vs, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(w, ws, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(c, cs, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(η, ηs, atol=1e-20, rtol = 1e-15)); ```. The test for `c` fails. When you then plot. ```Julia; fig = plot_to_compare(cs, c); fig; ```. <img width=""1290"" alt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1506325737:1896,wrap,wrapper,1896,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1506325737,1,['wrap'],['wrapper']
Integrability,"> (Anxiously waiting for this to merge so that I can update my scripts :)). I'll merge but just to be sure, the scripts can be updated provided you depend on `Oceananigans#glw/be-meaner` in your environment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872305587:148,depend,depend,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872305587,1,['depend'],['depend']
Integrability,> (Reduced Fields and Windowed Fields will have to be done separately). I think we just need to make sure these routines can handle `Nothing` boundary conditions and we're fine.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515736:112,rout,routines,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065515736,1,['rout'],['routines']
Integrability,"> (There is some inefficiency in the code that I did the wind and wall stress separately, even though they're basically the same thing, but a kind of merge of how I did each would probably be the most general way todo it because I put more work into the wind stress and just have the very simple flat bottomed law of the wall wall stress. Do you mean computational inefficiency, or inefficiency in terms of code length? For flat surfaces, we've designed an interface in ClimaOcean that depends on a roughness length callable object. This allows one to implement new models for the roughness length (which limit to wavy surface or smooth walls, combinations of the two, or other models). More generally our intent is definitely to encapsulate the parts that are not worth repeating elsewhere, and let users / external packages proliferate to do the interesting parts like designing new roughness lengths. Was that your vision too?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2386534371:457,interface,interface,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2386534371,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,"> (in theory we should not run a simulation with CFL > 1 but that might be desired when we prescribe the velocity). Aren't there time stepping schemes that can handle CFL > 1? This depends on the time-stepping scheme. Le and Moin 1991 claim that the theoretical limit for RK3 is 1.6. But there are other RK schemes with more stages that can handle even higher CFLs. I'm not sure there is a ""theory"" that places an absolute limit on the CFL for all possible schemes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773314840:181,depend,depends,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773314840,1,['depend'],['depends']
Integrability,"> * There is a lot happening here. :) I can have a crack reviewing this but I may ask lots of clarifications?; > * Perhaps we need to expand a bit the [finite volume](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/finite_volume/) section in the docs to clarify what, e.g., `Azᶜᶜᵃ` is? How come `Axᶜᶜᵃ` or `Ayᶜᶜᵃ` are not needed btw?. `Axᶜᶜᵃ` and `Ayᶜᶜᵃ` both depend on vertical location, so the constructs you're mentioning would only be valid on a horizontally-curvilinear but _vertically-regular_ grid. I think we should just encode the general form of operators, so we should have things like `Axᶜᶜᶜ` and `Axᶜᶜᶠ` only.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951037471:394,depend,depend,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951037471,1,['depend'],['depend']
Integrability,"> * Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES). I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. (Note that we do illustrate interfacing with other packages like `Random`, `JLD2`, `NCDatasets`, `Plots`, etc --- but showcasing packages in our ""ecosystem"" specifically is certainly in our interest.). > * Use Python/xarrray to read and plot the data. To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain. I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263:538,integrat,integrated,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263,1,['integrat'],['integrated']
Integrability,"> . You can also treat the CFL limitation due to the free surface by using a mode-splitting technique, solving the vertically integrated equations with the small CFL imposed time-step while doing the full 3D calculations with a larger time step. That would allow for a better representation of shorter gravity waves but needs careful designs to ensure a consistent 2D transport with the 3D velocities (e.g. Killworth 1991, Beckers 1991).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119299248:126,integrat,integrated,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119299248,1,['integrat'],['integrated']
Integrability,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975:891,interface,interfaces,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975,2,['interface'],"['interface', 'interfaces']"
Integrability,"> 1. Should we enforce `.nc` in `NetCDFOutputWriter`? I think it's nice to enforce this. I think the benefit of enforcing it for NetCDF is less clear than for JLD2, so I chose to not place any requirements that NCDatasets.jl doesn't. But again I don't have a strong opinion here. > 2. Related to 1., we may want to provide an interface that omits the extension entirely (eg `filename` has no extension). This leads to an interface that is truly independent --- just change `JLD2` to `NetCDF` and you change the file format (and the extension is updated for you, which is nice!); ; Yeah I like that. Although then it wouldn't be able to be called `filename` imo, since you're not giving the filename anymore :). > Both can be resolved later. Btw the bump is very important because this fixes broken docs!. Can we deal with these in other PRs though? I won't be able to work on these anymore for a couple of weeks and I don't want this PR to go stale (especially because it has doc fixes, like you mentioned).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096:326,interface,interface,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096,2,['interface'],['interface']
Integrability,"> 2\. It would be a good idea in my opinion to support either options of passing the prefix or the filename (as many softwares do) so that we always preservw the extension which I believe is our priority. (Just implement a check on the last relevant characters, if there is a correct extension leave it as is otherwise append it). I think this is an excellent suggestion!. We can do. ```julia; dotindex = findlast('.', filename); possible_ext = isnothing(dotindex) ? """" : filename[dotindex+1:end]; possible_ext == "".nc"" || filename *= "".nc""; ```. We can put similar logic into `FieldTimeSeries`. I was stuck on trying to throw an error if the ext is wrong, which has the major downside that we can't use `.` in filenames anymore. But this is a pretty nice solution I think. The main downside is that if you accidentally call your file `.jld2` for netcdf then you'll end up with a file `.jld2.nc`. But I think we can just _recommend_ that `filename` has no extension and we figure it out. And we also support explicit extensions for users that want that interface, with the caveat that if they screw up they'll have funny filenames. I'll make the changes to the output writers here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345:1053,interface,interface,1053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345,1,['interface'],['interface']
Integrability,"> > (Anxiously waiting for this to merge so that I can update my scripts :)); > ; > I'll merge but just to be sure, the scripts can be updated provided you depend on `Oceananigans#glw/be-meaner` in your environment. I'm aware. I just was waiting for this because master already has some other bug fixes that I want, and it hadn't been merged with this branch. > crossed_fingers hope GPU works since we don't have GPU CI right now... ~Hmm, that's a good point. Now that you merged master into this branch it might be worth waiting and I'll just use this branch.~. Oops, too late! haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872308626:156,depend,depend,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872308626,1,['depend'],['depend']
Integrability,"> > 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.); > ; > I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). Also making this change would mean that a bunch of scripts would fail silently. Meaning that, depending on what/where fluxes are prescribed, the fluxes would flip, producing a completely different result, without Oceananigans throwing an error (since I think we wouldn't change the interface). So if we do go that way I think we'd need to be really careful about it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086349867:854,depend,depending,854,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086349867,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"> > > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > > ; > > > ; > > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > > ; > > ; > > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt.; > ; > But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another. Makes sense. `advect_lagrangian_particles!` first before `dynamics` it is!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866:330,depend,depends,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866,1,['depend'],['depends']
Integrability,"> > > > We could think about a `ParticleAdvectiveForcing` or also a `ParticleVelocityTendency` function that specifies the rhs of dvdt=G; > > > ; > > > ; > > > One example that this might be tricky for this approach is where the particles have a constant sinking velocity on top of the fluid velocity.; > > ; > > ; > > A constant sinking velocity is easy to implement using `dynamics`, since it's constant everywhere and doesn't depend on the position / fluid velocity experienced by the particle.; > ; > I don't think a constant sinking velocity can be implemented in `dynamics` in this setup where `dynamics` comes before advection. You could imagine a particle being advected with its sinking velocity at the `dynamics` step, then later on at the `advect_lagrangian_particles!` it'll be advected by the field velocity at a new location, which will be of a different value. I suppose this is fine if `dynamics` and `advect_lagrangian_particles!` are reversed. For a constant velocity, the only difference that switching the order of function calls makes is the way we interpret the initial condition or final state. For example, if we call `dynamics` _after_ advection, but also shift the initial condition vertical positions by `dt * w_sinking`, then the result would be identical as calling `dynamics` before advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819859736:429,depend,depend,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819859736,1,['depend'],['depend']
Integrability,"> > > @iuryt can we do it in a new PR? I can get it started to illustrate, and you can help me by refining the implementation and getting the tests to pass. What do you think?; > > ; > > ; > > As this new PR will change this current PR, I will work on the new PR first and then come back here.; > ; > @glwagner Should I work on this PR first and then when make the new implementation update the validation scripts again?. Up to you but it seems like you will save yourself some effort if you first update the user interface, and then update the validation scripts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915262473:514,interface,interface,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915262473,1,['interface'],['interface']
Integrability,"> > > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > > ```; > > > ∇⋅(ν∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > > In the future I think it would be better to have something like this,; > > > ```; > > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > > ; > > ; > > This depends on the formulation right?; > ; > Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents.; > ; > For the conservative form, I think it would be easiest to have; > ; > ```; > ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > which does insure that viscosity does not increase kinetic energy. Cool!. We have to write this as a ""rotational"" and ""divergence"" term to reproduce our other results, which only use divergence damping (relying on WENO vector invariant to dissipation enstrophy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091:881,depend,depends,881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091,1,['depend'],['depends']
Integrability,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352:278,integrat,integrated,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352,2,"['bridg', 'integrat']","['bridge', 'integrated']"
Integrability,"> > > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > > ```; > > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > > ; > > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > > ; > > ; > > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > > ; > > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.; > ; > Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?. I think if its a common application, it's important to demonstrate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378:980,depend,depends,980,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378,1,['depend'],['depends']
Integrability,"> > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > ; > > ; > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > ; > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt. But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919:312,depend,depends,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919,1,['depend'],['depends']
Integrability,"> > > Is this something that is handled on the MIT side ?; > > ; > > ; > > Yeah, it’s something the Oceananigans dev team should sort out! :); > ; > Curious to know if there's any movement on getting this resolved. I can offer some help in getting an allocation request in to Pawsey Supercomputing Centre - I mentioned to @navidcy that I have a solution for doing CI on systems with job schedulers (like Pawsey's Setonix).; > ; > If existing hardware systems at MIT are not available for this, I can also help with procurement, if needed. If you go this route, I can look into providing some time on our systems to get testing rolling. @simone-silvestri can you please help with this? I agree its critical to get this PR merged ASAP, it's already getting stale. I think we should contact Satori folks first directly or via @christophernhill . @Sbozzolo might be able to help if there are AMD machines on the caltech cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997634181:554,rout,route,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997634181,1,['rout'],['route']
Integrability,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081:691,interface,interface,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081,2,['interface'],['interface']
Integrability,"> > > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > > ; > > ; > > Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them.; > ; > Ok got it. What's the purpose of that?. Unless I've missed something I believe that structs with `Tuple{:Symbol}` properties can't be passed to GPU kernels when I manually change the element in bgc model I'm having problems with to a tuple of integers it works",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717571221:627,depend,dependent,627,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717571221,1,['depend'],['dependent']
Integrability,"> > > Very interesting idea. How do you plan to combine the different schemes to get a smooth result?; > > ; > > ; > > We'll use the WENO method, which weights candidate stencils based on a smoothness metric.; > ; > Makes sense, thanks!. The non-trivial part of the method is to use a non-trivial stencil to reconstruct `u` at the interfaces of tracer cells. For both advection and continuity we use the (trivial) second-order reconstruction. ```; u_ijk = u[i, j, k]; ```. Yet high-order reconstructions are possible; for example a fourth-order reconstruction (in the x-direction only) is. ```; u_ijk = 13/12 * u[i, j, k] - 1/24 * u[i-1, j, k] - 1/24 * u[i+1, j, k]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081894372:331,interface,interfaces,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081894372,1,['interface'],['interfaces']
Integrability,"> > > We could think about a `ParticleAdvectiveForcing` or also a `ParticleVelocityTendency` function that specifies the rhs of dvdt=G; > > ; > > ; > > One example that this might be tricky for this approach is where the particles have a constant sinking velocity on top of the fluid velocity.; > ; > A constant sinking velocity is easy to implement using `dynamics`, since it's constant everywhere and doesn't depend on the position / fluid velocity experienced by the particle. I don't think a constant sinking velocity can be implemented in `dynamics` in this setup where `dynamics` comes before advection. You could imagine a particle being advected with its sinking velocity at the `dynamics` step, then later on at the `advect_lagrangian_particles!` it'll be advected by the field velocity at a new location, which will be of a different value. I suppose this is fine if `dynamics` and `advect_lagrangian_particles!` are reversed. However, I think that advection forcing should be run at the same time as `advect_lagrangian_particles!`. This would be important for cases where the additional advection is a function of its location for example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819556970:411,depend,depend,411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819556970,1,['depend'],['depend']
Integrability,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:338,integrat,integration,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787,1,['integrat'],['integration']
Integrability,"> > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > ```; > > ∇⋅(ν∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > In the future I think it would be better to have something like this,; > > ```; > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > ; > This depends on the formulation right?. Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents. For the conservative form, I think it would be easiest to have. ```; ∇⋅(ν h ∇⃗ u⃗); ```. which does insure that viscosity does not increase kinetic energy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306:807,depend,depends,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306,1,['depend'],['depends']
Integrability,"> > @tomchor @whitleyv what's the ultimate vision for this PR; > ; > I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. For sure! A forcing function could serve as a prototype for the new tendency kernel function that I'm proposing, right? That was my original motivation for proposing the forcing function --- because we would be able to re-use that code (eg all the right conditionals, etc) when we went to implement immersed boundary conditions in the source code. The new tendency kernel function that @simone-silvestri and I are suggesting would be identical to such a forcing function. > I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input. That's true we have to take care with interpolation. I think the first question is what user API we'd like to support; then we can generate source code to match.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345:1006,depend,dependencies,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345,1,['depend'],['dependencies']
Integrability,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1302,integrat,integration,1302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586,1,['integrat'],['integration']
Integrability,"> > AUUUGHHH that was hard but finally found the source of the type instability:; > ; > which type instability; is this related to discussion in #3750?. Yes. That issue documents slow reductions for windowed fields on immersed boundary grids. I hypothesized that it was due to a failure of type inference. Looking into it further I see that `axes(op::AbstractOperation)` cannot be type inferred when indices is not `(:, :, :)` because of the tuple generator. We found the same problem with `axes` for `Field` and fixed it but didn't fix it for AbstractOperations. Reducing windowed fields on immersed boundary grids requires this because they are wrapped in `ConditionalOperation` in order to mask the immersed regions during the reduction. This PR extends the fix we implemented for `Field` to also encompass `AbstractOperation`. It also cleans up conditional operations quite a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438:647,wrap,wrapped,647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438,1,['wrap'],['wrapped']
Integrability,"> > Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?; > ; > This PR _defines_ the ""buffer"" as the halo dependent region of the domain.; > ; > Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR. Ok, can we leave the refactoring to another PR than to clean up this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122:115,depend,dependent,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122,2,['depend'],['dependent']
Integrability,"> > Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions.; > ; > That's an interesting example. This wouldn't generalize to cut cells, right? Perhaps we need an abstraction that represents the distances to the boundary, for use within boundary conditions. That way we can ensure the distance to the boundary is computed correctly regardless of how the boundary is represented. Agreed. Although I think that's for another PR, right?. > As an aside, hasn't it been shown that MOST is not valid in complex terrain? (That wouldn't prevent it from still somehow improving model fidelity, at least in principle.). Yes, although the discrepancy is less severe for neutral stability, which I suspect encompasses most of the simulations people have been using Oceananigans for. Interestingly, there's been a very recent attempt at generalization that [looks pretty promising](https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.130.124001)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1595915982:77,depend,depend,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1595915982,1,['depend'],['depend']
Integrability,"> > But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet.; > ; > We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term. Right, we need an API for immersed fluxes. I think for continuous functions we can build objects under the hood for each possible location (so six `ContinuousBoundaryFunction` for east, west, south, north, top, bottom). For `discrete_form` we'll need to ponder because in that case to be correct the user must provide six functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397:328,interface,interface,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100198397,3,"['Depend', 'interface']","['Depending', 'interface']"
Integrability,"> > But it's possible to write code that works for all grids by referencing the kernel functions directly (rather than trying to extract the spacings from the grid properties). That's how we get spacings inside the code, so if we use the same method in the user interface then all is good.; > ; > @glwagner, what do you mean here by ""kernel functions""?. By ""kernel function"" I mean ""a function meant to be used inside a kernel"". In our convention these functions have the first four arguments `i, j, k, grid`. An example is `Δxᶠᶜᶜ(i, j, k, grid)`, which gets the x-spacing at face, center, center. Annoyingly they are all defined via metaprogramming, eg:. https://github.com/CliMA/Oceananigans.jl/blob/f4d7a94faeaa00cc48d0f92a26027a90d917ec62/src/Operators/spacings_and_areas_and_volumes.jl#L93. the 2D spacings though are defined . https://github.com/CliMA/Oceananigans.jl/blob/f4d7a94faeaa00cc48d0f92a26027a90d917ec62/src/Operators/spacings_and_areas_and_volumes.jl#L138",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1641138360:262,interface,interface,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1641138360,1,['interface'],['interface']
Integrability,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:927,depend,depending,927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678,1,['depend'],['depending']
Integrability,"> > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `bu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:276,integrat,integrated,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,2,"['bridg', 'integrat']","['bridge', 'integrated']"
Integrability,"> > Does it make more sense for Open to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set OpenBoundaryCondition(nothing) unless a user sets something else.; > ; > This choice should not merely be a question about user interface / convenience but also about how the code internals work.; > ; > One problem is that the topology refers to both sides. We want to support domains that are, for example, bounded on the west but open on the east.; > ; > We do have an abstraction called `RightConnected` for distributed cases. Possibly, we can implement topologies that represent doubly open and single-sided open.; > ; > But to motivate such an abstraction, I think this needs to have implications on the grid level --- not just a way to generate boundary conditions conveniently. I think there are other solutions for generating boundary conditions conveniently. I see, I think having an open boundary does necessarily have grid level implications because every tracer needs to have some open boundary specified if the grid has an open boundary right? I suppose the other way todo this is to check if some tracer has an open boundary specified and add them to all of the others. It would be a bit confusing to keep having this as a boundary condition applied to a `Bounded` direction though since the grid isn't bounded in the same way anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1966755583:297,interface,interface,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1966755583,1,['interface'],['interface']
Integrability,"> > Even if curvilinear grids are not supported yet for the non-hydrostatic model, I like the idea of moving `validate_momentum_advection` to `Models` like `validate_tracer_advection`.; > ; > does this mean that I should actually write separate versions of `validate_momentum_advection` for `HydrostaticFreeSurfaceModels` and 'NonhydrostaticModel` instead?. Just moving `validate_momentum_advection` to the `Models` module is fine. In the end, `validate_momentum_advection` only depends on the grid and the advection scheme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3344#issuecomment-1769755929:479,depend,depends,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3344#issuecomment-1769755929,1,['depend'],['depends']
Integrability,"> > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. I ran a tracer with initial value of 1 everywhere to look at the concentration leakage. I took the percentage of the difference in the area integrated concentration of the IBM and nonIBM scaled by the initial concentration, ie. `100 x abs(IBM - nonIBM)/ initial`. The results are below. It looks like for a 256 x 256 grid after 200s only about 3 x 10^-5 % of the initial concentration has leaked out, which is pretty good and seems to scale well with refinement!; ![volint_Concentration_leakage](https://user-images.githubusercontent.com/67593861/123316291-b051de80-d4fa-11eb-86e7-4ee969af5703.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867903313:633,integrat,integrated,633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867903313,1,['integrat'],['integrated']
Integrability,"> > I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:962,depend,depend,962,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457,1,['depend'],['depend']
Integrability,"> > I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up.; > ; > I'm actually not sure. All that `NonTraditionalFPlane` does is to tilt the rotation axis of an f-plane based on latitude. So it just projects some component of `f` onto the `y` direction. `GeneralFPlane` (or whatever we end up calling it) can tilt the rotation axis in any arbitrary direction, so it can already do what `NonTraditionalFPlane` does (and more). So really (imho) I don't see much use for `NonTraditionalFPlane` after this gets implemented, except maybe as a convenience function. This should definitely replace `NonTraditionalFPlane`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886716989:115,depend,depends,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886716989,1,['depend'],['depends']
Integrability,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:924,wrap,wrap,924,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884,1,['wrap'],['wrap']
Integrability,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:379,depend,depends,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023,1,['depend'],['depends']
Integrability,"> > I think eq 9 in https://clima.github.io/OceananigansDocumentation/previews/PR2639/numerical_implementation/poisson_solvers/ is correct; am I right?; > > if so, I seem to have trouble deriving eq 10…; > ; > OK, I see the derivation in pages 7-8 of https://www.overleaf.com/project/6042a885d8327860fae7cc5e. I think we need to include a bit more steps from this derivation here... Ageed. It seems that we integrate the continuity equation from the bottom, z=-H, to the surface, z=0, exchange the order of integration and differentiation, and then substitute in the kinetmatic boundary conditions at the top and bottom. But maybe even more detail would be helpful?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064:407,integrat,integrate,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064,2,['integrat'],"['integrate', 'integration']"
Integrability,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:1260,rout,route,1260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247,1,['rout'],['route']
Integrability,"> > I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit.; > ; > To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU?. If the precomputation is storing values in an `Array` or `CuArray` (which is already mutable) then no. If you need to precompute a number for every boundary, then yes you need something mutable. But it looks like this would not involve the `BoundaryCondition` itself but rather a component of the boundary condition (eg the `condition` or the `classification`). None of this is hard though. I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558,1,['interface'],['interface']
Integrability,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:87,depend,depends,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237,3,['depend'],"['dependencies', 'depends']"
Integrability,"> > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > ```; > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > ; > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > ; > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > ; > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > ; > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated. Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524:928,depend,depends,928,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524,1,['depend'],['depends']
Integrability,"> > I think we need an required_biogeochemical_auxiliary_fields like required_biogeochemical_tracers because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); > ; > Should the user specify this, or should the biogeochemical model add it its struct (taking in `grid` for this purpose) and evaluate it during `update_biogeochemical_state`?. This is a good point, I think doing it as part of the model in update state is a much better solution",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311540745:300,depend,dependence,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311540745,2,"['depend', 'integrat']","['dependence', 'integrating']"
Integrability,"> > I'm strongly opposed to having multiple small packages.; >; > Why is that, given the benefits?. Mainly I think we can get all the same benefits by maintaining a single unified and tidy repository with sub-modules. I don't see Oceananigans as a complex project yet, we're barely at 2,500 lines of code (minus turbulence closure operators which aren't integrated yet). I can see reasons for having a separate repository for examples and tutorials if there are enough of them, but I don't see e.g. the output writers as being logically separate from the main code. As a stand alone package, OceananigansOutput.jl doesn't do anything useful. Something like TurbulenceClosures.jl could though. Keeping things in tidy submodules within a single repository increases code visibility, which I think is important. When I see a package or framework spread across multiply small packages I find it hard to get an idea about what it can do. Another nice thing is we currently have ""unified versioning"" so when releases occur we know everything works together. We don't have to worry about running with Oceananigans v0.x with OceananigansPlotting v0.y and OceananigansOutput#master to fix some issue. From a development perspective, issues and pull requests are now spread across multiple repositories and we can end up with pull requests that depend on other pull requests in other repositories, e.g. when adding in halo regions the main code got refactored but so did the output writers and plotting code would change as well. We can also end up with multiple test suites that need to pass, plus possibly multiple CI pipelines to manage. So right now it's easy to make atomic changes that touch upon multiple pieces of code (and we'll probably be in this stage where we need to refactor frequently for a while). I also don't have to git clone a bunch of repositories just to work on a simple example. But this is getting off-topic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749:354,integrat,integrated,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749,2,"['depend', 'integrat']","['depend', 'integrated']"
Integrability,"> > I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.; > ; > Thought more about this and I think it might be quite complicated to change to this so I will leave for now. That isn't what `fields` means right now (in fact, it doesn't have much of a concrete meaning at all and is defined rather vaguely, as it arbitrary omits some model fields while including others). Possibly, there is scope for another utility that returns something like ""prognostic + background fields, and selected auxiliary fields). Perhaps `forcing_fields` or something. However, I would pause a moment to consider whether this is the most useful abstraction for users. It may actually prove more limiting than helpful from the user perspective, as it is typically the case that a forcing function (such as a sponge layer) should depend only on perturbation fields rather than a ""total"" field representing perturbation + background...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255:198,depend,dependant,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255,2,['depend'],"['depend', 'dependant']"
Integrability,"> > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > ; > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`. I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time $t$ before it is being advected to time $t + \Delta t$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652:293,depend,depends,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652,1,['depend'],['depends']
Integrability,"> > Is it possible to get julia to ignore the manifest (i.e. specify that we want to ignore it in the CI), so that when a user downloads it they can still use the manifest?; > > Having asked that I don't actually know what the manifest does that isn't already taken care of by the Project?; > ; > The Project compat is supposed to take care of everything. It's just that subtle bugs can creep into packages that might cause things to fail for us (for example something subtle can break type inference, causing everything to fail on the GPU). So using the Manifest is a bit more conservative, because we fix all of the packages that don't _need_ to be upgraded. On the other hand, we are better community members by deleting the Manifest because catching those bugs is important for everyone. To be more specific, with Project.toml we specify compat on packages we depend on, but we do not have compat on packages that our dependencies depend on. The Manifest tracks all packages including dependencies of dependencies (and dependencies of those). We've caught issues in the past by comparing the committed Manifest to another Manifest with different packages. Some issues include, a version of MPI_jll that doesn't work on Mac, or some weird bug in ChainRulesCore... things that we don't have explicit compat for...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361792025:864,depend,depend,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361792025,6,['depend'],"['depend', 'dependencies']"
Integrability,"> > Is this something that is handled on the MIT side ?; > ; > Yeah, it’s something the Oceananigans dev team should sort out! :). Curious to know if there's any movement on getting this resolved. I can offer some help in getting an allocation request in to Pawsey Supercomputing Centre - I mentioned to @navidcy that I have a solution for doing CI on systems with job schedulers (like Pawsey's Setonix). . If existing hardware systems at MIT are not available for this, I can also help with procurement, if needed. If you go this route, I can look into providing some time on our systems to get testing rolling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1995881191:531,rout,route,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1995881191,1,['rout'],['route']
Integrability,"> > It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.; > ; > Yeah, my question was in the sense of ""is there Julia functionality to do that"". If it requires us to write a script to manipulate the text, then I agree that it'd be too much of a headache for something rather hacky... I guess what `Pkg` provides is: if we add `Oceananigans` as a dependency, compat for `Oceananigans` is imposed on `benchmarks/Project.toml`. But this complicates the purpose of the benchmarks, which is to execute the local code. Maybe we can add lines at the top of the benchmark script like. ```julia; using Pkg; Pkg.dev(""..""); ```. Then we add the local version of Oceananigans to the `Project.toml` before the script is executed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049:478,depend,dependency,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090399049,1,['depend'],['dependency']
Integrability,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:348,integrat,integrated,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132,1,['integrat'],['integrated']
Integrability,"> > Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples.; > ; > Yes yes yes!; > ; > Can we have alias?. We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805:42,interface,interface,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805,1,['interface'],['interface']
Integrability,"> > Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?; > ; > Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid.; > ; > I agree that we should have a test for that and maybe something in the docs, sometime?. Added a note in docstring + an `@assert` check. See [43cfed7](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/43cfed75cf5601f543f91eef8cdd3c29d90fa05e)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451:154,message,message,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451,1,['message'],['message']
Integrability,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:50,integrat,integrate,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795,8,"['Integrat', 'integrat']","['IntegratedField', 'integrate', 'integrating']"
Integrability,"> > Requires [JuliaGPU/KernelAbstractions.jl#399](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399) # On hold at the moment; > ; > At the top comment it says this PR depends on another KA PR that isn't merged. However, this PR is merged (and tagged). Does this not depend on [JuliaGPU/KernelAbstractions.jl#399](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399) anymore?. Yeap, it doesn't. I edited the first post ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729628669:176,depend,depends,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729628669,2,['depend'],"['depend', 'depends']"
Integrability,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538:673,interface,interface,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538,2,['interface'],['interface']
Integrability,"> > Some good news is that more tests seem to be passing compared to the prevoius PR.; > > One of the messages I saw was there was a cancellation signal, see below. Lots of the tests just cancelled, and I'm not sure why.; > > ```; > > Testing Oceananigans; > > # Received cancellation signal, interrupting; > > ```; > ; > I don't know what you saw. But what I see here:; > ; > https://buildkite.com/clima/oceananigans/builds/14750; > ; > is that almost all tests pass. Thanks @navidcy , that does look very promising!. The error that I saw is copied below. I am not quite sure where this comes from though.; ```; [8dfed614] Test; Status `/tmp/jl_pRHyI0/Manifest.toml`; [403513] signal (11.1): Segmentation fault; in expression starting at /storage5/buildkite-agent/.julia-14750/packages/CUDA_Runtime_jll/rcOoh/.pkg/platform_augmentation.jl:102; Allocations: 2907 (Pool: 2899; Big: 8); GC: 0; ERROR: failed process: Process(`/storage5/buildkite-agent/julia-1.10.2/bin/julia -C native -J/storage5/buildkite-agent/julia-1.10.2/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_pRHyI0/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/storage5/buildkite-agent/.julia-14750""]); append!(empty!(Base.DL_LOAD_PATH), String[]); cd(""/storage5/buildkite-agent/.julia-14750/packages/CUDA_Runtime_jll/rcOoh/.pkg""); include(""/storage5/buildkite-agent/.julia-14750/packages/CUDA_Runtime_jll/rcOoh/.pkg/select_artifacts.jl""); ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-libstdcxx30-julia_version+1.10.2`, ProcessSignaled(11)) [0]; Stacktrace:; [1] pipeline_error; @ ./process.jl:565 [inlined]; [2] read(cmd::Cmd); @ Base ./process.jl:449; [3] collect_artifacts(pkg_root::String; platform::Base.BinaryPlatforms.Platform); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:720; [4] collect_artifacts; @ /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458:102,message,messages,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458,1,['message'],['messages']
Integrability,"> > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them. Ok got it. What's the purpose of that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716883676:615,depend,dependent,615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716883676,1,['depend'],['dependent']
Integrability,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:1629,integrat,integration,1629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509,1,['integrat'],['integration']
Integrability,"> > The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:; > ; > ; > First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this.; > You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface.; > > As I said though, I agree it's a good idea to make this kind of thing easier. Actually I realized that `dynamics` is called _before_ advection, which makes it more annoying:. https://github.com/CliMA/Oceananigans.jl/blob/dd893745e50fd7aef945f765df929d2a7510db6e/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L123-L132. That makes it a little trickier. It's still possible, since you can compute a ""fake particle update"", and then add the inertia term, before the ""real update"" that occurs in `advect_lagrangian_particles!`. But it's complicated. Why do we call `dynamics` before advection? Should we switch the order of those two? It also seems like we should update particle properties _after_ we advect the particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649:468,interface,interface,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819370649,2,['interface'],['interface']
Integrability,"> > This is good after changes.; > > My only question is whether another implementation might be something like; > > ```julia; > > function Base.:(==)(grid1::AbstractGrid, grid2::AbstractGrid); > > !isa(grid2, typeof(grid1).name.wrapper) && return false; > > topology(grid1) == topology(grid2) && return false; > > ; > > x1, y1, z1 = nodes((Face, Face, Face), grid1); > > x2, y2, z2 = nodes((Face, Face, Face), grid2); > > ; > > return x1 == x2 && y1 == y2 && z1 == z2; > > end; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > This has different behavior than what's implemented here. In particular, two grids will be identified as equal even if one has ""number spacing"" (eg a constant) whereas the other has array-spacing with all the values equal to that number. In other words, while; > > ```julia; > > julia> 1.0 == ones(2); > > false; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > we may want to identify this case with numeric equality for a grid.; > > The key here is that two grids are ""equal"" if they have the same nodes. The other properties (like spacings) are really implied by the placement of the nodes.; > ; > OK, perhaps then your suggestion is better. What about when two grids are otherwise the same but one lives on GPU and one on CPU. Will the above render them equal? I guess no since, e.g., `z1 == z2` will return false if one is an Array and other a CuArray. Actually, the julia gods have decided that CPU and GPU arrays can be numerically equal:. ```julia; julia> using CUDA. julia> a = rand(3); 3-element Vector{Float64}:; 0.3492331921297629; 0.4354818891776633; 0.684771954777823. julia> a == CuArray(a); true; ```. Since we use `==` on the nodes (which are always arrays), we retain the behavior that a CPU grid and a GPU grid can be _numerically_ identical via `==`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951556601:229,wrap,wrapper,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951556601,1,['wrap'],['wrapper']
Integrability,"> > Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`; > ; > Actually, even putting `@show ""hi""` **just before** `calculate_pressure_correction!` also does the job. Right, `calculate_pressure_correction!` does nothing for the free surface model so it shouldn't matter where it's placed relative to that. Is that the only place within `time_step!` that fixes it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299382102:140,synchroniz,synchronization,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299382102,1,['synchroniz'],['synchronization']
Integrability,"> > Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.; > ; > Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though.; > ; > We can calculate more metrics for sure.; > ; > I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?; > ; > Here are some docs:; > ; > https://numba.pydata.org/numba-doc/latest/user/parallel.html. You run out of memory bandwidth at some point - usually before you get to saturate all the cores for something; like diffusion. So some of 16 thread drop off could be that. . I guess we could get even more minimalist and check a multi-threaded stream benchmark to see that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304:249,depend,dependent,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304,1,['depend'],['dependent']
Integrability,"> > We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type.; > > Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector).; > ; > Okay, so a longer term plan.; > ; > For the moment we need that `HydrostaticModel` uses traditional f- or beta-plane, or something that does the same thing. It is `NonhydrostaticModel` that will allow for more types of coriolis terms. Understood. Note too that the problem is really specific to a spherical geometry. In a rectangular geometry, a thin aspect ratio approximation is mathematically equivalent to a change in the axis of rotation. In a spherical geometry this is no longer possible and we need to explicitly state that we are making a hydrostatic approximation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888491064:120,depend,depends,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888491064,1,['depend'],['depends']
Integrability,"> > We could think about a `ParticleAdvectiveForcing` or also a `ParticleVelocityTendency` function that specifies the rhs of dvdt=G; > ; > One example that this might be tricky for this approach is where the particles have a constant sinking velocity on top of the fluid velocity. A constant sinking velocity is easy to implement using `dynamics`, since it's constant everywhere and doesn't depend on the position / fluid velocity experienced by the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819491364:392,depend,depend,392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819491364,1,['depend'],['depend']
Integrability,"> > What's the error with `TimeInterval`?; > ; > I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel. (copy-pasting from #2618). One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698:829,interface,interface,829,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698,1,['interface'],['interface']
Integrability,"> > Yeah, I can change it back to be similar to how it was before?; > ; > I'm not sure exactly how it was before --- but if that works, it works! I can also help (next week, it's Thanksgiving right now over here in the US). Done this now, to make it work with `SomethingBiogeochemistry` I had to add the light attenuation model as a property of the `SomethingBiogeochemistry` so it can integrate, I think it works okay?. Edit for clarity: the default is to have no light attenuation model so if users don't want to integrate one (like the origional phytoplankton growth model) they don't have todo anything.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1330454554:386,integrat,integrate,386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1330454554,2,['integrat'],['integrate']
Integrability,"> > ```julia; > > OpenBoundaryCondition(nothing) # impenetrable; > > OpenBoundaryCondition(1) # external state = 1, no matching scheme; > > OpenBoundaryCondition(external_state, matching_scheme) # explicit matching scheme; > > ```; > ; > This does seem like the best user interface for it. Is keeping the external state in the condition and the matching scheme in `Open` okay then?. We can have this syntax whether or not we separate where the external state and matching scheme are stored. I prefer keeping them together because I believe the source code will be easier to understand in that case. I think we should also discuss with @simone-silvestri.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986537294:272,interface,interface,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986537294,1,['interface'],['interface']
Integrability,"> > `test_dynamics.jl` fail.; > > Is this correct here?; > > https://github.com/CliMA/Oceananigans.jl/blob/ad110ecdc635192c110e229df4fbfa04fc7a2266/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L39-L41; > > ; > > I guess it should be `if formulation == VerticallFormulation() and ...`?; > ; > No that's correct --- we can't use vertically implicit time-stepping with `HorizontalFormulation`.; > ; > The reason is that `HorizontalFormulation` has no vertical terms. Then the error message should be `only supported for `VerticalFormulation or ThreeDimensionalFormulation""`, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185:514,message,message,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185,1,['message'],['message']
Integrability,"> > afaik the second test filter is only needed when assuming that `β` can vary between scales.; > ; > I think you're correct here! Sorry for the confusion here, but I suppose by scale-invariance I mean `β` has a power law dependence on the scale size. And since we were trying to implement the scale-dependent version, `β` would vary across different scales? Hence we need the `α=4` filter as well. Am I understanding Equation (26) in [Bou-Zeid et al. 2005](https://dx.doi.org/10.1063/1.1839152) correctly here?. Ah, I see, I was under the impression you were trying to implement the scale-_invariant_ version, but it does make sense to if you're implementing the scale-dependent version.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3638#issuecomment-2187294884:223,depend,dependence,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3638#issuecomment-2187294884,3,['depend'],"['dependence', 'dependent']"
Integrability,"> > or in general, coming up with a system that makes sure that the API is compatible with the choice of complex BCs For example, in a script people should not be allowed to do; > > ```julia; > > u, v, w = model.velocities; > > fill_halo_regions!((u, v, w)); > > ```; > ; > I understand the first part, but can you explain why the latter isn't desirable and why it would be hard to come up with something? The way I see it, if we set in stone that `fill_halo_regions!()` needs to have `clock` and `fields(model)` passed, then can't we just remove the method that would make `fill_halo_regions!((u, v, w))` possible?. No, we definitely don't want that. That would make it impossible to use `Fields` without a model. We want simple / default boundary conditions to work without an entire model state. One has to understand the additional arguments to `fill_halo_regions!` as part of a system to support _additional_ features for fields, such as boundary conditions that depend on other parts of the model state. There's a circular depedancy issue: when field boundary conditions depend on other fields, the entire system of fields must be created simultaneously for the computation to work properly. We don't have a _general_ system for this. We just support it within the context of a model, like the hydrostatic or nonhydrostatic model. This works because whenever we fill halo regions _within_ the model time-stepping algorithm, we can indeed incorporate the whole model state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179182260:968,depend,depend,968,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179182260,2,['depend'],['depend']
Integrability,"> @Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the momentum equations.; > ; > If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue. @francispoulin I am interested deriving/testing closures in the 2D Adv-Diff equation in the (general) case of periodic shear flows. A constant shear flow won't do it. More like a velocity field that can be decomposed into a shear flow u(y) (e.g. a cosine in y or sum of cosines) plus a cellular flow (square waves). I am still a newbie over here, so I am open to trying different models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388:396,depend,depending,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388,1,['depend'],['depending']
Integrability,"> @ali-ramadhan and @glwagner is the incmod(), decmod() stuff the right thing to do in this. I am trying to think how this will interact with Halo() code elsewhere? Would we be better off filling halos at various intermediate stages for now. We can then tidy up and use wiser halos later? Any thoughts?. Not sure if this is the final form of this PR, but I suggested we just merge the closures as is, with operators that use `incmod1` and `decmod1`, mostly to integrate the closures ASAP. It's definitely inconsistent with the rest of the fields that actually use halos. We could focus on cleanup of this kind once we verify that the LES closures work, unless this is a pretty urgent issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-509414597:460,integrat,integrate,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-509414597,1,['integrat'],['integrate']
Integrability,"> @ali-ramadhan would it be good to send messages to everyone who has a fork maybe and maybe keep an issue open, so people who have cloned can see?. That's a good idea, I think the only other person who had an issue was @arcavaliere who had an open PR at the time, but otherwise we could tag all the forkers. > Of course it would also be good not to rewrite the history - that pretty much breaks how git works. In theory reviewing PRs should catch this?. Agreed. Yeah it took us a while to find the leak in #509 (JLD2 file wasn't added by us but by examples generating files when built) and the damage was contained to the `gh-pages` branch but the reason it affected the `master` branch was that I also deleted an old regression test file. Now that we're more aware of this issue I think we can stop it from happening again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577237824:41,message,messages,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577237824,1,['message'],['messages']
Integrability,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:1126,wrap,wrapping,1126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436,1,['wrap'],['wrapping']
Integrability,"> @glwagner : I understand what you are saying about the traditional approximation.; > ; > If we include the non-tradidtional terms, we obtain the Quasi-Hydrostatic model, as discussed in the MITgcm. This is something we can solve in the `HydrostaticModel`, right?; > ; > I'm not suggesting we change the name of the model but I thought we could use this in either model, but maybe there's a problem because of the pressure solve, which might not allow for this?. We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type. Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888444391:580,depend,depends,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888444391,1,['depend'],['depends']
Integrability,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?. @francispoulin I think he's talking about the fact that the graph on the right (the domain average/integrated momentum) isn't monotonic for IBM cases. Overall it has the correct tendency (loss of momentum) but has small scale fluctuations that aren't physical (i.e. there's no physical mechanism increasing the avg momentum in the domain, so the fluctuations must be numerical in origin).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101512266:266,integrat,integrated,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101512266,1,['integrat'],['integrated']
Integrability,"> @glwagner Yes you are right. I tried restarting Julia, and it worked without the error message. Sorry!. no worries!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386940947:89,message,message,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386940947,1,['message'],['message']
Integrability,"> @glwagner arguably it could be biogeochemonanigans.jl or biogeocheminanigans.jl ?. I know _chemistry_! Ahaha I like those. `Biogeochemmingaround.jl`? Ok, let's brainstorm. > Thinking more, it would be so the function automatically adds the callbacks to the simulation?. There are multiple possible places where one might update the `biogeochemical_state`. An ""external"" paradigm requires `Callback`. But an ""embedded"" paradigm can hard-code functionality into `update_state(model)!`:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl. I think we want to pursue code design that allows these paradigms to be interchanged. I think it's crucial that functionality developed ""externally"" can be ""copy/pasted"" into `Biogeoceananigans.jl`. This probably would be less pretty than it sounds (style, code quality, names...), but I think is still a good organizing principle for the design. > Would it be interesting to think about an interface that could be helpful for projects like https://github.com/openjournals/joss-reviews/issues/4207/https://github.com/JuliaOcean/PlanktonIndividuals.jl from @[zhenwu0728](https://github.com/zhenwu0728) and @gaelforget too at some point?. I see very much what you're saying. There's an opportunity to also support biogeochemistry on Lagrangian particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116870174:999,interface,interface,999,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116870174,1,['interface'],['interface']
Integrability,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847:80,interface,interfaces,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847,2,"['integrat', 'interface']","['integrator', 'interfaces']"
Integrability,"> @liuchihl Have you tried running on the CPU to see if you get a more useful error message?. Thanks, I'll give that a try. I could be wrong, but my guess is that the issue might be related to the use of GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429704389:84,message,message,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429704389,1,['message'],['message']
Integrability,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:340,integrat,integration,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702,1,['integrat'],['integration']
Integrability,"> @navidcy thanks, I was able to bring the branch up to date to a more reasonable delta. @glwagner I think there's no need to separate ROCm support and multi-GPU support, since multi-GPU support was mostly dependent on modifications in PencilFFTs.jl. If the PencilFFTs update is small, that makes it a great candidate for a small independent PR. It's especially important here because there is potentially a conflicting PR: https://github.com/CliMA/Oceananigans.jl/pull/2538. Perhaps we can do the distributed FFT PR first if its easy, then continue working on AMD support? There are likely a fair number of users interested in multi GPU. Hopefully we can make the new PR compatible with https://github.com/CliMA/Oceananigans.jl/pull/2538.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1451020491:206,depend,dependent,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1451020491,1,['depend'],['dependent']
Integrability,"> @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > ; > ```; > ∇⋅(ν∇⃗ u⃗); > ```; > ; > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > ; > In the future I think it would be better to have something like this,; > ; > ```; > 1/h ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR. This depends on the formulation right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980:668,depend,depends,668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980,1,['depend'],['depends']
Integrability,"> @simone-silvestri, will you expand this regression to `ImplicitFreeSurface` as well? If not, then perhaps add a note in one of the `@info` messages clarifying e.g. ""... with explicit free surface formulation""?. Good idea, if the test is still cheap!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956275604:141,message,messages,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956275604,1,['message'],['messages']
Integrability,"> @tomchor @whitleyv what's the ultimate vision for this PR. I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. So I'd prefer something a little more exact.) Hard coding this option in is mostly a test to see how it would go while using the available framework, before creating a full method that users would be able to implement nicely. . Implementing immersed boundary conditions as a separate term would work, I believe! A `value` immersed option wouldn't involve as much effort (as we've previously worked out for no slip), besides getting the direction correct. I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953:979,depend,dependencies,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953,1,['depend'],['dependencies']
Integrability,"> @tomchor I found some dispatch on `ComputedField` --- but nothing about the output construction should depend on whether a field has an abstract operation underneath or not; all of the logic we are working on regards data but not operand, right? Do you mind if I clean this up? I also think we need to sort out a bug with `parent_index_range`. Not at all! I'm taking long with this PR because I'm not that familiar with the internal workings on `Field`s. I'm currently editing some files right now but honestly it doesn't feel like I'm making any progress, so feel free to help me out. And I appreciate it :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127151051:105,depend,depend,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127151051,1,['depend'],['depend']
Integrability,"> @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?. The specific purpose atm is to make this code on Oceanostics work (currently it does not):; https://github.com/tomchor/Oceanostics.jl/blob/29a544d3decd833d9f86da05b66a7392197c3b93/src/Oceanostics.jl#L25-L39. The bigger purpose is to make it easier for users to work with viscosities and diffusivities. As far as I know there isn't a unified interface to getting these fields. I've needed that many times in the past in my scripts and had to use `if-else` statements to get ν and κ for each closure. I think it'd help users if Oceananigans could provide a standard interface for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940:43,interface,interface,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940,4,['interface'],['interface']
Integrability,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:954,Wrap,Wrapping,954,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212,1,['Wrap'],['Wrapping']
Integrability,"> Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? [- @glwagner]. Flux boundary conditions are both conceptually and practically easier to implement when the boundary fluxes are zero or constant. They can be trickier when they depend on interior flow variables. In our case, for example, the boundary condition on the perturbation variable $b'$ (the buoyancy tracer in Oceananigans) is that the *total* diffusive flux should vanish, which means the *perturbation* diffusive flux needs to be minus the *background* diffusive flux. . ![image](https://github.com/CliMA/Oceananigans.jl/assets/12971166/d5eae1d6-4aa8-438e-870b-0ff17352dcea). Imposing a flux boundary condition requires knowing the diffusivity $\kappa$ right at the boundary. It is obvious how to implement this if the diffusivity is a constant, because the background diffusive flux is also a known constant, but less obvious how to do it when using a subgrid turbulence closure that yields a diffusivity that varies in space and time. @tomchor pointed out to use that we can sidestep this complexity if we just divide both sides of the boundary condition by $\kappa$, because then the boundary condition simply becomes that the buoyancy gradient across the boundary should just be equal to minus the background buoyancy gradient—a known constant in our problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146:272,depend,depend,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146,1,['depend'],['depend']
Integrability,"> After some thought, I think what we want to do is to implement a way to implicitly time-step components of the model term by term (rather than implementing some way to time-step part of a term implicitly. For the implicit time-stepping API are you thinking of supporting 3D implicit time-stepping or just vertically implicit? I guess 3D implicit could be slow but in the right situations (e.g. low Re) could allow much longer time steps. If we just want to tackle vertically implicit for now, would the implicit time-stepping look pretty similar to OceanTurb's backward Euler: https://glwagner.github.io/OceanTurb.jl/latest/numerics/#Time-integration-methods ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-783471566:641,integrat,integration-methods,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-783471566,1,['integrat'],['integration-methods']
Integrability,"> Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model. Even more than details associated with particular challenging ODEs is the more fundamental software challenge of designing a flexible and useful system for user-specification of ODEs (special fields defined on sets of particles, each associated with an independent ODE that is coupled to the model solution) to be solved on particle trajectories. If we were integrated with DifferentialEquations.jl, this might not be all that hard, however.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256:668,integrat,integrated,668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256,1,['integrat'],['integrated']
Integrability,"> Ah interesting. Does this work because broadcasting over GPU subarray views is a little rough around the edges?; > ; > Also, is it worth adding the MWE from [#1767 (comment)](https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868793917) as a test?. Certainly _something_ is rough... I think it's ""broadcasting over ReducedField"" that's the issue here. Prior to this PR, `mean!` used a broadcast over `R::AbstractReducedField` to compute the normalization. For some reason this has data synchronicity issues on the GPU (I'm at a loss to explain why). This PR just changes that broadcast operation to compute over all members of `R`. The halo regions of `R` (presumably) aren't touched during `sum!`, so doing some extra normalization in the halos doesn't really matter, I guess... (if we want halos to be right we should probably fill them after executing `mean!` in `compute!`, or something). But the _reason_ why this change fixes the issue isn't at all obvious to me. Maybe there's a bad interaction between `KernelAbstractions` (which gets used for the broadcast) and `sum!`? Not sure. Maybe another solution would wrap `sum!` in `CUDA.@sync` (eg the solution here could _implicitly_ synchronize in order to perform the broadcast correctly; otherwise CUDA wouldn't work generally... ?!?). Might be worth testing that, though I don't know which solution we should prefer (if any). In fact, it seems better to avoid using custom broadcasting machinery if possible (which is the current solution)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671:1135,wrap,wrap,1135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671,2,"['synchroniz', 'wrap']","['synchronize', 'wrap']"
Integrability,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319:1169,message,message,1169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319,1,['message'],['message']
Integrability,"> Ali, i thought the stretching was sorted now, after the hackathon. Without stretching the code will have limited use. John. Yes well, we know how to do a very fast Poisson solve in a vertically stretched grid but still working on integrating it (PR #306). The fast solver (which relies on cyclic reduction) may need some massaging to work with Neumann boundary conditions for pressure... The plan is to merge the vertically stretched grid with the finite volume operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-510488262:232,integrat,integrating,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-510488262,1,['integrat'],['integrating']
Integrability,"> All 6 boundaries are something like; > ; > ```julia; > using Oceananigans.AbstractOperations: flip; > ; > east_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); > south_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, flip(LY), LZ, i, j, k, grid); > bottom_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, LY, flip(LZ), i, j, k, grid); > ; > west_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i+1, j, k, grid) ; > north_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, flip(LY), LZ, i, j+1, k, grid); > top_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(LX, LY, flip(LZ), i, j, k+1, grid); > ```; > ; > something like that. There could be a mistake. Yep I think this would work...; Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not), in that case we would need ; ```; bottom_bounded(LX, LY, LZ, i, j, k, grid) = solid_node(LX, LY, LZ, i, j, k-1, grid) & !solid_node(LX, LY, LZ, i, j, k, grid)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176083:1022,Depend,Depends,1022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176083,1,['Depend'],['Depends']
Integrability,"> Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?. This PR _defines_ the ""buffer"" as the halo dependent region of the domain. Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397258056:113,depend,dependent,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397258056,2,['depend'],['dependent']
Integrability,"> Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions. That's an interesting example. This wouldn't generalize to cut cells, right? Perhaps we need an abstraction that represents the distances to the boundary, for use within boundary conditions. That way we can ensure the distance to the boundary is computed correctly regardless of how the boundary is represented. As an aside, hasn't it been shown that MOST is not valid in complex terrain? (That wouldn't prevent it from still somehow improving model fidelity, at least in principle.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1591106939:75,depend,depend,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1591106939,1,['depend'],['depend']
Integrability,"> Also we get some deprecation warnings. E.g., for; > ; > ```; > SpecifiedTimes(times::Vararg{<:Number}) = SpecifiedTimes(sort([Float64(t) for t in times]), 0); > ```; > ; > we get; > ; > ```; > Wrapping `Vararg` directly in UnionAll is deprecated (wrap the tuple instead).; > ```; > ; > I don't understand what that means tho. I think a39445a and [bf06da1](https://github.com/CliMA/Oceananigans.jl/pull/3100/commits/bf06da180131d8cbede895913d21aa9348684095) dealt with this",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566861284:195,Wrap,Wrapping,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566861284,2,"['Wrap', 'wrap']","['Wrapping', 'wrap']"
Integrability,"> Also, we should not use β for the haline contraction coefficient.; > ; > _Originally posted by @glwagner in https://github.com/glwagner/OceanTurb.jl/issues/41#issuecomment-506905395_. +1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/20#issuecomment-506906377:43,contract,contraction,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/20#issuecomment-506906377,1,['contract'],['contraction']
Integrability,"> Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though. Doesn't this depend on the setup? The actual ocean bottom is littered with boulders and other features of various sizes, and there's plenty of work in very steep canyons, ie https://en.wikipedia.org/wiki/Scripps_Canyon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067:261,depend,depend,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100251067,1,['depend'],['depend']
Integrability,"> Am I correct in thinking that we want xspacing, yspacing, zspacing, etc. (+ λ, φ, ξ, η, r) to all be functions of (i, j, k, lx, ly, lz, grid) and return a number?. yes. > Then we want xspacings, yspacings, zspacings, etc. to return an array of spacings (perhaps with a with_halos flag)? Should it be an array or a Field?. The cleanest implementation is to return a `KernelFunctionOperation` that calls `xspacing`, `yspacing`, etc, under the hood. I don't really like `with_halos`, I think that's a plotting issue not a spacing issue. We can solve that via the Makie extension. Or one can write `Field(xspacings(grid, lx, ly, lz), indices=(1:Nx, 1:Ny, 1:Nz))`. `Field` works too as a return type but I don't think we need to always allocate memory for the spacings. One barrier to this was plotting, but this issue is beginning to be solved with the new extension:. https://github.com/CliMA/Oceananigans.jl/blob/f2a8fb32251135f9cd9b230e0873f7bc1936f762/ext/OceananigansMakieExt.jl#L41-L45. > Should the returned array/field be reduced when possible?. The `KernelFunctionOperation` should have `Nothing` locations if the spacings / metrics do not depend on that direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822:1147,depend,depend,1147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450510822,1,['depend'],['depend']
Integrability,"> And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4 ; > Note/update:; > ; > Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336:387,depend,dependant,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336,2,['depend'],['dependant']
Integrability,> Another issue to add into this discussion is the fact of how to handle output (e.g. file.nc) with checkpoints and file_splitting. I propose handling this by initializing output files within `run!` rather than during instantiation of the output writer. This is separate from the interface discussion here though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391721684:280,interface,interface,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391721684,1,['interface'],['interface']
Integrability,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263:199,interface,interface,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263,1,['interface'],['interface']
Integrability,> Another place I think we need to change is particle advection:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/f3113c492f309846f026e0ac150dc8480f96e0f2/src/LagrangianParticleTracking/update_particle_properties.jl#L157-L161; > ; > Because currently background velocity fields don't get integrated which I think is wrong? At least in the case I was using them for I had to add the background velocities manually. Totally agree particles should be advected with prognostic + background,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482935693:292,integrat,integrated,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482935693,1,['integrat'],['integrated']
Integrability,"> Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?. Sorry I forgot to reply to this sooner. If we use `ch` then we can write the advection term as a divergence form, and then use a lot of the existing code that we have for the other models. This seems easier to me, rather than having to write different solvers for the alternative form of advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447:165,integrat,integrated,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447,1,['integrat'],['integrated']
Integrability,"> As far as I know there isn't a unified interface to getting these fields. The interface for `AbstractScalarDiffusivity` is the function `viscosity(closure, diffusivities)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114,2,['interface'],['interface']
Integrability,"> As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would HydrostaticCurvilinearCoriolis be appropriate?. I haven't added `HydrostaticCurvilinearCoriolis` yet --- I'm planning to implement that once the PR is merged. At the current moment, I've only changed `BetaPlane`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605:100,depend,depends,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605,1,['depend'],['depends']
Integrability,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:197,interface,interface,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990,1,['interface'],['interface']
Integrability,"> Awesome!; > ; > How big is `wet_cells_map`? Should we extend `ImmersedBoundaryGrid` so that users can opt in/opt out of this feature?. It is not that large, I figured that with `UInt16` we can cover almost all practical cases. `wet_cell_map` will be a vector of _active_ locations defined by a tuple of indices. Depending on what % of the domain is active, the size of the map will be. `prod(size(grid)) * %active * 3 * sizeof(Type)`. where `Type` is the `UInt` with the minimum size required to represent `maximum(size(grid)))`; In the example of the ocean, where 57% of the domain is active, the map is 42.75% the size of a standard Float64 `Field`:. a UInt16 occupies 2 bytes, so compared to a field, the map is . `(0.57 * 3 * 2) / 8 ≈ 0.4275` . I guess adding the opt in/opt out can be nice and is very easy because of . https://github.com/CliMA/Oceananigans.jl/blob/b7835edbac0a7318d49462addb1c1046014e39c4/src/ImmersedBoundaries/wet_cells_map.jl#L10-L21. which is used now to calculate the map only when we construct the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775:314,Depend,Depending,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775,1,['Depend'],['Depending']
Integrability,"> Before I push my local commits, does Manifest.toml require any changes?. `Manifest.toml` typically has to be synchronized with `Project.toml`, so it probably will have to be updated if you've changed `Project.toml`. In a perfect world (if our package compatibility bounds in `Project.toml` were perfect) then users could generate `Manifest.toml` on their local machine without requiring a committed version. However, it turns out to be a bit annoying to keep compatibility bounds up to date, so we use the `Manifest.toml` as a hack. Since we can't really review changes to the `Manifest.toml` it's best to be conservative about updating packages, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-866286260:111,synchroniz,synchronized,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-866286260,1,['synchroniz'],['synchronized']
Integrability,"> Before proceeding further, I guess we should discuss a bit on whether we want a single parameter for gravitational acceleration (`effective_gravitational_acceleration`, which can encapsulate both gravitational acceleration `g` and reduced gravity `g'` terms) or two parameters (one for `g` and `g'` each), with Navid's code above an example of the latter. I am inclined towards the former as I feel it's cleaner (scientifically and for coding purposes), but happy to go either ways. I didn't really think through my code above so don't pay too much attention to it. :); It was just a placeholder to demonstrate about parametric types. But I don't understand exactly what you suggest. `gravitational_acceleration` is a number, and it the same regardless of the number of layers you have. It's the acceleration that the top-layer surface feels (given that we use the approximation that `ρ_air ≪ ρ_fluid`. The reduced gravities `g'_{k+1/2} = g * (ρ_layer_k+1 - ρ_layer_k) / ρ_layer_k+1` are the gravitational accelerations each of the fluid interfaces feel. So `g'` is a Tuple of `k-1` numbers, where `k` is the number of layers, right? And this parameter is irrelevant for the SingleLayerModel. Were you suggesting to combine these in a single `k`-long tuple, e.g.,. ```julia; gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); ```; which will become a number for single layers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937:1040,interface,interfaces,1040,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937,1,['interface'],['interfaces']
Integrability,"> But I guess users don't have to worry about ghost cell values and nonlinear diffusivities as they'll get filled in or calculated as needed. That's not quite true for the ordinary definition of ""as needed"". Halos and nonlinear diffusivities are only filled or calculated immediately prior to a time-step! If you `set!` the model state (or even if you time-step the model forward), you cannot actually calculate, diagnose, or plot 1) the gradients of fields across boundaries or 2) the nonlinear diffusivities. In fact, it hadn't occurred to me previously but with our current paradigm the LES diffusivity field that is output is actually inconsistent with the velocity field even if they are output at the same `model.clock.time`. So at the moment this is a legitimate concern. Are the ""atmospherigans"" being discussed here of the same form? Are some of these fields related diagnostically to one another, or are they only related diagnostically along a model boundary? (Or something --- its hard for me to generalize from the example given above.). We may want to develop the concept of a model ""state"". We can provide a function `update_state!` that updates all fields (eg halos + fields that depend diagnostically on others like nonlinear diffusivities and possibly others), and use this both in `set!` as needed, during time-stepping, and prior to output. We can also create a system for 'tagging' components of the model that have `update_state!` methods attached to them. For example, some turbulence closures require the computation of perturbations from a horizontal average (eg, the buoyancy perturbation). Such fields would also need to be updated during an `update_state!` call. The lack of such an abstraction is currently a barrier to the implementation of those turbulent closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-583382816:1196,depend,depend,1196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-583382816,1,['depend'],['depend']
Integrability,"> But I realized that a second way to implement this immersed flux is to re-use the conditional flux functions, but reverse the logic. Not sure what is best yet. We did run into the problem with the conditional flux functions, that fluxes located on the same spot (like `_fcc`), won't be checking the same faces for an interface/ normal direction (`_uy` will be checking the south-north interface and `_vx` would be east-west). Depending on the function, the symmetric fluxes might not be assigned as the same either, esp. when it comes to interpolation. We just made new separate conditional flux functions for each viscous flux combo, but that might not be the way to go long term.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818:319,interface,interface,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100172818,3,"['Depend', 'interface']","['Depending', 'interface']"
Integrability,"> But it's possible to write code that works for all grids by referencing the kernel functions directly (rather than trying to extract the spacings from the grid properties). That's how we get spacings inside the code, so if we use the same method in the user interface then all is good. @glwagner, what do you mean here by ""kernel functions""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638272192:260,interface,interface,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638272192,1,['interface'],['interface']
Integrability,"> But this PR doesn't require users to use 1.10 right? It's just about running the tests on 1.10. (Yes, but also the Manifest includes a lot of updates for various dependencies so that all pkgs versions are resolved with v1.10.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022:164,depend,dependencies,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1945461022,1,['depend'],['dependencies']
Integrability,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:35,interface,interfaces,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470,4,"['integrat', 'interface']","['integrated', 'interface', 'interfaces']"
Integrability,"> Can spatial units be set?. Spatial attributes can be set but Oceananigans.jl assumes meters right now so more unit misattribution. If the time units can be set, then we should be able to set the spatial units. > Are packages like Unitful.jl not mature enough to be used for these purposes? I understand this is a pretty extreme solution for this problem specifically, but It would be pretty cool if Oceananigans could understand units. I think it's mature enough but not I guess we're not sure where to use it (we discussed a bit in #1116). Would be perfect for specifying these kinds of units as long as it's not a heavy dependency. For other simulations, e.g. icy moons, it's nice to use rotation periods. Another place where units are assumed is `prettytime` so the `Simulation` always thinks your units are SI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502:624,depend,dependency,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791485502,1,['depend'],['dependency']
Integrability,> Can we wrap the reduced objects somehow so that the iterators for both objects match?. That should work. Could be done with a new `Field` type?. Would you object to merging this PR in it's current form though? It's an optional feature that works for curvilinear grids and is tested. It's been helpful for debugging cubed sphere validation experiments so I'm using it in PR #1522.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984:9,wrap,wrap,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984,1,['wrap'],['wrap']
Integrability,"> Can you help me figure out what we are using as a reconstruction?. For the velocity field or tracer?. For the tracer it depends on the advection scheme. For the velocity field, I think our method is consistent with either a constant or linear reconstruction. I'm not sure about higher. Not that if we use a different reconstruction for computing tracer fluxes, we'd have to use the same reconstruction for calculating the divergence of the velocity field so that they are consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874283792:122,depend,depends,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874283792,1,['depend'],['depends']
Integrability,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:919,depend,depending,919,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939,1,['depend'],['depending']
Integrability,> Can you point me to where in the code this goes down?. It happens in this halo fill:. https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Models/NonhydrostaticModels/pressure_correction.jl#L8-L20. after the tendency integration but before the pressure correction,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389132522:257,integrat,integration,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389132522,1,['integrat'],['integration']
Integrability,"> Can you use mean on a view into the parent array on the GPU?. Unfortunately no. It's still a non-contiguous view. ```julia; julia> using Statistics, CuArrays; C = rand(128, 128, 128) |> CuArray; @time CuArrays.@sync mean(C, dims=[1, 2]);; 0.000575 seconds (221 allocations: 8.797 KiB). julia> using Statistics, CuArrays; C = rand(128, 128, 128) |> CuArray; @time CuArrays.@sync mean(view(C, 2:127, 2:127, 2:127), dims=[1, 2]);; 18.857220 seconds (10.15 M allocations: 342.416 MiB, 1.11% gc time); ```. A 33,000x slow down lol. > Note also that due to our current convention for fields and indexing, the “correct” horizontal average depends on both the field type and the boundary conditions. Ah good point, that would complicate things...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519600896:634,depend,depends,634,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519600896,1,['depend'],['depends']
Integrability,"> Can't we add advective terms via the biogeochemical forcing term?; > ; > edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples.; > ; > PS we should add those scripts to `validation/biogeochemistry/`. > I think we can impose a little more structure that eases biogeochemical model development.; > ; > One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like; > ; > ```julia; > struct TracerBasedBiogeochemistry; > biogeochemical_tracers; > drift_advection_schemes; > drift_velocities; > transitions; > auxiliary_fields; > end; > ```; > ; > and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior.; > ; > Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow).; > ; > I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like; > ; > ```julia; > biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); > ```; > ; > rather than having to use the ""discrete form"".; > ; > This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development. This seems like a good idea, I will have a think and try and come up with something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594:353,rout,route,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594,3,"['interface', 'rout']","['interface', 'route']"
Integrability,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:205,integrat,integration,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027,1,['integrat'],['integration']
Integrability,"> Changing `force` to `mode` seems totally fine. Agreed. > I think the main issue is to figure out how to merge the interface. JLD2 supports file ""splitting"" which is why a `prefix` and `dir` makes more sense than specifying the whole filepath. We could try to infer `prefix` and `dir` from a `filepath` too, just need to decide if we are ok that users write `filepath` but then the files end up in different places (because of the file splitting). Personally I think it probably makes more sense to change `NetCDF` to take the file `prefix` and `dir` separately than the whole `filepath`. I also think using `dir` and `prefix` is easier than asking for `filepath` and then trying to split it behind the scenes for the JLD2 writer. Here's what I would do as a unified interface:. - `dir`; - `filename`. I think we should use `filename` and not `prefix` since it's more descriptive. Also it gives the opportunity for user to use different extensions which they might want.; - `mode`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1029529033:116,interface,interface,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1029529033,2,['interface'],['interface']
Integrability,"> Comparing the `model.clock.time` seems to be a good solution since RK3 `tick!` increases the stage and `model.clock.time`.; > ; > I'm just curious why `FieldStatus` is required as it's just a container/wrapper around a `Float64`. Couldn't you dispatch on `::Number` and `::Nothing` instead of `::FieldStatus` and `::Nothing`?. I couldn't do that because that would require making `AveragedField` a `mutable struct` (for example), which cannot be used directly on the GPU. The adapt method for `FieldStatus` (which is mutable) returns a `NamedTuple` (similar to `Clock`). I think that's right...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698425183:204,wrap,wrapper,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698425183,1,['wrap'],['wrapper']
Integrability,> Could also switch the Plots.jl backend to use PyPlot then maybe vmin and vmax (or the Plots.jl equivalent) will work correctly?. We would need to add `PyPlot` as a dependency for that to work.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1107#issuecomment-717569694:166,depend,dependency,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1107#issuecomment-717569694,1,['depend'],['dependency']
Integrability,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:696,interface,interface,696,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324,1,['interface'],['interface']
Integrability,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731:2,Depend,Depends,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731,2,"['Depend', 'interface']","['Depends', 'interface']"
Integrability,"> Do we currently have a function to retrieve spacings that considers whether a cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:296,depend,depends,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561,1,['depend'],['depends']
Integrability,> Do you mean when we're computing a diagnostic like vorticity should the kernel include the boundary point?. > > Can you point me to where in the code this goes down?; > ; > It happens in this halo fill:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Models/NonhydrostaticModels/pressure_correction.jl#L8-L20; > ; > after the tendency integration but before the pressure correction. Where is the halo filling code?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163421:387,integrat,integration,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163421,1,['integrat'],['integration']
Integrability,"> Do you think this will be ready to merge soon-ish?. Yes I think so. . The main clarifications here are that. 1. The concept of 'buoyancy' is on solid ground for any equation of state, provided we are within the Boussinesq approximation. 2. The dynamic component of the buoyancy gradient (the squared buoyancy frequency) should be calculated using the local thermal expansion coefficient and haline contraction coefficient (the analytical derivatives of the equation of state with respect to temperature and salinity at constant depth) --- This is (apparently) a more accurate approximation to the buoyancy gradient than calculating the buoyancy gradient with finite differences of buoyancy at different vertical levels. But this means that all equations of state should define functions that return these coefficients. In addition, we will supply a function to calculated the buoyancy frequency squared (I'm currently calling it `N2`). 3. For Boussinesq equations of state, we do not require the non-static components of pressure as input; instead we use the geopotential depth (corresponding to the use of hydrostatic pressure, `ρ₀ g depth`, to calculate compressive / thermobaric effects on density). At the moment we thus only require `-z` as an input --- though we may need to generalize the buoyancy implementation in the future if for some reason calculating the 'geopoential depth' requires more information (like free surface elevation). Luckily, this is a small change that just requires changing the function arguments to `buoyancy_perturbation`; etc. 4. The name `buoyancy_perturbation` is ok. It is actually potentially confusing, since ""buoyancy"" in ordinary usage is *already* associated explicitly with density anomalies --- rather than static, typically constant or z-dependent components of the density profile. So I think calling this function simply `buoyancy` might be better. On the other hand, we probably want to use `model.buoyancy` to refer to the model field that holds buo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557:400,contract,contraction,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557,1,['contract'],['contraction']
Integrability,"> Do you want to contribute an advection scheme to Oceananigans? A lot of people might benefit from having the kind of advection scheme that you are using! It may not be very much work, since we have an interface for adding new advection schemes. Sure! I'll submit a PR soon. > Do you evolve the tracer fully outside of the `Oceananigans` infrastructure? . Yes, it's fully outside of `Oceananigans`. I just use the velocities from `Oceananigans`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694262045:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694262045,1,['interface'],['interface']
Integrability,"> Does anybody know what is the rationale for `similar(::Field)` to drop the boundary conditions?. I think it depends on how you view ""boundary conditions"". If we adopt a ""weak formulation philosophy"" then boundary conditions are part of the definition of an equation set and don't belong to fields at all. This is how `ImmersedBoundaryGrid` works; inhomogeneous boundary conditions can only be enforced by adding boundary fluxes to a tendency. There's no such thing as a ""boundary condition"" outside the context of time stepping. Unfortunately, `Oceananigans` is not consistent in how this philosophy is applied and when we are on ""non-immersed"" grids we have more of a ""strong formulation"" philosophy. I believe the rationale for not transferring boundary conditions is the expectation that we will eventually adopt a ""weak formulation philosophy"" consistently throughout the code. In that case, non-default boundary conditions are meaningless on anything but prognostic fields that are evolved during time-stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487:110,depend,depends,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487,1,['depend'],['depends']
Integrability,"> Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact. Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103004854:274,integrat,integrated,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103004854,2,"['bridg', 'integrat']","['bridge', 'integrated']"
Integrability,"> Does it make more sense for Open to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set OpenBoundaryCondition(nothing) unless a user sets something else. This choice should not merely be a question about user interface / convenience but also about how the code internals work. . One problem is that the topology refers to both sides. We want to support domains that are, for example, bounded on the west but open on the east. We do have an abstraction called `RightConnected` for distributed cases. Possibly, we can implement topologies that represent doubly open and single-sided open. But to motivate such an abstraction, I think this needs to have implications on the grid level --- not just a way to generate boundary conditions conveniently. I think there are other solutions for generating boundary conditions conveniently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965123859:288,interface,interface,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965123859,1,['interface'],['interface']
Integrability,"> Does the magnitude of the velocity error scale with the time-step, or resolution? Perhaps plotting the dependence of the error on some of those parameters can give us confidence that the method is working as expected.; > ; So far I've run two different grid sizes, but I've been changing the time step with the grid size for stability, so I'm not sure. I mean the grid spacing will make it more accurate, so it probably does a better job, but I think the pressure correction is so close to the velocities we're seeing that the time step within the pressure correction has to play a big role. > Victoria, is the velocity normal to the cylinder zero? and perhaps the tangential component too, if you are using no-slip boundary conditions. I have a nice application of all this if you are going in 3-d. John; > […](#). The velocity roughly normal to the cylinder at the top (0-180 degrees) is close to zero. I'm not sure if my normal velocity calculation is off, but the bottom half of the cylinder is showing a lot more variation. ; ![Vnorm_onCylinder](https://user-images.githubusercontent.com/67593861/101094135-ea24bd00-3589-11eb-88e4-bfe756fc6969.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738346186:105,depend,dependence,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738346186,1,['depend'],['dependence']
Integrability,"> Does the magnitude of the velocity error scale with the time-step, or resolution?. I think the expected behavior is that the velocity error in the object scales with the non-hydrostatic pressure gradient times the timestep of the Runge-Kutta substep. Presumably the non-hydrostatic pressure gradient in the object scales as the non-hydrostatic pressure over the length scale of the object. If the strength of the non-hydrostatic pressure field on the object of the boundary is a function of the outer-flow and object configuration, then I don't think grid refinement will help much. We should do a more rigorous validation of this at some point, but at least the dependence on the timestep gives a way to control the velocity error. I also suspect the pattern of the normal velocities in the plot shown may be spurious, as we know the velocity gets very small in all 'solid' nodes fully inside the object. The apparent error on the boundary as a function of angle may have to do with the how the current first-pass implementation sets the solid boundary location on the c-grid. . @christophernhill thanks very much for the offer! It will be good to take you up on that down the line, but let @whitleyv and I do a bit of digging first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738460012:665,depend,dependence,665,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738460012,1,['depend'],['dependence']
Integrability,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:460,depend,depend,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878,2,['depend'],['depend']
Integrability,> Error message:. Huh. What's the type of `vz_op`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996:8,message,message,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996,1,['message'],['message']
Integrability,"> Expose the parallelism in RungeKutta3 timestepper and in the update_state! method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in @apply_regionally. This is not strictly necessary right? Just if we want to also support RungeKutta3.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032:241,wrap,wrapping,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032,1,['wrap'],['wrapping']
Integrability,"> FATAL ERROR: Symbol ""__nv_llabs""not found. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). I have seen this error when working with `KernelAbstractions` without any CUDA dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010:221,depend,dependency,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010,1,['depend'],['dependency']
Integrability,"> For the record, I did try this yesterday with FlatExtrapolationOpenBCs and it also blew-up. Ok great. How about the same problem (including CG pressure solver) but no immersed boundaries?. Something to keep an eye on is the number of iterations the CG solver does. It'd be good to report what is going on with those during / prior to breakup. You can call `iteration(model.pressure_solver)` to diagnose it (where it will correspond to the previous solve). > interestingly, when I run your exact example things take a little longer to blow up. This is important; the dependence on time step should be diagnosed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2408115770:568,depend,dependence,568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2408115770,1,['depend'],['dependence']
Integrability,"> Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different; target arch. Right --- we can use a wrapper that redefines `getindex` (and potentially also is associated with a certain loop ordering). Looks like there's a julia type that does this:. https://github.com/JuliaLang/julia/blob/master/base/permuteddimsarray.jl. I doubt it would be very hard to figure out how to abstract away loop ordering so it can be flexibly changed for a target architecture. One question still remains: which is the most intuitive convention for `getindex` calls? I personally like `i, j, k` for `x, y, z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365865:188,wrap,wrapper,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365865,1,['wrap'],['wrapper']
Integrability,"> Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. It's a very breaking change!. > Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though. This PR doesn't remove `StateChecker`, it just stops exporting it. > I use it in almost every script I write haha, but that's because I wrote it to my liking. Touche, but none of the examples use it so it isn't very visible. I'm not even quite sure what the application is, which might be part of the issue? Anyways the point is not to remove this functionality but just not stop exporting it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194:107,interface,interface,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194,1,['interface'],['interface']
Integrability,"> Gregg, Ali, can we get variable delz in at the same time? John. I'm happy to start working on that in October. I think we should reverse the k-index first, because I think at least part of the variable delz algorithm will depend on the direction of `k`. @ali-ramadhan on `buoyancy` versus `buoyancy_perturbation` --- since this is an internal issue (not part of the API), I'm fine to stick with `buoyancy_perturbation` for now and continue to discuss what the best nomenclature is after this PR is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533099629:224,depend,depend,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533099629,1,['depend'],['depend']
Integrability,"> Having said that, you could setup CI to run a few time steps and compare the output with blessed output - this is what MITgcm does for its CI tests. Indeed --- the test of the [Golden Master](https://en.wikipedia.org/wiki/Characterization_test)! That sounds like an excellent idea for `Oceananigans.jl`. No master is more golden than MITgcm. > This might work, but you'll need to decide how closely it should match. You definitely won't get machine precision matches - we can't even do that with different MITgcm runs. The output from MITgcm depends on the machine, the compiler, and the optimisation level. Touche. I was naive.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467624611:544,depend,depends,544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467624611,1,['depend'],['depends']
Integrability,"> Hello, @amontoison. Nice work. Do you see a performance improvement when switching to this package? There should be some benchmarks in the `benchmark` folder that we can test (probably we need to update that folder a bit, let me know if you have problems with it). Hi @simone-silvestri, `cg` is not too hard to implement, so I don't think we will see a significant performance improvement on CPU. ; However, for other methods like `gmres`, `Krylov.jl` easily outperforms `IterativeSolvers.jl`.; On GPU, though, we might see a difference because I try to dispatch to the BLAS/LAPACK routines of the GPU vendors as much as possible, whereas `IterativeSolvers.jl` relies on some broadcast. Also, to the best of my knowledge, only `cg` works on (NVIDIA) GPUs for `IterativeSolvers.jl`, while all solvers in `Krylov.jl` work on the GPUs of any vendor. I'll try to run some benchmarks before the end of the week.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041:584,rout,routines,584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041,1,['rout'],['routines']
Integrability,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:485,interface,interface,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413,3,['interface'],['interface']
Integrability,"> Hi, is there a reason why this isn't in the official examples?. Is it ready? This comment suggests it's not:. > This PR in a work-in-progress and depends on #1091. I still need to make it Literate. Perhaps @ali-ramadhan wouldn't mind some help though. It's probably stale right now and would need a merge master and update.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915:148,depend,depends,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-891817915,1,['depend'],['depends']
Integrability,"> Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose.; > ; > I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with... I definitely see your point. But if that's true, then I think there's a deeper problem here which is that neither the validation scripts nor the benchmarks are kept up to date. (The benchmarks on the docs right now are done with v0.34.0!). I actually tried discussing this in https://github.com/CliMA/Oceananigans.jl/issues/1634, and even proposed a solution that should work. I think we have three options:. - We adopt the opinion that even though it's not ideal because it's out-of-date, we keep the validation experiments since they are cool set-ups that show that our code worked in the past (and supposedly should still be working now, although without proof); - We adopt the opinion that if it's not up-to-date, it's not desired. So we nuke the benchmarks and the validation experiments altogether; - We try to fix this issue and keep the validation experiments and benchmarks up-to-date. You [seem to agree](https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832203095) that creating a separate repo for validation and relying on `CompatHelper` to automatically create PRs would work. I'd be happy to help implementing that, but I don't have access to a server with GPUs that I set-up the CI for (or enough knowledge of the CI tbh). Any one of those 3 options would work for me, but I think it would be good to make an explicit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477:64,depend,depend,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477,1,['depend'],['depend']
Integrability,"> Hmmm, I don't know if many log levels will be that helpful. I'm not entirely sure either. It's worth considering whether the standard `Info` and `Debug` levels might be enough for some of your uses, but there's also nothing wrong with trying out some custom levels and removing them if they don't end up making sense. For general logging I've often wondered whether it would be helpful to have a `Notice` level with severity between `Info` and `Warn` to allow informational messages to be stratified into two groups, though we would need clear guidelines for how to use it. Likewise, to have a `Debug2` or `VerboseDebug` level for ""really verbose"" debugging messages (possibly compiled out by default, though that would need a minor tweak in Base to make it possible). > but for user-facing info messages maybe we should remove the file name and line number and instead a custom log level like `DIAGNOSTIC` or `MODEL_SETUP` will be useful. This is basically what the standard `Info` level printing does in `Logging.ConsoleLogger` - it just ignores the line and file info captured by the fontend to simplify the pretty printing of the message. Btw, the pretty printing of log events can be separate from the storage format if desired. For example we could serialize log records to a binary file (including all file,line information etc) but have a tool to pretty print them with extra filtering, replay the messages from a simulation in faster than real time etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-547209159:476,message,messages,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-547209159,5,['message'],"['message', 'messages']"
Integrability,"> Hmmm, yeah I guess model.parameters may be useful in boundary conditions (possibly elsewhere too). To make `model.parameters` fully obsolete, we would need wrappers / interfaces for boundary conditions; eg. ```julia; bc = SimpleBoundaryCondition(Flux, (x, y, t, parameters) -> something, parameters=parameters); ```. Not suggesting we do it now, but something to think about for the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-540062839:158,wrap,wrappers,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-540062839,2,"['interface', 'wrap']","['interfaces', 'wrappers']"
Integrability,"> Honestly I think this is already pretty handy and enforces the idea that in order to compute something it needs to be a field. Hmm, I think the key concept here is that in order to _store_ the result of a computation, we need to allocate memory. That's what invoking `Field` does. It's worth mentioning for posterity the subtlety that calling `compute!` does have an affect on abstract operation, because it triggers the computation of all the leaves. So if an AbstractOperation depends on a field that needs to be computed, calling `compute!` on the abstract operation will cause that child field to get computed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718:481,depend,depends,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036773718,1,['depend'],['depends']
Integrability,"> How do we deal with errors of this kind in the doctests?:; > ; > ```; >   | │; >   | │ diff =; >   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.; >   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.; >   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration; >   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44; >   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; > ...; > ```; > ; > i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different.; > ; > I remember there was a relatively simple way to deal with this, but I can't find it. Damn... I remember the issue... Something with filter doctests. I can try to sort it out. Ignore it for now :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200:620,message,message,620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200,1,['message'],['message']
Integrability,"> How is this possible with a periodic solution?. Maybe I'm missing something, but I can't imagine how that would _not_ happen. Take the example animation that @ali-ramadhan posted in the first message. If you image the same IC but with a domain periodic in x and z the blob would accelerate towards the upper right and come back in the lower left endlessly, but constantly gaining speed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737551257:194,message,message,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737551257,1,['message'],['message']
Integrability,"> I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. That's where the chicken and egg problem comes from IMO. It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. But that's only my personal opinion and that's obviously up for debate. I'll close this issue we apparently aren't ready for what I proposed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980:110,interface,interface,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980,3,['interface'],"['interface', 'interfaces']"
Integrability,"> I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction.; > ; > ; > ; > ```; > ; > Immersed Fluid; > ; > ----------- ...........; > ; > | ∘ | ∘; > ; > f c f c; > ; > k-1 k-1 k k; > ; > ```; > ; > My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The question is where bottom_height lies in these diagrams. GridFittedBottom is not a limiting case of PartialCellBottom in the way we have coded it, because GridFittedBottom uses the cell center to determine whether the cell is immersed or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043118605:558,interface,interface,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043118605,1,['interface'],['interface']
Integrability,"> I am not sure about the purpose of this PR. What is the reason we do not want to calculate the periphery in the nonhydrostatic model tendencies?; > ; > If there is a specific reason, does this solution also apply to immersed boundaries with active cell map? It seems like nothing changed for that case. Because some open boundary conditions integrate an alternative PDE on the boundaries (eg for radiation conditions). In other words the algorithm we are using is only valid for simple open boundary conditions (we designed it for impenetrable condition). More generally, the algorithm is wrong. There are two other benefits. First, we do not use the tendencies on the periphery. So this increases the clarity of the code. Previously, it might not be obvious that even though we compute tendencies on the boundary, we overwrite the field values in `fill_halo_regions!`. It saves a little bit of computation as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988:343,integrat,integrate,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988,1,['integrat'],['integrate']
Integrability,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:535,depend,dependent,535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319,1,['depend'],['dependent']
Integrability,"> I am thinking about the ease of use in bc, for example; > ; > ```julia; > @inline time_interpolated_bc(i, j, grid, clock, fields, p) = p.time_array[i, j, 1, clock]; > ```; > ; > vs; > ; > ```julia; > @inline function time_interpolated_bc(i, j, grid, clock, fields, p) ; > time = Time(clock); > return p.time_array[i, j, 1, time]; > end; > ```; > ; > I find the first implementation a bit more straightforward, but we can also have both. I propose we prioritize the user interface rather than the source code implementation, which basically has to be written once then left alone",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696133206:472,interface,interface,472,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696133206,1,['interface'],['interface']
Integrability,"> I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. . Ok, after changing from `IterationInterval` to `TimeInterval` in the 1D diffusion example ([source](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl)), I am able to reproduce the same problem now. . Here is the progress message after picking up the checkpoint:; <img width=""580"" alt=""image"" src=""https://github.com/user-attachments/assets/9ef385f4-b53d-4954-97f9-54656420c232"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244270596:423,message,message,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244270596,1,['message'],['message']
Integrability,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142:959,depend,depends,959,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142,1,['depend'],['depends']
Integrability,"> I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?. Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg. ```; ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; ```. > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though. As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685:906,depend,depend,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685,2,['depend'],['depend']
Integrability,"> I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up. I'm actually not sure. All that `NonTraditionalFPlane` does is to tilt the rotation axis of an f-plane based on latitude. So it just projects some component of `f` onto the `y` direction. `GeneralFPlane` (or whatever we end up calling it) can tilt the rotation axis in any arbitrary direction, so it can already do what `NonTraditionalFPlane` does (and more). So really (imho) I don't see much use for `NonTraditionalFPlane` after this gets implemented, except maybe as a convenience function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886258285:113,depend,depends,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886258285,1,['depend'],['depends']
Integrability,"> I can prob code this myself, but from this issue it seemed like people were interested... I think this would be a great feature to have in Oceananigans!. I'd be happy to pair program with you @Mikejmnez to help you get started if you like. Feel free to message me on the julia slack (Oceananigans channel is at https://julialang.slack.com/archives/C01D24C0CAH).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768618886:255,message,message,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768618886,1,['message'],['message']
Integrability,"> I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:; >; > Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. I agree that far from the wall there is a clear trend. But I'm not sure that's a fair way to look at it. > But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps. That said, good point that the coefficient doesn't necessarily translate into the eddy viscosity. I'll check the eddy viscosity later and see what comes up as I am now curious :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803:209,depend,dependence,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803,1,['depend'],['dependence']
Integrability,"> I don't have very much to offer, but I believe that compiler behavior / execution can differ on different machines due to difference in underlying packages and compiler dependencies, even when the julia packages are identical. Yeah, I thought so too, but even using the pre-compiled binaries doesn't seem to fix this so idk anymore... > It'll be nice if upgrading to 1.6 (#1514) solves this. I have high hopes that it will!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828451928:171,depend,dependencies,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828451928,1,['depend'],['dependencies']
Integrability,"> I don't think it matters that the full cubed sphere is Periodic. I think the topology is somewhat undefined especially since the i or ""x""-direction doesn't point in any particular dimension. Right, I guess I am thinking of a domain consisting of two connected grids in which the whole domain is bounded. It seems that if `Connected` behaved exactly as `Periodic` then we would have no need for a new type. (I think you understand this and imply it in your text, but I just want to be clear that the only reason `const Connected = Periodic` works is because we are considering a case in which the grids ""wrap around"", and thus having every grid behave like `Periodic` is valid).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371:605,wrap,wrap,605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371,1,['wrap'],['wrap']
Integrability,"> I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`. Ah, I didn't realize this was specifically a Mac M1 issue. I think we'll continue to get issues and questions about this error if we don't do something about it (and its very inconvenient for this important subset of users). What's the best way to solve this problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418:41,depend,dependency,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418,1,['depend'],['dependency']
Integrability,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:111,rout,routines,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038,3,['rout'],['routines']
Integrability,"> I guess I also see timers as a debugging tool for users. Totally agree since simulation performance can depend entirely on performance of forcing functions, boundary conditions, and diagnostics; not just code that ships in src.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027:106,depend,depend,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027,1,['depend'],['depend']
Integrability,"> I guess if we run this on different nodes the efficiency is bound to go down, but that's a problem with the architecture I guess and not something we can change with software. Unless there is something I don't know about?. Yeah I don't have much experience with scaling MPI but I'm guessing single-node scaling depends on your software while multi-node scaling depends more on the cluster/hardware?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413:313,depend,depends,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413,2,['depend'],['depends']
Integrability,"> I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it.; > ; > Does this make sense to everyone? I also can't see an obvious way to get Δt to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. To clarify, the statement ""when U_b is negative"" means more generally ""when U_b implies inflow into the domain"". It makes sense to me that inflow is prescribed, whereas outflow is a little tricker, requiring us to smoothly advect information out of the domain. Having the boundary condition depend on the previous time-step does seem to break assumptions we have made about how information flows. For example, we call `update_state!` during model construction. How does the first time-step / initialization work with this kind of outflow model? It might help to consider that. Practically speaking it would not be hard to pass the time-step to update state. But it might be nice to understand the implications before committing, because a different design / redesign could make sense. For example I supposed we would need to have a default ""time step"" that is 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289:1167,depend,depend,1167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289,1,['depend'],['depend']
Integrability,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:370,depend,depends,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980,1,['depend'],['depends']
Integrability,"> I haven't gone through everything but I get the feeling that there is a lot of leftover docstrings/docs that are related to the previous default T, S option. Am I right? We should have T, S where is needed for the demonstration, not just have it everywhere because it's a leftover from before.; > ; > I don't. @navidcy Thanks for the review! I think your message got a little cut in the end. But I totally agree. I have modified these instances where I identified them (for example in model_setup/tracers.md), but a busy schedule kept me from doing a more thorough search for occasions where these happen. I'll fix the ones you found and look for some more!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993:357,message,message,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993,1,['message'],['message']
Integrability,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103:232,depend,dependent,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103,1,['depend'],['dependent']
Integrability,"> I like it! I changed the NonhydrostaticModel to be the same.; > ; > A way to facilitate users is that we leave the option to specify a global `advection` (so that we keep the keyword) or two separate `momentum_advection` and `tracer_advection`. I would rather just change it to be consistent with the HydrostaticFreeSurfaceModel directly.; > ; > what do you guys think?. I think we should do that in a different PR because it's a major, major breaking change to the most popular model!. As for the syntax I'd prefer --- I would prefer one keyword argument `advection`. We need that for the changes proposed in #2454 --- because the schemes for different components can depend on one another. So it's easier to put it in one object. I also feel it's better to just specify `grid` once to the `advection` constructor. But that would be harder to implement now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1130023720:671,depend,depend,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1130023720,1,['depend'],['depend']
Integrability,"> I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. By the way, this is available in stdlib `Logging.ConsoleLogger`, but it's hidden behind the `right_justify` keyword and I'm not sure anyone uses it! I had a long debate about this when putting this code into Base, which I lost ;-) (TBH I'm happy with the outcome because having people copy and paste log messages which are right-justified to a particular terminal width would have led to rather a mess.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-544768913:112,message,messages,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-544768913,2,['message'],['messages']
Integrability,"> I propose handling this by initializing output files within `run!` rather than during instantiation of the output writer. This is separate from the interface discussion here though. Ok, I see. I agree that that discussion can be left to the other PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391887025:150,interface,interface,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391887025,1,['interface'],['interface']
Integrability,"> I proposed `domain_depth` to distinguish it from the already existing `depth` interface that tracks the `depth` as a function of `k` which is used in the turbulence closure module. I think `domain_depth` communicates the idea of a total static depth. Ok, that makes sense, so `d = depth(i, j, k)` is 3D. What about `column_depth(i, j)`? Just want to have a discussion about it rather than simply deciding. Any other ideas besides ""column"", ""domain"", and ""total""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844:80,interface,interface,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844,1,['interface'],['interface']
Integrability,"> I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. NetCDFOutputWriter, JLD2OutputWriter. If you are referring to #3793 my intent is just to introduce an additional wrapper on top of the existing writers. It's merely an alternative to adding output writers manually to `simulation.output_writers`, which I find inelegant. > I believe it will be simple to change by only executting the initialize_nc_file! and initialize_jld2_file! once the model is running, instead of two times, once the writers are initialised and in run time (write_output!). I agree that it's simple to design. > Despite the implementation of this, I still see value in having a flag overwrite_existing, likely set up to false as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. Why would it result in (unintended) data loss? Because its common to mistakenly re-run a simulation? . > Regarding my changes in this PR, the function is_output_splitted! may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function. Okay, I'll take a look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954:98,wrap,wrapper,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954,3,"['depend', 'wrap']","['depending', 'wrapper']"
Integrability,"> I see, I think having an open boundary does necessarily have grid level implications because every tracer needs to have some open boundary specified if the grid has an open boundary right?. What are those implications?. For example, `Periodic` implies that there is one fewer interface for `Face` fields in that direction. As a result, `Periodic` direction changes the way that a grid needs to be constructed. This is what I mean by ""grid-level implication"". What's the difference between `Open` and `Bounded` in terms of data layout? It seems to me that `Open` is a boundary condition rather than dictating a different data layout. For example, would the different topology change the way that we construct the grid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1967469013:278,interface,interface,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1967469013,1,['interface'],['interface']
Integrability,"> I see. My aversion to putting something like this in the condition is that we would have to make a lot of changes to allow users to specify the external state, because if we just have the condition like all of the other boundary types then we don't have todo anything for the user to be able to put in anything as the external state.; > ; > We could change `Open` to be:; > ; > ```julia; > @kwdef struct Open{MS} <: AbstractBoundaryConditionClassification; > matching_scheme :: MS = nothing; > end; > ```; > ; > then by default this behaves exactly as it does now, but we could add `_fill_halo_...` methods for different matching schemes. For example if a user want to specify an external state: `OpenBoundaryCondition(1)`, or if they want to use a matching scheme `BoundaryCondition(Open(SomeMatchingScheme()), 1)` or we could make a utility like `SomeMatchingSchemeBoundaryCondition(val)` which returns `BoundaryCondition(Open{SomeMatchingScheme}, val)`. I like the examples you provide, but need to clarify that this discussion has no effect at all on existing code. Adding a new `condition` that is specific to `Open` does not stop us from also using `OpenBoundaryCondition(1)`. To emphasize --- we are talking about how information is organized under the hood. We are not talking about the user interface. For the user interface, I suggest the following syntax:. ```julia; OpenBoundaryCondition(nothing) # impenetrable; OpenBoundaryCondition(1) # external state = 1, no matching scheme; OpenBoundaryCondition(external_state, matching_scheme) # explicit matching scheme; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986426328:1302,interface,interface,1302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986426328,2,['interface'],['interface']
Integrability,"> I share here a double drake experiment that makes full use of this PR; > ; > #### Grid setup; > * latitude longitude grid from 75 S to 75 N; > * 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); > * 150 exponentially stretched vertical levels for a 3km deep ocean; > * double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); > ; > #### Top BC:; > * temperature: restoring to reference profile (cosine shape); > * salinity: prescribed latitudinally dependent surface flux; > * zonal velocity: prescribed latitudinally dependent wind stress; > ; > #### Bottom BC:; > * velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; > ; > #### Initial conditions; > * zero velocities; > * exponentially stratified temperature with SST equal to the reference temperature; > * constant salinity; > ; > #### Model setup; > * linear equation of state; > * Richardson-based diffusivity for BL mixing; > * vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; > * vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); > * WENO for tracer advection (no horizontal diffusivity); > * Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); > ; > #### Simulation setup; > * time step of 10 minutes; > * ran on 2 MPI processes with CUDA-aware MPI; > * performs about 10 simulated years per day; > ; > On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). This would be a good setup to add to `ClimaOcean.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342:489,depend,dependent,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342,2,['depend'],['dependent']
Integrability,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255:175,message,message,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255,1,['message'],['message']
Integrability,"> I suggest we wait on this for the time being. We are in discussions to start a formal collaboration to develop the ocean biogeochemistry component of the CliMA model. We need to plan our strategy with the new collaborators who will join us. It will happen soon and we can then have a discussion with all people involved on what is the best strategy moving forward. I agree, this issue is for planning purposes, but there's no timeline for setting up a new package. I think the package itself is easy, but designing the interface that allows different ""biogeochemical models"" to plug in to Oceananigans will require a bit more care. On the Oceananigans side, it seems like some necessary features of a `biogeochemistry` interface are. * User-specified `biogeochemistry` model ""automatically"" adds the tracers it needs in the model constructor (does not require user to explicitly specify tracers): `model_tracers = add_biogeochemical_tracers(biogeochemistry, user_tracers)`.; * There's a ""biogeochemical tendency"" term in the tracer equations that's controlled by `model.biogeochemistry` type.; * There's an interface in `update_state!(model)` like `update_biogeochemical_state!(model.biogeochemistry, model)` so that biogeochemistry models can precompute a state (eg cumulative integrals to determine light penetration) when needed. Perhaps further consultation will produce additional requirements. One big one that I see is for chemistry models that require subcycling or special numerical methods for time-stepping (ie stiff carbonate chemistry systems as in [Smith et al 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001486)). Supporting those cases will be more challenging. I think our Lagrangian particles already (or are intended to) support dynamics-on-particles so there may not be much to do there on the Oceananigans side.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691:521,interface,interface,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691,3,['interface'],['interface']
Integrability,"> I think it is good to use it in hydrostatic simulations where the aspect ratio is very high (for example drag on the sides should not be equal to drag on the bottom). Also if we use a Monin-Obukhov-based drag law the drag coefficients will depend on the grid-spacing in that direction, meaning they'd need to be applied separately if the spacing is different in different directions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588431703:242,depend,depend,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1588431703,1,['depend'],['depend']
Integrability,> I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit. To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU? That's why I didn't originally go down the route of making the velocity explicitly part of the boundary condition.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869:39,interface,interface,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869,2,"['interface', 'rout']","['interface', 'route']"
Integrability,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:889,integrat,integration,889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887,4,"['depend', 'integrat']","['depends', 'integration']"
Integrability,"> I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. It's definitely possible, but I think this isn't the example to do that. Since it's a tilted boundary layer, there's some extra complexity in the TKE budget. It's not a technical obstacle of anything, but it would require more explanation. I think the ocean convection example would be a much better option for a TKE budget.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752:262,integrat,integrated,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953910752,1,['integrat'],['integrated']
Integrability,"> I think its a fine idea to merge, though it is interesting that the code will still be called Oceananigans :-D. > Agree we need another name, perhaps a variant of shenanigans. True. The window of opportunity to change names is closing though. It might not be good to change package name after the JOSS paper comes out. I'm open to a name change if we can all agree on a new name. > I'm not sure I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. Right. But I guess users don't have to worry about ghost cell values and nonlinear diffusivities as they'll get filled in or calculated as needed. But in JULES.jl, if you want to add a potential temperature perturbation and modify θ you need to modify both the density ρ and the ρθ field. [Example:](https://github.com/thabbott/JULES.jl/blob/beec6727eef83343dd1adac8834f1545994098e2/verification/dry_rising_thermal_bubble/dry_rising_thermal_bubble.jl#L91-L95). ```julia; θ = Θ[i, 1, k] / ρ[i, 1, k] + θ′(xC[i], 0, zC[k]); π = Π(i, 1, k, grid, gas, Θ). ρ[i, 1, k] = pₛ / (Rᵈ*θ) * π^(cᵥ/Rᵈ); Θ[i, 1, k] = ρ[i, 1, k] * θ; ```. From a user's perspective this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:546,depend,depend,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['depend'],['depend']
Integrability,"> I think overwrite_existing = false could be the default. Seems to me that users could easily add the overwrite_existing = true in their script if they know they are experimenting with something and don't wanna be deleting the output every time. So, `overwrite_existing=false` is the current default. I don't dispute that it's ""easy"" to add `overwrite_existing=true`, but I don't think we should design the interface only up to the point where ""easy"" changes close the gap between the default and what users want to do, most of the time. I think the default should legitimately be useful. I think that `overwrite_existing=false` is rarely desirable -- users only want this when they run big, expensive simulations. I would say that it's almost impossible to set up a big, expensive simulation without going through some prototyping phase first. Moreover, prototyping consumes much more human time than big, expensive simulations. Therefore `overwrite_existing=true` is the correct default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433125490:408,interface,interface,408,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433125490,1,['interface'],['interface']
Integrability,"> I think providing a string as a closure doesn't even make it to the new error message you added so you get a MethodError from `with_tracers`!; > ; > ```julia; > julia> using Oceananigans, Test; > Precompiling Oceananigans; > 1 dependency successfully precompiled in 11 seconds. 129 already precompiled.; > ; > julia> grid = RectilinearGrid(CPU(), size=(2, 2, 2), extent=(1, 2, 3)); > 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; > ├── Periodic y ∈ [0.0, 2.0) regularly spaced with Δy=1.0; > └── Bounded z ∈ [-3.0, 0.0] regularly spaced with Δz=1.5; > ; > julia> closure = ""not a closure""; > ""not a closure""; > ; > julia> NonhydrostaticModel(; grid, closure); > ERROR: MethodError: no method matching with_tracers(::Tuple{}, ::String); > ; > Closest candidates are:; > with_tracers(::Any, ::Nothing, Any...; kwargs...); > @ Oceananigans ~/Research/OC11.jl/src/Utils/with_tracers.jl:44; > with_tracers(::Any, ::Oceananigans.TurbulenceClosures.TwoDimensionalLeith{FT}) where FT; > @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl:61; > with_tracers(::Any, ::ScalarBiharmonicDiffusivity{F, N}) where {F, N}; > @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl:85; > ...; > ; > Stacktrace:; > [1] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{}, closure::String, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, hydrostatic_pressure_anomaly::Oceananigans.Models.NonhydrostaticModels.DefaultHydrostaticPressureAnomaly, nonhydrostatic_pressure::Field{…}, diffusivity_fields::Nothing, pressure_solver::Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325346266:80,message,message,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325346266,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:85,depend,depends,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978,3,['depend'],"['dependencies', 'depends']"
Integrability,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502:848,depend,depends,848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502,1,['depend'],['depends']
Integrability,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891:46,interface,interface,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891,3,"['integrat', 'interface']","['integrated', 'interface']"
Integrability,"> I think we need an required_biogeochemical_auxiliary_fields like required_biogeochemical_tracers because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field). Should the user specify this, or should the biogeochemical model add it its struct (taking in `grid` for this purpose) and evaluate it during `update_biogeochemical_state`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310889513:298,depend,dependence,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310889513,2,"['depend', 'integrat']","['dependence', 'integrating']"
Integrability,"> I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code. I will try (feel free to edit):. The use cases we want to add support for is advection of user specified values into the domain (in a ""soft"" way, i.e. not directly specifying incase the interior solution has diverged from the boundary specified solution), we also want to be able to advect information out of the interior domain. . We want to be able todo this with both user specified bulk velocities as well as velocities that depend on the wall normal velocity and possibly wall normal acceleration (some also consider oblique waves but from what I have read it doesn't help that much). The calculated bulk velocities might be the different at every point (i.e. computed within the fill kernel), but may also (often) be the same at every point on the boundary so should be computed before the fill kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979835760:562,depend,depend,562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979835760,1,['depend'],['depend']
Integrability,"> I think we should find a general solution to adding citations in docs, rather than attempting to avoid it. Can we define a macro that transforms a citation into a footnote? Then we can include this macro at the top of a documentation file that needs citations. I think that raising an issue with Documenter is a good idea for this. In general we should be comfortable with driving improvements to packages that we depend on rather than hacking inelegant solutions (a last resort). I think @charleskawczynski is also interested in this problem, we can try discussing on Slack. It might not be too hard if we can reuse some existing pieces:. There was an attempt back in 2017 to add a `bibtex` option to `makedocs` that allowed citations with `[<label>](@ref)`: https://github.com/JuliaDocs/Documenter.jl/issues/379#issuecomment-292157714. But it had to use the Python package `pybtex` to parse bibtex files. But since then there's been a native Julia version: https://github.com/JuliaTeX/BibTeX.jl. So maybe if we can get that `bibtex` option to work with BibTeX.jl then we can pretty easily have citations in Documenter?. I'll open an issue on Documenter.jl to see if it's possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474#issuecomment-543170619:416,depend,depend,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474#issuecomment-543170619,1,['depend'],['depend']
Integrability,"> I think wrapping `Base.Broadcast.materialize!` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/Fields/broadcasting_abstract_fields.jl#L24; > ; > around `@apply_regionally` for multi region fields might do the job. Or we can extend `materialize!(dest::MultiRegionField, ...)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485:10,wrap,wrapping,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485,1,['wrap'],['wrapping']
Integrability,"> I think you can define in `ImmerdsedBoundaries`; > ; > ```; > return_metrics(grid::ImmersedBoundaryGrid) = return_metrics(grid.underlying_grid); > ```; > ; > and that should solve the problem, because the coefficients only depend on the metrics, not on the grid itself (then maybe change some warnings) ideally we can put the `return_metrics` function in the `Grids` module, as it is not particular to `WENO` (although it is used only there at the moment). Good point!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125307847:225,depend,depend,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125307847,1,['depend'],['depend']
Integrability,"> I wanted to flag for @glwagner and @ali-ramadhan the issue that the above changes to the pressure solver would impact issue #1036, which relies on the decomposition of pressure into hydrostatic and non-hydrostatic components. I'm not sure how big an issue this would be, but good to be aware. As far as I can tell there is no impact of tilting on the pressure solver. For example, one clean algorithm would introduce three buoyancy contributions `x_dot_g_b`, `y_dot_g_b` and `z_dot_g_b` in the three momentum equations, and then solve for non-hydrostatic pressure (which is independent of the direction of gravity). In the current algorithm, we treat buoyancy as special and, rather than adding its contribution to the ""vertical"" momentum equation, we integrate it in ""z"" and then add the _horizontal_ derivatives of that quantity to the _horizontal_ momentum equations. But if we don't make the hydrostatic approximation specifically, then there's nothing special about ""z"" and we could do the same procedure for any of the terms on the RHS of the momentum equation... ?. So, if we tilt the domain, I think we can keep the current pressure decomposition, provided that we correctly project the buoyant acceleration into the tilted coordinate system. A valid criticism is that the algorithm is unnecessary convoluted, of course, which I agree with... > If you rotate gravity, you likely also want to allow the planetary rotation vector to also be rotated. We currently support this: https://clima.github.io/OceananigansDocumentation/latest/model_setup/coriolis/#Non-traditional-f-plane. But it's a good point that we may want a cleaner abstraction. The problem here is really just terminology (or if one wants to tilt their domain in x rather than y). Long ago I argued that we shouldn't use the word `FPlane` et al, but rather just implement a general abstraction for ""background rotation"" of the reference frame of the solution. It might make sense to have this now...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-737375395:754,integrat,integrate,754,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-737375395,1,['integrat'],['integrate']
Integrability,"> I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799:124,depend,depending,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799,1,['depend'],['depending']
Integrability,"> I wonder if it's better to define abstract types like Uniform or Regular for dimensions with uniform grid spacing and Stretched or NonUniform for non-uniform grid spacing. What information do you need for a stretched grid? Is this just a matter of `Δx` becoming a `Function / Array` rather than a number?. In that case we just have `CartesianGrid`, and dispatch occurs on the type of `Δx` for each dimension individually. Edit: may be best to save this change until we have a stretched grid. We haven't really discussed how we'd construct stretched grids, but our design may depend on that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541322605:577,depend,depend,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541322605,1,['depend'],['depend']
Integrability,"> I'll explain quickly what is happening to document it. In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used.; > ; > This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active.; > ; > The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction) let's say the advection is centered order 4 so hypothetically it requires two halo points. We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!).; > ; > This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray.; > ; > My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed. This was the problem. So in the end I decided to just require one additional halo for the immersed boundary grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144:1608,message,message,1608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144,1,['message'],['message']
Integrability,"> I'm not really sure how to fix this one... Not sure if I completely understand what's happening since I am not super familiar with the `NetCDFOutputWriter`, but it looks to me like an implementation of `define_output_variable` has been provided for `WindowedSpatialAverage`, but not for the case when `WindowedSpatialAverage` is wrapped inside a `WindowedTimeAverage` (in which case the type of the output is `::WindowedTimeAverage{<:WindowedSpatialAverage}` as written in the error message above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525:331,wrap,wrapped,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525,2,"['message', 'wrap']","['message', 'wrapped']"
Integrability,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:243,depend,dependency,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869,6,"['depend', 'synchroniz']","['dependency', 'synchronization', 'synchronizations', 'synchronize', 'synchronizing']"
Integrability,"> I'm not sure that the corner points are used in the prognostic calculations right?. It depends on the physics. You should check for coriolis, VectorInvariant advection, and biharmonic viscosities. I suspect the corners come into play for those. > Do you mind pointing me in the right direction?. Check out `Oceananigans.Utils.KernelParameters` and use this when launching the kernel that fills the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2439771342:89,depend,depends,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2439771342,1,['depend'],['depends']
Integrability,"> I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots mor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:920,integrat,integrate,920,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['integrat'],['integrate']
Integrability,"> I'm wondering if it might be a bit much to put docstrings on every single AbstractGridMetric for this experimental feature? They aren't exported so not user-facing (I think we may end up using this internally only for things like IntegratedField down the line). Fair point. But internal docstrings also help I think. It's way easier for me to contribute, for example, when the internal functions are well-documented. I think the more we add these, the more likely we are to get contributions from people outside of the regular group, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826008043:232,Integrat,IntegratedField,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826008043,1,['Integrat'],['IntegratedField']
Integrability,"> I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm. https://github.com/CliMA/slurm-buildkite is what is being used IIUC. . Oceananigans doesn't use this afaik, but instead just uses runners on a private compute node.; Looks like me, @glwagner or @charleskawczynski have the right priviliges to create an agent token.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736:108,integrat,integrate,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736,1,['integrat'],['integrate']
Integrability,"> I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > ; > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum. Thought more about this and I think it might be quite complicated to change to this so I will leave for now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1757338739:198,depend,dependant,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1757338739,1,['depend'],['dependant']
Integrability,"> I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C.; > ; > Does anyone working on Oceananigans have experience doing that sort of thing?. Could be worth asking on julia slack! You'll have to ship an independent wrapper package (eg `VkFFT.jl`) and figure out how to precompile the binaries, right (so we can install everything from the REPL)?. Could be good for this PR to focus on getting explicit free surface to work, then build up the rest of the features after that. Doing this for real will also require figuring testing out I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503:32,wrap,wrap,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735314503,2,['wrap'],"['wrap', 'wrapper']"
Integrability,"> I've used xarray to analyze and plot Oceananigans NetCDF files quite a lot in the past with little difficulty (still really like xarray). Being on a regular Cartesian grid helps a lot obviously. You can use `xarray` on Oceananigans data blindly and be happy with it (I do it for the most part!), but their routines for interpolation and especially integration and differentiation don't match up with Oceananigans' finite volume scheme. So if you need to be precise with your calculations, you definitely shouldn't use the `xarray` default routines. And yes, this definitely overlaps with `AbstractOperations`, but I think that's okay, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045:308,rout,routines,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772627045,3,"['integrat', 'rout']","['integration', 'routines']"
Integrability,"> If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message. Ah for sure. I was just remarking that if you need the eltype, you can use `AbstractArray{FT}` (or you can simply call `eltype`, which is preferred by [YASGuide](https://github.com/jrevels/YASGuide) --- type parameters should be used for dispatch only). I think it's ok if you keep `AbstractVector`. We can create a wrapper for Krylov.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962:136,message,message,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962,2,"['message', 'wrap']","['message', 'wrapper']"
Integrability,"> If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up?. The user has to define `update_biogeochemical_state!` for the particular `BasicBiogeochemistry` they would like to use; if they want to compute light attenuation, they'll have to write that. However, I can envision child packages to Oceananigans providing more structured functionality for users. I think we just want to keep the Oceananigans interface as simple and general as possible since we expected it to be used by many different types of chemistry and biology models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999:481,interface,interface,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999,1,['interface'],['interface']
Integrability,"> If it's slow, that's because of some implementation issue rather than an intrinsic reason. We _should_ be able to do fast reductions of abstract operations. Then I see no reason not to pursue the proposed changes :). On the user interface side: I believe ""diffusive CFL"" isn't quite correct, since the Courant-Friedrichs-Lewy condition is the advective one. (Although I agree that ""diffusive CFL"" is pretty easy to understand and intuitive.) Should we try to come up with a different name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293:231,interface,interface,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293,1,['interface'],['interface']
Integrability,"> In dealing with a stretched grid, don't we need these to depenend on the horizontal grid?. Not in general; without bathymetry we would only need this for three-dimensional curvilinearity. If we have only horizontal curvilinearity (as arises in a thin approximation to the spherical shell), then vertical spacing are independent of horizontal location. But as noted in this issue, vertical spacing *do* depend on horizontal location with an immersed boundary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966423864:404,depend,depend,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966423864,1,['depend'],['depend']
Integrability,"> Indeed, the boundary conditions for `U` and `V` should be the integral of boundaries for `u` and `v`. I am unsure about the boundaries for `η`; I think `η` is typically prescribed outside the domain in regional simulations, but we probably need to find a reference for that. For reference, I think ROMS currently uses the algorithm described [here](https://www.sciencedirect.com/science/article/abs/pii/S146350031000082X?via%3Dihub). I haven't read it carefully, but it seems to project both `U` and `η` to a common point outside of the domain, calculate a variable that depends on both quantities (Eq. (2)), and specify the BCs for both based on that. (Likewise for `V`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930:573,depend,depends,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930,1,['depend'],['depends']
Integrability,"> Interesting that it modifies `field` in place. I think perhaps a starting point could be an implementation that puts the result in a new field, perhaps?. Yes, in my case, I created a copy of the field I wanted to integrate and then applied the function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098913682:215,integrat,integrate,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098913682,1,['integrat'],['integrate']
Integrability,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:363,depend,dependencies,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800,1,['depend'],['dependencies']
Integrability,> Is it worth using Python here though? I feel like we'd need to have a whole conda environment set-up just for that. Julia can handle the dependencies if we want to use it. See `PyPlot.jl`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065514482:139,depend,dependencies,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065514482,1,['depend'],['dependencies']
Integrability,> Is that message going to display _every_ time a model is created?. No. Only when a model is created with `gravity_unit_vector != NegativeZDirection()`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460733936:10,message,message,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460733936,1,['message'],['message']
Integrability,"> Is the PR on KA very crucial?; > ; > Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?. I would wait for KA to merge (we do not want to depend on a branch). . On the other hand, I would prefer not to wait for KA to have this PR ready to merge so we can merge the two PRs in rapid succession and not take time to refactor/review this one later (it would be better to merge this by July 15th and I think it has some major changes we want to discuss before). In the end the KA PR just handles how offsets are used in indexing kernels. I don't think that API will change even when changing the internals, and even if it does, it is just a matter of changing one function (`launch!` in `src/Utils/kernel_launching!`) to reflect the API changes",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191:210,depend,depend,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191,1,['depend'],['depend']
Integrability,"> Is the solution outside the body perfectly symmetric?. > @wenegrat and @whitleyv sounds good - is the angle dependence maybe due to time dependence of flow, does it move around as the flow changes?. @christophernhill This should be a _roughly_ steady state solution for Re = 40 by the end of the simulation. Changes in velocity at that point are O(10^-5). Here is the velocity contours for the above case @weymouth. Angle-wise, 0 degrees was taken due east but the flow is not in that direction, so it should have been symmetric from [-90,90] and [90,270]. As @wenegrat mentioned, the normal velocity may be uneven due to the interpolation and derivative calculations so near the boundary. ![velocity_Re40_dx04_small](https://user-images.githubusercontent.com/67593861/101181102-7ed6fb80-361a-11eb-92f1-041f0daa398e.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738849541:110,depend,dependence,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738849541,2,['depend'],['dependence']
Integrability,"> Is there a forcing function that computes the ""immersed boundary normal"" direction with associated logic?. Not exactly, but if you're determining a grid fitted normal direction then these boolean functions determine if the location is an interface with fluid on the left and solid on the right or vice versa for all the options. They are only true on a boundary face, not if its a solid-solid or fluid-fluid wall. https://github.com/CliMA/Oceananigans.jl/blob/8b988b34abcfbfd2e0453aedec5916c22b8c35c7/src/ImmersedBoundaries/conditional_fluxes.jl#L48. I don't think it would be hard to use these to set a directional sign for the normal direction, depending on which way you're doing that. If you want the normal direction to be based on the true IB rather than grid fitted, then I don't have anything recent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496:240,interface,interface,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100111496,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,> Is there a way for me to cancel tests so they don't have to run every commit?. You can include `[skip ci]` in the commit message: https://docs.github.com/en/actions/managing-workflow-runs/skipping-workflow-runs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165:123,message,message,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165,1,['message'],['message']
Integrability,"> Is there a way to test x_f_cross_U et al?. Yes: construct a model with the given feature and then perform a time-step. I guess ideally we would form a giant matrix representing all possible model configurations and time-step them all once. This would be expensive. Maybe we should just loop over each physics specification individually and cross our fingers that there's no bad interactions (I can already tell this would be naive, for example, when a turbulence closure depends on buoyancy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/616#issuecomment-583371090:473,depend,depends,473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/616#issuecomment-583371090,1,['depend'],['depends']
Integrability,"> Is there any other reason why it should be positional?. I guess I'm just arguing that it's not consistent with most of the API, eg we write `CenterField(grid)`. I find the position representation of required arguments to be a natural and concise interface but perhaps I shouldn't die on that hill",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1716901107:248,interface,interface,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1716901107,1,['interface'],['interface']
Integrability,"> Is this extra simplicity in the user interface worth the extra code to maintain?. Given the minor code changes required and the priority we place on user interface, I think so. > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:39,interface,interface,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,2,['interface'],['interface']
Integrability,"> It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the HeptadiagonalIterativeSolver. Both of those solvers actually use the preconditioned conjugate gradient method. It's also not true --- the `PreconditionedConjugateGradientSolver` has been validated. I'm not even sure it's possible to use the FFT-based preconditioner with the heptadiagonal solver, they have different interfaces. Maybe you worked on that. It's not obvious how to generalize the `HeptadiagonalIterativeSolver` to support `Distributed` architecture, and its also likely more difficult to optimize for immersed boundary methods using an active cells map. We shouldn't waste our time with the `HeptadiagonalIterativeSolver`. If the `PreconditionedConjugateGradientSolver` has issues, we should fix them. It's a waste of energy to work on both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835:536,interface,interfaces,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835,1,['interface'],['interfaces']
Integrability,"> It may be that several other dependencies need to be updated. Yep, a few others updated when I ran . ```julia; (Oceananigans) pkg> update SeawaterPolynomials; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3035#issuecomment-1488008980:31,depend,dependencies,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035#issuecomment-1488008980,1,['depend'],['dependencies']
Integrability,"> It may become common if users do realistic GCM stuff, because there will be many turbulence closures, but only *one* of them would require explicit boundary-diffusivity modeling to control field gradients and diffusivities along boundaries (for example, prescribing some interesting lateral diffusivity parameterization on top of a vertical mixing parameterization). Ah interesting I didn't think of such cases. I believe we can set up arbitrarily complicated boundary conditions so anything is possible. It's just hard and probably unfeasible/undesirable to extend the user interface to handle all these cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589850223:577,interface,interface,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589850223,1,['interface'],['interface']
Integrability,"> It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P), and model makers will need to do the setup stuff I've done to make the advective velocity fields. Can't we add advective terms via the biogeochemical forcing term?. edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples. PS we should add those scripts to `validation/biogeochemistry/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224:40,interface,interface,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224,1,['interface'],['interface']
Integrability,"> It will allow us embed a little more multi process in the code. Can you explain this point?. To me it looks like the main difference / improvement of (3) is the _user interface_ rather than functionality, because every grid has an `architecture`. Thus in source code it's the difference between `grid.architecture.partition` or `grid.partition`. With a `process_partition(grid)` interface (which we should have...) even that distinction is lost. The primary tradeoff against the user interface change is an increase in code complexity. New developers have to wrestle with and users have to puzzle over `grid.partition`, even though it's relevant only in a minority of cases (particularly because we are GPU-focused, and are providing features for multi-GPU). For example with `MultiRegionGrid` we'd have `grid.partition` and `grid.region_grids[1].partition`. But maybe I am missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110:381,interface,interface,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121142110,2,['interface'],['interface']
Integrability,"> It'd be nice to state in writing the justification for writing a separate CPU solver for certain problems. In general, I think that any algorithm that works on the GPU will also work on the CPU. Thus at least in principle the simplest choice is presumably to use the same solver on both architectures. Good point, I've been meaning to set up a script for benchmarking the different pressure solvers. We should use performance benchmarking results to make decisions. > Also, I'd encourage writing this code into as self-contained a submodule as possible. I think there are other codes in the julia ecosystem (not least FourierFlows.jl!) that would benefit from fast and multi-architecture Poisson solvers. We don't have to break this into a separate package just yet, but we do want to ensure this is easy to do in the future. Another good point. As you pointed out some of these solvers depend on the `grid` but if we take that out (which would be trivial) then I think the solvers in PR #589 would be pretty reusable by other packages. Although right now they're pretty specific to staggered grids (except for `BatchedTridiagonalSolver`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204:889,depend,depend,889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204,1,['depend'],['depend']
Integrability,"> It's added under `[extras]` beneath `Plots`... where should I put it instead?. But it's not used by the package nor by the tests, right?. I though we added test dependencies under `[extra]` which included Plots.jl but now that examples are not run as part of the tests (only as part of building the docs) then shouldn't both Plots.jl and Measures.jl be in `docs/Project.toml` and not the main `Project.toml`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-724235003:163,depend,dependencies,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-724235003,1,['depend'],['dependencies']
Integrability,"> It's because the two fields use the same data:; > ; > ```julia; > u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); > v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data); > ```; > ; > therefore, the problem is that we are not ""recomputing"" the dependent operands of `outputs_avg.u1` correctly. If we don't recompute the operands of `outputs_avg.u1` and `outputs_avg.v1` when we compute them, then they can be identical (and thus wrong) because they are both computed using the same array. That makes sense, especially because if I don't specify the scratch data it goes away. But any guesses as to why it only pops up when using IBMs?. https://github.com/CliMA/Oceananigans.jl/pull/2582 seems to suggest that it's because the Average is only computed at fluid nodes and therefore is applied conditionally. Is that it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139232131:285,depend,dependent,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139232131,1,['depend'],['dependent']
Integrability,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:46,interface,interface,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203,3,['interface'],['interface']
Integrability,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:193,depend,depending,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860,2,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"> Just added BitInformation to the Project.toml, due to dependency on `StatsBase` and `Distributions` this also adds; > ; > ```; > Updating `~/git/Oceananigans.jl/Project.toml`; > [de688a37] + BitInformation v0.6.1; > Updating `~/git/Oceananigans.jl/Manifest.toml`; > [66dad0bd] + AliasTables v1.1.2; > [de688a37] + BitInformation v0.6.1; > [49dc2e85] + Calculus v0.5.1; > [31c24e10] + Distributions v0.25.108; > [fa6b7ba4] + DualNumbers v0.6.8; > [1a297f60] + FillArrays v1.11.0; > [34004b35] + HypergeometricFunctions v0.3.23; > [77ba4419] + NaNMath v1.0.2; > [90014a1f] + PDMats v0.11.31; > [1fd47b50] + QuadGK v2.9.4; > [79098fc4] + Rmath v0.7.1; > [2913bbd2] + StatsBase v0.34.3; > [4c63d2b9] + StatsFuns v1.3.1; > [f50d1b31] + Rmath_jll v0.4.0+0; > ```; > ; > also why is the Manifest.toml committed?. Through past experience we found that we needed the Manifest committed to make sense of the errors we encounter during CI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109117793:56,depend,dependency,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109117793,1,['depend'],['dependency']
Integrability,"> Just curious if DataAPI, Formatting, SortingAlgorithms, StatsBase, and UnicodePlots are required for this PR? They got added to Manifest.toml but no new dependencies were added to Project.toml. No. I have no idea why that happened. What can we do to remove them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545710527:155,depend,dependencies,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545710527,1,['depend'],['dependencies']
Integrability,"> Just ran into this and wanted to mention [NCTiles.jl](https://github.com/gaelforget/NCTiles.jl) which we, https://github.com/lmilechin and myself, recently released.; > ; > Not sure if `NCTiles.jl` is readily applicable to your package output but maybe it would be interesting to discuss some sort of integration. What do you think?. Hi @gaelforget , . Thank you for bringing this to our notice! From what I understand, NCTiles provides convenient functions to either use NCDatasets.jl or NetCDF.jl and integrates with MeshArrays.jl, which has representations for tri-polar grids and such. I haven't had the time to read your 2015 paper so please correct me if I did not grasp the full extent of NCTiles' capabilities. So far Oceananigans does not have support for anything other than regular cartesian grids so NCTiles might be an overkill. But we can definitely consider it in the future when Oceananigans gains new capabilities. . By the way, did you notice any differences in performance between NCDatasets.jl and Netcdf.jl?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-537189439:303,integrat,integration,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-537189439,2,['integrat'],"['integrates', 'integration']"
Integrability,"> Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget.; > ; > Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. I see. Did you try `Oceananigans.Fields.ConstantField`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766:218,integrat,integrate,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766,1,['integrat'],['integrate']
Integrability,"> Lagrangian-averaged should be slightly less diffusive right?. Hmm, I'm not aware of that. afaik it's about the same in a doubly periodic domain. Looking at Bou-Zeid's Figure 1 I also don't see any obvious trend that way. What is generally true is that scale-dependent formulations (not implemented here) tend to be less diffusive then scale-invariant ones (which is the one implemented here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448410206:260,depend,dependent,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448410206,1,['depend'],['dependent']
Integrability,"> Looks like a good interface to me.; > ; > But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?; > ; > @liuchihl will test it in our configurations. Well yes, it's substantial effort to support background fields. So we implemented it in the nonhydrostatic model first. Nobody has requested having background fields for the hydrostatic model. It's not impossible but might require some thinking if it's going to work with the more complicated turbulence closures (like CATKE or k-epsilon) that sometimes get used for hydrostatic applications. Since the nonhydrostatic model is fast (at least on one GPU) the hydrostatic model is mostly important for simulations on the sphere (although this statement needs to be evaluated more carefully for complex domains when we have a proper nonhydrostatic solver).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460:20,interface,interface,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460,1,['interface'],['interface']
Integrability,"> Looks like this is a bad idea, so I'm closing. I'm not sure it's a bad idea. I've been having some issues with spurious waves in rotated domains and I'm thinking this might be the cause. (Since we're modifying the direction gravity is acting on, but we're still integrating the pressure in the model's z direction.). I still haven't been able to test my rotated domain on this branch, so I'm not sure. But if indeed this is the culprit, it might be a good idea to have a flag that turns the hydrostatic separation off for rotated domains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672:264,integrat,integrating,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672,1,['integrat'],['integrating']
Integrability,"> Maybe I'm missing something, but I can't imagine how that would not happen. Take the example animation that @ali-ramadhan posted in the first message. If you image the same IC but with a domain periodic in x and z the blob would accelerate towards the upper right and come back in the lower left endlessly, but constantly gaining speed. I think the problem is that we cannot impose a `b` that has a non-zero domain average. This is consistent with its definition (eg it is proportional to the density _perturbation_; we subtract out a reference density in Boussinesq). Consider the x-momentum equation:. ```; du/dt + ... = b sin(theta); ```. if `b` has no net average, then the average of this equation is just. ```; d <u> / dt = 0; ```. right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737554035:144,message,message,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737554035,1,['message'],['message']
Integrability,"> Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364:216,interface,interface,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364,2,['interface'],['interface']
Integrability,"> Maybe a better question (which might be silly): is there any reason why benchmarks need to have a different benchmark from the main repo?. Because our benchmarking scripts have additional dependencies that are unrelated to the source code, like `BenchmarkTools`, `BSON`, `PyPlot`, `PrettyTables`, `PkgBenchmark`, `Plots`, `DataFrames`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767:190,depend,dependencies,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090378767,1,['depend'],['dependencies']
Integrability,"> More on the top of this issue, there is a small difference between the two kernels: in one the reference density (which is otherwise arbitrary?) appears to be 1027 and in the other its 1024. Sorry that was a typo. Just fixed it. > But otherwise I don't see why it wouldn't work and I am a bit stumped. Yes, I've dedicated several hours to investigating this issue also and got nothing. The issue also is that I'm actually depending on that result for research, and it's pretty expensive to calculate that offline. Do you have any suggested workarounds?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786245625:424,depend,depending,424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786245625,1,['depend'],['depending']
Integrability,"> My primitive logic: for a flux boundary condition, bc.calc() ""calculates"" the flux at the given grid point and time-step. For a ""value"" boundary condition, bc.calc() ""calculates"" the value of the boundary condition at the given grid point and time-step. But I agree it is a weird name. What is a better name?. It may not stand up to mathematical rigor but I still like `bc.impose()`. In your two examples, I feel like a flux is being _imposed_ and a value is being _imposed_. If `bc.calc()` calculates a number then it should be used as; ```julia; something = bc.calc(args...); ```; while `bc.impose` should be used like; ```julia; bc.impose!(args...); ```. But now we're just arguing semantics instead of what's important. > There are two issues: the backend, and the user interface. Maybe the title of this PR is confusing, because I think it's primarily about the backend. I think so too. API suggests more front-end. I also think discussing these dense and complicated issues (e.g. this PR and #120) among multiple busy people is difficult on GitHub. Little far ahead but maybe the Monday CliMA meetings are a good place to get high-level feedback?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472250439:776,interface,interface,776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472250439,1,['interface'],['interface']
Integrability,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:333,integrat,integrated,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928,1,['integrat'],['integrated']
Integrability,"> No we should fix this for sure. I'm asking because you would save a lot of memory if you avoid writing `Field(w*c)`. Ah, I see. That's a good point, I'll investigate that. I'm wrapping things in `Field()` calls because I use the `data` option in all of them to reuse scratch space and save memory. But indeed when averages are involved that might not be the best way to go...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438745870:178,wrap,wrapping,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438745870,1,['wrap'],['wrapping']
Integrability,"> Nono in the code it should stay the same, because pressure due to `h` and `hB` should have opposite signs. Also for the `VectorInvariantFormulation` I directly calculate `g ∂xᵢ(h - hB)`. That depends on whether `b` is positive or negative. Before, `b <0`, and therefore the total height was `h = \eta -b`, where `\eta` is the free-surface. However, if `b > 0`, then `h = \eta + b`. . This becomes important when we evaluate the pressure graident. . In the first case we have, which is not what we had; ```; -∇η = -∇(h + b) = - ∇h - ∇b; ```; In the second case, we should have ; ```; -∇η = -∇(h - b) = - ∇h + ∇b; ```; which is what we have. Actually, now it seems that with changing the sign of `b`, the code is consistant with the equations we are now solving. Does that make sense?. But if you compute it directly, then do we need to extra `bathymetry` terms that I pointed to above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129220793:194,depend,depends,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129220793,1,['depend'],['depends']
Integrability,"> Not _exactly_ sure why it was [1][3], but if `u_init` was an active variable at one point then we we would want to get its derivative which is there. Hm ok got it, it depends on the status of what's returned",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544:169,depend,depends,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544,1,['depend'],['depends']
Integrability,"> Not sure if this is useful but it seems like the `worksize` tuple and some `args` tuple aren't being inferred correctly but `worksize` is just used to launch the kernel so maybe `args` is the problem. I'll have a deeper look when I have more time. You're looking at CPU code here; you rather want to prefix your application with `@device_code_warntype interactive=true` (which will spawn a Cthulhu UI for every kernel), or use `descend_code_warntype` directly passing the kernel's function and argument typle type. It _should_ be possible to reconstruct the tuple type from the error message:. ```; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; ```. But seeing how it's fairly complex you might be better off using `@device_code_warntype interactive=true` (after having imported Cthulhu).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673514740:586,message,message,586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673514740,1,['message'],['message']
Integrability,"> Note that tests will fail on dev/nightly builds (Julia 1.2) because something changed which broke Cassette (which GPUifyLoops depends on). Pushed a fix for that this morning, and also tagged GPUifyLoops v0.2.1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479513151:128,depend,depends,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479513151,1,['depend'],['depends']
Integrability,> Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples. Yes yes yes!. Can we have alias?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417:40,interface,interface,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417,1,['interface'],['interface']
Integrability,"> OK, I'll close this for now then and leave the issue open to remind us to heal the duplicate `R_Earth` that appear in Oceananigans...; > ; > I like the approach that users should set their constants depending on whatever choices they like. E.g., simulating an ocean in Europe or a fish tank on the top of Everest. Can you just get rid of the constant called ""R_Earth""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632295:201,depend,depending,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632295,1,['depend'],['depending']
Integrability,"> OK, perhaps I'm a bit oblivious to physics of tilted gravity etc. Are is the tilted gravity crucially important for this to occur?. Apparently yes. This doesn't happen when the buoyancy acceleration is aligned with the model's z-coordinate. > Also, is there an energy integral associated with these dynamics when there is a fixed imposed buoyancy? Even in the continuous case, before we go to discrete world, is there guarantee that E should decrease?. That's a good point and as far as I can tell this system should have a a finite, non-increasing total energy since the background buoyancy is stable. So the background buoyancy shouldn't be introducing any extra energy reservoirs (unlike, for example, an Eady set-up, which constantly injects energy into the system by imposing a horizontal buoyancy gradient). My understanding of this comes mainly from [Umlauf et al (2015)](https://journals.ametsoc.org/configurable/content/journals$002fphoc$002f45$002f12$002fjpo-d-15-0041.1.xml?t:ac=journals%24002fphoc%24002f45%24002f12%24002fjpo-d-15-0041.1.xml). Their equation (24) applied to the set-up above (i.e. without any boundary stresses and without applying a Reynolds decomposition) reads. ```math; \frac{d}{dt}\int_V \left[ \frac{u_i u_i}{2} + \frac{b^2}{2N^2} \right] dV = ; - \int_V \left[ ; \kappa \frac{\partial_j b \partial_j b}{N^2} ; + \nu {\partial_j u_i \partial_j u_i}; \right] dV \le 0; ```. Also it's worth noting that even in a `(Bounded, Flat, Bounded)` domain I still get an energy buildup, although in this case the KE stops growing after a while:. https://user-images.githubusercontent.com/13205162/228590310-51b59910-2550-48c9-93a7-f22d70c2474e.mp4. I say that because this may be a more familiar set-up and because sometimes a tilted, periodic domain might introduce some unexpected effects.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882:740,inject,injects,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882,1,['inject'],['injects']
Integrability,"> Ok you convinced me with the `print`. Better to use @navidcy's solution. On the other hand it feels a little clunky, so maybe we can define a `nameof` function which returns `string(typeof(scheme1).name.wrapper)`. `nameof` is a cool idea. Is there a similar julia function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986835999:205,wrap,wrapper,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986835999,1,['wrap'],['wrapper']
Integrability,"> Ok, so from what I understand, the `immersed_boundary` would be the same in case of `GridFitted` and `PartialCell` but the latter would ""add"" an additional height on top of that? (which modifies fluxes in the cell). The two changes are:. 1. A cell `is_immersed` if the _interface above the cell center_ is below the bottom (or nearly so). Actually the precise condition requires using `minimum_fractional_Δz` as noted above; I think we should have something like. ```julia; function is_immersed(i, j, k, ibg); ϵ = Δzᶜᶜᶜ(i, j, k, ibg) * ibg.immersed_boundary.minimum_fractional_Δz; z_above = znode(c, c, f, i, j, k+1, ibg.grid); return z_above - ϵ < get_bottom_height(i, j, k, ibg.grid, ibg.immersed_boundary.bottom_height); end. function get_bottom_height(i, j, k, grid, bottom_height); x, y, z = nodes(c, c, c, i, j, k, grid); return bottom_height(x, y); end. get_bottom_height(i, j, k, grid, bottom_height::AbstractMatrix) = @inbounds bottom_height[i, j]; ```. Should be inspected closely, might be an error... 2. The vertical grid spacings `Δzᶜᶜᶜ` are modified for the cells that are _just above the bottom_ (ie, `is_immersed(k)` is false, but `is_immersed(k-1)` is true). Note that the interface spacings `Δzᶠᶜᶜ` have to take the minimum between the `Δzᶜᶜᶜ` in adjacent cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195:1192,interface,interface,1192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195,1,['interface'],['interface']
Integrability,"> On a different note, if a `BackgroundField` is time dependent then evaluating it at every time step makes sense. But if it's time independent, as in this case, then it's working a lot more than it should. Agreed!. > If we have an array, say b_array, then can we can turn it into a field using b_field = ComputedField(b_array)?. Just `b_field .= b_array`. > Would it be of interest to have an option for it to not compute it at every time?. There are two ways to achieve this. The underlying data for a concrete `BackgroundField` can be updated via the `progress` callback every time step. A better method that's currently only possible currently with `HydrostaticFreeSurfaceModel` is to add it to the model's list of `auxiliary_fields`. In this case `compute!(field)` is called on every member of that list, so if the `BackgroundField` has a `compute!` method (eg if it's a `ComputedField`, or some other custom `Field` with a `compute!` method) then it will be updated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875586940:54,depend,dependent,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875586940,1,['depend'],['dependent']
Integrability,"> On a side note, since you asked, I am going through some difficulties running the same example with a GPU. My inexperience with GPUs is keeping me from figuring this one out. What GPU are you running on? You'll need an Nvidia GPU and the CUDA library installed. Installing Oceananigans through the Julia package manager should install all the required Julia package dependencies (but won't install CUDA itself). Are you getting any errors?. Hmmm, so there is a small caveat that `Nx` and `Ny` need to be multiples of 16 on the GPU right now, although you'd get an error about this. > Should I create another issue?. Hmmm yeah that might be a good idea just to keep each issue self-contained. > (I'm not sure how much you guys want to be involved in these debugging processes...). We're very interested in being involved with the debugging process! We're still in early development so I'd expect things to break quite often, and we still haven't ironed out all the bugs and usability issues. We've also mostly been using the model ourselves (hard to improve usability if you know all the internals haha), so if you're willing to report issues it would be a huge help with development!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740:368,depend,dependencies,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740,1,['depend'],['dependencies']
Integrability,"> On codecov --- the recent for the poor marks is because we basically will not test `Computation`. This makes sense as we are having trouble with CI and we also want to nuke these features. However, the NetCDFOutput writer still has some functionality that uses `Average` (which in turn has an interface to `Computation`) so I'm not sure we can get rid of them just yet. Sounds good to me to skip those tests. We should just be careful not to tag a new release until things have settled.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-691045772:295,interface,interface,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-691045772,1,['interface'],['interface']
Integrability,"> On the other hand, there is also more noise, and something is happening in the Indian ocean that crashes the simulation. Hypothesis: dissipation by WENO is beautiful but may impose time-step restrictions. Or put another way, for whatever reason the _amount_ of dissipation introduced by WENO may have limits. And, WENO dissipation is, by design, dependent on grid-scale gradients. Thus if there are dynamics that synoptically produce tiny scales WENO may be ""too weak"" to dissipate over a given ""longish"" time-step. A bit vague but that's one guess at what might be happening. Hyperviscosity is more robust of a filter perhaps (the problem is that we always have to guess the coefficient). Does ""vorticity smoothing"" (vs velocity smoothing) WENO also blow up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996:348,depend,dependent,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996,1,['depend'],['dependent']
Integrability,"> Once the simulation is chugging along, it seems like the Poisson problem is not as difficult. It does seem like the solution becomes more accurate in time (but unfortunately, the CG solver does not start to converge more quickly...). The issue is interestingly related to this comment in MITgcm (which may be wrong by the way, but nevertheless reflects some observation about the CG solver): . https://github.com/MITgcm/MITgcm/blob/c7a06a2c29b2186c216f05f729b330d10e23c8be/model/src/cg3d.F#L86C1-L88C81. For this MWE, the RHS is 0 with `OpenBoundaryCondition(0.01)` on both sides, but not with `FlatExtrapolationOpenBoundaryCondition()`. @jm-c remarked that the RHS is also not zero for the Poisson equation beneath a free surface (which, in a z-coordinate, also essentially has an open boundary since $w(z=0) \ne 0$). > I'll close this issue since the original MWE works now. It's just a matter of setting maxiter. I think this comment is true in a practical sense. Possibly we do need another issue about the non-convergence of the CG solver. I think there is scope for someone to put in some effort to document this (eg come up with tools to evaluate convergence) and present a few nice MWEs (I think in addition to the present one with `FlatExtrapolationOpenBoundaryCondition()`, it would be nice to have a demonstration with impenetrable boundary conditions as well). . The way that the Poisson solver and open boundary conditions are intertwined is also a good reason to implement new open boundary condition matching schemes directly in Oceananigans @jagoosw . Note that we are also thinking about how to develop an interface to `Krylov.jl` in #3803 which may open up additional avenues for progress on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2422592019:1625,interface,interface,1625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2422592019,1,['interface'],['interface']
Integrability,"> One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Good to know. Thanks for explaining. > Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Agreed! Often unexpected things happen, which keeps us on our toes. > We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. I don't pretend to understand the details of this and don't know the potential pay off so not sure whether I think this will bear fruit or not. > I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. . Good. > _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ah, I don't think I'm getting into that now but it's something to be aware of.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988:838,interface,interface,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988,1,['interface'],['interface']
Integrability,"> One thing that I noticed is that advection seemed to be commented out for tracers. Did I read that right?. Yes --- because we are still finalizing the user interface that controls the advection term + advection scheme for momentum and tracers. I think ideally we want to preserve the ability to use high-order advection schemes for momentum when we are on a `RegularCartesianGrid`. However, we also have to use a ""vector-invariant form"" of the advection term when running on curvilinear grids. So we need a way to specify both continuous and numerical aspects of the advection term implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674:158,interface,interface,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776767674,1,['interface'],['interface']
Integrability,"> Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?. Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid. I agree that we should have a test for that and maybe something in the docs, sometime?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890:152,message,message,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890,1,['message'],['message']
Integrability,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:48,integrat,integrate,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764,3,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,"> Out of curiosity @simone-silvestri could you check; > ; > ```julia; > fts2[1, 2, 3, 4] == fts2[1, 2, 3, 4.0]; > ```; > ; > in your example with the `.jld2` file above?. the outcome depends on whether `fts.times = [1, 2, 3, 4]` or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696113759:183,depend,depends,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696113759,1,['depend'],['depends']
Integrability,"> Output needs to be arbitrary. We may need to perform on-line analysis and output the result (example: turbulent dissipation rate, time-averages, slices of fields, point values, etc).; > ; > We should design an additional interface for Fields. The type of the field indicates the coordinates on which the field is defined, so we should design an interface that uses that information.; > ; > _Originally posted by @glwagner in https://github.com/ali-ramadhan/Oceananigans.jl/pull/93#issuecomment-468290310_. Just adding your comment here as I think there are two new questions raised:; 1. How to integrate diagnostics with the output writing framework?; 2. Right now each NetCDF output file shows a single snapshot. Maybe it makes more sense to keep appending to an existing NetCDF file. This might also make addressing (1) easier especially if the diagnostics have a different output frequency that other fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-468304803:223,interface,interface,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-468304803,3,"['integrat', 'interface']","['integrate', 'interface']"
Integrability,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827:359,integrat,integrate,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827,1,['integrat'],['integrate']
Integrability,"> Perhaps this usage should be demonstrated in the `Forcing` docs or something... Yes, I think that would be really helpful. I just checked and, across all of the examples, callbacks are only used for the timestep wizard and progress messages. Probably for this reason a lot of others users also don't realize they are more generally useful!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098848659:234,message,messages,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098848659,1,['message'],['messages']
Integrability,"> Please add a small description of this PR in the top comment. Done. > Question: is Oceananigans the right place for the extension to be or an extension for Oceananigans in Enzyme?; > ; > (I'm not arguing for one or the other; I'm just wondering.). So I think here is the right place, since code has a dependency on Oceananigans itself and EnzymeCore (which is dependency free). It also is how other packages (like NNlib, LinearSolve, SciMLSensitivity, etc) work with Enzyme and other AD tools.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051:303,depend,dependency,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756032051,2,['depend'],['dependency']
Integrability,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:882,mediat,mediated,882,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,1,['mediat'],['mediated']
Integrability,"> Quick general question: with this interface IBM immediately goes to drag BC, right?. That's correct. There's no way to run IBM without a drag BC with this implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050209244:36,interface,interface,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050209244,1,['interface'],['interface']
Integrability,"> Requires [JuliaGPU/KernelAbstractions.jl#399](https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399) # On hold at the moment. At the top comment it says this PR depends on another KA PR that isn't merged. However, this PR is merged (and tagged). Does this not depend on https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399 anymore?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729619719:168,depend,depends,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1729619719,2,['depend'],"['depend', 'depends']"
Integrability,"> Should AMD use z_dot_g_b now?. The implementation of a ""buoyancy-aware"" AMD is not correct... But yes, if we wanted to have a working version of this feature, it would have to know the direction of gravity. We'd have to add terms that depend on the horizontal directions for it to be correct I think, which probably warrants re-deriving it for generalized gravity from scratch. Since it doesn't even work for vertical gravity we should probably just nuke it and address later. Simplest would be to implement a working version for vertical gravity and throw an error if gravity is tilted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788:237,depend,depend,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788,1,['depend'],['depend']
Integrability,"> Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's more inline with the physics, which are additive, and we don't gain significant computational efficiency from neglecting it. I think my suggestion is being misinterpreted --- I was referring only to changes to software and data structures; not changes to the partial differential equations being solved. . If we do not ""add"" the constant background viscosity component to `model.diffusivities.νₑ`, we would instead add the contribution of the constant background viscosity to the total diffusive flux divergence separately from the contribution associated with the nonlinear eddy viscosity (similar to how the diffusive flux divergence for constant background viscosity is currently calculated without the auxiliary field `model.diffusivities.νₑ`). Thus my suggestion only changes the content of `model.diffusivities.νₑ` and otherwise preserves both the user interface and the default behavior for `Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation`. We could also completely remove ""constant background"" parameter from `AnisotropicMinimumDissipation` and preserve existing behavior, since users can use multiple turbulence closures to achieve the same effect, as in. ```julia; closure = (AnisotropicMinimumDissipation(), IsotropicViscosity(ν=1.05e-6)); ```. for example. This might be a better user interface than what we have now. As a side note, since there's no constant background viscosity that's appropriate for all scenarios, it should probably be zero by default if we continue to allow users to set it as a parameter in `AnisotropicMinimumDissipation` (eg #1278).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051:982,interface,interface,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-776178051,2,['interface'],['interface']
Integrability,"> Since this is a breaking change (?) do you want to bump to version 0.27.0 in this PR?. Ah, it isn't a breaking change btw (it just adds a wrapper around existing functionality) --- but it does add a new feature, so 0.27.0 could still be warranted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599508063:140,wrap,wrapper,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599508063,1,['wrap'],['wrapper']
Integrability,"> So if support for `pressure = nothing` (or `pressure_solver = nothing`) is added, would `BackgroundField` effectively work as a prescribed unchanging velocity?. Yes, something like this is an alternative design. But do we think that setting `pressure=nothing` might be too roundabout of a way to avoid launching kernels that calculate the velocity tendencies and to avoid allocating memory for the velocity fields?. The design I'm suggesting would have users write `velocities = PrescribedVelocities(...)` in the constructor for `IncompressibleModel` as the interface; so there's just a single keyword arg to set. We don't want `advection=nothing` since this turns off all advection, including advection by `BackgroundField`s. So out of the box @ali-ramadhan's suggestion doesn't work, but its possible that something _like_ it might be designable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768491247:560,interface,interface,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768491247,1,['interface'],['interface']
Integrability,"> So it seems that execution does not have to hit the @warn for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. Precisely. > And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. Perhaps a positional argument to `lambertw`, either boolean or perhaps even better a type (to use multiple dispatch) to control behavior, things like. * `WarnFailures()` (throw warning for failures); * `MarkFailures(value=NaN)` (mark failures with a specific value, do not throw warning); * `IgnoreFailures()` ?; * `WithSolverInfo()` (return a type that contains the root, boolean `converged`, and possibly also number of iterations). > It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. It is interesting to consider auto-sanitization of GPU code...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451,2,['interface'],['interface']
Integrability,"> So seems that all is good? So the problem comes when I continue the integration longer?. It appears that the issue does get worse the longer you run, yes. The original MWE I posted runs for 18 time steps and it looks like this:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Running it for 2 time steps it looks like this:. ![image](https://user-images.githubusercontent.com/13205162/220152519-7dab5501-6636-4c57-851d-5a944ab1d524.png). The results are still different from different tracers, but not visibly so. (The order of magnitude of the differences is around 1e-5 in this case)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437234615:70,integrat,integration,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437234615,1,['integrat'],['integration']
Integrability,"> So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`.; > ; > This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward...; > ; > Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation.; > ; > I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case... I also prefer the copy/paste method (that's what I used in https://github.com/CliMA/Oceananigans.jl/pull/3111). If I understand correctly these two functions are the only ones that need to be generalized, no?: . https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L74-L83. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L88. if so, that's not too bad. Is duplicating one of the tests in [test_batched_tridiagonal_solver.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_batched_tridiagonal_solver.jl) but rotating everything to two different directions enough to test this new functionality?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584:570,wrap,wrapper,570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584,1,['wrap'],['wrapper']
Integrability,"> So the problem comes when I continue the integration longer?. This could be worth trying, note that. ```julia; julia> using Oceananigans.Units. julia> 0.15hours / 30; 18.0; ```. So you can run for 18 steps instead of 4. (@tomchor why 18?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436104605:43,integrat,integration,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436104605,1,['integrat'],['integration']
Integrability,"> So we want to look at model.clock.time and sch.previous_interval_stop_time + sch.interval. It does seem probable the issue is roundoff error. It does seem like a roundoff error, below is the progress message. At iter:64, for example, `model.clock.time` is slightly larger than `sch.previous_interval_stop_time + sch.interval` （which I think they should've been equal):. ```julia; [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds, model clock time:0.0, previous_interval_stop_time + interval:0.1, u-avg: 0.0, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time:0.0, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.0, collecting: true; [ Info: ... simulation initialization complete (231.038 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (546.837 ms).; [ Info: Iter: 11, time: 100 ms, model clock time:0.1, previous_interval_stop_time + interval:0.2, u-avg: 0.1202985845671951, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time:0.1, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.1, collecting: false; [ Info: Iter: 22, time: 200 ms, model clock time:0.2, previous_interval_stop_time + interval:0.30000000000000004, u-avg: 0.8057920910530502, window_start_time: 0.11, window_start_iteration: 12, previous_collection_time:0.2, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.2, collecting: false; [ Info: Iter: 32, time: 300.000 ms, model clock time:0.30000000000000004, previous_interval_stop_time + interval:0.4, u-avg: 2.0225593735128355, window_start_time: 0.21, window_start_iteration: 23, previous_collection_time:0.30000000000000004, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.30000000000000004, collecting: false; [ Info: Iter: 42, time: 400 ms, model clock time:0.4, previous_interval_stop_time + interval:0.5, u-avg: 3.664512241688186, window_start_time: 0.3100000000000001, window_start_iteration: 33,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2282230302:202,message,message,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2282230302,1,['message'],['message']
Integrability,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:704,interface,interface,704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['interface'],['interface']
Integrability,"> Some benchmarks from running `implicit_surface_solvers_benchmark.jl`; > ; > On GPU: FFT: 0.902434 seconds (1.58 M allocations: 549.219 MiB, 13.25% gc time) PCG: 37.329798 seconds (17.07 M allocations: 2.563 GiB, 1.85% gc time) Heptadiagonal: 4.323861 seconds (6.06 M allocations: 675.694 MiB, 4.72% gc time, 1.32% compilation time) MG: 4.495123 seconds (1.50 M allocations: 492.900 MiB, 2.16% gc time) PCG with FFT preconditioner: 22.673894 seconds (3.53 M allocations: 864.587 MiB, 0.77% gc time); > ; > On CPU: FFT: 6.548544 seconds (3.61 M allocations: 1.910 GiB, 14.07% gc time, 1.30% compilation time) PCG: 32.354310 seconds (20.29 M allocations: 7.041 GiB, 5.80% gc time) Heptadiagonal: 9.795938 seconds (3.51 M allocations: 1.595 GiB, 39.13% gc time) MG: 11.868795 seconds (3.85 M allocations: 3.991 GiB, 43.10% gc time) PCG with FFT preconditioner: 10.473279 seconds (5.38 M allocations: 2.654 GiB, 9.37% gc time). nice. A problem with having an iterative matrix solver algorithm (like the pcg) is going to high resolutions (or conversely large time steps). ; The matrix becomes poorly conditioned because the diagonal (which depends on `Δt²`) decreases faster than the off-diagonals (which depend on the integrated areas) and the number of iterations required to converge spike up.; This means that on a GPU both eddy-permitting and resolving simulations are dominated by the cost of the implicit solver.; Our default preconditioner (for the Heptadiagonal solver) also loses efficiency when increasing `Δt` (or increasing resolution) because it assumes that the matrix is diagonally dominant. This is a problem that the FFT solver does not have.; I would be very interesting to know if with a multigrid algorithm this problem is less severe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577:1136,depend,depends,1136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577,3,"['depend', 'integrat']","['depend', 'depends', 'integrated']"
Integrability,"> Some good news is that more tests seem to be passing compared to the prevoius PR.; > ; > One of the messages I saw was there was a cancellation signal, see below. Lots of the tests just cancelled, and I'm not sure why.; > ; > ```; > Testing Oceananigans; > # Received cancellation signal, interrupting; > ```. I don't know what you saw.; But what I see here: . https://buildkite.com/clima/oceananigans/builds/14750. is that almost all tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988349960:102,message,messages,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988349960,1,['message'],['messages']
Integrability,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:327,wrap,wrap,327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443,1,['wrap'],['wrap']
Integrability,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994:122,message,message,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994,1,['message'],['message']
Integrability,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161:444,message,message,444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161,3,['message'],"['message', 'messages']"
Integrability,"> Sorry @glwagner Maybe I didn't express very well. I don't see any problem in split files and understand the importance in having that. What I meant is that we could access the rank id from Distributed output to use it on the output filename so that we don't need to explicitly import MPI. I was responding to @simone-silvestri !. In terms of user scripts, I certainly do think it's better to access the `rank_id` from the architecture. I think it's easier to read too, and it allows user scripts to depend on one fewer package. However, I think that the output writers should automatically change the filename when the simulation is distributed. This should be pretty easy and just involves adding the suffix `_rank$(rank_id)` to the filename for distributed architectures. We should also have an API for callbacks that are intended to only run on one rank (for example for printing stuff); eg a property `on_rank=0` which is used when `arch isa Distributed`. There's probably other useful things. `FieldTimeSeries` will have to be modified so that it can combine distributed files, for example. Probably, distributed output should also save some kind of ""meta"" file that contains information about the processor layout, to be used by `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329:501,depend,depend,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329,1,['depend'],['depend']
Integrability,"> Thanks @glwagner . I started but have a few questions.; > ; > * Why didn't the hydrostatic model need a `with_halo` function?; > * I started to write a `new_halo` function in `ImmersedBoundaries.jl` but don't think this is the right spot. Where should it go?; > * Most of the function is pretty easy except for when we define the new_grid. What I have [here](https://github.com/CliMA/Oceananigans.jl/blob/5ea7b9168a40619a17d2c9ab42b65b622a7c9ac1/src/ImmersedBoundaries/ImmersedBoundaries.jl#L86) is wrong but can you help me modify it? It seems like we know infomration about the bump but that is not currently passed in new_halo. Maybe we need to pass more information?. I guess the hydrostatic model doesn't call `with_halo`:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl. I think you need `with_halo` rather than `new_halo`, if I read the error message correctly. In that case I think the needed function is a one-liner:. ```julia; with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. But maybe I am missing something? I don't quite understand what you mean about `new_grid`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844285667:932,message,message,932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844285667,1,['message'],['message']
Integrability,"> Thanks @glwagner .; > ; > Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed.; > ; > I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same. Ok but there is no ""one"" hydrostatic model. Also note that you are prescribing fluxes here, not wind. These are different because bulk formula typically use relative winds, and also because momentum fluxes depend on buoyancy fluxes. Can you state more clearly what you would like to do? It sounds like you want to run two simulations --- one hydrostatic, and one shallow water, which are forced similarly. Is that right? We have to set both of those up then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938:816,depend,depend,816,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938,1,['depend'],['depend']
Integrability,"> Thanks @jagoosw and @glwagner for your thoughts on this. @glwagner, the approach to nesting is going to be highly dependent on the particular case. The nesting strategy for a simulation with mesoscale eddies passing across the boundary will be very different from the strategy to nest an LES inside a low resolution simulation. I think that this PR should provide different types of boundary conditions (the 'ingredients') and the user will need to decide how to use them for their particular case (the 'recipe' which will rely on different combinations of the 'ingredients'). Does that make sense?. Yes, that makes sense! I do think we need to have a way to test the different methods... ideally, the tests are non-trivial enough to illustrate that the numerics ""works"" for each ingredient that we implement (either independently or when combined with other ingredients to make a recipe). But the tests don't have to be exhaustive; I imagine it will take some time to develop our best practices.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040113530:116,depend,dependent,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040113530,1,['depend'],['dependent']
Integrability,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:342,depend,dependence,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148,1,['depend'],['dependence']
Integrability,"> That makes sense. I didn't realize the difference between a ""golden master"" and a ""regression"" test. I wouldn't call the output we produce right now to be ""golden master"" level. That's just how I'm defining it. > The two regression tests may be failing for different reasons. Since this test will help you determine that, I guess I feel it will be useful for your work. But if you think there is some intrinsic problem with the test added in this PR then ok. I need this test to integrate the turbulence closures into the code, so I will be using it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496241755:481,integrat,integrate,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496241755,1,['integrat'],['integrate']
Integrability,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:761,depend,depending,761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685,1,['depend'],['depending']
Integrability,"> That's not my intention at all. I have plans to try to implement a dynamic option with or without the above flexibility I proposed. I do think there are legitimate reasons to allow for a user-defined coefficient. Like manually decreasing the coefficient in regions where it's overly diffusive, or when running wall-resolved LES. Basically, since the necessary change is a couple lines of code, I tend to think that flexibility is worth it. That said, the `Array`-based method you proposed can also cover these cases. Ok, but you proposed an interface that would include the velocity field. What are the use cases for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187205089:543,interface,interface,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187205089,1,['interface'],['interface']
Integrability,"> The boundary condition implementation should dispatch on the type of the boundary conditions. I agree that's a good approach. To do this, we'd have to merge PR #288. Do you have some time to look at it?. > We probably need a kernel to fill the halo regions. We do have a couple but they need to be rewritten. I ended up switching to broadcasts but I think kernels would be more readable, especially as the halo filling will be different for velocities (u, w) and tracers (T, S) with v being a special case as the walls are in the y-dimension. I plan to switch back to kernels before merging this. > I don't understand @jm-c's comment about ""having to fill the halo regions very frequently"". A few more details on this point would be helpful to facilitate a discussion about it. I think it may have been specifically in reference to how the 3rd order positivity-preserving DST (+ flux limiter) advection scheme is implemented (prototyped in PR #183). Not sure if other advection schemes pose a similar issue, but I figure we cross that bridge when we get there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-504984087:1037,bridg,bridge,1037,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-504984087,1,['bridg'],['bridge']
Integrability,"> The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before. Sorry, I meant this example, where I want to do something like is done in field-dependent forcing where when it's materialised it converts some tracer names into indices and replaces the names in the model with them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716346783:606,depend,dependent,606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716346783,1,['depend'],['dependent']
Integrability,"> The changes look good to me but I admit that I am a bit confuses as to when we have superscripts a vs c or f. The superscript `a` refers to ""Any"" location. For example, the difference operator `δxᶜᵃᵃ` is _independent_ of the `y` and `z` directions:. https://github.com/CliMA/Oceananigans.jl/blob/6bfc1551c57403268138b85620d88dba8114a4c0/src/Operators/difference_operators.jl#L7. Thus this operator is valid if `y` and `z` are respectively `Center` or `Face`. When this is not true (for example, on a horizontally-curvilinear grid, the grid spacing in the x-direction depends on both `x` and `y` location), we need to explicitly specify the location of the operator / object.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813396548:569,depend,depends,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-813396548,1,['depend'],['depends']
Integrability,"> The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to JLD2OutputWriter and NetCDFOutputWriter in a WindowedTimeAverage. Yeah, sorry, `windowed_time_average.jl` is what I meant to link to. I guess somewhere these accumulation of the denominator of the mean should be reset to zero when the proper time interval has passed, but I'm not sure where. And thanks for the line-by-line explanation. I understand that part but I really don't see how to fix the issue right now. > Can you explain why isn't this captured in our tests?. I don't know for now. I don't fully understand the `WindowedTimeAveraged` tests to be honest. I think I'd need to run those manually on the REPL but I don't quite have a lot of time on my hands right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141:154,wrap,wrapping,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872459141,1,['wrap'],['wrapping']
Integrability,"> The dependency on OrthogonalSphericalShellGrids here is blocking the progress (the `SplitExplicitAuxiliaryFields` type has changed in this PR). How do we deal with this? We could remove the dependency in the tests of Oceananigans and move those tests over at OrthogonalSphericalShellGrids. Shall we do this? In case we want to do it I have prepared https://github.com/CliMA/OrthogonalSphericalShellGrids.jl/pull/47.; If yes, we can merge that one then this one, then update OrthogonalSphericalShellGrids with the new interface",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2437244222:6,depend,dependency,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2437244222,3,"['depend', 'interface']","['dependency', 'interface']"
Integrability,"> The error message we are gettig now does not seem to involve this PR at all.; > ; > If that is the case do we need to reset it?. Yeah, this is an annoying error we get sometimes for reasons unbeknownst to me. I'll restart the build.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843330164:12,message,message,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843330164,1,['message'],['message']
Integrability,"> The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect. I'm aware of that. My point was more that I don't quite remember how the issue was manifested in the dynamics (the recognition of which was what prompted us to abandon https://github.com/CliMA/Oceananigans.jl/pull/1910). > @tomchor I updated the PR description. Feel free to edit it further. Thanks, that's a great detailed description. I only added one item to the advantages: simpler code and user interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197:648,interface,interface,648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197,1,['interface'],['interface']
Integrability,"> The main advantage of having DiskTimeSeries in Oceananigans would be to use it in examples without depending on another package. I'm not sure what `DiskTimeSeries` specifically is, I guess I missed that discussion, so take my comments with a grain of salt. But I don't think Oceananigans examples depending on other packages is necessarily a bad thing. In fact I see it as a good thing. . Right now there is at least one package, possibly two (LESbrary.jl and Oceanostics.jl) that can make the user's life easier when running Oceananigans. At the moment, there is no way for the user to find out that these packages exist, unless they joined the slack or stumbled upon them in an Oceananigans issue (unless I missed something in the docs). I also bet there are many other useful Julia packages that could make one's life easier in Oeananigans that I and many users have never used or heard of. I think including these packages in at least some examples would encourage users to experiment and explore. One of the advantages of python is its powerful ecosystem of packages, and I guess this could be the start of something similar for physical oceanographers in Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908:101,depend,depending,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-810245908,2,['depend'],['depending']
Integrability,"> The main downside I think is that the validation repo goes stale by design. Wouldn't JuliaRegistrator keep this from happening? ; If we list Oceananigans as a dependence, it'll create a new PR with the an updated version of Oceananigans everytime we update Oceananigans.jl, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423:161,depend,dependence,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423,1,['depend'],['dependence']
Integrability,"> The problem with custom forcing is that the `dynamics` function is not implemented where the particle is actually advected (inside the particle advection kernel). We need a way to calculate a particle velocity that differs from the fluid velocity; > ; > for example, particles with inertia that follow dvdt=1τp(u−v) where v is the particle velocity and u is the fluid velocity can be implemented as:. First of all, I think it's great to implement a better interface for forcing particles. So I'm on board with this. You could probably implement inertia (and many other things) by storing the previous particle velocity (or whatever properties you needed for correct dynamics) inside the particle struct. So I'm pretty sure you could also implement these dynamics with the current interface. As I said though, I agree it's a good idea to make this kind of thing easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620:458,interface,interface,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819357620,2,['interface'],['interface']
Integrability,"> The purpose of this PR was to save mutliple scalars using `NetCDFOutputWriter` and there seemed to be some problems, i.e. some checks fail.; > ; > @glwagner mentioned that maybe `using Statistics: norm` might work without any additional work. Is this the case? If yes then I am happy to close this PR and give it a try on the shallow water Bickley jet example. Ah... the change is fairly innocuous, there's just a few things that make me nervous. 1) It _shouldn't_ fix the problem that it's intended to fix. Unless there's something I am missing... if it fixes the problem that was raised, it's due to some unintended side effect that we don't understand? (Providing some detail and the error message that was received could help, or it could be raised in an issue). A more grave concern is 2) it will slow down the code and cause memory allocation. This is almost always completely negligible since other parts of the code matter more, but it could affect small models, our CI pipeline, etc. It's hard to intentionally throw away type stability :-/ So in a way it's creating technical debt and possibly creating work for us in the future...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824916415:695,message,message,695,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824916415,1,['message'],['message']
Integrability,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816:58,integrat,integrated,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816,2,['integrat'],['integrated']
Integrability,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:342,rout,routine,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850,1,['rout'],['routine']
Integrability,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:247,wrap,wrapped,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103,1,['wrap'],['wrapped']
Integrability,"> This function only works if you have a diagnostic though. I prefer to simply output the horizontal averages directly to file. How would I do that with the code in this PR?. If you don't want to use a diagnostic, you'd have to pre-allocate a 1D CuArray of size `1*1*Nz` for `Rxy` and a 2D CuArray of size `1*Ny*Nz` for `Rx`, then call `gpu_accumulate_xy!(Rxy, Rx, data, nothing, +)`, then save `Rxy` to disk. Seems like that would be less efficient as you'd have to pre-allocate memory every time you want to calculate a horizontal average. Which is why having a `VerticalProfile` diagnostic that takes care of this stuff is nice. We could write a wrapper function that allocates the arrays, and returns only the horizontal average.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520552786:649,wrap,wrapper,649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520552786,1,['wrap'],['wrapper']
Integrability,"> This is good after changes.; > ; > My only question is whether another implementation might be something like; > ; > ```julia; > function Base.:(==)(grid1::AbstractGrid, grid2::AbstractGrid); > !isa(grid2, typeof(grid1).name.wrapper) && return false; > topology(grid1) == topology(grid2) && return false; > ; > x1, y1, z1 = nodes((Face, Face, Face), grid1); > x2, y2, z2 = nodes((Face, Face, Face), grid2); > ; > return x1 == x2 && y1 == y2 && z1 == z2; > end; > ```; > ; > This has different behavior than what's implemented here. In particular, two grids will be identified as equal even if one has ""number spacing"" (eg a constant) whereas the other has array-spacing with all the values equal to that number. In other words, while; > ; > ```julia; > julia> 1.0 == ones(2); > false; > ```; > ; > we may want to identify this case with numeric equality for a grid.; > ; > The key here is that two grids are ""equal"" if they have the same nodes. The other properties (like spacings) are really implied by the placement of the nodes. OK, perhaps then your suggestion is better.; What about when two grids are otherwise the same but one lives on GPU and one on CPU. Will the above render them equal? I guess no since, e.g., `z1 == z2` will return false if one is an Array and other a CuArray.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951386368:227,wrap,wrapper,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951386368,1,['wrap'],['wrapper']
Integrability,"> This is great! Have you started a PR already to support Sparse in AMDGPU proper?. @vchuravy yes here's the PR: https://github.com/JuliaGPU/AMDGPU.jl/pull/298. We're stuck for some time since we're getting some timing issues on a couple of tests; We get incorrect results depending on the timing of the operations. Even after adding synchronization after each operation, the error still persists. Other than that they seem to work fine. @jpsamaroo can update you on that. > So this PR is to merge something on an Oceananigans.jl branch, `amdgpu`. It modifies 482 files?!; > The `amdgpu` branch is waaay outdated so as a first step perhaps we need to bring that branch up to date? I'm wondering if the seemingly proposed changes to 482 files would be much reduced if we bring `amdgpu` up to date with `main`?. @navidcy @simone-silvestri I don't have write access to this branch so you can update the branch first before reviewing the PR. This work is not yet ready to be merged yet to the main branch so we decided in the past that this might be the place for it while we test it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562:273,depend,depending,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562,2,"['depend', 'synchroniz']","['depending', 'synchronization']"
Integrability,"> This is great, though I'm wondering what it's role in the Oceananigans code base is. Is the intention to remove these bits once WENO is actually implemented in the code?. Yeah so the point of this PR was to test the WENO operators independently of Oceananigans.jl (also to play around with how advection schemes interact with different time steppers). The WENO operators were coded so that we can readily integrate them with the existing operators in `tracer_advection_operators`. So when an advection scheme abstraction is implemented and `weno.jl` is integrated into the main code, `verification/tracer_advection_1d/tracer_advection_1d.jl` can be converted into an Oceananigans.jl verification experiment. Right now it's just a WENO-5 verification experiment. > Why not?. Ah sorry I wasn't clear. I just didn't think running with CFL=4 would be possible in 3D. > I think the first course of action may be to do something similar to what we did for the nonlinear equation of state: implement a simple new advection scheme (even as simple as first order upwind?) for the purpose of designing an `Advection` abstraction. Agreed. First-order upwind is actually included in this PR; ```julia; @inline ∂x_advective_flux(i, Δx, u, ϕ, ::FirstOrderUpwind) =; max(u[i], 0) * (ϕ[i] - ϕ[i-1])/Δx + min(u[i], 0) * (ϕ[i+1] - ϕ[i])/Δx; ```; but it's so diffusive I don't know if we want to include it as an option (although it's up to the users, they may have a good reason to use first-order upwind).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-579900751:407,integrat,integrate,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-579900751,2,['integrat'],"['integrate', 'integrated']"
Integrability,"> This looks super cool: I'll be happy to meet for coffee and chat in person (assuming you're both at MIT) but I am not very familiar with tools in climatology* and think @meggart @visr @evetion @mkborregaard and @juliohm will be in a better position to comment about it.; > ; > *The packages in JuliaGeo have been mostly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models. That might be useful down the line! Yes we're both around MIT. I think we're still figuring how we want to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:394,interface,interface,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['interface'],['interface']
Integrability,"> This output writer works (but TimeInterval won't work):. One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563:694,interface,interface,694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563,1,['interface'],['interface']
Integrability,"> Those animations look great @tomchor, thanks for working so hard to put this together.; > ; > One observation is that the first plot, the velocity, shows that the initial structures are very small scale in both the horizontal and the vertical. I wonder if increasing \nu would produce an aniamtion that is better resolved?. Yes, this simulation is a bit underresolved I think. Increasing ν would definitely help. The reason I didn't do this is because when I increase it to the point that the simulation is well-resolved, then the videos become pretty boring! I'd need to increase the number of points too and then it would be too costly of a simulation for a docs example. . This also depends on the philosophy behind the docs examples. Do we want them to be simulations that absolutely hold scientific scrutiny from all fronts? If so then yeah, I should probably make it better-resolved. I see the docs example as having some wiggle room, though, as long as it teaches users something valuable. But that's obviously up for debate. > ; > As for what to do with this, you are the creator, but I would sugget creating a doc. This is a great opportunity to show the nice results and help teach people how to use different features. By creating a doc, do you mean docs example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-951263873:688,depend,depends,688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-951263873,1,['depend'],['depends']
Integrability,"> To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on TimeInterval which should, in theory, work perfectly. Wouldn't the MWE I posted above work? Or do you mean a MWE that generates round-off errors at _predictable_ times? (I cannot predict when the errors will occur in the MWE above.). > Hmm and there is one more point. Round-off error is the reason we get tiny time-steps, and we should fix that. However, that would still leave open the underlying problem, which is that the pressure correction fails for machine epsilon time-steps. So I'm wondering if in fact we should fix both issues. I agree with this point, but I feel like I'm also missing something here. Let's say we change the pressure correction so that it works for machine epsilon. Won't the pressure gradient force still depend on `Δt`? That is, won't it be larger for small `Δt`s and vice-versa? If so, this implies the pressure gradient doesn't converge with `Δt` and if so, how do we close a budget where the pressure term is important? (Maybe that's a question for another place also... I don't want to derail the discussion from the specific issue at hand.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427:861,depend,depend,861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427,1,['depend'],['depend']
Integrability,"> True.; > ; > @tomchor would you be keen to add drag in the internal tide example? If you just add the code I can deal w the rest. I can, but I don't really see drag there adding value to the example. @navidcy, do you think it would be relevant to the physics? Or do we just want drag to be there as an example of using the interface?. Also, I'm not very familiar with these larger-scale, hydrostatic simulations. What's the physically-preferred way to add drag there? Does something like. ```math; \vec\tau = -C^D \vec u \sqrt{u^2+v^2}; ```; (applied to `bottom`, `west` and `east`, with $C^D \approx$ 1e-3) look reasonable?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606158789:325,interface,interface,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606158789,1,['interface'],['interface']
Integrability,"> Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`. Actually, even putting `@show ""hi""` **just before** `calculate_pressure_correction!` also does the job.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299354090:138,synchroniz,synchronization,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299354090,1,['synchroniz'],['synchronization']
Integrability,"> Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > ; > ; > ; > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > ; > ; > ; > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up. . Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though. We can calculate more metrics for sure. I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?. Here are some docs:. https://numba.pydata.org/numba-doc/latest/user/parallel.html",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990:257,depend,dependent,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990,1,['depend'],['dependent']
Integrability,"> Was it some random one-off stochastic error?. Turns out this happens on a Quadro GP100 GPU, but not on a Tesla V100. I'm using Julia 1.8.3 on NCAR's Casper server using the (current as of this message) main branch. Not sure what to do about this. Does it have to do with the Compute Capability? @navidcy which GPUs does tartarus have again?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499163705:195,message,message,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499163705,1,['message'],['message']
Integrability,"> We could also just change the signature of the `calc_` functions to pass all the fields instead of just velocities and tracers separately `fields(model)`. Yeah I like that idea. Also, is there anything that keeps us from passing `model` itself? It seems like it'd simplify the interfaces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483:279,interface,interfaces,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483,1,['interface'],['interfaces']
Integrability,"> We could do that, in fact the requests are stored in the `arch.mpi_requests` vector. The problem with using the length of that vector for inferring a `field_id` is that is not unique for different ranks. For example, a slab decomposition on a bounded domain will lead to 2 requests for the rank adjacent to boundaries (RightConnected or LeftConnected) and 4 for ranks connected on both sides. In this way, the counter is incremented globally when one field is sent, the side is inferred from the `fill_halo_side!` routine so this, combined to a location, leads to a unique tag.; > ; > What about changing the `mpi_tag` name to `active_comm_counter` and add an inverse function to extract the inputs from the tag? Then it is quite easy to inspect the tag and understand what communication we are looking at. I don't follow. You have all of that information if you simply store the `HaloFillEvents` in a vector. Maybe you can't use the ""length"" but surely you can compute the number needed, which is currently stored as a ""counter"". You can also store the pointer to the field itself rather than an ""id"" / number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287:516,rout,routine,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287,1,['rout'],['routine']
Integrability,"> We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type.; > ; > Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector). Okay, so a longer term plan. For the moment we need that `HydrostaticModel` uses traditional f- or beta-plane, or something that does the same thing. It is `NonhydrostaticModel` that will allow for more types of coriolis terms. Understood.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888464586:118,depend,depends,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888464586,1,['depend'],['depends']
Integrability,"> We could just fully switch to passing the simulation to output writers and diagnostics?. Doesn't seem like there's much of a downside to that?. If `OutputWriters` are basically fancy functions of `model`, but checkpointing depends on the `Simulation`, then a `Checkpointer` might not be an output writer at all... We may want have a pow wow and rethink the whole concept of checkpointing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568:225,depend,depends,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568,1,['depend'],['depends']
Integrability,"> We could write a wrapper function that allocates the arrays, and returns only the horizontal average. I think what would be most useful is a function that takes in a pre-allocated array, (potentially scratch space if that is needed), and an array to be averaged, and stores the result of the average in the preallocated array.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520580976:19,wrap,wrapper,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520580976,1,['wrap'],['wrapper']
Integrability,"> We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).; > ; > _Originally posted by @glwagner in [#2050 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805)_. Wouldn't it be better to have something like `Δx = grid_spacing(model.velocities.v, 1)`? Because I'm assuming the `Δx` has to change depending if they want to use it on a quantity that lies on a `Face` or `Center` node in that direction. Maybe just `Δx = grid_spacing(Face, grid, 1)`, or something akin to the already-existing `nodes` function, that returns all 3 at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-967762357:396,depend,depending,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-967762357,1,['depend'],['depending']
Integrability,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:941,interface,interface,941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281,1,['interface'],['interface']
Integrability,"> Well, I don't know what is long or short (but I agree, O(10mins) seems bit long). But most importantly, in my benches I find that v0.90.1 is **faster** than 0.89.3, contrary to what you claim. Do you see a difference if you wrap `ζ` in `Field`? I guess that is my major claim.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804812622:226,wrap,wrap,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804812622,1,['wrap'],['wrap']
Integrability,"> What change was observed?. As you see in my original message, `u.parent[3,3,3] = -0.00829848` should be the same as `u.parent[35,3,3] = -0.00859588`, but it's not. It's because the halo regions are not filled after each time step. I noticed this difference because I use halo regions for the advection of a periodic domain and the mass was not conserved after I updated to the `master` branch. . Now I know why the halo regions are not correct and I can fill the halo regions myself. Problem solved!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-693768293:55,message,message,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-693768293,1,['message'],['message']
Integrability,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267:1727,message,messages,1727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267,1,['message'],['messages']
Integrability,"> What parallelism strategy makes sense? One particle per thread?. I think that makes sense, and we just queue up a huge amount of blocks like we already do with 3D kernels. Although if we use DifferentialEquations.jl then maybe we won't have to worry about parallelism here?. > Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Yeah I'm not super sure what's a good approach here. We're on a regular Cartesian grid right now so maybe the difference isn't huge?. The [Parcels v2.0 paper by Delandmeter & van Sebille (2019)](https://www.geosci-model-dev.net/12/3571/2019/) discusses interpolation schemes for curvilinear C-grids using mostly Lagrange polynomials. But on a rectilinear grid like ours, it seems that it just reduces down to linear interpolation [see Eq. (3)]. Maybe a good question for @jm-c. > Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design. Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399:1001,depend,depend,1001,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399,1,['depend'],['depend']
Integrability,"> What's the motivation for using a macro rather than multiple dispatch?. The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write _5! = 120_ new functions. The `update_source_terms!` function is already 52 lines long so I'd rather avoid having to dispatch on this function. > An argument against macros is that they make the code more obscure. It's harder to figure out what is happening because you have to find the definition of the macro. I think this is context-dependent. The purpose of a macro with a name like `@insert_forcing_u` or `@insert_forcing_term` is pretty clear. If we used dispatch then you'd still have to scroll through multiple function definitions. > Come to think of it, the user can also just define a forcing function that indexes into some constant array. Why is this not a good solution?. I think this would work pretty well. I couldn't figure out how to pass in the array to be indexed so that it can fit in the `Fu(grid, velocities, tracers, i, j, k)` signature and be available for the user to fill. Where in the model should we store the forcing array in this case?. Hmmm, actually we could make the function accept the forcing struct, e.g.; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k); ```; but then we'd have to have arrays in the forcing struct, e.g.; ```julia; struct Forcing{Tu,Tv,Tw,TT,TS,TA<:AbstractArray}; u::Tu; v::Tv; w::Tw; T::TT; S::TS; u_arr::TA; v_arr::TA; w_arr::TA; T_arr::TA; S_arr::TA; end; ```; and then the forcing function is just; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k) = forcing.u_arr[i, j, k]; ```. Either we have 5 array types so fields with an actual forcing function get `nothing` for the array or we have 1 array type `TA` and set the arrays for forcings with a function to something like `Array{Float64}(undef, 0)`. Might be a little too ugly but I think yeah we should be able to a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318:591,depend,dependent,591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318,1,['depend'],['dependent']
Integrability,"> When I set the halo to be `halo=(3,3)` I get the following error message since it wants `halo=(3,3,0)`. This seems slightly less than idea. Should we make it so that either are acceptable?; > ; > ```; > [2021/05/18 12:08:59.339] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grid; > ```. This is a warning, not an error right?. Yes, I think it'd be good to change the warning (since it's wrong). I would save this for another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843321244:67,message,message,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843321244,1,['message'],['message']
Integrability,"> Why is a vector that represents the diagonal elements of a hypothetical viscosity tensor useful?. Because I think most of the tuple closures used are `(HorizontalDiffusivity, VerticalDiffusivity)`, where the diagonal is what you need. Although that intuition might be wrong. But most of the reason for my attempted changes to `viscosity()` here is that apparently [`viscosity()` is the user interface to retrieve the viscosities regardless of closure](https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114). However, if a user uses that in the example below, the output isn't correct considering the physics:. ```julia; julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> closure = (HorizontalScalarDiffusivity(ν=1), VerticalScalarDiffusivity(ν=2));. julia> model = NonhydrostaticModel(grid=grid, closure=closure);. julia> using Oceananigans.TurbulenceClosures: viscosity. julia> viscosity(model.closure, model.diffusivity_fields); 3.0; ```. Maybe the best way to move forward isn't to change `viscosity()`, but IMO a user-facing function to get viscosities that works as expected (i.e., returns something like `[1, 1, 2]` in the above example) would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938:393,interface,interface,393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938,1,['interface'],['interface']
Integrability,"> Would it be in the scope of this PR to add to `regularize_field_boundary_conditions` or similar to automatically add a warning when one tracer is specified as having an open boundary but others are not? Alternativly to set some default alternative but I'm not sure what that would be. We could but it might be good to look at what the code looks like first. Adding a warning makes an assumption about what the user inteface is, but we haven't really discussed exactly what we want the user interface to look like. You can include a script for the visualization above perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004737693:492,interface,interface,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004737693,1,['interface'],['interface']
Integrability,> Wrapping `Vararg` directly in UnionAll is deprecated (wrap the tuple instead). The internet says to use `times::Vararg{Number}`. somewhere in . https://discourse.julialang.org/t/deprecation-warnings-from-atom-with-v1-7/72400/3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567728743:2,Wrap,Wrapping,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567728743,2,"['Wrap', 'wrap']","['Wrapping', 'wrap']"
Integrability,> Yeah I encountered it when trying to put some interpolations with arrays in a DiscreteForcing. I guess they're not as commonly used as ContinuousForcing. Might be nice to have an interface for that for `ContinuousForcing`!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1642#issuecomment-836949524:181,interface,interface,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1642#issuecomment-836949524,1,['interface'],['interface']
Integrability,"> Yeah, I've done some tests here: [#3646 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211254101); > The 1D test is consistent with the analytical solution, which works great!. @liuchihl, I think @navidcy is asking about smaller unit tests that could be run in Continuous Integration (CI) to automatically test the package whenever any changes get made. The simplest test would be a 1D simulation with a background linear tracer profile with boundary conditions of $\text{Flux} = - \kappa \partial_{z} c$ at the top and bottom. The correct solution would be that nothing happens when the simulation is time-stepped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950:303,Integrat,Integration,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950,1,['Integrat'],['Integration']
Integrability,"> Yep, I would call it bulk velocity though, instead of phase speed, and change the name from `Orlanski` to something more descriptive like `AdvectiveOutflow`. But these are mathematically identical right? Orlanski called is a ""phase speed"", but ""outflow velocity"" is equally valid and refers to exactly the same mathematical object. The reference you posted says. > The test results also confirm that this type of boundary condition, which was originally designed by Orlanski primarily for equations which are hyperbolic in nature, also performs well for parabolic problems. I think we can keep the name ""Orlanski"" and provide a generic interface for specifying the outflow speed (whatever you want to call it). It can be user-specific, dynamically computed, etc. The code can be extensible, so if users want to experiment with different methods for computing the outflow speed, this is possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832:638,interface,interface,638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832,1,['interface'],['interface']
Integrability,"> Yes, that seems promising! For some problems of that nature we have recommended that people write functions to interpolate their discrete data, since one can then change resolution seamlessly... but perhaps there's a case where writing an interpolator doesn't make sense or is too cumbersome for a simple setup. 🤔. Writing an interpolator function would certainly be the most elegant way but some user might already be used to other regridding tools (like nco) and would prefer to read in some fields?. A simple fun example for using array inputs:. Prepare a tracer field by backward advecting the attached image or a logo in a Stommel gyre. Save the distorted image and now prepare the example using this distorted image as the initial condition for a forward advection :-). More seriously you could do the example including backward and forward integration to show the quality difference of several advection schemes. ![image](https://user-images.githubusercontent.com/19711382/118604859-ef7f6800-b7b5-11eb-87de-98934b4df17d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736:849,integrat,integration,849,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736,1,['integrat'],['integration']
Integrability,"> Yes, this simulation is a bit underresolved I think. Increasing ν would definitely help. The reason I didn't do this is because when I increase it to the point that the simulation is well-resolved, then the videos become pretty boring! I'd need to increase the number of points too and then it would be too costly of a simulation for a docs example.; > ; > This also depends on the philosophy behind the docs examples. Do we want them to be simulations that absolutely hold scientific scrutiny from all fronts? If so then yeah, I should probably make it better-resolved. I see the docs example as having some wiggle room, though, as long as it teaches users something valuable. But that's obviously up for debate. I think underresolution is ok; many of the examples are underresolved, mostly because we want them to be cheap. The docs examples (in my opinion) are to demonstrate code functionality; eg give users the tools and inspiration they need to set up their own experiments. . A great docs example does go above and beyond and also includes lessons about physics, style and scripting practices, and creative uses of the code. So we could imagine a docs example that illustrates the _concept_ of numerical convergence, and how to build such a test using Oceananigans. But I don't think the mere _realization_ of convergence is that helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953850791:369,depend,depends,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953850791,1,['depend'],['depends']
Integrability,"> Yes. Given the derivation I posted, and what @glwagner said, it seems like we want to be using the velocity at an edge not the cell-averaged values, which is what we are storing as fields. But I could be missing something here. I think we are making a particular choice: because we are using a staggered grid, we can reconstruct the velocity field at tracer cell interfaces simply be evaluating the cell-averaged velocity field there. Perhaps this reconstruction has a particular order of accuracy (eg second-order?) I'm not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567:365,interface,interfaces,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567,1,['interface'],['interfaces']
Integrability,> Yes. We essentially want to mapreduce over operations like w / Δz but w and Δz need to have the same size for mapreduce to work on multiple iterators (w and Δz). They have different sizes on all grids right now. Can we wrap the reduced objects somehow so that the iterators for both objects match?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811437698:221,wrap,wrap,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811437698,1,['wrap'],['wrap']
Integrability,> You are right that maybe horizontally `Flat` does not work in general with lat-long. I change the test to have lat-lon grids with only one. of the horizontal directions flat. I think we should add a warning/error message when someone tries to create a lat-lon grid with both lat and lon being Flat. (but not in this PR).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073:215,message,message,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073,1,['message'],['message']
Integrability,"> You can start by allowing the coefficient to be an array as in AMD:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L143; > ; > Then with a callback you can implement any model, including dynamic Smagorinsky. So this provides unlimited flexibility in developing a new closure.; > ; > I think its possible you will find that its more efficient to precompute (eg in a callback) the coefficient rather than compute it on the fly with a function, especially because the computation of the different filters is a bit non-local, eg you have to average over a few grid points, which could involve relatively expensive memory fetches. I see what you mean. That's a good point. I think I'll start with that PR. > A function-based interface could be nice too, but note that they are relatively complicated. Do we expect a lot of users to experiment with custom coefficient functions? @tomchor if this feature is just for you to experiment with dynamic Smagorinsky implementations then I think experimenting in the source code is an even quicker and easier option than designing a function-based interface... That's not my intention at all. I have plans to try to implement a dynamic option with or without the above flexibility I proposed. I do think there are legitimate reasons to allow for a user-defined coefficient. Like manually decreasing the coefficient in regions where it's overly diffusive, or when running wall-resolved LES. Basically, since the necessary change is a couple lines of code, I tend to think that flexibility is worth it. That said, the `Array`-based method you proposed can also cover these cases. > @simone-silvestri and @xkykai have talked about dynamic Smagorinsky too but I think their main conclusion is that it is not a gimme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187186033:862,interface,interface,862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187186033,2,['interface'],['interface']
Integrability,"> You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence.; > ; > Does `AnisotropicMinimumDissipation` work? Or other closures?. Nice catch! It does work for AMD. I hadn't tried that before because I assumed it wasn't gonna work. Unfortunately I can't really use AMD because it produces a lot of noise in the stratified regions of my domain, but hopefully adapting Smag isn't too hard?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249:167,integrat,integrated,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249,1,['integrat'],['integrated']
Integrability,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461:423,depend,depends,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461,1,['depend'],['depends']
Integrability,"> `KernelAbstraction.synchronize(device(arch))` would be the same as the previous `wait(device(arch), event)` where the error would be thrown. Thank you. I was about to comment this:; > Another thing with the new kernels. I believe I've now got the particle advection kernels working, but unless some event causes a delay, for example printing some informaiton out, the `advect_lagrangian_particles!` event does not finish before the test tries to test that its been correctly done which causes it to fail. . >If I change it so that `advect_lagrangian_particles!` returns `advect_particles_kernel!(...`, and wrap `advect_particles_kernel!` in wait (i.e. `wait(advect_lagrangian_particles!(particles, model, Δt))`) then it does run correctly. . >This seems like a bigger issue with how kernel events are working? If other events aren't being finished in order this might cause other issues?. But the new alternative should be to call `KernelAbstraction.synchronize(device(arch))` instead then?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514597017:21,synchroniz,synchronize,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514597017,3,"['synchroniz', 'wrap']","['synchronize', 'wrap']"
Integrability,"> ```julia; > @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask) ; > condition = arch_array(architecture(operand.grid), condition) ; > return ConditionalOperation(operand; func, condition, mask) ; > end ; > ```. I think there's a typo here that's making it so that the computation doesn't exclude the nodes inside the immersed boundary. I think the correct definition is closer to what I suggested in https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1904623674. Specifically `condition` need to be wrapped around `NotImmersed`:. ```julia; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask); condition = arch_array(architecture(operand.grid), NotImmersed(condition)); return ConditionalOperation(operand; func, condition, mask); end; ```; which seems to produce the correct result on the CPU, but I can't get it to work on GPUs. Here's a MWE I cooked up where we can check that the results are correct:; ```julia; using Oceananigans; using CUDA: has_cuda_gpu. arch = has_cuda_gpu() ? GPU() : CPU(); grid_base = RectilinearGrid(arch, size = (1, 4, 4), extent = (1,1,1)); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> -1/2)). using Oceananigans.AbstractOperations: ConditionalOperation; using Oceananigans.Fields: AbstractField; import Oceananigans.Fields: condition_operand; IF = AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}; using Oceananigans.ImmersedBoundaries: NotImmersed. using Oceananigans.Architectures: architecture, arch_array; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask); condition = arch_array(architecture(operand.grid), NotImmersed(condition)); return ConditionalOperation(operand; func, condition, mask); end. using Oceananigans.Grids: ynode, znode; yᶜᶜᶜ = KernelFunctionOperation{Center, Center, Center}(ynode, grid, Center(), Center(), Center()); zᶜᶜᶜ = KernelFunctionOperation{Center, Center,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1905170213:560,wrap,wrapped,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1905170213,1,['wrap'],['wrapped']
Integrability,"> ```julia; > OpenBoundaryCondition(nothing) # impenetrable; > OpenBoundaryCondition(1) # external state = 1, no matching scheme; > OpenBoundaryCondition(external_state, matching_scheme) # explicit matching scheme; > ```. This does seem like the best user interface for it. Is keeping the external state in the condition and the matching scheme in `Open` okay then?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986472888:256,interface,interface,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986472888,1,['interface'],['interface']
Integrability,"> ```julia; > function fill_west_and_east_halo!(c, west_bc, east_bc, size, offset, loc, arch, grid, args...; kwargs...); > west_bc_args = get_boundary_arguments(west_bc, Val(:west), size, offset, loc, arch, grid, args...; kwargs...); > east_bc_args = get_boundary_arguments(east_bc, Val(:east), size, offset, loc, arch, grid, args...; kwargs...); > ; > return launch!(arch, grid, KernelParameters(size, offset),; > _fill_west_and_east_halo!, c, west_bc, east_bc, loc, grid, west_bc_args, east_bc_args, Tuple(args); kwargs...); > end; > ```; > ; > Where the default behaviour is:; > ; > ```; > get_boundary_arguments(args...; kwargs...) = (); > get_boundary_arguments(bcs::Tuple, args...; kwargs...) = Tuple(get_boundary_arguments(bc, args...; kwargs...) for bc in BCS); > ```; > ; > But we can add methods like this:; > ; > ```; > get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow}, side, size, offset, loc, arch, grid, args...; kwargs...) = (@info typeof(bc); (bc.classification.bulk_speed, )) # fallback; > ; > function get_boundary_arguments(bc::BoundaryCondition{<:BulkOutflow{Nothing}}, ::Val{:west}, size, offset, loc, arch, grid, Δt, clock, fields, args...; kwargs...); > u = fields.u; > ; > # THIS WILL NOT BE GPU FRIENDLY; > Uᵇ = sum([u[1, j, k] * Axᶜᶜᶠ(1, j, k, grid) for j=1:grid.Ny, k=1:grid.Nz]) / (grid.Ly * grid.Lz); > ; > return (Uᵇ, ); > end; > ```; > ; > If everyone is happy with this my next issue is working out how to calculate Ub in a way that will work on GPU since boundary conditions are defined before Fields so I can't use `Average`.; > ; > I also made a subdirectory for these boundary conditions but then I realised it would be easiest to not have different classifications depending on where Ub is coming from so I didn't have to make as many different things so I'll move them back at some point. I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977651465:2189,depend,depending,2189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977651465,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"> `w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions.; > ; > We could think to change the dependencies to all fields instead of only the prognostic ones. I wasn't aware of that. Is there a way to use `w` as a dependency here? In the MWE `w` is superfluous, but on complex bottom topography the drag on the sides should physically depend on `w`, among other things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667:97,depend,dependency,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667,4,['depend'],"['depend', 'dependencies', 'dependency']"
Integrability,"> afaik the second test filter is only needed when assuming that `β` can vary between scales. I think you're correct here! Sorry for the confusion here, but I suppose by scale-invariance I mean `β` has a power law dependence on the scale size. And since we were trying to implement the scale-dependent version, `β` would vary across different scales? Hence we need the `α=4` filter as well. Am I understanding Equation (26) in [Bou-Zeid et al. 2005](https://dx.doi.org/10.1063/1.1839152) correctly here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3638#issuecomment-2187284277:214,depend,dependence,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3638#issuecomment-2187284277,2,['depend'],"['dependence', 'dependent']"
Integrability,"> any suggestions for tests I might add to get the coverage up?. Hmmm, I think for now it's sufficient that the regression tests pass as this PR should preserve existing functionality. If you're going to implement more rigorous/high-level LES tests in the future then the coverage will go up. And it'll probably become clearer which unit tests are needed. > Lastly, I am thinking that all the doc strings in closure_operators.jl are actually a detriment to readability and understandability. Thoughts?. I kind of agree, but with the docstrings we can integrate them into the documentation, and if the docstrings have LaTeX then we can view the operators alongside the math in the docs. I guess it's readable documentation vs. more readable code? Good practice says we should probably keep them, but maybe we can separate them somehow? I guess right now we only read the code but maybe in the future we'll mainly be reading the docs and not the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496471848:551,integrat,integrate,551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496471848,1,['integrat'],['integrate']
Integrability,"> as mentioned on slack here's @jlk9 's Enzyme integration test PR #3480; > ; > We should check that the tuple doesn't also break that (or try to find the correct mutually happy solution like maybe vararg type). @jlk9 , the test on #3480 does not pass right now, is that correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1946397811:47,integrat,integration,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1946397811,1,['integrat'],['integration']
Integrability,"> but that would mean passing the simulation to the time step, which is not ideal. We can create a schema where the argument to `Callback.func` depends on ""flavor"" / ""callsite"", etc, similar to how we have different ""forms"" for boundary conditions and forcing functions. > Do we need to support that accurate callback (happening at each RK substep)?. I guess as @jagoosw argues this is an important feature to support for advanced applications. There are a few different ""intra time step"" callsites we might envision (modifications to `calculate_tendencies!` differ from modifications to `update_state!`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279333832:144,depend,depends,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279333832,1,['depend'],['depends']
Integrability,"> hmmm, can you read a jld2 file with NCDatasets? I am not sure how that package works. NCDatasets is a wrapper on top of the NetCDF C API which is based (in part) on the HDF5 library. As JLD2 is a julia implementation of HDF5, some simple JLD2 files are (surprisingly) readable NCDatasets but this is not generally the case, and arbitrary HDF5 files are [not supported by the NetCDF C library](https://docs.unidata.ucar.edu/netcdf-c/current/interoperability_hdf5.html). It is indeed better to use JLD2.jl for JLD2 files.😃",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759:104,wrap,wrapper,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759,1,['wrap'],['wrapper']
Integrability,"> it took me a while to understand that I couldn't put abstract operations into the output writers. This makes sense to me --- after all, who cares what a `Field` is? We want to write a computation to disk. Maybe we should support AbstractOperations and Reduction as output directly, to save the boilerplate of always wrapping things in `Field`? It occurs to me that the majority of users don't really need to know what a `Field` is (at least not when they're starting out).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036754829:318,wrap,wrapping,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036754829,1,['wrap'],['wrapping']
Integrability,"> it would be weird if `end < grid.Nx + 2grid.Hx` when working with halos. I agree with this now. This is better fixed with documentation. It _should not_ be surprising that `end` does not refer to the final physical grid point. When working with discrete data, a knowledge of the discrete grid is required. With a solid interface for working with continuous function input, we can create the impression that discrete input requires care and careful consideration, which will hopefully mitigate the misunderstanding.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-710684738:321,interface,interface,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-710684738,1,['interface'],['interface']
Integrability,"> may be best to save this change until we have a stretched grid. We haven't really discussed how we'd construct stretched grids, but our design may depend on that. True, good idea. My main concern was readability as we dispatch on `RegularCartesianGrid` and `VerticallyStretchedGrid` often in the updated operators (PR #283).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541323721:149,depend,depend,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541323721,1,['depend'],['depend']
Integrability,"> most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". My impression is that that's why the `parameters` argument existed (but please correct me if I'm wrong). In the current way `computed_dependencies` and `parameters` clearly indicate what's what (and what happens behind the scenes). So on that note, personally, I like that `computed_dependencies` keeps things explicit. Also, I can't say for other people, but I frequently pass fields that require computation to `KFO`. (Usually passing `u-U` to calculate fluctuations, etc.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786:80,depend,dependencies,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786,2,['depend'],['dependencies']
Integrability,"> note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. >Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here... In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia? . In terms of the resulting Stokes drift profile, ""theory wave"" usually gives a weaker Stokes shear under the same wind. The Donelan et al. (1985) spectrum used in Harcourt and D'Asaro (2008) is for pure wind-wave and gives a strong Stokes shear especially very close to the surface. . I have never used ""theory wave"" to drive an LES. But if we want to approximate the Stokes drift under a wide range of wave conditions with both wind waves and swell, I guess it might not be a bad option at least in an averaged sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882:763,integrat,integration,763,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882,3,"['depend', 'integrat']","['depends', 'integration']"
Integrability,"> oh @francispoulin I now saw your message!. Great minds think alike, and at the same time it seems! ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139117389:35,message,message,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139117389,1,['message'],['message']
Integrability,"> oh now I saw that the secondary hidden commit message talks about ""a bug..."" can you reproduce the bug here? I mean, can you tell me how to reproduce the bug because I don't know exactly what you are talking about...; > ; > (there is a chance you may need to delete the dowloaded `.jld2` file to force DataDeps to download it again... perhaps that's your issue -- I'm not sure). The bug manifests when executing the following code snippet over the REPL:; ```; using Oceananigans; using DataDeps; cs32_4 = DataDep(""cubed_sphere_32_grid_with_4_halos"",; ""Conformal cubed sphere grid with 32×32 cells on each face and 4 halos on each side"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cs32_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2"",; ""fbe684cb560c95ecae627b23784e449aa083a1e6e029dcda32cbfecfc0e26721""); DataDeps.register(cs32_4); grid_filepath = datadep""cubed_sphere_32_grid_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2""; cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); ```; The complete error message is; ```; ERROR: KeyError: key ""panel1"" not found; Stacktrace:; [1] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/groups.jl:101; [2] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/JLD2.jl:494; [3] conformal_cubed_sphere_panel(filepath::String, architecture::CPU, FT::Type; panel::Int64, Nz::Int64, z::Tuple{…}, topology::Tuple{…}, radius::Float64, halo::Tuple{…}, rotation::Nothing); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/orthogonal_spherical_shell_grid.jl:807; [4] construct_regionally(::Int64, ::Function, ::String, ::Vararg{Any}; kwargs::@K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954:48,message,message,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954,1,['message'],['message']
Integrability,"> on `buoyancy` versus `buoyancy_perturbation` --- since this is an internal issue (not part of the API), I'm fine to stick with `buoyancy_perturbation` for now and continue to discuss what the best nomenclature is after this PR is merged. Completely agree. @suyashbire1 and I are hoping this gets merged ASAP because all our scripts are depending on old versions right now (which have other issues) and we need to update them but can't until the buoyancy and rotation API is stable (well we can, but we want to refactor all our scripts at once).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533102511:338,depend,depending,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533102511,1,['depend'],['depending']
Integrability,"> right, `particle` is a list of particles though. `p` is the index that we have to pass in. we can call it forcing but it is specifically an advective forcing (or velocity forcing) because it is added to the velocity. That's a detail and can be implemented regardless of the type of interface. The difference is. 1. Users _extend_ an Oceananigans function to implement a forcing, OR; 2. Users pass a function into `ParticleAdvectiveForcing` to implement a forcing. Option 1 is fine, no doubt. It's just that the rest of our user interfaces implements option 2. I think we should have a uniform interface across the code. Our original motivation for choosing option 2 is because we believed it would be easier to use for people who don't know Julia very well. People should be able to use Oceananigans without knowing what ""multiple dispatch"" is. We can revisit this. If we think that extending forcing function is a better pattern, we should change it throughout the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238:284,interface,interface,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238,3,['interface'],"['interface', 'interfaces']"
Integrability,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:801,interface,interface,801,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876,1,['interface'],['interface']
Integrability,"> the offender is this line; > ; > https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75; > ; > `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; > ; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110; > ; > `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main); > ; > I see two solutions here:; > ; > 1. change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); > 2. Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?). The main criteria for the design is ease of use. So that's what we have to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603164230:210,wrap,wrapping,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603164230,2,['wrap'],"['wrap', 'wrapping']"
Integrability,"> these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature.; > ; > We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. I would include:; > ; > * buoyant particles (sinking or rising with a density-dependent vertical velocity); > * particles with drag. The discussion is fine but we first need to resolve something more fundamental: the particles do not have indices `i, j, k`. The only way to use Eulerian fields to determine particle forcing is to `interpolate` the Eulerian fields to the location of the particle. Obviously, that's how advecting particles works in the first place, by interpolating the velocity field to the location of the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287:53,depend,depend,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287,2,['depend'],"['depend', 'dependent']"
Integrability,"> where would increased vertical diffusion for static instability show up? Is that a new closure or some attribute of the VerticalDiffusion closure?. I think `ConvectiveAdjustment` should ultimately be a type of turbulence closure (but we can hack it in another way if we need it before we have a nice API for implicit diffusion). Jamming off the above example one might write. ```julia; vertical_diffusion = VerticalDiffusion(νz = 1e-4, κz = 1e-4, timestepping=Implicit()); horizontal_diffusion = HorizontallyCurvilinearDiffusion(νh = 100, κh = 10.0); convective_adjustment = ConvectiveAdjustment(ν = 10.0, κ = 10.0). model = HydrostaticFreeSurfaceModel(closure=(vertical_diffusion, horizontal_diffusion, convective_adjustment), ...); ```. > in many cases a closure could be some blend of several approaches and may want to allow some experimentation. e.g. a Redi like isopycnal coefficient, a biharmonic coefficient, some slope dependent bolus term etc... Do we need to think about that at this stage - maybe have a way several closures can be applied. The ""tupled closure"" approach adds the closures together. However, we could come up with alternative combination methods, perhaps designing a wrapper like. ```julia; closure = BlendedTurbulenceClosure(blending_method, vertical_diffusion, horizontal_diffusion, convective_adjustment); ```. However we design it I think we should make it as explicit as possible. > in a case like GM (for example), its more a 3d closure in practice. I suppose if a closure involves multiple terms that must be evaluated together (or precomputed), but then is subsequently has parts that are treated explicitly and parts that are treated implicitly, then we just have to deal with that unavoidable complexity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-782957283:930,depend,dependent,930,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-782957283,2,"['depend', 'wrap']","['dependent', 'wrapper']"
Integrability,"> with bathymetry we would have -g∂ₓ(h + b - H) = -g∂ₓh -g∂ₓb, and in conservative form, -g∂ₓ(h²/2) -gh∂ₓb, right?. Oh, this seems right. Apologies for the confusion. I'm still not sure we want to analytically integrate one of the pressure gradient terms `h dx(h) = dx(h^2/2)` but leave the other unchanged. If we treat them both similarly then we would write the pressure gradient term. ```; -g h * ∂ₓ(h + b); ```. It might be worth testing both possibilities to see if one has favorable numerical properties?. Perhaps this is related to the whole issue re: well-balanced methods, etc... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115162071:210,integrat,integrate,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115162071,1,['integrat'],['integrate']
Integrability,"> would there be 30+ nested parameterized types for ModelBoundaryConditions. Is/should that be a concern?. @ali-ramadhan do you mean with regards to performance? I'm not sure. With multiple dispatch being core to julia it seems this scenario is not uncommon (30+ may not be very large). > Just one initial question: I might be misunderstanding the purpose of bc.calc but why not bc.impose(args...) instead of bc.calc(args...) as we usually say that we impose boundary conditions?. The function `calc` does not actually impose a boundary condition --- the imposition of boundary condition depends on, for example, the viscosity and diffusivity, and is a property of the equation (or turbulent closure) being implemented. Again for example, the K-Profile-Parameterization includes a modification of how a flux boundary condition is implemented. In other words, the ""specification of flux"" is separate from the ""imposition of a boundary condition"". The former is determined by the user. The latter is determined by the model/governing equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472225606:588,depend,depends,588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472225606,1,['depend'],['depends']
Integrability,"> yes but it has to be non-linear, advecting w velocity with a spatially constant u and v velocity doesn't cut it. Because that doesn't test a multi-dimensional implementation? That makes sense. I just wanted to clarify what was meant by ""nonlinear"". Some source refer to WENO for tracer advection as ""nonlinear"", because the weights depend on the tracer field itself. The key is to test multi-dimensional momentum advection, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219:334,depend,depend,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219,1,['depend'],['depend']
Integrability,"> ~Is there a way around the order of `includ`ing files so that this works? If not, it probably isn't necessary to force that the `particles` slot in models is taken by a `Nothing` or `LagrangianParticles` as it is now? So we could get rid of the particles dependency in models and change the order to `include` particles after models?~; > ; > ~The only thing I can think of is that if a user passes something other than particles it might give a confusing error.~; > ; > ~I think I found a use case for removing the typing of the particles slot and overloading the update functions too but I can't remember what it was now.~; > ; > This won't work because particles need to already be defined for the timesteppers. My other solution would be to define a function `total_velocities` that is defined somewhere early on, and then define new methods for each model?. What is the problem you are trying to solve?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493406171:257,depend,dependency,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493406171,1,['depend'],['dependency']
Integrability,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:192,integrat,integration,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440,1,['integrat'],['integration']
Integrability,"@ChrisRackauckas can the constant-dt Runge-Kutta methods be adapted to accept a changing time-step? This is important because we often have external criteria available (the CFL criterion, for example) that can be used to adapt time-step size. As for the fractional step method, we can also write a function that performs the fractional step algorithm using two substeps and an implicit pressure solve. Multiple fractional steps can then be embedded in a multi-step algorithm like Runge-Kutta; this may provide a route to integration with DifferentialEquations.jl. Note that the implicit pressure solves that forms the second part of the fractional step method requires a specialized fast solver for the 3D elliptic problem. We use this method:. https://www.sciencedirect.com/science/article/pii/0021999188901027. Integration with DifferentialEquations.jl will require integration of this FFT-based Poisson/Helmholtz solver into the algorithm. Our implicit solves are usually coupled, such that they require the use of fast methods for the solution of elliptic PDEs to time-step efficiently (either the FFT-based algorithm described above, or a fast batched tridiagonal solver for the GPU that we are currently working on). Can the user provide their own fast solver for implicit time stepping with the split ODE solver?. Our time-stepping method is roughly described here:. https://climate-machine.github.io/Oceananigans.jl/stable/manual/time_stepping/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549149954:512,rout,route,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549149954,4,"['Integrat', 'integrat', 'rout']","['Integration', 'integration', 'route']"
Integrability,"@EavenW here is some code for you:. ```julia; using Oceananigans; using Oceananigans.Fields. f = 1e-4 # [s⁻¹] Coriolis parameter. # Use 'const' so boundary functions work on the GPU.; const ω = 2π/f # [s] Inertial period; const u★ = 0.01 # [m s⁻¹], friction velocity. # fluxes *kinematic* because they are applied to the velocity field. ; x_momentum_flux(x, y, t) = u★^2 * cos(ω * t); y_momentum_flux(x, y, t) = u★^2 * sin(ω * t). τˣ = BoundaryFunction{:z, Face, Cell}(x_momentum_flux); τʸ = BoundaryFunction{:z, Cell, Face}(y_momentum_flux). u_boundary_condition = HorizontallyPeriodicBCs(top=BoundaryCondition(Flux, τˣ)); v_boundary_condition = HorizontallyPeriodicBCs(top=BoundaryCondition(Flux, τʸ)); ```. As @ali-ramadhan we are redesigning this API this week. So expect changes very soon if you keep `Oceananigans` updated. We think the API will become clearer and easier to use. This code is young so we certainly appreciate comments and criticism that will help us make the code easier-to-use. I just noticed that the docstring defined inside the struct does not print at the REPL, so here it is:. ```julia; """"""; BoundaryFunction{B, X1, X2}(func); A wrapper for user-defined boundary condition functions on the; boundary specified by symbol `B` and at location `(X1, X2)`. Example; =======; julia> using Oceananigans: BoundaryCondition, BoundaryFunction, Flux, Cell. julia> top_tracer_flux = BoundaryFunction{:z, Cell, Cell}((x, y, t) -> cos(2π*x) * cos(t)); (::BoundaryFunction{:z,Cell,Cell,getfield(Main, Symbol(""##7#8""))}) (generic function with 1 method). julia> top_tracer_bc = BoundaryCondition(Flux, top_tracer_flux);; """"""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-587013856:1158,wrap,wrapper,1158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-587013856,1,['wrap'],['wrapper']
Integrability,"@Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the mometnum equations. . If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710:389,depend,depending,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710,1,['depend'],['depending']
Integrability,"@Yixiao-Zhang what is the new user interface? Are you referring to the changes on #3142 ?. Either way, I recommend that you set up your simulation without using `ImmersedBoundaryCondition` at all. `ImmersedBoundaryCondition` is not appropriate for most physical modeling (I am considering whether we should say this more explicitly in the docstring). I suggest trying. ```julia; FieldBoundaryConditions(immersed=the_bottom_heating); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583458579:35,interface,interface,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583458579,1,['interface'],['interface']
Integrability,"@adelinehillier reports the following optimal values for CATKE to match the LESbrary (these values occur at iteration 10 -- we have to read these off the plots, as we do not have the actual numerical values. But a rough guideline should be good enough):. ![image](https://user-images.githubusercontent.com/15271942/166294013-00a64681-18f7-4abf-a35b-7f7c9b0ed3fb.png). Note that these are optimal values for an _older_ version of CATKE that calculated diffusivities at cell centers:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L140-L143. which was the case for Oceananigans v0.74.2. Therefore work still remains to recalibrate CATKE for current numerics, which calculate diffusivities at vertical cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024:860,interface,interfaces,860,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024,1,['interface'],['interfaces']
Integrability,"@ali-ramadhan ; Thanks for the suggestion. I tried running it on the CPU and got a different error message, which is shown below. Additionally, the error occurs when defining background fields in the model as such; ```julia ; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B̄_field); ```; But it runs fine like the usual way; ```julia; background_fields = (; b=B̄_field); ```. ```; [ Info: Initializing simulation...; ERROR: LoadError: type BackgroundFields has no field u; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35 [inlined]; [3] u_velocity_tendency; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:92 [inlined]; [4] cpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; [5] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [6] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; [7] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; [8] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; [9] launch!(::CPU, ::ImmersedBoundaryGrid{…}, ::Symbol, ::typeof(Oceananigans.Models.Nonhydros",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343:99,message,message,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343,1,['message'],['message']
Integrability,@ali-ramadhan I am happy to change `arch` to `architecture` and `eos` to `equation_of_state`. I think this is the right PR for those changes. I am also happy with omitting `initialize_tracers` --- requiring users to initialize tracers is more explicit and therefore probably preferred. We can write wrappers / convenience constructors if its important to have models with pre-initialized tracers in the future.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/401#issuecomment-531224291:299,wrap,wrappers,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401#issuecomment-531224291,1,['wrap'],['wrappers']
Integrability,@ali-ramadhan and I created that warning message. Maybe it's too agressive and we should rethink it as people clearly become concerned by it? Will have to think about that a bit more but glad it's working!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832330440:41,message,message,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832330440,1,['message'],['message']
Integrability,"@ali-ramadhan could the NVidia cufftw interface help ( https://docs.nvidia.com/cuda/cufft/index.html#fftw-supported-interface ) as a step. My reading is that this does things on GPU, so could avoid copy, but may not be as super optimal as native cuFFT. Maybe you already tried that - the advertising on the box seems to imply you just switch a few headers, link and existing FFTW works, but maybe there is small print?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/56#issuecomment-464772997:38,interface,interface,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56#issuecomment-464772997,2,['interface'],['interface']
Integrability,"@ali-ramadhan do you have any thoughts on the design of `x, y, z` `Topology` traits for the grid? I think this is becoming more important, especially because we now have two grids. This may be an essential abstraction, so we may want to make it a ""medium"" priority to implement it (and also eliminate a lot of boiler plate associated with `ChannelModel` constructor. It also will break the user API because it will enable a much simpler and straightforward interface for specifying boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-578411695:457,interface,interface,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-578411695,1,['interface'],['interface']
Integrability,@ali-ramadhan that sounds neat! Also integrate DimArray with AbstractField so the spatial dimensions can also be named? That might be the first thing to do; then we just have to add Time to DiskTimeSeries. You are a lot more familiar with DimArray so whatever makes sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801953852:37,integrat,integrate,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801953852,1,['integrat'],['integrate']
Integrability,"@ali-ramadhan the constants have slightly different meaning, which creates confusion --- let me explain:. * In the Rozema version of AMD, the 'filter width' `δ` is defined as the grid spacing. Thus on an isotropic grid, the eddy viscosity becomes. `ν = -C_roz * Δ^2 * r / q`,. where r and q are defined in equations (9) and (11) in [Rozema et al. (2015)](https://aip.scitation.org/doi/abs/10.1063/1.4928700). * In the Verstappen version of AMD (and as described in Vreugdenhil and Taylor 2018), the 'filter width' `δ` is defined as *twice* the grid spacing for finite differences (and 3/2 for spectral discretization). Thus on an isotropic grid and with finite differences the Verstappen version of AMD reduces to. `ν = -C_ver * δ^2 * r / q = - 4 * C_ver * Δ^2 * r / q`. Thus in this case `C_ver = 1/12` is equivalent to `C_roz = 4/12 = 0.33`. . On anisotropic grids, things can be slightly different. I'm open to changing the implementation, but I'm not sure what the best route is. Possibly we will phase out the Rozema version... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526170772:974,rout,route,974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526170772,1,['rout'],['route']
Integrability,"@ali-ramadhan would it be good to send messages to everyone who has a fork maybe and maybe keep an issue open, so people who have cloned can see? Of course it would also be good not to rewrite the history - that pretty much breaks how git works. In theory reviewing PRs should catch this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577221566:39,message,messages,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577221566,1,['message'],['messages']
Integrability,@apaloczy just wanted to thank you for raising this issue!. I'm going to take this strategy to fix it:. 1. First merge #2426 (this changes `fill_halo_regions!`); 2. Update the halo filling interface so that field _location_ is passed into the boundary kernels. We can then use field location to infer the correct metrics. It might make sense to include 2. as part of #2437 .,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1100210727:189,interface,interface,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430#issuecomment-1100210727,1,['interface'],['interface']
Integrability,"@arcavaliere just to clarify what I think this issue is all about: during a simulation we often would like to print messages that inform us of the simulation's progress. One example of this comes from a `@printf` statement inside a time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting de",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:116,message,messages,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,2,['message'],['messages']
Integrability,"@christophernhill Thanks for posting the gist! @mg547 and I were able to get it working with our Laplacian operator. Going to try and inject it into the pressure solver now, fingers crossed!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443903880:134,inject,inject,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443903880,1,['inject'],['inject']
Integrability,"@christophernhill Yes I believe I am using the FFTW interface to do the FFT/IFFTs on the GPUs. Where I got stuck is that the existing solver uses `FFTW.r2r!(f.data, FFTW.REDFT10, 3)` for the DCT and `FFTW.r2r!(ϕ.data, FFTW.REDFT01, 3)` for the IDCT, but under the ""FFTW Interface to cuFFT"" table, Read-to-Real Transforms and Read-to-Real Transform Kinds are ""Not supported"". So I implemented a DCT using the N FFT ([following this post](https://dsp.stackexchange.com/a/10606)); https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L359-L370. and an IDCT using the IFFT ([following these course notes](http://fourier.eng.hmc.edu/e161/lectures/dct/node2.html)); https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L372-L387. They work in isolation (they produce the same output as `FFTW.r2r!` but do not work when I substitute them into the Poisson solver. I'm playing around with it right now, hoping it's just a bug on my part.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/56#issuecomment-464777647:52,interface,interface,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56#issuecomment-464777647,2,"['Interface', 'interface']","['Interface', 'interface']"
Integrability,"@fluidnumerics-joe, is the `GPUArrays` a dependency only for the `allowscalar`? If so, I think `GPUArraysCore` is much more lighter and includes `allowscalar`. (saw this from @vchuravy's attempts over at https://github.com/CliMA/Oceananigans.jl/pull/3066)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1943471486:41,depend,dependency,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1943471486,1,['depend'],['dependency']
Integrability,"@francispoulin ! No worries about the question. I like questions. To answer your latest question --- our nonhydrostatic pressure solver is based on FFTs for regular grids and is therefore quite fast. In simple benchmarks long ago we found that other parts of the algorithm dominated the cost of a time-step. Because of that we aren't sure that having a hydrostatic-only solver would help. Of course, the story is different if we need to stretch the grid in horizontal directions. That said, it would still be interesting to be able to solve hydrostatic-only problems. This would complicate the algorithm a bit because you have to distinguish the barotropic mode, and perform a 2D pressure solve. We already have a function to integrate the buoyancy field to obtain the hydrostatic pressure. For ""things I want worked on"" my wish list falls into three categories: new physics features, new numerics / algorithms, and more boring software / UI work. Here's a couple... 1. Finishing the vertically-stretched grid implementation (numerics). We started work on this but its incomplete. This is a tricky and arduous task but would be quite nice to have... 2. Vertically-implicit time-stepping for diffusion terms (numerics). Ocean models typically use a time-stepping method that treats vertical diffusion terms implicitly. We haven't worried about this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rot",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:726,integrat,integrate,726,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['integrat'],['integrate']
Integrability,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:703,message,messages,703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441,3,"['message', 'wrap']","['messages', 'wraps']"
Integrability,"@francispoulin Sorry for the neglected state of this PR. It's in a half-baked state and I keep meaning to revisit it. You can decompose the domain into x, y, z cubes/slabs/pencils/etc. Then ""halo communication boundary conditions"" are injected on edges where the model needs to communicate with another rank then communication occurs as part of `fill_halo_regions!`. I was working on adding a test to verify that all halo region data was communicated properly for CPU and GPU models but encountered some deadlocking (according to latest commit message haha). Hoping to revisit soon, don't think it should be too hard to get this PR to work for a shallow water model or compressible model (pressure solver will the hard part of an MPI incompressible model).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-732934807:235,inject,injected,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-732934807,2,"['inject', 'message']","['injected', 'message']"
Integrability,"@francispoulin explained the situation well for `Gradient` and `Value` boundary conditions. I'd like to restate what he said in the context of the finite volume method and clarify the situation for `Flux` boundary conditions because I said something wrong above... Oceananigans uses a weak formulation of PDEs via the finite volume method. We evolve the average value of fields, integrated over a cell volume. In this integral formulation there are two contributions to the tendency of a field: fluxes across cell interfaces (advective and diffusive usually, but also possibly others via user-defined forcing), and interior ""sources"" (such as pressure gradients, Coriolis forces, gravitational forces). When users invoke `Gradient` or `Value` boundary conditions, then the same model is used for fluxes across interior cell interfaces as for ""exterior"" interfaces (domain boundaries). Thus if users set `closure=nothing` and zero out diffusive fluxes, boundary fluxes are _always_ zero regardless of what `Gradient` or `Value` are specified. More specifically, we enforce `Gradient` or `Value` boundary conditions by filling halo regions and then calculating exterior fluxes using the same kernel that's evaluated in the interior. As @francispoulin points out this is not some quirk of our algorithm or numerics; this follows from the properties of the underlying PDE. Something different happens when `Flux` boundary conditions are specified and this is where I was wrong above. With `Flux` boundary conditions, users are really specifying two _different_ models for fluxes: one across ""interior"" cell interfaces, and another for fluxes across domain boundaries. Setting `closure=nothing` in this case only nullifies _interior_ diffusive fluxes. But since boundary fluxes are explicitly specified in this case, they still do have an impact on interior tendency values. . A further subtlety is that `Value` and `Gradient` boundary conditions do actually have an impact if there is non-zero `NormalFlow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191:379,integrat,integrated,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191,4,"['integrat', 'interface']","['integrated', 'interfaces']"
Integrability,"@francispoulin is this a better solution?. ```julia; julia> scheme1 = UpwindBiasedThirdOrder(); UpwindBiasedThirdOrder(). julia> scheme2 = WENO5(); ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Research/Oceananigans.jl/src/Advection/weno_fifth_order.jl:145; WENO5 advection scheme with:; ├── X regular; ├── Y regular; └── Z regular. julia> string(typeof(scheme1).name.wrapper); ""UpwindBiasedThirdOrder"". julia> string(typeof(scheme2).name.wrapper); ""WENO5""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2098#issuecomment-986380458:469,wrap,wrapper,469,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2098#issuecomment-986380458,2,['wrap'],['wrapper']
Integrability,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:547,Integrat,Integrated,547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741,1,['Integrat'],['Integrated']
Integrability,"@glwagner : . I am trying to follow the reasoning as to why the momentum flux does not need the area terms and I have an idea. First, I have tried to follow the dependencies of the flux function and find the following:. `div_hUu` -> `momentum_flux_huu`, -> `_advective_momentum_flux_Uu` -> `advective_momentum_flux_Uu`. The final function is defined for either centered of upwinding schemes. . `centered_advective_fluxes.jl` has a defintion that shows it's proportional to `Ax`, and hence the area: https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Advection/centered_advective_fluxes.jl#L15. `upwind_biased_advective_fluxes.jl` has a definition that shows it is proportional to `Ax` as well: https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Advection/upwind_biased_advective_fluxes.jl#L24. Something similar is true for `advective_tracer_flux`, and those can be found in the same files. Does this answer the question why there should not be any area terms in the flux?. If this convention is confusing, do we want to do something different?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116357004:161,depend,dependencies,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116357004,1,['depend'],['dependencies']
Integrability,"@glwagner @ali-ramadhan and @jm-c sounds good. . Some thoughts. 1. where would increased vertical diffusion for static instability show up? Is that a new closure or some attribute of the VerticalDiffusion closure? . 2. in many cases a closure could be some blend of several approaches and may want to allow some experimentation. e.g. a Redi like isopycnal coefficient, a biharmonic coefficient, some slope dependent bolus term etc... Do we need to think about that at this stage - maybe have a way several closures can be applied. 3. in a case like GM (for example), its more a 3d closure in practice. It has pieces in the isopycnal direction and pieces in the diapycnal direction. The terms tend to be evaluated together, so that numerically the discrete formulation has the right properties (conservation, no problematic null spaces, avoiding large v small term truncations, consistent empirical thresholds to deal with small number/zero divisions, consistent handling of domain and immersed boundary rules etc...) .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-782877943:406,depend,dependent,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-782877943,1,['depend'],['dependent']
Integrability,"@glwagner @navidcy the biggest blocker here is AMGX. I would propose moving AMGX support to a separate package?. The primary motivation is that ideally `Oceananigans` should not depend directly on CUDA.jl, but ""just"" use KA. The backend packages are large and not necessarily compatible. So all CUDA.jl/AMDGPU.jl/Metal.jl specific code should go into an extension package.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1497609415:178,depend,depend,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1497609415,1,['depend'],['depend']
Integrability,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:444,depend,dependent,444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426,2,['depend'],"['dependent', 'dependent-Lagrangian-dynamic-model-for']"
Integrability,@glwagner I see you've added a JLD2 output writer but JLD2 (and FileIO if you use it) aren't listed as dependencies in `Project.toml` nor `Manifest.toml`. We can also get rid of the JLD dependency since we nuked checkpointing in PR #282 and I forgot to remove it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515486332:103,depend,dependencies,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515486332,2,['depend'],"['dependencies', 'dependency']"
Integrability,"@glwagner Just FYI, some of the things that did not work for you, actually worked for me. Most notably:. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Center, Center, Center) via identity;    ├── + at (Center, Center, Center);    │   ├── ^ at (Center, Center, Center) via identity;    │   │   ├── - at (Center, Center, Center) via identity;    │   │   │   ├── Field located at (Face, Center, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    │   │   └── 2;    │   ├── ^ at (Center, Center, Center) via identity;    │   │   ├── - at (Center, Center, Center) via identity;    │   │   │   ├── Field located at (Center, Face, Center);    │   │   │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center);    │   │   └── 2;    │   └── ^ at (Center, Center, Center) via ℑzᵃᵃᶜ;       │   ├── Field located at (Center, Center, Face);       │   └── 2;    └── 2. julia> compute!(tke). julia> ; ```. So it appears to be machine-dependent at least to some extent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-822887354:1306,depend,dependent,1306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-822887354,1,['depend'],['dependent']
Integrability,"@glwagner Sorry for posting in the wrong place. Here's the same message again:. @glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in this commit. I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via KernelComputedField on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700:64,message,message,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700,1,['message'],['message']
Integrability,"@glwagner Sorry, I missed these messages and just saw them now. I further inspected the code and it seems that the discrepancy comes from having one of the directions with `size=1`, simulating a `Flat` dimension. I'm not sure how worrisome this issue is given that you have PR https://github.com/CliMA/Oceananigans.jl/pull/1340, which may address this issue? . So, for example, consider the code block below (btw, I'm sorry that my examples are large, but I don't quite know how to create fields with BCs very well without creating a model behind it...):. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Fields. # Get simulation parameters; f0 = 1e-4; dudy = -1.25e-4; dudz = -4e-3; dbdz = 1e-5. #++++ GRID; topology = (Periodic, Bounded, Bounded); grid = RegularCartesianGrid(size=(1, 4, 4), extent=(1000, 1000, 200),; topology=topology). # Define our model!; u_g(x, y, z, t) = dudy * y + dudz * z; b_g(x, y, z, t) = dbdz * z; model = IncompressibleModel(architecture = CPU(),; grid = grid,; tracers = (:b,),; buoyancy = BuoyancyTracer(),; background_fields = (u=u_g, b=b_g,),; ). # START DIAGNOSTICS; import Oceananigans.Fields: ComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z. u, v, w = model.velocities; b = model.tracers.b. U = model.background_fields.velocities.u; B = model.background_fields.tracers.b. u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). # Get correct constant values; Ri_true = dbdz / dudz^2. # Abstract operations tests; Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex. dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; ; compute!(Ri_abs); compute!(Ri_abs2); ```. In the code above `Ri_abs2` gets calculated correctly, but `Ri_abs` does not:. ```julia; julia> Ri_true; 0.6250000000000001. julia> interior(Ri_abs2); 1×4×5 view(OffsetArray(::Array{Float64,3}, 0:2, 0:5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445:32,message,messages,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-773439445,1,['message'],['messages']
Integrability,"@glwagner Yes you are right. I tried restarting Julia, and it worked without the error message. Sorry!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386824056:87,message,message,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386824056,1,['message'],['message']
Integrability,@glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future. . Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109:78,interface,interfaces,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109,2,"['integrat', 'interface']","['integrator', 'interfaces']"
Integrability,@glwagner is this PR breaking only because of the deletion of `MEWSVerticalDiffusivity`?. Or is there something else that's breaking in the `Simulation` interface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3282#issuecomment-1749389837:153,interface,interface,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3282#issuecomment-1749389837,1,['interface'],['interface']
Integrability,"@glwagner thanks for clarifying. Coming from an atmospheric sciences background, I'm a bit unclear on the details of TEOS-10 and the nuances associated with it. In particular it seems counter-intuitive to me how an equation of state that depends on depth fits in a Boussinesq fluid (where adiabatic rearrangement of parcels shouldn't change their buoyancy). But this probably isn't the best place to have a long discussion about it. Using the more fundamental definition of `z_*` does circumvent some of the issues mentioned by @hdrake, no? (Like topography.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109:238,depend,depends,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109,1,['depend'],['depends']
Integrability,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:870,integrat,integrating,870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['integrat'],['integrating']
Integrability,"@glwagner this should reproduce the error. The message is thrown when calling `set(model,...)`. ```using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, mask_immersed_field!. using Oceananigans.Architectures: device; using Oceananigans.Grids: xnode, znode; using KernelAbstractions: MultiEvent; using JLD2; using Printf; #using GLMakie; using SpecialFunctions. arch = GPU(); Nx = 256; Nz = 64 # Resolution; #Ny = 64; κ = 1e-6 # Diffusivity and viscosity (Prandtl = 1). underlying_grid = RectilinearGrid(arch,; size = (Nx, Nz),; x = (0, 5),; z = (-0.05, 1.0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). #const gamx = 2.0; #const gamy = 20.0. @inline bottom_topography(x,y) = 0.0;#*exp.(-gamy*y.^2); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom_topography)). no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(bottom=no_slip, immersed=no_slip); w_bcs = FieldBoundaryConditions(immersed=no_slip); boundary_conditions = (; u = u_bcs, w = w_bcs). model = NonhydrostaticModel(grid = grid,; advection = WENO5(),; boundary_conditions = boundary_conditions,; closure = ScalarDiffusivity(ν=κ,κ=κ),; coriolis = nothing,; tracers = :b,; buoyancy = BuoyancyTracer()). b₀(x,y, z) =0.5*(erf.((x.-1.0)*10).-1.0); set!(model, u = 0.0, b = b₀)```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087:47,message,message,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087,1,['message'],['message']
Integrability,"@glwagner, I got rid of this ```UnderVarError``` but now I am facing ```domain error``` while applying Chebyshev spacing in z.; But at the same time, when I apply any linear profile, It works. linear function like -``` (2k-1/2Nz)```; . I get the error message after applying the set() function.- . ```. julia> # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ); ERROR: TaskFailedException:; DomainError with -1.1554673348527535e-7:; Exponentiation yielding a complex result requires a complex argument.; Replace x^y with (x+0im)^y, Complex(x)^y, or similar.; ```; If we see the error message, it says to replace x^y, but there is no arithmetic like that in my code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-818569992:252,message,message,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-818569992,2,['message'],['message']
Integrability,"@glwagner:; > I'm still not sure we want to analytically integrate one of the pressure gradient terms `h dx(h) = dx(h^2/2)` but leave the other unchanged. If we treat them both similarly then we would write the pressure gradient term; > ; > ```; > -g h * ∂ₓ(h + b); > ```; > ; > It might be worth testing both possibilities to see if one has favorable numerical properties?; > ; > Perhaps this is related to the whole issue re: well-balanced methods, etc... ?. @francispoulin:; > I agree with @glwagner . Currently, `ShallowWaterModel` separates out the advection terms and the pressure term, which makes sense since they are inherently different.; > ; > One issue is that since we are using a finite volume method, the above term presents a bit of a problem as it's not in divergence form However, even in the other formulation, as you can see from the paper cited above, we still end up getting a term that is not in divergence form, `h dh_B/dx`.; > ; > I support trying @glwagner 's proposal of keeping the pressure term as he wrote it above. So it seems the best way forward for implementing bathymetry is to do it in the non-conservative form of the equations after #2522 is merged. Do we then want to have the conservative form of `ShallowWaterModel` be available only for `bathymetry == nothing`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1120402030:57,integrat,integrate,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1120402030,1,['integrat'],['integrate']
Integrability,"@hdrake can you clarify specifically what is difficult about the calculation? If we know the specific calculations we need to make we might be able to support / facilitate them with abstractions. For example, it may be possible to sort abstract operations --- like the product of a field and a grid metric like cell area or volume, or another multiplicative factor that represents the effect of bathymetry on cell interface area / volume.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839078260:414,interface,interface,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839078260,1,['interface'],['interface']
Integrability,"@hdrake's point references Huang (2005), who point out that a reference state (associated with z* in Winters et al 1995) may not be easily or uniquely definable for seawater with a nonlinear equation of state that depends on salinity, temperature, and pressure:. ![image](https://user-images.githubusercontent.com/15271942/117912548-2d4b3080-b28c-11eb-8693-3805190dd52b.png). In practical terms I think the issue here is determine the ""adiabatic rearrangement"" mentioned by Winters et al. 2005. For a nonlinear equation of state like TEOS-10 where the buoyancy field `b` in the code _depends on depth / hydrostatic pressure_, the adiabatic rearrangement of the water column may not be obtained simply by sorting. However, @hdrake points out that an iterative procedure in which parcels are sorted, their buoyancy recalculated at the new depth, and then sorted again, may eventually converge to an adiabatic reference state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661:214,depend,depends,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661,1,['depend'],['depends']
Integrability,@iuryt https://github.com/iuryt/Bioceananigans.jl looks like an awesome start!!! 🚀 . @glwagner arguably it could be biogeochemonanigans.jl or biogeocheminanigans.jl ? . Would it be interesting to think about an interface that could be helpful for projects like https://github.com/openjournals/joss-reviews/issues/4207/https://github.com/JuliaOcean/PlanktonIndividuals.jl from @[zhenwu0728](https://github.com/zhenwu0728) and @gaelforget too at some point? . Note -. 1. in the end both Eulerian and Lagrangian formulations of biogeocheminanigans/biogeochemonanigans/Bioceananigans/Bichemoceananigans style stuff end up as mostly pointwise functions. So a number of bits of an API framework could be common across Eulerian and Lagrangian I think. . 2. On the fluid solver side the API could also support reactive and passive transport in an atmosphere (i.e. work with atmoscheminanigans 😄 ),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116866522:211,interface,interface,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116866522,1,['interface'],['interface']
Integrability,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:432,interface,interface,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176,2,['interface'],['interface']
Integrability,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:83,integrat,integration,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444,1,['integrat'],['integration']
Integrability,"@jm-c and I talked today and we have an additional point to make (this is related to #115 as well). Notice first that the [operators `δz_f2c` and `δz_e2f`](https://github.com/glwagner/Oceananigans.jl/blob/3307031283dab154d32c071c47d9e275f1a6e17e/src/operators/ops_regular_cartesian_grid.jl#L29) are identical:. ```julia; @inline function δz_f2c(f, Nz, i, j, k); if k == Nz; @inbounds return f[i, j, k]; else; @inbounds return f[i, j, k] - f[i, j, k+1]; end; end. @inline function δz_e2f(f, Nz, i, j, k); if k == Nz; @inbounds return f[i, j, k]; else; @inbounds return f[i, j, k] - f[i, j, k+1]; end; end; ```. Our solution:. ```julia; abstract type Location end; struct Center end; struct Interface end. struct Field{Lx<:Location, Ly<:Location, Lz<:Location, A, G}; data::A; grid::G; end; ```. we then need only two `δz` functions that dispatch on `Lz`; for example:. ```julia; δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Center} = ...; δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Interface} = ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471136259:689,Interface,Interface,689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471136259,2,['Interface'],['Interface']
Integrability,"@johncmarshall54 Good point. The flow field satisfies; ```julia; u(x, y, z, t) = -sin(2π*y) * exp(-4π^2 * ν * t); v(x, y, z, t) = sin(2π*x) * exp(-4π^2 * ν * t); ```; from which we can get both time-dependent Dirchlet conditions; ```julia; u(z = 0) = -sin(2π*y) * exp(-4π^2 * ν * t) # example BC for u_top; ```; and zero Neumann boundary conditions `du/dz = 0` so I decided to impose the more complicated Dirchlet condition thinking they were more correct for some reason. Just switched to using zero Neumann boundary conditions and it works just as well so that's nice (and more concise)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518895045:199,depend,dependent,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518895045,1,['depend'],['dependent']
Integrability,"@johncmarshall54 that would be nice I agree! But not super easy. I've concentrated on tools in `OceanTurb` that allow us to quickly develop new models (abstractions for time-stepping, PDEs, macros for declaring the prognostic variables in a PDE, etc). . These tools *could* be implemented in `Oceananigans` (I'd love to, in fact) but it's not copy and paste. Not only would they require substantial changes to Oceananigans (more abstraction, decoupling of the time stepper from equation specification, etc), there there will likely be some challenges adapting `OceanTurb` ideas to the GPU. . We will need to start using `Oceananigans.jl` eventually to develop parameterizations for the mesoscale problem. For that, we will probably want to use `Oceananigans` as both our 'data' (high-res model) and as 'model' (low-res model with parameterization). For this effort we *will* need some of the abstractions developed for `OceanTurb` to easily change the underlying PDE implemented in `Oceananigans.jl` and develop/implement new and radical paramterization ideas.. So this process may begin soon, but it will be gradual. . That said, hopefully it *can* begin in a few months after I have wrapped up the column modeling work and (with everyone's blessing) turned my attention to the mesoscale problem. It's been nice to keep them separate so far --- I've made a lot of drastic and breaking changes to `OceanTurb` in my quest to prototype and refine abstraction techniques. I think the current PR #210 is an example of what we should do with increasing frequency in the next few months --- take ideas that have been developed in `OceanTurb` (in 1D) and reimplement them in 3D in `Oceananigans`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-486742843:1185,wrap,wrapped,1185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-486742843,1,['wrap'],['wrapped']
Integrability,@liuchihl Have you tried running on the CPU to see if you get a more useful error message?. I think; ```; Reason: unsupported call to an unknown function (call to jl_f_getfield); ```; could just be the result of a typo in an expression like `a.b`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429559746:82,message,message,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429559746,1,['message'],['message']
Integrability,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:325,integrat,integration,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085,1,['integrat'],['integration']
Integrability,@matinraayai I quickly looked at your work on PencilFFTs and it looks awesome. I'd be happy to merge it in some form. My main reservation is that I'd rather not include CUDA and AMDGPU as hard dependencies. I guess this can be easily corrected using the new package extensions on Julia 1.9. Feel free to open a PR over at PencilFFTs and we can continue the discussion there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1466277982:193,depend,dependencies,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1466277982,1,['depend'],['dependencies']
Integrability,"@navidcy , yes, that looks great. However, when I click on the link I don't think I can execute the commands, but maybe I was too quick to close the page. I created a notebook for the 1D diffusion problem by basically copying and pasting what you have in the example. My markdown is a bit rusty but luckily you had all the right syntax there already. I was going to attach it to this message here but it seems that notebook are unsupported. It is nothing fancy but I do think that if there was an open to open the notebook and run it that would make it a bit easlier than copying and pasting. @glwagner that sounds like a great way to run the script, which is certainly what you want to do. Personally, when learning what a script is doing it's nice to execute it line by line to get to know the process. After you've seen it once then you definitely want to the entire example. Anyhow, my 2 cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724718454:384,message,message,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724718454,1,['message'],['message']
Integrability,"@navidcy @glwagner this should superceded all previous enzyme prs (including compatbwlper), which I've gone ahead and closed just now. Some non enzyme tests had a nondeterministic ci failure about a directory not being empty, but otherwise all pass (incl enzyme tests). Once landed we should add a lot more integration test cases like @jlk9 your flux boundary",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2195453317:307,integrat,integration,307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2195453317,1,['integrat'],['integration']
Integrability,"@navidcy I just did a lazy switch to CUDA 3.8.0 (and CUDAKernels 0.3.3) in my latest PR and it seems to be somewhat ok (for sure not all is required) but there are still some problems with `gpu_nonhydrostatic_regression` (an `device kernel invalid image`), `gpu_cubed_sphere`(an `out of bounds access`) (and for some weird reason distributed CPU??). I ll try to figure out a bit more... @francispoulin I don't have an indepth idea of the scaling but I with some basic trials I saw that the message passing is quite quick (the advantage is that is passes directly from GPU to GPU, which maybe is the same as cuda-aware MPI?). The advantage is surely the ease of implementing such a method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495:490,message,message,490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495,1,['message'],['message']
Integrability,"@navidcy I think you're right that with proper `[compat]` bounds, a `Manifest.toml` is unnecessary. But I think that would mean that as developers we would have to be meticulous about updating lower and upper bounds of dependencies. In particular, if a bug is introduced in a dependency then it could cause our master branch to fail (unless we had very strict upper `[compat]` bounds and updated them regularly). I guess I see strict `[compat]` bounds as saying that ""our package is guaranteed to work as long as your dependencies lie between these versions"" (might take a lot of testing to ensure all version combinations are fine), while just using a `Manifest.toml` with loose `[compat]` bounds is saying ""our package is guaranteed to work with the versions prescribed in the `Manifest.toml`"". I like the `Manifest.toml` approach as it gives us more control: we only update dependencies when we're ready and deal with any new issues one-by-one before merging. And it lets us play around with upgrading/downgrading the version on different dependencies, e.g. CUDA.jl, without worrying about `[compat]` bounds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/860#issuecomment-679199928:219,depend,dependencies,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/860#issuecomment-679199928,5,['depend'],"['dependencies', 'dependency']"
Integrability,"@navidcy and @glwagner, I created this halo test branch from your tracer advection branch the day before yesterday, prior to its merger with the main. Given that the tracer advection, along with other branches, was integrated into the main branch yesterday, this branch started displaying numerous reverse changes. To address this, I merged the main branch into this one, resolved the conflicts manually by accepting the incoming changes. This process led to several commits. I will close this PR and create a fresh branch from the main. I will then push my commits. Please bear with me for a few minutes while I do this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401:215,integrat,integrated,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401,1,['integrat'],['integrated']
Integrability,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:857,synchroniz,synchronizes,857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['synchroniz'],['synchronizes']
Integrability,"@navidcy may be referring to a couple of places / messages where ""no units"" is assumed to mean ""SI units"". I don't think we support explicit units though. It seems overkill to wrap every float for the purpose of a few messages. We could maybe attach some metadata to `Simulation`. What kind of API would be ""easy"" @navidcy ? Is it `Clock` that needs to know dimensions, or just things that print messages?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1778#issuecomment-869736354:50,message,messages,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1778#issuecomment-869736354,4,"['message', 'wrap']","['messages', 'wrap']"
Integrability,"@navidcy thanks, I was able to bring the branch up to date to a more reasonable delta.; @glwagner I think there's no need to separate ROCm support and multi-GPU support, since multi-GPU support was mostly dependent on modifications in PencilFFTs.jl.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1450982937:205,depend,dependent,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1450982937,1,['depend'],['dependent']
Integrability,@navidcy that is only true in theory I think when package versions can be inferred from the dependency tree. In reality we need to maintain the precise versions of packages that are used... ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/860#issuecomment-675819662:92,depend,dependency,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/860#issuecomment-675819662,1,['depend'],['dependency']
Integrability,"@sandreza thanks! We utilize this functionality for many of our objects, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/9ef95e7bef2db1dc9ac04af78664418b0caaf99b/src/AbstractOperations/binary_operations.jl#L144. For some reason, during an undocumented attempt to apply this logic to fields back in October, we were unsuccessful to get code to work on the GPU. Back then, the field consisted of an OffsetArray wrapped around a CuArray, and a grid. Both of those objects can be adapted to GPU kernels, so it should have worked, I think. So I'm not 100% sure why our attempt to use `adapt_structure` failed for fields, while working for other objects. Any insight appreciated...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025:422,wrap,wrapped,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025,1,['wrap'],['wrapped']
Integrability,@sangeethasankar01 if you post the whole error message that you get with the stack trace we will understand more which line triggered this error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2018666356:47,message,message,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2018666356,1,['message'],['message']
Integrability,"@simone-silvestri `DistributedComputations` is imported before models here:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Oceananigans.jl#L221-L224. What was ""enable overlapping communication"" intended to support? Is there something that depends on whether `isnothing(mpi_requests)`? Perhaps more direct specification of this feature would help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749703750:284,depend,depends,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749703750,1,['depend'],['depends']
Integrability,@simone-silvestri and I think there is a missing synchronization for one of the boundary updates,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427297511:49,synchroniz,synchronization,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427297511,1,['synchroniz'],['synchronization']
Integrability,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009:43,interface,interface,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009,1,['interface'],['interface']
Integrability,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:475,depend,dependencies,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426,2,['depend'],"['dependencies', 'dependency']"
Integrability,"@simone-silvestri do you have any formula for computing the local energy dissipation rate due to numerical viscosity? For the global dissipation I think evaluating the time evolution of the total KE is a good route, but I'm less sure the best method for obtaining the local dissipation rate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404146906:209,rout,route,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404146906,1,['rout'],['route']
Integrability,"@simone-silvestri if we want to unify the user interface across all models, we could introduce the type `AdvectionScheme` (which will be rather trivial now, but we can update it in the future). Then we can have syntax like. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. Or,. ```julia; model = NonhydrostaticModel(; grid, advection=WENO5()); ```. which the model constructor interprets as. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=WENO5(grid)); ```. (this is nice too, because we can build `WENO5` on the grid under the hood). We could also _always_ ""regularize"" the advection scheme with `grid`, so that. ```julia; advection = AdvectionScheme(momentum=WENO5(), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. translates to. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); ```. under the hood.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113:47,interface,interface,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113,1,['interface'],['interface']
Integrability,"@simone-silvestri suggests removing `topology` as an argument from the `MultiArch` constructor. `MultiArch` now uses `topology` to construct `RankConnectivity` (ie the mapping between ranks). But in @simone-silvestri's words ""connectivity is a grid thing"". I'm not 100% sure how to solve it though. One possibility is to 1) rebuild `MultiArch` in the grid constructor adding connectivity information. Or we can 2) introduce a wrapper for grids on distributed domains or 3) add `connectivity` to all grids, set to `nothing` when not distributred. I think 1) is easiest but maybe not the cleanest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121059896:426,wrap,wrapper,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121059896,1,['wrap'],['wrapper']
Integrability,@simone-silvestri we should probably remove this explicit dependency if it isn't needed,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2511#issuecomment-1116728705:58,depend,dependency,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2511#issuecomment-1116728705,1,['depend'],['dependency']
Integrability,"@simone-silvestri, from symmetry arguments, the metrics on the halo on one face should be the same as the metrics on some other face. E.g., `Δxᶠᶠᵃ[0]` on one face should be either `Δxᶠᶠᵃ[grid.Nx+1]` or `Δyᶠᶠᵃ[grid.Ny+1]` on the other face (or something like that, depending on whether a rotation applies). Right?. So we could hardcode these in from a single face instead of constructing 6 faces and filling halos to fill the halo metrics. It will assume, thought, that a specific face configuration is implied.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447:264,depend,depending,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447,1,['depend'],['depending']
Integrability,"@tomchor I found some dispatch on `ComputedField` --- but nothing about the output construction should depend on whether a field has an abstract operation underneath or not; all of the logic we are working on regards data but not operand, right? Do you mind if I clean this up? I also think we need to sort out a bug with `parent_index_range`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886:103,depend,depend,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886,1,['depend'],['depend']
Integrability,"@tomchor I think we should revisit this PR. Rather than ""moving"" the masking, I think we should start by adding a feature to both output writers that defines a ""mask value"" for immersed regions. What do you think about that? I would like to open a new PR for that. And before that, I'm going to open an issue so we can discuss the user interface. Once we have a nice feature for masking output, we can consider whether or not to also mask (or not) within the time-stepping. These are separate questions, I think. If you agree with that then we can close this PR and I will open an new issue to discuss the user API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998:336,interface,interface,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998,1,['interface'],['interface']
Integrability,"@tomchor I think your solution might help RK3, but as you noted there is _also_ a problem with AB2:. > In this particular MWE if I switch the time-stepper to Adams-Bashforth the issue seemingly goes away (even though there's an initial jump in the pressure that I wouldn't expect), but it does persist (albeit more mildly) in more complex simulations. There's an issue somewhere in. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Simulations/run.jl#L41-L56. I'm also wondering if one issue is that we need to change the line. ```julia; aligned_Δt = schedule_aligned_Δt(sim, aligned_Δt); ```. and maybe instead have an interface where callbacks return the next time of actuation. `TimeInterval` may also need to be redesigned... the fact that we compute the next actuation time b. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Utils/schedules.jl#L65. maybe invites round-off error. To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on `TimeInterval` which should, in theory, work perfectly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147:662,interface,interface,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147,1,['interface'],['interface']
Integrability,"@tomchor and I added a `BuoyancyModel` type (can't call it `Buoyancy` since that would conflict with the module name, name is up for debate) to store the gravity unit vector and the buoyancy model. Seems to work with `BuoyancyTracer` from @tomchor's simulations!. I guess what we weren't sure about is the user interface. Right now tilting gravity is done via e.g. ```julia; θ = 45; g = (0, sind(θ), cosd(θ)); model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=BuoyancyTracer(), gravitational_unit_vector=g); ); ```. so now `model.buoyancy` is a `BuoyancyModel`. ---. But what should the user interface look like for not tilting gravity?. We could enforce explicit construction of a `BuoyancyModel` in every script, which may be seen as adding boilerplate, e.g. ```julia; model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=SeawaterBuoyancy()); ); ```. or we could continue allowing. ```julia; model = IncompressibleModel(...; buoyancy = SeawaterBuoyancy(); ); ```. and the model constructor can convert `SeawaterBuoyancy` to a `BuoyancyModel`. This is less boilerplate but maybe somewhat implicit. I'm leaning towards the more implicit second solution of allowing just `buoyancy = SeawaterBuoyancy()`, but might be good to decide on one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664:311,interface,interface,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664,2,['interface'],['interface']
Integrability,"@tomchor do you mind if I generalize this issue to talk about refactoring the examples in general?. Here are my thoughts:. 1. I agree we should combine Langmuir turbulence and Ocean wind mixing and convection. I think we should implement one LES example with all bells and whistles: surface waves, wind forcing and buoyancy forcing, temperature/salinity, and potentially also a nonlinear equation of state. 2. I think we should keep convecting plankton and continue to develop that as a pedagogical example for both time-dependent boundary conditions and to illustrate Oceananigans' potential for chemistry / biology modeling via nonlinear forcing functions. 3. I think we should convert the Eady turbulence example to something that uses the hydrostatic model with bathymetry (perhaps some baroclinic instability example with bathymetry). 4. We should get rid of the geostrophic adjustment example. 5. We need an example on `LatitudeLongitudeGrid`. I also think we should generate rough timings for all the examples so we understand which ones are costing us the most.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507:521,depend,dependent,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507,1,['depend'],['dependent']
Integrability,"@tomchor just wanted to echo @ali-ramadhan's thank you for finding that bug!. Right now Oceananigans shines for medium-size LES problems around 256^3, perhaps up to 384^3. For that application I think you may find it is as fast or faster than other codes. On that note, it'd be great to compare performance with other codes for this problem size. . For utterly massive problems like the one reported in the Sullivan paper you've posted, Oceananigans is probably not the right tool right now. We haven't experimented with multi-node parallelism yet, but as @ali-ramadhan suggests, its possible we will start working on either multi-CPU parallelism or multi-GPU parallelism soon. For reproducing the Sullivan paper, you may want multi-CPU parallelism simply because of the sheer number of nodes you'll need. It's worth noting that our AMD turbulence closure *may* be less resolution-dependent than the TKE-based closure used by NCAR LES / Sullivan (and yourself?) and thus it may be possible to run at lower resolution (potentially saving factors of 10-100 in resolution. A [paper by Abkar and Moin (2017)](https://link.springer.com/article/10.1007/s10546-017-0288-4) hints at the potential for very coarse simulations with AMD.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569:881,depend,dependent,881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569,1,['depend'],['dependent']
Integrability,"@tomchor let's discuss here, we could use a refresh... I think the main issue is to figure out how to merge the interface. JLD2 supports file ""splitting"" which is why a `prefix` and `dir` makes more sense than specifying the whole filepath. We could try to infer `prefix` and `dir` from a `filepath` too, just need to decide if we are ok that users write `filepath` but then the files end up in different places (because of the file splitting). Personally I think it probably makes more sense to change `NetCDF` to take the file `prefix` and `dir` separately than the whole `filepath`. Changing `force` to `mode` seems totally fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1029513877:112,interface,interface,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1029513877,1,['interface'],['interface']
Integrability,"@tomchor there was an interface location at which high order methods were looking ""into"" the immersed boundary. This is because the boundary treatment was the same as for regular boundaries where we always fill at least one halo. Since the value inside the immersed region is zero because of the masking, this was producing an effectively higher (lower) and lower (higher) tracer source in two consecutive cells (i.e. a spurious maximum and minimum). . This problem was difficult to find because in some way it is ""masked"" by the WENO weighting procedure:; WENO evaluates three different stencils and weights them based on their individual smoothness. Most of the times, the stencil containing the invalid cell has a very low smoothness which means that it is removed by the calculation. This might seem like a fix but it can lead to stability problems because the only stencils remaining might be the ""centered"" and ""downwind"" stencil which are inherently more unstable than the upwind stencil. The issue is immediately visible if you try to advect a constant tracer field `c=1` with high order reconstruction such as Upwind 5 or Upwind 3 (it is not immediately visible in WENO because of the above reason). . If you run this code you'll notice that the advective fluxes (which should be only 0 and 1) actually have a different value (0.96666667) at one specified location near the immersed boundary; ```; using Oceananigans; using Oceananigans.BoundaryConditions; using Oceananigans.ImmersedBoundaries; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10), topology = (Bounded, Bounded, Bounded)). Nx, Ny, Nz = size(grid). boundary = zeros(Nx, Ny, Nz); boundary[1:2, :, :] .= 1; boundary[:, 1:2, :] .= 1; boundary[:, :, 1:2] .= 1. ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary(boundary)). model = HydrostaticFreeSurfaceModel(grid = ibg, ; closure = nothing, ; buoyancy = nothing, ; tracers = :c, ; tracer_advection = Up",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454:22,interface,interface,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454,1,['interface'],['interface']
Integrability,@tomchor you can use the web interface to automatically accept @ali-ramadhan suggested changes:. ![image](https://user-images.githubusercontent.com/15271942/99996535-e2933600-2d89-11eb-8fe1-9d3b9edc6914.png),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1193#issuecomment-732320048:29,interface,interface,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1193#issuecomment-732320048,1,['interface'],['interface']
Integrability,"@tomchor, indeed you are correct on 1. above, but let me remark that sponge layers could be a bit tricky. I explain:. What you want sponge layers to do is to allow flow propagation into the sponge region but where drag would dissipate any fluid motion there. The ""tricky"" part is to make the sponge layer transition smooth enough so that the fluid does not experience it as a ""wall"". If the transition region is very short then the fluid ""sees"" the sponge as a wall and waves are reflected back into the fluid. But how ""short"" is short-enough depends on the scales of the fluid motion... In my experience always there is some fiddling to be done for every problem or even for same problem at different parameter regimes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733210428:543,depend,depends,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733210428,1,['depend'],['depends']
Integrability,"@vchuravy - I modified `src/Grid/zeros_and_ones.jl` to be; ```; using CUDA; using AMDGPU; using Oceananigans.Architectures: CPU, CUDAGPU, ROCmGPU, AbstractArchitecture; using KernelAbstractions; import Base: zeros. zeros(FT, ::CPU, N...) = zeros(FT, N...); zeros(FT, ::CUDAGPU, N...) = CUDA.zeros(FT, N...); zeros(FT, ::ROCmGPU, N...) = KernelAbstractions.zeros(AMDGPU.ROCBackend(), FT, N...). zeros(arch::AbstractArchitecture, grid, N...) = zeros(eltype(grid), arch, N...); zeros(grid::AbstractGrid, N...) = zeros(eltype(grid), architecture(grid), N...). @inline Base.zero(grid::AbstractGrid) = zero(eltype(grid)); @inline Base.one(grid::AbstractGrid) = one(eltype(grid)); ```. This throws the same error as just using `AMDGPU.jl`. For reference. ```; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GP",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420:949,interface,interface,949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420,1,['interface'],['interface']
Integrability,"@vchuravy thank you that is very helpful! I don't think it will be too difficult to build up a small test suite for AMD. We can start with unit tests and a handful of cheap integration tests. @fluidnumerics-joe we don't have any current plans to get AMD GPU resources, but that could change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1937323799:173,integrat,integration,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1937323799,1,['integrat'],['integration']
Integrability,"@wenegrat and @whitleyv sounds good - is the angle dependence maybe due to time dependence of flow, does it move around as the flow changes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738463407:51,depend,dependence,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738463407,2,['depend'],['dependence']
Integrability,"A ""dynamic function invocation"" means that the compiler thinks a function is being called whose scope can change ""dynamically"" (I think). This is the error one gets when a function depends on a global variable that is not `const` (for example). In this case, the error tells us that the types of the objects involved in calling `getindex` defined on `BinaryOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/AbstractOperations/binary_operations.jl#L34. are not correctly inferred. The way getindex comes into play is in the kernel function `_compute!` that evaluates the `AbstractOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Fields/computed_field.jl#L84-L87. calling `getindex(operand, i, j, k)` (or equivalently `operand[i, j, k]`) triggers recursive `getindex` calls that traverse the `AbstractOperation` tree. It seems that when the tree is too large, this traversal cannot be entirely compiled. Perhaps there are tricks we might use to help the compiler parse this kind of operation, like putting some type annotations / hints into `getindex(b::BinaryOperation, ...)`. Not sure. Another possibility is to figure out how to simplify the object `BinaryOperation`, `MultiaryOperation`, so that the compiler is less stressed trying to compile them... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140:181,depend,depends,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140,1,['depend'],['depends']
Integrability,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:265,interface,interface,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,1,['interface'],['interface']
Integrability,"A better solution would resolve #1138 and add the appearance of NaNs as a ""stop critierion"", rather than using a diagnostic. Things are confusing because we essentially have multiple interfaces to specifying callbacks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733194471:183,interface,interfaces,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733194471,1,['interface'],['interfaces']
Integrability,"A few additional thoughts:. This problem could be solved if we ever figure out how to adapt fields to work on the GPU (#746). We can then define `lastindex` for fields ~~properly~~ in a special way. A second solution is to define a thin wrapper `FieldData` around `OffsetArray` with a special `lastindex` method that covers the same purpose, but does not contain pointers to `grid` or `boundary_conditions` (therefore being more likely to work on the GPU, unlike `Field`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691062002:237,wrap,wrapper,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691062002,1,['wrap'],['wrapper']
Integrability,"A few ideas:. 1) If we're doing an euler step, zero out the `G⁻` tendencies beforehand. 2) Put an if statement in to take `euler_step!` rather than `ab2_step!`. The problem with 2) is that we haven't figured out how to abstract the stepping interface to handle different models. Basically, we don't really have an generic PDE time-stepper. Instead we have manually implemented time-stepping schemes for the different models; for example:. https://github.com/CliMA/Oceananigans.jl/blob/383e5b60ca8d3bfb3c8497b11b6be30946a25728/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L14-L36. Thus to achieve 2) we'll probably have to write an `euler_step!` for the hydrostatic free surface model. Maybe not a problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046338764:241,interface,interface,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046338764,1,['interface'],['interface']
Integrability,"A few more thoughts:. 1) It's probably simplest to use a native time-stepping schemes to advance particle trajectories. The third-order Runge-Kutta scheme seems like a fine choice. 2) I think it makes sense to launch one kernel to compute particle trajectories. ""One kernel per thread"" is a simple paradigm. Up to ""one particle per grid point"", we know this method will work well. 3) A few challenges that I see are: i) writing functions that linearly interpolate the velocity field to the particle location, and ii) dealing with boundaries. Enforcing boundary conditions, presumably, requries launching an additional kernel after a time-step is complete that checks the location of each particle and adjusts it if the particle location lies outside the domain. Enforcing periodic conditions presumably requires a cyclic shift of the particle location. I'm less sure how to deal with solid boundaries: perhaps reflecting the particle position (an elastic collision?) is a good model?. 4) I think tackling the problem of determining particle trajectories is a big enough challenge for now. I think once we have the ability to interpolate fields to the particle location, it may not be difficult to introduce ""auxiliary fields"" for each particle, with user-specified RHS that depend on local tracer and velocity fields at the particle position.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-694869271:1274,depend,depend,1274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-694869271,1,['depend'],['depend']
Integrability,"A few other things that this PR inspired me to think about:. 1. I think it'd be nice if `FieldBoundaryConditions` accepted a positional argument to specify the ""default"" boundary condition in `Bounded` directions. This would simplify scripts where every boundary is no-slip (for example) since we could write. ```julia; no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(no_slip); ```. Since the positional argument specifies the default we can also override it:. ```julia; u_bcs = FieldBoundaryConditions(no_slip, top=FluxBoundaryCondition(nothing)); ```. to have no-slip on all boundaries except the top, where we have free-slip / zero flux. 2. I think we do really need a convenience constructor for drag boundary conditions because a) this is friendly for a very common case and b) the drag boundary condition involves uncertain free parameters (Von Karman, roughness...) which we may want to calibrate via ParameterEstimocean and c) similar to the last point, it's crucial that these parameters are obviated in user scripts for reproducibility; defining an interface for drag will help. I think some simple struct called `QuadraticDrag`, which `regularize_boundary_condition` knows how to deal with (since it knows `field_name`, we know how to treat the different velocity components), will suffice for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638:1080,interface,interface,1080,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638,1,['interface'],['interface']
Integrability,"A mapping between index and base coordinate system is what we typically use. Base coordinate system can be geographic lat-lon, or could be cylindrical polar for some process studies). We probably do want to keep flexibility in the mapping, but we do want an easy route to understand the mapping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/50#issuecomment-463229274:263,rout,route,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/50#issuecomment-463229274,1,['rout'],['route']
Integrability,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:191,wrap,wrapping,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969,1,['wrap'],['wrapping']
Integrability,"A possible implementation of `QuadraticallyStretchedFaces` with the ""z faces interface"" might allow syntax like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z_faces = QuadraticallyStretchedFaces()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815961732:77,interface,interface,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815961732,1,['interface'],['interface']
Integrability,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:210,synchroniz,synchronize,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,3,['synchroniz'],['synchronize']
Integrability,"Actually, I think those docs are misleading. The straightforward way to arrive at the implicit step equation is to first discretize in space, and then after that derive the fractional step method. The key steps are:. 1. Discretize the continuity equation, and then sum in the vertical to obtain the finite-volume discretized free surface equation in terms of the vertically integrated transports; 2. Introduce the predictor velocities in the discretized momentum equation, and then sum the discretized momentum equation in the vertical.; 3. Combine the discretized momentum equation with the free surface equation by taking the divergence of the vertically-summed momentum equation. Steps 2 introduces the vertical sum of the discretized barotropic pressure gradient into the implicit step equation, which is how we see that these two contributions in fact come from the same place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145:374,integrat,integrated,374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145,1,['integrat'],['integrated']
Integrability,"Adding a Manifest + Project toml files in each validation scripts directory is a good idea!; However, if we do it while we are working on them in a PR, then the Manifest comes with an Oceananigans dependency that points to the branch, e.g.,. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/Manifest.toml#L1202. and the branch gets deleted after the PR is merged. . So what one would need to do is to make another PR with a Manifest pointing to the specific commit on `main` or to the next tagged release? Sounds like too much work to be sustainable...?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915:197,depend,dependency,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915,1,['depend'],['dependency']
Integrability,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:368,depend,dependencies,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,3,['depend'],"['dependencies', 'dependency']"
Integrability,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:84,message,message,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801,1,['message'],['message']
Integrability,"After last week's discussions I think I'm on board with the separate `Simulation` type. I agree that `output_writers` and `diagnostics` can move outside of the `Model` and into `Simulation` as they're not used inside `time_step!`. I think the `clock` should stay inside the model though. If we use a narrow interpretation of a model as a discrete representation of a physical system as you've suggested, then the current time is inherent to the physical system. Forcings and boundary conditions could be time-dependent, etc. In your second example, you should have probably set time (and iteration number) back to zero in addition to initializing all the prognostic fields. I think this is what we have so far for a design:; ```julia; struct Simulation; model; Δt; diagnostics; output_writers; simulation_stop_time; simulation_stop_iteration; wall_time_limit; progress; end; ```. `progress(model)` will be a user-specified function that takes one input, the `model`. Note: `wall_time_limit` will be useful for running long simulations on clusters with time limits (the majority of them).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-584356786:509,depend,dependent,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-584356786,1,['depend'],['dependent']
Integrability,"Agree we need another name, perhaps a variant of shenanigans. On Thu, Jan 30, 2020, 3:31 PM Gregory L. Wagner <notifications@github.com>; wrote:. > I think its a fine idea to merge, though it is interesting that the code; > will still be called Oceananigans :-D; >; > I'm not sure I understand point 4 completely. The ocean model also has the; > concept of a model ""state""; for example, ghost cell values and nonlinear; > diffusivities depend on the velocity and tracer fields, in general. We; > currently handle this only during time-stepping --- there is no guarantee,; > for example, that the diffusivities or ghost cell values are consistent; > with the velocity field if the velocity field is set by the function set!; > (in fact, the diffusivities are *always* inconsistent with the current; > velocity field due to the fact that they are calculated *prior* to taking; > a time-step). If we want to guarantee such a consistency, we can develop; > the concept of a model ""state"" and apply it to both ocean and atmospheric; > models (eg a function update_state!(model), or something similar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:436,depend,depend,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['depend'],['depend']
Integrability,"Ah I see, the GPU compiler would just see `Fu(grid, velocities, tracers, i, j, k)` and not know what to call at compile time. Would `struct ForcingFunctions{FFu, ...}` be the best approach to inject arbitrary functions (maybe with a specific signature) into a GPU kernel at run time? Can't think of many options myself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467044774:192,inject,inject,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467044774,1,['inject'],['inject']
Integrability,"Ah Julia installed Oceananigans v0.5.1 (an extremely ancient version), probably due to conflicts between dependency versions. The latest release is Oceananigans v0.57.1. To grab the latest version you can try to explicitly update by typing `] add Oceananigans@0.57.1` in the REPL. There may be conflicts with some other packages like CUDA v3.1.0. Oceananigans is still depending on CUDA v2 so you might have to `] rm CUDA` to be able to `] add Oceananigans@0.57.1`. This might also explain the weird error you reported in #1635. PS: You might encounter issues when using Oceananigans.jl with Julia 1.6 right now. It still requires Julia 1.5 for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832291603:105,depend,dependency,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832291603,2,['depend'],"['dependency', 'depending']"
Integrability,"Ah interesting. `SubArray` is what `view` returns. I'm hazy about why you see what you see, but we do know that _singly_ wrapped containers get special treatment. Possibly there have been some improvements for double+ wrapped containers like `view` of `OffsetArray`. As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O. However, I believe this is a bug with CUDA so that would just be a workaround rather than a legitimate solution. Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`? In other words use the same code as above but reduce to a view of `a` rather than a view of `o`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494:121,wrap,wrapped,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494,2,['wrap'],['wrapped']
Integrability,"Ah nice, that's great. I do think a full example would be nice since that's the entry point for a lot of people. @BrodiePearson might have a good script to start an example from that showcases a few features at the same time, including spatially-dependent boundary conditions and a nonlinear equation of state... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-663090954:246,depend,dependent,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-663090954,1,['depend'],['dependent']
Integrability,"Ah ok I see, you still have to merge main. Then synchronization problems will be fixed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514622516:48,synchroniz,synchronization,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514622516,1,['synchroniz'],['synchronization']
Integrability,"Ah ok so I think this is just an issue with running `makedocs` multiple times after each other without cleaning up what `makedocs` has done before. So it's complaining that when it ran the `jldoctest` a second time it got this message:. ```; more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; ```. so the output is different. I guess we have 3 possible automated fixes (manual fix being to remove the files manually):; 1. We can clean up and remove these files as part of `make.jl`.; 2. Using `NetCDFOutputWriter` in `jldoctest` we should use the `mode = ""c""` kwarg to avoid the info/warning message.; 3. `jldoctest` blocks should remove files at the end of the block (and there should be a way to hide this from the docs but not 100% sure right now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994:227,message,message,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994,2,['message'],['message']
Integrability,"Ah ok! Was the behavior different in prior versions of Oceananigans? This is what I would like to understand. We did not fill halo regions *after* time stepping in prior versions of Oceananigans, either, as far as I know. Do you want to contribute an advection scheme to Oceananigans? A lot of people might benefit from having the kind of advection scheme that you are using! It may not be very much work, since we have an interface for adding new advection schemes. Do you evolve the tracer fully outside of the `Oceananigans` infrastructure? Or is the tracer ""included"" in the list of tracers for your `IncompressibleModel`, but you somehow negate tracer advection and add it outside of `time_step!`, somehow? It would be interesting to see this method, and figure out how to make it easier for users to solve problems like the one you're encountering in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694211534:423,interface,interface,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694211534,1,['interface'],['interface']
Integrability,"Ah sorry yes it was a misuse of the `JLD2OutputWriter` so I will close this issue. I still think we should make the interfaces to `JLD2OutputWriter` and `NetCDFOutputWriter` more similar for consistency across the package and to make it easier to switch between them, but more work needs to be done on `NetCDFOutputWriter` first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-580297746:116,interface,interfaces,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-580297746,1,['interface'],['interfaces']
Integrability,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:40,message,message,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825,1,['message'],['message']
Integrability,"Ah sorry. I think you should use. ```julia; pressure_solver = FFTBasedPoissonSolver(grid, FFTW.ESTIMATE); ```. PS try triple backticks (```) rather than single backticks (`) for formatting blocks of code / error messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674:212,message,messages,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674,1,['message'],['messages']
Integrability,Ah that looks quite nice. Would it make sense to try and integrate `DiskTimeSeries` with a `DimensionalData.DimArray` to get named axis behavior?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801:57,integrat,integrate,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801,1,['integrat'],['integrate']
Integrability,"Ah that makes sense, thank you for investigating!. I think Oceananigans.jl depends on the latest CUDA packages (CUDAnative.jl, CUDAdrv.jl, CuArrays.jl, etc.) while other packages might require older versions of them. PS: Apologies in advance if parts of the documentation has gone out of date as we've made a lot of improvements recently. But please open another issue if you hit any problems!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/679#issuecomment-595585915:75,depend,depends,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/679#issuecomment-595585915,1,['depend'],['depends']
Integrability,"Ah yes I remember @jm-c's concern now! Yes, just ""face"" and ""edge"" are ambiguous. So your proposed solution will make it explicit exactly which interface the field is being interpolated from and to, which will be nice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471178907:144,interface,interface,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471178907,1,['interface'],['interface']
Integrability,"Ah, I foolishly assumed it was running in CPUs but do see it's running on GPUs. I gather it's slow because the GPU I have on my desktop is poor. Maybe I'll kill it and run it on a CPU as that maybe faster on my local machine. One thing that should be changed, sometime, is the only output I see is a warning message. ```; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735:308,message,message,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735,1,['message'],['message']
Integrability,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:257,depend,depends,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100,1,['depend'],['depends']
Integrability,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:474,interface,interface,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439,1,['interface'],['interface']
Integrability,"Ah, but the ""cape"" is oriented in x --- it sticks out from the southern boundary with unit 1 and tapers to 0 as x -> -infty and +infty. If the flow comes in from the west, it would impinge on the cape. Right?. Note that y < exp(-x^2) is true along the entire southern boundary where `y=0` and `x` varies from `-10` to `+10`. So imposing an inflow along the southern boundary will be masked out, I believe, depending on the order of operations in `update_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852778265:406,depend,depending,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852778265,1,['depend'],['depending']
Integrability,"Ah, it looks like I accidentally branched this PR from `glw/diagnostic-dependencies` rather than `master`. We should merge #886 first anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/887#issuecomment-683473091:71,depend,dependencies,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/887#issuecomment-683473091,1,['depend'],['dependencies']
Integrability,"Ah, nevermind --- the behavior of `slice_indices` depends on the location of `field`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/926#issuecomment-690280001:50,depend,depends,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/926#issuecomment-690280001,1,['depend'],['depends']
Integrability,"Ah, you may be running into some hidden limitations of AbstractOperations --- they seem to fail when the operations are too complex. It's a shifty problem, because it appears to depend on the julia compiler. It's good that you opened this issue because it would be nice to document our efforts for solving this tricky problem. I don't think this is a problem of `AveragedField`s specifically. Rather it's an issue with `ComputedField`s, are more specifically, evaluating complex `AbstractOperations` on the GPU. Over at LESbrary, we are circumventing this issue by hand-writing particularly important complicated kernels. I think `ViscousDissipation` may be the object you're looking for:. https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/viscous_dissipation.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-737402077:178,depend,depend,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-737402077,1,['depend'],['depend']
Integrability,"Ali, can I think of this as a shallow water model that knows about reduced; gravity? John. On Wed, Apr 21, 2021, 1:45 PM Ali Ramadhan ***@***.***> wrote:. > This PR adds an eddying aquaplanet validation experiment that's still a; > work-in-progress (early stage PR).; >; > The idea is to force a HydrostaticFreeSurfaceModel on a CubedSphereGrid; > with a ""tradewind-like"" zonal wind stress pattern akin to Marshall et al.; > (2007); > <https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml>.; >; > This is figure 3 from the paper:; >; > [image: i1520-0469-64-12-4270-f03]; > <https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif>; >; > and this is the analytic formula I'm using to mimic it:; >; > [image: image]; > <https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png>; >; > We integrate τ to obtain a streamfunction for the wind stress which we; > then use to diagnose the surface; > momentum fluxes on the cubed sphere. *I think I got the magnitude wrong; > so I fixed it with a scaling factor...*; >; > I tried adding a lot of noise to the initial velocities but the wind; > stress smoothed it away.; > cubed_sphere_eddying_aquaplanet.mp4; >; > @christophernhill <https://github.com/christophernhill> suggested adding; > some random noise to the wind stress as well. And we probably also need a; > mechanism to remove energy otherwise the wind stress keeps accelerating the; > fluid until the model blows up. Maybe we need some bottom drag even though; > we only have one vertical level?; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1602; > Commit Summary; >; > - Regularize cubed sphere boundary conditions; > - First draft of eddying aquaplanet; > - Run with diffusion for 7 days and copy paste plotting script; >; > File Changes; >; > - *M* src/CubedSpheres/CubedSphere",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767:896,integrat,integrate,896,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767,1,['integrat'],['integrate']
Integrability,"Ali, i thought the stretching was sorted now, after the hackathon. Without; stretching the code will have limited use. John. On Wed, Jul 10, 2019, 3:32 PM Ali Ramadhan <notifications@github.com> wrote:. > We agreed this could be a test case against which we can verify the; > implementation of AMD in PR #309; > <https://github.com/climate-machine/Oceananigans.jl/pull/309>, although; > the published results use a slightly modified version of AMD.; >; > They report a number of LES runs, and since we don't have a vertically; > stretched grid, it might be easiest to try and reproduce the Pr = 0.7 case; > which they do with (Nx, Ny, Nz) = (64, 49, 64) grid points [for Ri=0 or; > 0.01, for Ri = 0.04 it's (64, 65, 64)]. I might suggest focusing on the Ri; > = 0 case as they also run a resolved DNS with (Nx, Ny, Nz) = (256, 129,; > 256) against which we might be able to compare (might not be possible,; > depending on vertical grid stretching).; >; > Unfortunately, I don't think we can reproduce their results without a; > vertically stretched grid... If I understand the paper correctly, the grid; > is stretched according to; >; > y_j = h*tanh(Sf*(2*(j-1)/(Ny-1))) / tanh(Sf); >; >; > so for h=1 you get grid spacings of Δy ~ 0.125 away from the wall and Δy ~; > 0.0000035 adjacent to the wall. So a faithful reproduction would need; > 35000+ vertical levels lol.; >; > I don't fully understand how they got their values for the vertical grid; > cell size adjacent to the wall ∆y_w^+, but it seems like if h = 100,000; > then our values agree (they get a spacing of Δy ~ 0.35 adjacent to the; > wall). Either way, the ratio between the thickest and thinnest spacings is; > ~35,000.; >; > Not sure if there's still a way we could compare results in this case; > without a vertically stretched grid...; >; > Absolute worst case scenario, I've been working on an implementation of a; > vertically stretched grid (see PRs #283; > <https://github.com/climate-machine/Oceananigans.jl/pull/283> and #3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-510099706:909,depend,depending,909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-510099706,1,['depend'],['depending']
Integrability,"Ali, what are the time-dependent conditions at top? Free slip should be; good: du/dz=0. On Tue, Aug 6, 2019, 6:38 PM Ali Ramadhan <notifications@github.com> wrote:. > Never mind, I rewrote the test to act in the x,y plane with more; > complicated time-dependent boundary conditions at the top and bottom for u; > and v.; >; > It still works and doesn't require changes to the time stepping (which; > have been reverted).; >; > Will add this to the tests.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/336?email_source=notifications&email_token=AKXUEQUPZKYNNCILQG2ECITQDH4PTA5CNFSM4IJ2G5UKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD3WVFWI#issuecomment-518869721>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQTOLS6ZGXSWBIYRBQDQDH4PTANCNFSM4IJ2G5UA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518882791:23,depend,dependent,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518882791,2,['depend'],['dependent']
Integrability,"Ali,; changes to; - Poisson (div v etc) and; - diagnosing w from continuity instead of stepping forward the vertical mtm; equation; are major algorithmic changes.; Important to do an extended integration to make sure nothing is broken.; Free convection?; Did the divide or multiply by del_t get sorted out?; John. On Thu, May 23, 2019 at 8:50 PM Ali Ramadhan <notifications@github.com>; wrote:. > Now that the velocity field is truly incompressible in time.; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/233; > Commit Summary; >; > - Update thermal bubble golden master output.; >; > File Changes; >; > - *M* test/thermal_bubble_golden_master_10.nc; > <https://github.com/climate-machine/Oceananigans.jl/pull/233/files#diff-0>; > (0); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceananigans.jl/pull/233.patch; > - https://github.com/climate-machine/Oceananigans.jl/pull/233.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/233?email_source=notifications&email_token=AKXUEQXNYO4M3IXQPZJTXITPW43ULA5CNFSM4HPLKXNKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVS43WA>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQTT25U7Q4S3UQHKFGTPW43ULANCNFSM4HPLKXNA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/233#issuecomment-495690445:192,integrat,integration,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/233#issuecomment-495690445,1,['integrat'],['integration']
Integrability,"All that's really needed is to define. https://github.com/CliMA/Oceananigans.jl/blob/0415938fa0fbd9cb581e3301b31083e064519b06/src/Coriolis/hydrostatic_spherical_coriolis.jl#L33-L34. for other `coriolis` schemes. Probably it needs to dispatch on both `FPlane` / `BetaPlane` and `AbstractRectilinearGrid`. The code should be restructured a bit. If we do that, the only that makes coriolis ""spherical"" or not is the dependence of `f` on `i, j`. So we should put the definition of the Sabourny stencils in a new file.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873641159:413,depend,dependence,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873641159,1,['depend'],['dependence']
Integrability,Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2396162646:111,depend,dependent,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2396162646,1,['depend'],['dependent']
Integrability,"Also this doesn't blow up, right? I think with increasing energy, eventually nonlinearities and numerical diffusion would kick in. The integrated KE might exhibit oscillatory behavior on long time-scales. (The example in the OP only blows up because the `TimeStepWizard` increases the time step too much.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445270762:135,integrat,integrated,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445270762,1,['integrat'],['integrated']
Integrability,"Also we get some deprecation warnings. E.g., for. ```; SpecifiedTimes(times::Vararg{<:Number}) = SpecifiedTimes(sort([Float64(t) for t in times]), 0); ```. we get. ```; Wrapping `Vararg` directly in UnionAll is deprecated (wrap the tuple instead).; ```. I don't understand what that means tho.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566849601:169,Wrap,Wrapping,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566849601,2,"['Wrap', 'wrap']","['Wrapping', 'wrap']"
Integrability,Also wondering why there isn't a test that catches this? Does it depend on the size of the problem?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639:65,depend,depend,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639,1,['depend'],['depend']
Integrability,"Although that PR makes CUDAnative behave a little better, it does not change the warnings. Ideally, Pkg would have conditional dependencies and a way for the build process to inform that the package is or is not available, but lacking that the warnings seem like the only way. Maybe you have an other idea?. Maybe you should comment at https://github.com/JuliaLang/Pkg.jl/pull/977",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178#issuecomment-483716921:127,depend,dependencies,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178#issuecomment-483716921,1,['depend'],['dependencies']
Integrability,"An alternative solution is to supply our own syntax for working with the boundary of fields, similar to. https://github.com/JuliaArrays/EndpointRanges.jl/blob/master/src/EndpointRanges.jl. For example, we can define `east, west, north, south, top, bottom`, so that one can write. ```julia; top_flux(i, j, grid, clock, fields) = fields.c[i, j, top]; ```. This will work best if we generalize `adapt_structure` for fields so that field location information is preserved, which will allow us to accurately interpret these indices when applied to fields at cell interfaces (currently we throw away the entire field wrapper and keep only `data`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-721740161:558,interface,interfaces,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-721740161,2,"['interface', 'wrap']","['interfaces', 'wrapper']"
Integrability,"An “edge” is the case in which 2 of Lx, Ly, or Lz are “interface”. We just; don’t need special notation. This method of specifying locations in a cube; is simpler, but also more general. On Sat, Mar 9, 2019 at 8:52 AM Ali Ramadhan <notifications@github.com>; wrote:. > Ah yes I remember @jm-c <https://github.com/jm-c>'s concern now! Yes,; > just ""face"" and ""edge"" are ambiguous.; >; > So your proposed solution will make it explicit exactly which interface; > the field is being interpolated from and to, which will be nice.; >; > —; > You are receiving this because you were assigned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471178907>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBlzM_EBoVLsfUYqw-V_v_Pe2admmks5vU7yqgaJpZM4bEKew>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471179020:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471179020,2,['interface'],['interface']
Integrability,And all tests pass! Great! Ignore my messages!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091221383:37,message,messages,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091221383,1,['message'],['messages']
Integrability,"And right, for thin aspect ratios (H/L << 1), we typically neglect the dependence on `w` for two reasons: (1) `w` is small (eg `w ~ u * H/L`), and (2) `w` is non-zero only on side-walls, which make a negligible contribution to the overall flux, because side-wall areas are O(H/L) smaller than vertical-normal areas. For this example, we can either use a hydrostatic-specific drag, or we can use a more general formulation and comment on how it could be simplified using an assumption of thin-aspect ratio (which is also the basis for the hydrostatic approximation). In the context of Oceananigans, it turns out to be _simpler_ to specify a 3D drag. So the ""simplification"" for thin-aspect ratio isn't as important as it is, for example, for analytical / theoretical calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370:71,depend,dependence,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370,1,['depend'],['dependence']
Integrability,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:390,Wrap,Wrapping,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786,2,"['Wrap', 'depend']","['Wrapping', 'dependencies']"
Integrability,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281:103,interface,interface,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281,1,['interface'],['interface']
Integrability,"Another change that we may want to wrap into the changes discussed in this issue (because it also affects `fill_halo_regions!` and field initialization) is to the convention we use for face-centered directions. Currently, the left halo of a face-centered field lies outside the domain, while the right ""halo point"" of a face-centered field is actually located on the boundary. . We need to change this definition so that all halo points are located outside the domain for face-centered fields. In other words, parent arrays need to have `N + 1 + 2H` points along face-centered dimensions, and `N + 2H` points along cell-centered directions. Because we use `OffsetArrays` for indexing I don't think this change will affect any code except field initialization and `fill_halo_regions!` (which makes assumptions about indexing due to the need to reference the `parent` array directly). This change is necessary for the correct evaluation of the pressure Poisson equation in bounded domains and for general equations / boundary conditions. There will also need to be concomitant changes in `fill_halo_regions!` for no-penetration boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580324305:35,wrap,wrap,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580324305,1,['wrap'],['wrap']
Integrability,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:91,interface,interfaces,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072,3,['interface'],"['interface', 'interfaces']"
Integrability,"Another non-function example is this piece of code from the wind mixing case:. ```julia; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m s⁻¹, surface temperature flux. # Finally, we impose a temperature gradient `dTdz` both initially and at the; # bottom of the domain, culminating in the boundary conditions on temperature,. dTdz = 0.01 # K m⁻¹. T_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); ```. This should work on the GPU. The reason is that `Qᵀ` and `dTdz` are not referenced in functions. Instead, they end up inside the data structures `model.tracers.T.boundary_conditions.top.condition` and `model.tracers.T.boundary_conditions.bottom.condition`. Likewise, this code is valid too:. ```julia; @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S # [salinity unit] m s⁻¹; nothing # hide. # where `S` is salinity. We use an evporation rate of 1 millimeter per hour,. evaporation_rate = 1e-3 / hour # m s⁻¹. # We build the `Flux` evaporation `BoundaryCondition` with the function `Qˢ`,; # indicating that `Qˢ` depends on salinity `S` and passing; # the parameter `evaporation_rate`,. evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); ```. because `evaporation_rate` enters into `Qˢ` in its 5th argument. It does not need to be, and should not be, `const`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881690306:1068,depend,depends,1068,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881690306,1,['depend'],['depends']
Integrability,Another place I think we need to change is particle advection:; https://github.com/CliMA/Oceananigans.jl/blob/f3113c492f309846f026e0ac150dc8480f96e0f2/src/LagrangianParticleTracking/update_particle_properties.jl#L157-L161. Because currently background velocity fields don't get integrated which I think is wrong? At least in the case I was using them for I had to add the background velocities manually.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482931094:278,integrat,integrated,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482931094,1,['integrat'],['integrated']
Integrability,"Another possibility is to write some tests using `HydrostaticFreeSurfaceModel` with `ExplicitFreeSurface`, which is entirely explicit and thus requires only halo filling via MPI (with no PencilArrays dependency)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942:200,depend,dependency,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942,1,['depend'],['dependency']
Integrability,Any code using threading is eventually just going to hang on M1. My point is that Oceanigans should not be working around this for the user since it declares an unecessary dependency for everyone else. Users can pin mpich_jll locally if needed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112623087:172,depend,dependency,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112623087,1,['depend'],['dependency']
Integrability,"Apologies for confusing the nomenclature, I should have said `exterior_cell` (I named it this to contrast with the function `interior`). Though ""exterior"" and ""interior"" strictly aren't mutually exclusive, they are loosely connected... > So external_cell is just a special case external_node, correct?. Correct, `exterior_cell` is identical to `exterior_node` evaluated at tracer cell centers. > It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. No, there is no assumption. The notion of `exterior_cell` is independent of the immersed boundary implementation. There are `exterior_cell`s for any grid `Bounded` in one or more direction. The implementation for underlying grids is here:. https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/src/Grids/exterior_node.jl. Differences between ""full cell"" immersed boundary methods and other types of methods manifest in the way grid metrics are modified (spacing, areas, and vectors normal to cell interfaces). All immersed boundary methods will both define `external_cell` and any boundary-specific modifications to metrics. We'll also need an interface for specifying the face normal vector, since those normals won't lie along the cardinal directions anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563:982,interface,interfaces,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563,2,['interface'],"['interface', 'interfaces']"
Integrability,"Are we integrating bottom-up or top-down now?. Ultimately it might be nice to eliminate that step and explicitly time-step the vertical velocity, since thats valid for general boundary conditions...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-541212190:7,integrat,integrating,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-541212190,1,['integrat'],['integrating']
Integrability,"Are we ok with this as a user interface? it's a little implicit. We could alternatively use a function-based API to make things a little more obvious, something like. ```julia; fts[1, 2, 3, 4] # get 4th time-index; ```. ```julia; at_time(4, fts, 1, 2, 3) # linearly interpolate to t=4; ```. mainly i'd be worried about issues like. ```julia; fts[1, 2, 3, 4] \ne fts[1, 2, 3, 4.0]; ```. which is rather easy to confuse?. We also might be able to use syntax like. ```julia; fts[1, 2, 3, time=4]; ```. if that is performant. Or. ```julia; fts[1, 2, 3, Time(4)]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139:30,interface,interface,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139,1,['interface'],['interface']
Integrability,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:26,interface,interface,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100,7,['interface'],"['interface', 'interfaces']"
Integrability,"As a side note: I think it's ok to include ""shared utils"" at the top level within a submodule prior to importing logically-distinct functionality contained in separate files. Sometimes this can improve code-readability if there are a small number of utils. The need for a separate ""utils.jl"" file should decrease when the code structure is more modular and separated into logical subunits, I think. We can also have single-file submodules, as in Documenter.jl (I think their file structure looks very sane and manageable):. https://github.com/JuliaDocs/Documenter.jl/tree/master/src. There's still a bit of work we need to do to understand inter-submodule dependencies; once that's sorted out I think the top-level Oceananigans.jl file will clean up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/512#issuecomment-547404935:656,depend,dependencies,656,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/512#issuecomment-547404935,1,['depend'],['dependencies']
Integrability,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:509,interface,interface,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,1,['interface'],['interface']
Integrability,"As discussed elsewhere, it might be most convenient for users if an interface to applying moving averages is provided within the constructor for an output writer, rather than creating a wrapper object like `TimeAveragedOutputWriter`. An example of this would be. ```julia; U = HorizontalAverage(model.velocities.u); V = HorizontalAverage(model.velocities.v). statistics_writer = JLD2OutputWriter(model, (U=U, V=V), time_interval=1hour, time_averaging_window=1minute); ```. The advantage of this syntax is that deciding to time-average output is as simple as adding a keyword argument to an existing output writer. This may be easier to user than previously proposed interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-673085748:68,interface,interface,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-673085748,3,"['interface', 'wrap']","['interface', 'interfaces', 'wrapper']"
Integrability,"As discussed via zoom with @kburns, passing a key to computations to be stored and used to determine whether a computation needs to be performed is a simple method that may work for us. A simple option for a key is the current model time, which works for all the time stepping methods we employ and has the additional advantage of interpretability. One complication is that we allow users to specify memory space for `ComputedField`s and `AveragedField`s. As a result, two `ComputedField`s that share memory space may have incorrect `data` if the memory is overwritten. This is, in fact, a problem even in the current code and not dependent on the optimizations discussed in this issue. Since we think it is important to give users the option of avoiding unnecessary memory allocation by managing the allocation of scratch space for computations, we cannot prevent incorrect output resulting from overwriting of scratch space during operations with embedded averaged fields and computed fields. We simply have to document this potential ""gotcha"". We can make avoiding repeated operations a bit safer by requiring users to enable it when a `ComputedField` or `AveragedField` is constructed by a keyword argument, something like `recompute_safely`: . ```julia; U = AveragedField(model.velocities.u, dims=(1, 2), data=scratch, recompute_safely=false); ```. When `recompute_safely` is disabled, the model time at computation will be cached. The cache can either be inside `AveragedField`, or in a global cache. (A global cache has the advantage of being on the CPU; a local cache has the advantage of being local).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458:631,depend,dependent,631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458,1,['depend'],['dependent']
Integrability,"As far as I can tell the main purpose of `CLIMAParameters` is to provide a central / global place to specify common parameters found in different model components. For example, `HydrostaticFreeSurfaceModel` has a `gravitational_acceleration` for both `buoyancy` and `free_surface`. On the other hand, it turns out that it's sometimes convenient for these to be different for testing and experimentation, which may impose additional requirements on `CLIMAParameters` that were not part of the original design. One possible solution might be to build a global `CLIMAParameters` instance in `Oceananigans` that's referenced in model constructors for default parameter values (but we can still let users change parameters when instantiating various model components if they want). A possible goal of CLIMAParameters is to _restrict_ the user interface so that users ""can't mess up""; eg users can't accidentally set `gravitational_acceleration` in `free_surface` and erroneously expect that this also changes `gravitational_acceleration` for buoyancy. Food for thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111:838,interface,interface,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111,1,['interface'],['interface']
Integrability,"As for a slip velocity that depends on buoyancy, one method uses `Callback`:. ```julia; # Define slip field with impenetrable boundary conditions; w_slip_bcs = FieldBoundaryConditions(grid, top=OpenBoundaryCondition(), bottom=OpenBoundaryCondition()); w_slip = ZFaceField(grid). # Build AdvectiveForcing; slip_forcing = AdvectiveForcing(w = w_slip). # later...; b = BuoyancyField(model) # or just model.tracers.b for BuoyancyTracer(); b_particle = 1e-4 # define particle ""buoyancy"". Requires reference fluid buoyancy / knowledge of initial condition.; particle_radius = 1e-3; molecular_viscosity = 1e-6. # Define an AbstractOperation that computes the slip velocity:; slip_velocity_op = 2/9 * (b_particle - b) / molecular_viscosity * particle_radius^2. function compute_slip_velocity!(sim); compute!(b) # compute buoyancy if it's a function of T, S; w_slip .= slip_velocity_op; Oceananigans.BoundaryConditions.fill_halo_regions!(w_slip); return nothing; end. simulation.callbacks[:compute_slip_velocity] = Callback(compute_slip_velocity!); ```. It's also possible not to use `Callback` if the forcing is written manually with the `discrete_form`. That requires a bit more work and more knowledge of Oceananigans internals though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083758705:28,depend,depends,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083758705,1,['depend'],['depends']
Integrability,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:188,interface,interface,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354,1,['interface'],['interface']
Integrability,"As part of this PR it would probably make sense to refactor the interface between `Simulation` and output writers a bit. For example, `Callback` has a place to insert custom `initialize!` but output writers do not:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Simulations/run.jl#L200-L214. The natural way to throw a warning would be during initialization, which should depend on both the output writer and the simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406:64,interface,interface,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"Awesome stuff! Just some comments, will look into the code and unit tests in more detail. To keep things moving I agree would be good to merge as a standalone module and work on integrating the closures and testing them in separate PRs. +1 to eventually merging the new operators into the existing `Operators` module but for now they can remain separate until we can integrate them with the rest of the code. I might suggest renaming `DirectionalDiffusivity` to `AnisotropicDiffusivity` for consistency. With the growing amount of notation for the operators and even things like `G` for source terms we should probably create a page in the docs that explains the code notation. Could be a useful reference. This PR also resolves #120. > Does anyone object to adding a new section to describe the governing equations? I think that new section would be the appropriate place to describe the turbulence closures. I feel that the math / governing equations are sufficiently different from the algorithm to warrant its own section. We already have a subsection that describes the governing equations. I don't object to giving it its own page.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495577981:178,integrat,integrating,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495577981,2,['integrat'],"['integrate', 'integrating']"
Integrability,"Awesome! Yes unfortunately the code has changed a lot recently and the docs have become stale in many places, we're hoping to revise them soon. > Maybe another possibility is to always have the user interface present fields centered and only when going into calculations doing the decentering/staggering internally. That would keep the user away from internals and staggering conventions. Yeah for sure. I think one of our goals with Oceananigans.jl is to eventually make it so users never have to think about the staggered grid. Most examples use functions to initialize fields like. ```julia; random_noise(x, y, z) = rand(); set!(model, u=random_noise, v=random_noise); ```. which will work no matter the size of the field, but in the 2D turbulence example we wanted the noise to have zero mean so we had to use arrays. Perhaps it can be revised to use functions. Either way we can keep this issue open until the docs (or the examples) are revised.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839735531:199,interface,interface,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839735531,1,['interface'],['interface']
Integrability,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:224,interface,interface,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432,1,['interface'],['interface']
Integrability,Before I updated and induced the problem I was getting O(seconds) initialisation time on M1 Mac so I think you're experiencing the problem with both versions @navidcy . I tried using JLD2 and got the same slow initialisation. Do they have a common dependency that does something to the field?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775:248,depend,dependency,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775,1,['depend'],['dependency']
Integrability,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:196,depend,depends,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933,1,['depend'],['depends']
Integrability,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:254,depend,dependencies,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133,1,['depend'],['dependencies']
Integrability,"Both the grid specification and the boundary condition API will change when we have the grid topology, because there won't be a need for monstrosities like `HorizontallyPeriodicSolutionBCs`. So, maybe this would be a nice change to make immediately following the upgrade to both grids. I agree that it would be nice to de-complexify the deep hierarchical structure of the current `boundary_conditions` container. I agree we should probably keep the `boundary_conditions` keyword argument to `Model` --- but note that `boundary_conditions` would no longer be a `Model` field. The `Model` constructor will get a bit more complicated, because we can no longer initialize fields within the function signature of `Model`. On the other hand, I have noticed that doing everything inside function signatures as keyword arguments has the downside of making errors that occur there much more difficult to locate and diagnose. So maybe this isn't such a bad thing. We will have to instead initialize field tuples as `nothing`, and then build the field if it isn't explicitly specified. I'm ok with this --- I suspect we will be working on smoothing out kinks in the user API for some time. We will also need a function that does. ```julia; new_field = with_boundary_conditions(old_field, new_field_boundary_conditions); ```. that creates a new `Field` wrapper around the array in `old_field`, but with specified rather than default boundary conditions. The correct implementation of `Flux` boundary conditions (eg determining gradients / ghost point values when flux boundary conditions are specified) is still something of a puzzle, but the situation for fields-with-boundary-conditions would be no worse than it is with the current design.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580313484:1341,wrap,wrapper,1341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580313484,1,['wrap'],['wrapper']
Integrability,"Building on what @jm-c said, I think we want to design an interface in which an equation is expressed as something like . ```; φ_t = Lφ + Ν(φ); ```. where `φ` is the solution (an array of fields in this case, probably), `L` is a linear operator that can be treated implicitly (depending on the time-stepping scheme), and `N(φ)` is a nonlinear operator. The challenge is including the pressure correction in this paradigm. I think it should be possible --- we may just have to consider only time-steppers that invoke the special pressure correction substep. I think the design should be about more than just 'marking' the terms. We can tackle the problem of designing a time-stepper to step forward an equation of a certain form completely independent from the development of an algorithm to calculate nonlinear terms, pressure corrections, and linear terms for a specific kind of equation. Then we put the pieces together to solve the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463209211:58,interface,interface,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463209211,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"But Oceananigans doesn't really output time in ""seconds"", does it? The time unit is arbitrary, or depends on user inputs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791008380:98,depend,depends,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791008380,1,['depend'],['depends']
Integrability,But since all tests run on a computer at MIT the time it takes also depends on how many tests are running (eg how many prs were just open) and other random factors.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-877432402:68,depend,depends,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-877432402,1,['depend'],['depends']
Integrability,"But still, I think that you first derive the equation for \eta (after the time discretization) and then integrate in volume. In the end it is still a derivative of a derivative (Following the docs from mitgcm https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html). So the \partial x on the LHS should be correct. You 'll see that the term that doesn't cancel (as you derived above) is contained in the integral of the area. On the other hand, I think we should change the batropic pressure gradient correction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966:104,integrat,integrate,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966,1,['integrat'],['integrate']
Integrability,"But the way @tomchor wrote the example, is `outputs_yavg` dependent on `outputs_full`? Seems like it... E.g.,. ```julia; outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full)); ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436095497:58,depend,dependent,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436095497,1,['depend'],['dependent']
Integrability,"By the way, an alternative route to getting ""automatic"" dimensioning for `NetCDFOutputWriter` could be to define a `default_dimensions(output::WindowedSpatialAverage, grid, field_slicer)` that does the right thing. You can put the location `X, Y, Z` in `WindowedSpatialAverage` without making the object subtype `AbstractField` (which will cause various issues with time-averaging as noted).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783575623:27,rout,route,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783575623,1,['rout'],['route']
Integrability,"By “dataframes” approach, do you mean the dictionary-like interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-468289283:58,interface,interface,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-468289283,1,['interface'],['interface']
Integrability,CI will complain because of GPU dependencies.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/54#issuecomment-464561875:32,depend,dependencies,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54#issuecomment-464561875,1,['depend'],['dependencies']
Integrability,"CUDA uses a special buffer, the parameter space, to put arguments in. This buffer is about 4K large, and has special semantics that benefit performance (read-only, so threads can read from it without synchronizing, etc). Although arguments in Julia are normally passed by reference, i.e. putting pointers in that space, when invoking kernels we change the calling convention and pass by reference such that loading e.g. the size or pointer of an array doesn't synchronize threads. That works great, until you pass a large (number of) arguments as you apparently do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-653428852:200,synchroniz,synchronizing,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-653428852,2,['synchroniz'],"['synchronize', 'synchronizing']"
Integrability,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:93,depend,dependency,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372,2,['depend'],"['dependencies', 'dependency']"
Integrability,Can I pin specific versions of dependencies to try out?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1677#issuecomment-845428120:31,depend,dependencies,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1677#issuecomment-845428120,1,['depend'],['dependencies']
Integrability,"Can confirm that the following Poisson solver generalizes as expected, so we should be able to get to a channel model pretty easily. For a channel with walls in the _y_ and _z_ directions, the following Poisson solver with proper operators produces a divergence-free solution. ```julia; using Test; using FFTW; using Statistics: mean; using GPUifyLoops: @launch, @loop, @synchronize. using Oceananigans. # Increment and decrement integer a with periodic wrapping. So if n == 10 then; # incmod1(11, n) = 1 and decmod1(0, n) = 10.; @inline incmod1(a, n) = ifelse(a==n, 1, a + 1); @inline decmod1(a, n) = ifelse(a==1, n, a - 1). @inline δx_c2f(g::RegularCartesianGrid, f, i, j, k) = @inbounds f[i, j, k] - f[decmod1(i, g.Nx), j, k]. @inline function δy_c2f(g::RegularCartesianGrid, f, i, j, k); if j == 1; return 0; else; @inbounds return f[i, j, k] - f[i, j-1, k]; end; end. @inline function δz_c2f(g::RegularCartesianGrid, f, i, j, k); if k == 1; return 0; else; @inbounds return f[i, j, k-1] - f[i, j, k]; end; end. @inline δx²_c2f2c(g::RegularCartesianGrid, f, i, j, k) = δx_c2f(g, f, incmod1(i, g.Nx), j, k) - δx_c2f(g, f, i, j, k). @inline function δy²_c2f2c(g::RegularCartesianGrid, f, i, j, k); if j == g.Ny; return -δy_c2f(g, f, i, j, k); else; return δy_c2f(g, f, i, j+1, k) - δy_c2f(g, f, i, j, k); end; end. @inline function δz²_c2f2c(g::RegularCartesianGrid, f, i, j, k); if k == g.Nz; return δz_c2f(g, f, i, j, k); else; return δz_c2f(g, f, i, j, k) - δz_c2f(g, f, i, j, k+1); end; end. @inline function ∇²_pnn(g::RegularCartesianGrid, f, i, j, k); 	(δx²_c2f2c(g, f, i, j, k) / g.Δx^2) + (δy²_c2f2c(g, f, i, j, k) / g.Δy^2) + (δz²_c2f2c(g, f, i, j, k) / g.Δz^2); end. function ∇²_pnn!(grid::RegularCartesianGrid, f, ∇²f); @loop for k in (1:grid.Nz; blockIdx().z); @loop for j in (1:grid.Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); @loop for i in (1:grid.Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); @inbounds ∇²f[i, j, k] = ∇²_pnn(grid, f, i, j, k); end; end; end. @s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483896344:371,synchroniz,synchronize,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483896344,2,"['synchroniz', 'wrap']","['synchronize', 'wrapping']"
Integrability,Can we keep these features in separate PRs? The output interface really is distinct from the lower-level features needed for the NetCDFOutputWriter.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393855771:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393855771,1,['interface'],['interface']
Integrability,"Can we use a wrapper that automagically loads data from file for the specified time index (and also perform spatial slicing), using the nice GeoData getindex syntax?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413:13,wrap,wrapper,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413,1,['wrap'],['wrapper']
Integrability,Can you explain? Why does a function like `read_output` depend on whether the time step is constant? Why does any part of the code need to assume a constant time-step?. I think adaptive time-stepping is useful in many scenarios and the time-step should not be assumed constant in general.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462546680:56,depend,depend,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462546680,1,['depend'],['depend']
Integrability,"Can you print the whole warning message? I can't see what file / function the warning is coming from because it's cut off, I only see `-@-> /home/fpoulin/software/Oceananigans.jl/src/Grid`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843328500:32,message,message,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843328500,1,['message'],['message']
Integrability,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:145,message,message,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,1,['message'],['message']
Integrability,"Can't reproduce that @navidcy . ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 160 already precompiled. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); 2×3×4 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 6×9×10 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, -2:7) with eltype Float64 with indices -1:4×-2:6×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> c .= rand(size(c)...);. julia> v = view(c, :, 2:3, 1:2); 2×2×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, 2:3, 1:2); └── data: 6×2×2 OffsetArray(view(::Array{Float64, 3}, :, 5:6, 4:5), -1:4, 2:3, 1:2) with eltype Float64 with indices -1:4×2:3×1:2; └── max=0.943733, min=0.11545, mean=0.571896. julia> size(v); (2, 2, 2). julia> v[2, 2, 2] == c[2, 2, 2]; true; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091185942:98,depend,dependency,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091185942,1,['depend'],['dependency']
Integrability,Closing this since after #1221 StaticArrays won't be a direct dependency anymore.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1222#issuecomment-736952052:62,depend,dependency,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1222#issuecomment-736952052,1,['depend'],['dependency']
Integrability,Comparing the `model.clock.time` seems to be a good solution since RK3 `tick!` increases the stage and `model.clock.time`. I'm just curious why `FieldStatus` is required as it's just a container/wrapper around a `Float64`. Couldn't you dispatch on `::Number` and `::Nothing` instead of `::FieldStatus` and `::Nothing`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698398410:195,wrap,wrapper,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698398410,1,['wrap'],['wrapper']
Integrability,"ComplexF64, CUDA.CUFFT.cCuFFTPlan{ComplexF64, 1, true, 3}, Float64}, Oceananigans.Solvers.Backward, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Int64, Bounded, Int64, NamedTuple{(:forward, :backward), Tuple{CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}}}, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, Nothing, Nothing, Nothing, NamedTuple{(:a,), Tuple{Int64}}}; dependencies::CUDAKernels.CudaEvent); @ Oceananigans.Models.NonhydrostaticModels ~/OC.jl/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:88; [16] calculate_interior_tendency_contributions!; @ ~/OC.jl/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:46 [inlined]; [17] calculate_tendencies!; @ ~/OC.jl/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:27 [inlined]; [18] #apply_regionally!#46; @ ~/OC.jl/src/Utils/multi_region_transformation.jl:118 [inlined]; [19] apply_regionally!; @ ~/OC.jl/src/Utils/multi_region_transformation.jl:115 [inlined]; [20] macro expansion; @ ~/OC.jl/src/Utils/multi_region_transformation.jl:197 [inlined]; [21] time_step!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:29871,depend,dependencies,29871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['depend'],['dependencies']
Integrability,"Cool. Getting to the finish line will be a bit of work I guess. I think we usually want to integrate downwards so that's annoying. Not sure if that exists exactly, or we have to implement some lazy version of `reverse` to achieve it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2098991202:91,integrat,integrate,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2098991202,1,['integrat'],['integrate']
Integrability,"Correction to my last message, I accidentally included a second prime. The form of the Stokes drift is actually:. $u^s(x,y,z)=f(x)g(y)h′(z)$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1813531626:22,message,message,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1813531626,1,['message'],['message']
Integrability,Correction: `InterfaceImmersedCondition` and `CenterImmersedCondition` might still useful during construction because they inform where the bottom height will be.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2402229975:13,Interface,InterfaceImmersedCondition,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2402229975,1,['Interface'],['InterfaceImmersedCondition']
Integrability,"Could be interesting to explore! @suyashbire1 has looked at this I think. The big concerns are obviously performance, GPU compatibility, and we probably don't want to depend on an immature or abandoned package. We depend heavily on OffsetArrays.jl but it doesn't really come with any features we use besides the array type itself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/457#issuecomment-541417904:167,depend,depend,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/457#issuecomment-541417904,2,['depend'],['depend']
Integrability,"Definitely agree the two interfaces should be consistent. I'd be okay with either, although still slightly favor the current interface in case we will want to pass two sets of kwargs in the future. Would you support merging this PR and we can open an issue to discuss the best interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2340922312:25,interface,interfaces,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2340922312,3,['interface'],"['interface', 'interfaces']"
Integrability,"Dependencies between fields are supposed to be accounted for. For example if we write. ```julia; wc = Field(w * c); wc_average = Field(Average(wc, dims=1)); ```. then . ```julia; compute!(wc_average); ```. should first call `compute!(wc)`. For example:. https://github.com/CliMA/Oceananigans.jl/blob/c929676bcce7fc19c3f96faafd459371935a6eba/src/Fields/field_reductions.jl#L72-L77. where `reduction.operand === `wc` in the above example. Thus this calls. https://github.com/CliMA/Oceananigans.jl/blob/c929676bcce7fc19c3f96faafd459371935a6eba/src/AbstractOperations/computed_field.jl#L64-L72. Note that `compute_at!` should always compute if needed because. https://github.com/CliMA/Oceananigans.jl/blob/c929676bcce7fc19c3f96faafd459371935a6eba/src/Fields/field.jl#L451-L462",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436096967:0,Depend,Dependencies,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436096967,1,['Depend'],['Dependencies']
Integrability,"Did you test it? :). I think providing a string as a closure doesn't even make it to the new error message you added so you get a MethodError from `with_tracers`!. ```Julia; julia> using Oceananigans, Test; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 129 already precompiled. julia> grid = RectilinearGrid(CPU(), size=(2, 2, 2), extent=(1, 2, 3)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 2.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-3.0, 0.0] regularly spaced with Δz=1.5. julia> closure = ""not a closure""; ""not a closure"". julia> NonhydrostaticModel(; grid, closure); ERROR: MethodError: no method matching with_tracers(::Tuple{}, ::String). Closest candidates are:; with_tracers(::Any, ::Nothing, Any...; kwargs...); @ Oceananigans ~/Research/OC11.jl/src/Utils/with_tracers.jl:44; with_tracers(::Any, ::Oceananigans.TurbulenceClosures.TwoDimensionalLeith{FT}) where FT; @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl:61; with_tracers(::Any, ::ScalarBiharmonicDiffusivity{F, N}) where {F, N}; @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl:85; ... Stacktrace:; [1] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{}, closure::String, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, hydrostatic_pressure_anomaly::Oceananigans.Models.NonhydrostaticModels.DefaultHydrostaticPressureAnomaly, nonhydrostatic_pressure::Field{…}, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::@Na",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325306269:99,message,message,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325306269,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"Differences are close to machine epsilon so pretty sure this branch produces the same numbers as before, up to truncation error (and we do integrate from the bottom up to enforce continuity now). ```; Running regression tests...; Testing thermal bubble regression [CPU]; [ Info: Δu: min=-3.01224e-15, max=3.01289e-15, mean=-3.94216e-22, absmean=5.13638e-16, std=7.36011e-16; [ Info: Δv: min=-3.01208e-15, max=3.00899e-15, mean=-1.19521e-21, absmean=5.13326e-16, std=7.35825e-16; [ Info: Δw: min=-7.64756e-15, max=5.88619e-15, mean=1.35968e-21, absmean=1.03765e-15, std=1.48909e-15; [ Info: ΔT: min=-1.77636e-15, max=1.77636e-15, mean=7.80626e-18, absmean=3.55618e-17, std=2.51247e-16; [ Info: ΔS: min=0, max=0, mean=0, absmean=0, std=0; Testing Rayleigh–Bénard tracer regression [CPU]; [ Info: Δu: min=-3.65818e-14, max=3.21965e-14, mean=-1.92406e-18, absmean=3.3529e-15, std=4.83978e-15; [ Info: Δv: min=-2.85535e-14, max=3.72202e-14, mean=1.62974e-19, absmean=3.29709e-15, std=4.79574e-15; [ Info: Δw: min=-4.56857e-14, max=4.32987e-14, mean=2.54957e-18, absmean=2.97761e-15, std=4.68161e-15; [ Info: ΔT: min=-5.19029e-14, max=3.71925e-14, mean=8.223e-18, absmean=2.55428e-15, std=4.14735e-15; [ Info: ΔS: min=-2.37588e-14, max=1.60982e-14, mean=1.15112e-18, absmean=1.13258e-15, std=1.79417e-15; Testing oceanic large eddy simulation regression [VerstappenAnisotropicMinimumDissipation, CPU]; [ Info: Δu: min=-8.1532e-16, max=7.47666e-16, mean=3.10996e-19, absmean=1.34093e-16, std=1.74514e-16; [ Info: Δv: min=-7.94503e-16, max=7.32053e-16, mean=1.62668e-19, absmean=1.30967e-16, std=1.70133e-16; [ Info: Δw: min=-2.21871e-15, max=2.4928e-15, mean=-4.54454e-18, absmean=2.67538e-16, std=4.09625e-16; [ Info: ΔT: min=-1.06581e-14, max=1.06581e-14, mean=-1.76661e-17, absmean=1.34445e-15, std=2.4561e-15; [ Info: ΔS: min=-2.13163e-14, max=2.13163e-14, mean=-9.38131e-17, absmean=2.61336e-15, std=4.82786e-15; Testing oceanic large eddy simulation regression [SmagorinskyLilly, CPU]; [ Info: Δu: min=",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-544732689:139,integrat,integrate,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-544732689,1,['integrat'],['integrate']
Integrability,"Dispatching on the location as a parameterized type looks neat, would definitely clean things up! Thanks for coding up the example. I see how this would clean things up for `δz_f2c` and `δz_e2f` but the δz operator also needs to know onto which location to interpolate, so how would this work with `δz_f2c` and `δz_f2e`?; ```julia; @inline function δz_f2c(f, Nz, i, j, k); if k == Nz; @inbounds return f[i, j, k]; else; @inbounds return f[i, j, k] - f[i, j, k+1]; end; end. @inline function δz_f2e(f, Nz, i, j, k); if k == 1; return 0; else; @inbounds return f[i, j, k-1] - f[i, j, k]; end; end; ```. To me it looks like they both fit; ```julia; δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Interface} = ...; ```; so I'm not sure how dispatch between the two.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471177715:699,Interface,Interface,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471177715,1,['Interface'],['Interface']
Integrability,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:143,rout,route,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057,1,['rout'],['route']
Integrability,"Do you have an example? . If you have a grid with `Nx = 10` and `Ny = 10` and set `h = 1.0` (and `fill_halo_regions!`) then the `h.data` will be 1 from `0:11, 0:11` and 0.0 elsewhere. Is this what you are referring to?. If x and y directions are bounded, points at `-2:-1, -2:-1` (and respective points above Nx and Ny) are never touched because both advection and diffusion are second order near the boundary. (You might want to use branch #2603 to make sure this is the case). So, for (2), I don't think we need it because those halo points should not be touched anyways.; For (1): I do not think there is an easy way to do that that does not involve writing some kernels, but you maybe reutilize the previous flux BC implementation and write something like this. ```; @kernel function _fill_height_west_and_east!(h, H, N); j, k = @index(Global, NTuple). @unroll for i in 1:H; @inbounds h[1-i, j, k] = h[i, j, k]; @inbounds h[N+i, j, k] = h[N+1-i, j, k]; end; end. @kernel function _fill_height_south_and_nort!(h, H, N); i, k = @index(Global, NTuple). @unroll for j in 1:H; @inbounds h[i, 1-j, k] = h[i, j, k]; @inbounds h[i, N+j, k] = h[i, N+1-j, k]; end; end. fill_height_west_and_east!(h, arch, dep, grid) = launch!(arch, grid, :yz, _fill_height_west_and_east!, h, grid.Hx, grid.Nx; dependencies=dep); fill_height_south_and_north!(h, arch, dep, grid) = launch!(arch, grid, :xz, _fill_height_south_and_north!, h, grid.Hy, grid.Ny; dependencies=dep); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814:1288,depend,dependencies,1288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814,2,['depend'],['dependencies']
Integrability,Do you know why the manual `synchronize` is needed?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1722074987:28,synchroniz,synchronize,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1722074987,1,['synchroniz'],['synchronize']
Integrability,"Doctests fail because of all the `loop not unrolled` warnings we get.; We should remedy this before we move to Julia v1.10. @glwagner you bumped onto this previously, right?. ```Julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requeste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:241,depend,dependency,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,1,['depend'],['dependency']
Integrability,"Does it have to do with output? Do you know what the time-step is when this happens? I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102989649:273,integrat,integrated,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102989649,1,['integrat'],['integrated']
Integrability,Doesn't `string(typeof(scheme).name.wrapper)` return something similar for all advection schemes? Or am I misunderstanding what you're saying?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986790987:36,wrap,wrapper,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986790987,1,['wrap'],['wrapper']
Integrability,Don't depend on master grrml...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/538#issuecomment-559295183:6,depend,depend,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/538#issuecomment-559295183,1,['depend'],['depend']
Integrability,"EDIT: This has nothing to do with Oceananigans.jl per se. Better pursued on LambertW.jl. I agree with https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904990127 . This part of the stack trace suggests that it is the `@warn` that is causing the problem. It should be possible to remove that somehow. Better would be to remove the `@warn` entirely and instead return the result along with info on the convergence. And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. I don't know anything about running on GPUs. Does `@warn` cause failure if it is anywhere in the package being compiled? or anywhere in the function being called? Or does execution have to hit the `@warn` so that io is attempted at run time?. EDIT: I missed this above:; >> Do you get a warning during CPU execution ?. > Nope. Everything seems to run pretty smoothly:. So it seems that execution does not have to hit the `@warn` for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. EDIT: so the following comment may be relevant, but perhaps not. It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. ```; Reason: unsupported call to an unknown function (call to jl_f__call_latest); Stacktrace:; [1] #invokelatest#2; @ ./essentials.jl:816; [2] invokelatest; @ ./essentials.jl:813; [3] macro expansion; @ ./logging.jl:381; [4] lambertw_root_finding; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:188; [5] lambertw_branch_zero; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:117; [6] _lambertw; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:93; [7] lambertw (repeats 2 times); @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:73; [8] W; @ /glade/derecho/scratch/tomasc/twake4/headland_simulations/mwe.jl:9; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910836945:452,interface,interface,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910836945,2,['interface'],['interface']
Integrability,"EDIT: there were a number of mistakes in the original post here. I've updated it. As for the _profiles_, there are some interesting differences between the ""Brevik"" and ""Lenain"" formulations. In particular, the Lenain profile depends on the _air_ friction velocity `u★`, while the Brevik does not. This is because Lenain divide the spectrum into saturation and equilibrium ranges, and the transition wavenumber between the two _depends on the friction velocity_ (it scales with `1 / u★^2`. Lenain also introduce an ""isotropic wavenumber"", which is an upper cutoff above which short waves do not contribute to the net Stokes drift. This isotropic wavenumber also scales with `1 / u★^2`. In all cases the Lenain model has strong shear at the surface. The effect is less pronounced on a (relatively coarse) grid with dz = 1 m, but still significant. The shear is also not monotonic in `u★`, possibly because the lower-frequency components start to contribute more at higher wind speeds, reducing the shear relative to the surface value of the Stokes drift. Check out the results:. ![image](https://user-images.githubusercontent.com/15271942/156649792-02639f67-5d0d-47f3-93f7-e1faa7ad92f9.png). Code:. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; Cᵝ = 0.105 # Toba's constant; Cʳ = 9.7e-3 # Transition wavenumber parameter, Lenain and Pizzo 2020 eq 4; Cⁱ = 0.072 # Cutoff / isotropic wavenumber parameter; # exp(π/2 - θ₀) / γ) from Lenain and Pizzo 2020 Appendix A; Cᴮ = 7e-3 # Saturation constant; g = 9.81 # m s⁻², gravitational acceleration; ρʷ = 1024 # kg m⁻³, water density; ρᵃ = 1.225 # kg m⁻³, air density. #####; ##### Stokes drift profile from Brevik et al 2016; #####. T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))); brevik(k, z) = T₁(k, z) - T₂(k, z). #####; ##### Stokes drift profile from Lenain and Pizzo 2020; #####. kⁿ(u★) = Cʳ * g / u★^2 # Transition wavenumber; kⁱ(u★) = Cⁱ * g / u★^2 # Isotropic wavenumber / upper wav",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264:226,depend,depends,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264,1,['depend'],['depends']
Integrability,"Exciting; On Mon, Dec 3, 2018 at 6:03 PM Ali Ramadhan <notifications@github.com> wrote:; >; > @christophernhill Thanks for posting this! @mg547 and I were able to get it working with our Laplacian operator. Going to try and inject it into the pressure solver now, fingers crossed!; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub, or mute the thread.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443920196:224,inject,inject,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443920196,1,['inject'],['inject']
Integrability,"Extrinsic is what we decide. When we use the cubed sphere we want to use geographic coordinates. But vector fields on the c-grid have their own coordinate system dictated by the structure of the grid. Except for `LatitudeLongitudeGrid`, the geographic coordinate system does not coincide with the ""other"" coordinate system (I called it intrinsic above, but if this is confusion we need another name) that's associated with the grid. What language would you like to use to describe (1) the coordinate system that we would like to impose on the grid for the user interface and 2) the coordinate system that the raw vector fields use (I'm trying to avoid the language I proposed to ask this question).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2187115309:561,interface,interface,561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2187115309,1,['interface'],['interface']
Integrability,Fixed in #128 . Yes the time integration was incorrect but only at the first time step and the error was small enough that it didn't matter for getting e.g. deep convection to look qualitatively correct. But it will matter a lot for testing and debugging as you point out.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/127#issuecomment-473386491:29,integrat,integration,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/127#issuecomment-473386491,1,['integrat'],['integration']
Integrability,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168:279,integrat,integrated,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168,1,['integrat'],['integrated']
Integrability,"Flux and gradient conditions are treated differently --- should test which one is causing the problem. Hopefully it doesn't depend on the initial condition, or the magnitude of the flux. You could just try setting both the flux and gradient to 0.0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/816#issuecomment-662725676:124,depend,depend,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/816#issuecomment-662725676,1,['depend'],['depend']
Integrability,"For `IncompressibleModel`, `calculate_tendencies!` unpacks the fields of the model:. https://github.com/CliMA/Oceananigans.jl/blob/fcd1d1b132970cb3003195def1d0132bcde71512/src/Models/IncompressibleModels/calculate_tendencies.jl#L24-L38. and thus depends on things like `surface_waves`, the hydrostatic pressure anomaly, and `buoyancy`, for example, which are not properties of all models. Are you proposing that we unpack these fields in `calculate_interior_tendency_contributions!` instead?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1239#issuecomment-737386273:246,depend,depends,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1239#issuecomment-737386273,1,['depend'],['depends']
Integrability,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:52,integrat,integrated,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715,1,['integrat'],['integrated']
Integrability,"For completeness I think the same grid could be generated with the current interface using. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; zF = k -> cos(π * (2k - 1) / 2Nz)); ```. I suppose the main difference is that the syntax with `z_stretching` makes the bounds of the domain explicit, whereas when using `zF` a code-reader has to compute the domain bounds by plugging `k = 1` and `k = Nz + 1` into the generating function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814466232:75,interface,interface,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814466232,1,['interface'],['interface']
Integrability,"For face indexing convention, 1 is the interface forming left boundary of the domain and N+1 is the interface forming the right boundary. For center indexing, the first cell on the left is 1 and the last cell on the right is N. I'm not 100% sure what you are asking but this is the definition of the indices. I think if you set N+1 for right-sided open boundaries, you should set 1 for left-sided open boundaries. If you set N+2 for the right side, then you would set 0 for the left side. Maybe there is a bug somewhere else?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2386242825:39,interface,interface,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2386242825,2,['interface'],['interface']
Integrability,"For now we might assume halos are symmetric. Then we can put something like. ```julia; halo = minimum_halo_size # 1; halo = max(halo, required_halo_size(advection)); halo = max(halo, required_halo_size(closure)); grid = with_halo(grid, halo); ```. in the constructor for `IncompressibleModel`. This assumes that other parts of the equation --- `buoyancy`, `coriolis`, `surface_waves`, `forcing` --- do not require halos larger than 1. This is currently true. Note that we also have to change the keyword arguments that depend on `grid`:. https://github.com/CliMA/Oceananigans.jl/blob/e808a821d78949b0482b8372533e992cabb5d65f/src/Models/incompressible_model.jl#L71-L91. We can convert `boundary_conditions` to an empty `NamedTuple` with no penalty. However, for `velocities`, `pressures`, `diffusivities`, and `pressure_solver`, we will have to use `nothing` defaults and conditionally construct them on `grid` if they aren't provided. We may also want to check that, if they are provided, that the grid they are associated with matches the grid being build (this is not currently done).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/941#issuecomment-699574591:519,depend,depend,519,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/941#issuecomment-699574591,1,['depend'],['depend']
Integrability,"For small scale testing we could use JuliaGPUs buildkite. On Wed, Sep 4, 2024 at 12:32 PM Simone Silvestri ***@***.***>; wrote:. > Right, I think the problem is the availability of AMD GPUs to run tests.; > If we find one, I can revamp this.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328512985>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XVCEUJNTZHWDD36KDZU3OVLAVCNFSM6AAAAABDHAZB6GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGMRYGUYTEOJYGU>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328706255:620,Message,Message,620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328706255,1,['Message'],['Message']
Integrability,"For sure, that is always an option. After a lot of searching it seemed that the problem was indeed the synchronization of the boundary conditions that still was not fixed. . this PR should be ready to merge, I ll do the last check of the comments I maybe missed and then merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964247231:103,synchroniz,synchronization,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964247231,1,['synchroniz'],['synchronization']
Integrability,"For the GPU case, again for 128x128 (still rather coarse and results will depend on resolution I suspect). ```; scheme ratio; ====== ===; C2 1.2; U3 1.5; C4 2.4; U5 1.5; W5 7.0. ```. In general the scalings tend to be better on GPUs vs CPUs (on this coarse grid). It does seem that `WENO5` does much worst, relatively speaking. . Benchmarks that I did with @ali-ramadhan found that on GPUs vs CPUs, shallow water model could be faster by a factor of `170`, which was for `U5`. With `WENO5` it was double that. I guess the moral of the story is that `WENO5` is very different and sometimes much better and sometimes much worst. I should say that the difference from the first run to the second sometimes differed by a factor of `10`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816776677:74,depend,depend,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816776677,1,['depend'],['depend']
Integrability,"From the standpoint of `NonhydrostaticModel`, the only requirement (I think?) is a pressure solver that's valid on more grids. The `FourierTridiagonalPoissonSolver` combines FFTs with a tridiagonal solve in one direction to solve the Poisson equation. Thus, this method can be used if the grid is stretched in just one (1) direction. Right now, we only support grids that are stretched in `z`, the third direction / index. Presumably it's at most a matter of copy and paste and index permutation to support grids that are stretched in `x` (and regular in `y, z`) or stretched in `y` (and regular in `x, z`). Under the hood, the `FourierTridiagonalPoissonSolver` relies on the `BatchedTridiagonalSolver` to perform the tridiagonal solve:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L81-L82. The `BatchedTridiagonalSolver` launches a kernel over `xy` and performs a tridiagonal solve in `z`:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L79-L80. So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`. . This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward... Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation. I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620:1679,wrap,wrapper,1679,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620,1,['wrap'],['wrapper']
Integrability,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:10,message,messages,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979,3,"['message', 'synchroniz']","['messages', 'synchronized']"
Integrability,Good catch. This should be made very clear as it has confused us in the past... I'll make sure to address this issue on the (increasingly stale =/) `ar/integrate-vs-grid` branch...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597581523:152,integrat,integrate-vs-grid,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597581523,1,['integrat'],['integrate-vs-grid']
Integrability,"Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. > Remove `OceananigansLogger`: rarely used. I use it in almost every script I write haha, but that's because I wrote it to my liking. There's a strong argument to be made that a logger configuration does not belong in Oceananigans.jl. I feel it's similar to Oceananigans' decision to not provide a default progress callback seeing as each user will probably want a different one. > Remove `StateChecker`: not used as far as I know. Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627:105,interface,interface,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627,1,['interface'],['interface']
Integrability,"Good news: shallow water tests pass!. Bad news: the halo tests now has 12 fails, of 600 in total. . ```; <div class=""JobLogOutputComponent"" style=""box-sizing: border-box; background: rgb(23, 23, 23); border-radius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1195,Inject,Injection,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['Inject'],['Injection']
Integrability,Good! I wonder if we can add a test here too to wrap this up.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711:48,wrap,wrap,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711,1,['wrap'],['wrap']
Integrability,"Great job! Though I have not looked at the code, I have two comments:. 1. I am surprised that the choice of `regularization` affects the convergence rate. I will think about it more.; 2. The rate of convergence depends on the distribution of eigenvalues of the preconditioned linear operator. I have a piece code of that outputs the preconditioned linear operator as a dense `Matrix`, which can be useful for testing the convergence rate and new algorithms without invoking `Oceananigans`. It can be helpful for testing why `FlatExtrapolationOpenBoundaryCondition` results in a much slower convergence. Besides, I have found that grids with better symmetry have faster convergence because the resulting Laplacian operators have more repeated eigenvalues. In theory, the number of iterations required for the CG method to get the exact solution is the number of unique eigenvalues. ```Julia; using LinearAlgebra; using Oceananigans; using Oceananigans.Models.NonhydrostaticModels: ImmersedPoissonSolver; using Oceananigans.ImmersedBoundaries: active_cells_map, immersed_cell, mask_immersed_field!; using Oceananigans.Solvers: solve!; using Statistics: norm, mean. using Oceananigans.Solvers: precondition!. ENV[""JULIA_DEBUG""] = ""Solvers"". # ---------------------------------------------------------------------- #; # Define Parameters. # Numerical Technic; const arch = CPU(). # Grid; const Nx = 10; const Ny = 10; const Nz = 10; const Lx = 1.0; const Ly = 1.0; const Lz = 1.0. const Δz = Lz / 2 # elevation difference at the top. # ---------------------------------------------------------------------- #; # Define Utils. # Height at Top; @inline function z_top(y::R) where {R<:Real}; # return Lz - Δz * sin(π/2 * y/Ly) - Δz * 0.2; return Lz - Δz; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (-Lx / 2, Lx / 2),; y = (0.0, Ly),; z = (0.0, Lz),; t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420373611:211,depend,depends,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420373611,1,['depend'],['depends']
Integrability,"Greg, Distinction between edgefield, cellfield etc, was a source of; confusion for Ali as oceananigans was built. Concerned about abstracting to; such a level that we can't easily see what's going on. We should all meet; in person to talk about how we reinstate finite volumes and support more; general grids. We can talk about nomenclature at the same time. When we get; back from Caltech? John. On Sat, May 11, 2019, 8:24 AM Gregory L. Wagner <notifications@github.com>; wrote:. > *@glwagner* commented on this pull request.; > ------------------------------; >; > In src/fields.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/218#discussion_r283094481>; > :; >; > > @@ -108,15 +65,26 @@ struct EdgeField{A<:AbstractArray, G<:Grid} <: Field; > grid::G; > end; >; > -function EdgeField(::CPU, g::RegularCartesianGrid{T, <:AbstractRange}) where T <: AbstractFloat; > - data = zeros(T, size(g)); > - EdgeField{typeof(data), typeof(g)}(data, g); > +EdgeField(T, arch, grid) = EdgeField(zeros(T, arch, grid), grid); > +EdgeField(arch, grid) = EdgeField(zeros(arch, grid), grid); > +; > +abstract type Location end; > +struct Cell <: Location end; > +struct Interface <: Location end; > +; > +""""""; >; > Note that once this is done we should also be able to eliminate CellField; > and FaceFieldX, etc, replacing them with GeneralField (and possibly; > renaming to just ""Field"").; >; > This should be easy via the definition of; >; > const CellField = GeneralField{C, C, C},; >; > with no other code changes, I think. Which is nice.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/218#discussion_r283094481>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXDUPWAX7GQ2SM36CDPU23I5ANCNFSM4HL7AH5A>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491513364:1169,Interface,Interface,1169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491513364,1,['Interface'],['Interface']
Integrability,"Greg, can we get your 1-d model integrated in to oceananigans? Doesn't; make sense to me to develop a 1-d model separately. So much ought to be and; could be common. Thoughts? John. On Thu, Apr 25, 2019, 11:09 AM Gregory L. Wagner <notifications@github.com>; wrote:. > My code literally works out of the box. I'll copy and paste and make a PR.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/174#issuecomment-486714424>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSTKSK54435JPSZCRLPSHCR5ANCNFSM4HE7436Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-486719329:32,integrat,integrated,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-486719329,1,['integrat'],['integrated']
Integrability,"Greg, is this something to be be done now? Let's get what we have now; completed and out to the community, get feedback etc. Development will; continue but we need to engage users. John. On Fri, Oct 25, 2019, 1:25 AM Gregory L. Wagner <notifications@github.com>; wrote:. > We need better and more stable time-steppers. One option is to implement; > by hand a 3rd-order low storage Runge Kutta scheme.; >; > Another interesting avenue is to figure out how to integrate with; > DifferentialEquations.jl, which would give us access to a large number of; > new time-steppers.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/506?email_source=notifications&email_token=AKXUEQROLPK63OJDILUPELLQQI4IFA5CNFSM4JE5AV32YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HUIGFOQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRRJKIBWQ77UVXKGZDQQI4IFANCNFSM4JE5AV3Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327:458,integrat,integrate,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327,1,['integrat'],['integrate']
Integrability,"Grr, didn't realize it depended on the double gyre... let me open a clean PR...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1122#issuecomment-719740718:23,depend,depended,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1122#issuecomment-719740718,1,['depend'],['depended']
Integrability,"Ha, @rabernat beat me to it. I just wanted to mention that I am also available for questions and maybe clarify one more point of confusion that seems to stem from our current docs (working on improving that with @tomchor s input). . There are two parts in the NetCDF output that would make the integration with xgcm smooth: ; - Proper metadata for the dimensions (as mentioned by @rabernat above); - Output of grid metrics, which are distances, areas and cell volume of the grid. An important detail there is that each of the metrics should describe properties of the *surrounding cell*. So if you have a tracer value on the point `xT` and the cell bounds are given by a staggered coordinate `xC`, the distance (lets call it `dx`) for each `xT` point should describe the distance between the two surrounding `xC` points (and have `xC` as coordinate, so it can be matched correctly by xgcm). Currently the user has to input these manually but it might be convenient to add the [cf-attribute `cell_measures`](http://cfconventions.org/cf-conventions/cf-conventions.html#cell-measures), which we might support in the future with a more complete support for cf-metadata (see e.g. https://github.com/xgcm/xgcm/issues/127)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849:294,integrat,integration,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849,1,['integrat'],['integration']
Integrability,"Happy to try these. The first one failed in the same way as before. The second one failed because the syntax does not seem right with clock. I instead tried this. ```; model = IncompressibleModel(architecture=GPU(), advection=WENO5(), clock=Clock{Float64}(0,0,1), grid=grid); ```; and that also had an error, with what seems to be the same message. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870707388:340,message,message,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870707388,1,['message'],['message']
Integrability,"Heh, I agree that says nothing!. Do you have any thoughts about a preferred user interface, among the options I give above (or perhaps you have ideas for another design)? That's the first design question to answer before writing any code. Once we settle on an interface I think the code-writing will be fairly straightforward in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389662247:81,interface,interface,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389662247,2,['interface'],['interface']
Integrability,"Hello @sam12396 , I am glad you have been able to run Oceananigans on GPUs. That could speed things up a great deal, depending on what you are trying to do. Oceananigans has been written in such a way that the user does not need to do anything different in terms of setting up a problem on CPUs vs GPUs. To illustrate my point, consider the shallow water Bickley jet example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/). The default is set up to run on CPUs but if you want to run it on GPUs, then it's easy. Where you define the model you need to add one line,. ```; model = ShallowWaterModel(; architecture=GPU(),; timestepper=:RungeKutta3,; advection=WENO5(),; grid=grid,; gravitational_acceleration=g,; coriolis=FPlane(f=f),; ); ``` ; When you make that one change (setting the architecture in the second line above), then the code will use GPUs. The producing of the data and reading and writing is then all done with GPUs. There is nothing else for you to do. In particular, if you define your forcing and initial conditions using functions, as the examples tend to do, then nothing needs to change. If you want to use Oceananigans.jl, are you sure you need to program things differently?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808453777:117,depend,depending,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808453777,1,['depend'],['depending']
Integrability,"Here's a clue: this fixes the issue. ```julia; Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). progress_cb = simulation.callbacks[:progress]; @show actuations = progress_cb.schedule.actuations. # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); progress_cb = simulation.callbacks[:progress]; progress_cb.schedule.actuations = actuations; run!(simulation, pickup=checkpoint); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650:173,message,message,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650,1,['message'],['message']
Integrability,"Here's a couple more thoughts:. * `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. * A very important usage of `Average`, however, is using it to reduce ""lazily evaluated data"". This is the case of taking an average of a ""`Computation`"". To take the average of a `Computation`, we have to trigger the generation of the data to be averaged. To support this functionality we have permitted `Average.field` to be defined as a `Computation`, and dispatched on this special case to ensure that the data is generated before the average is invoked. * One way to normalize these user-interfaces is to generalize the concept of an `AbstractField` to be ""lazy"" in general. There is one special case that does *not* require computation --- the ordinary case of a `Field`. But we can create an infrastructure where all `AbstractField`s are expected to have a function like `compute!` (or perhaps `evaluate!`). In that framework, we would always call `evaluate!` on `Average.field` before averaging it. Because `evaluate!(::Field) = nothing`, we preserve the basic functionality of `Average` when it acts on a basic `Field` and its data does not need to be generated. * Note that currently `Computation` data is stored in bare `Array`s. However, it should probably be stored as `Field`, and interacting with a `Computation` should feel the same as interacting with a field (with functions like `data`, `interior`, `getindex`, etc). We may also want to change the name of `Computation` to something that reflects its behavior a little more clearly. Perhaps `ComputedField`, or something. * `Average` itself should *also* subtype `AbstractField` within this framework. An `Average` is just a special type of computation that requires eva",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391:855,interface,interfaces,855,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391,1,['interface'],['interfaces']
Integrability,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:41,depend,dependence,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701,4,['depend'],"['dependence', 'dependent']"
Integrability,"Here's a few thoughts:. - Is there a unit issue? It looks like drag is imposed in the numerical solution (the velocity goes to 0). But the drag seems weaker in the analytical solution for some reason.; - It looks like you are using a time-step criterion based on free surface gravity waves, but I think its likely you are using the split-explicit free surface which has no such restriction. So you can take longer time-steps (not that this would change the present discussion).; - it probably makes sense to test how the numerical solution depends on spatial resolution; - if you also have the plotting code with the analytical solution, it would be nice to have a single script that runs the simulation and produces the comparison. That way we can check to make sure that the plotting script doesn't also have bugs (and also have an easy way to run this ourselves)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2137697636:540,depend,depends,540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2137697636,1,['depend'],['depends']
Integrability,"Here's a new 1D validation case that tests a ""buoyant particle"" model using a dynamic slip velocity that depends on buoyancy. The particle concentration field migrates to it's neural buoyancy (here in the center of the domain), until the particle concentration reaches a steady-state in a competition between diffusion and buoyant slippage. https://user-images.githubusercontent.com/15271942/161167309-bfedffdb-6f2b-4552-8f49-1ec23ce7b4ed.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172:105,depend,depends,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172,1,['depend'],['depends']
Integrability,"Here's a screenshot of the top row from the final time-step:. ![image](https://user-images.githubusercontent.com/15271942/160630444-6b07529f-cf8b-4d03-8421-a6027153298e.png). showing significantly more small scale features on the left. The difference (the key to this PR) is using the velocity field in the smoothness metric for vorticity reconstruction, rather than the vorticity field. The ordinary WENO algorithm uses the smoothness of the field being reconstructed to produce weights for the candidate stencils. This method is therefore an innovation, since we are using the _velocity_ field to evaluate smoothness for reconstructing _vorticity_. The velocity field is smoother than vorticity, so this generally leads to less-dissipative stencils (but still ""enough"" dissipation to stabilize the simulation). @simone-silvestri definitely has more plots showing differences in spectra and time-series of integrated enstrophy, perhaps he will share!. I'm also going to paste an example of using this scheme in the code once I figure that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042:907,integrat,integrated,907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042,1,['integrat'],['integrated']
Integrability,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:725,interface,interface,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,1,['interface'],['interface']
Integrability,"Here's the main differences:. 1. `FunctionOperation` is not backed by data; eg it doesn't allocate memory (its just a wrapper for a function); 2. `KernelComputedField` requires a `KernelAbstractions` `@kernel`. `FunctionOperation` requires a function of `i, j, k, grid, fields..., parameters)`. It's a subtle but real distinction. Sometimes defining `@kernel` may be more convenient / more readable.; 3. The `kernel` in `KernelComputedField` cannot be reduced on the fly (unless this is supported by `KernelAbstractions` someday, somehow, eg https://github.com/JuliaGPU/KernelAbstractions.jl/issues/234, but we don't know what this would look like yet). Taking the vertical vorticity for curvilinear / cubed sphere grids as an example, usage is. ```julia; using Oceananigans.Operators: ζ₃ᶠᶠᵃ # called with signature ζ₃ᶠᶠᵃ(i, j, k, grid, u, v). grid = model.grid; u, v, w = model.velocities. ζ_op = FunctionOperation(Face, Face, Center, ζ₃ᶠᶠᵃ, grid, computed_dependencies=(u, v)). ζ = ComputedField(ζ_op) # identical to `VerticalVorticityField`. barotropic_ζ = AveragedField(ζ_op, dims=3); ```. On the CubedSphere, `ζ₃ᶠᶠᵃ` cannot be expressed in terms of `AbstractOperations` due to the need to treat corners in a special manner.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827858910:118,wrap,wrapper,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827858910,1,['wrap'],['wrapper']
Integrability,"Hey @arcavaliere that would be awesome if you have the time! It's not a glamorous issue but super important for developing good software. How familiar are you with Julia?. I think the first step is to figure out how to use the logging macros, e.g. `@info` and `@debug`, to print the current time (and possibly even filename and line number) to provide more useful logging messages. So instead of; ```julia; julia> @info ""Test line""; [ Info: Test line; ```; which isn't super useful hopefully we can have logging messages like; ```julia; [09/10/2019 16:12:33] some_file.jl:55: Test line; ```; which would be more useful. If that's possible, I think we can start logging a lot more stuff knowing that the messages will have useful timestamps and line numbers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540173008:372,message,messages,372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540173008,3,['message'],['messages']
Integrability,"Hey @miguelraz I'm back online now and should be free to talk if you're still interested in running some of those simulations!. We worked on a Rayleigh-Benard example a little while ago but it probably needs updating a little bit. I'll message you on Slack as well, might be easier than talking through this issue. Didn't know about Weave producing Markdown with MathJax, looks great!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/157#issuecomment-494785875:236,message,message,236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157#issuecomment-494785875,1,['message'],['message']
Integrability,"Hey everyone, as an example I can point you to [Juls.jl](https://github.com/milankl/Juls.jl) which can be executed with type `T` as the first argument; ```julia; julia> using Juls; julia> RunJuls(Float64);; Starting Juls on Thu, 05 Dec 2019 15:03:14 without output.; 100% Integration done in 1.19s. julia> RunJuls(Float32);; Starting Juls on Thu, 05 Dec 2019 15:03:19 without output.; 100% Integration done in 0.72s. julia> RunJuls(Float16);; Starting Juls on Thu, 05 Dec 2019 15:03:28 without output.; 100% Integration done in 1min, 8s.; ```; without relying on type promotion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/552#issuecomment-562170113:272,Integrat,Integration,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/552#issuecomment-562170113,3,['Integrat'],['Integration']
Integrability,"Hi @EavenW hope it wasn't too hard to get started (the documentation needs some more work, sorry about that). Not totally sure what you mean by a flux boundary condition with two components (sounds like the u and v velocity fields might be further coupled via this boundary condition?). Sounds like you're trying to impose a (time-dependent?) surface flux boundary condition which can be done a few different ways.; * If it's independent of time then [imposing a flux BC with a 2D array](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Creating-individual-boundary-conditions-1) is one option.; * If it's time-dependent then [imposing the flux BC as a function](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Specifying-boundary-conditions-with-functions-1) is probably the way to go. The function signature for boundary conditions is `f(i, j, grid, t, U, C, params)` so the boundary condition can depend on time `t`, the velocity fields `U = (u, v, w)` and any tracer quantity in `C`.; * If you can write your surface flux BC as a function of only (x, y, t) then a [`BoundaryFunction`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/boundary_function.jl) can simplify the setup a little. I just realized this isn't showing up in the documentation but the docstring in the file I linked to has an example of how to use it. PS: Not sure which version you're running but we've been making some improvements to the user interface lately which may break certain things if you upgrade to v0.21 or v0.22. Please don't hesitate to ping us if you have any questions or if something isn't working. We're more than happy to help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085:331,depend,dependent,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085,4,"['depend', 'interface']","['depend', 'dependent', 'interface']"
Integrability,"Hi @EavenW, yes, you have to specify the x- and y- components of a momentum flux vector separately on u and v. Because each flux component is a function of time, you should use our BoundaryFunction wrapper for each component cf @ali-ramadhan comment above. Thanks for the question — keep them coming!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586764367:198,wrap,wrapper,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586764367,1,['wrap'],['wrapper']
Integrability,"Hi @c42f thank you for chiming in! Will definitely ping you as we work on logging. I think we probably should have tackled logging much earlier. We still use `@printf` and vanilla `@info` for logging, which has been quite counter-productive haha. Definitely hoping we can reach a useful logger that can; * help developers by providing info and debug messages. Also nice in test logs.; * help users understand what the model is doing and provide a better and more responsive user experience by logging what the model is doing. This is where `@setup` and `@diagnostic` logging messages might be really nice. Although `@setup` and `@diagnostic` might be bad names as they don't imply logging? Not sure of the best solution but maybe your kwarg suggestion would help here, e.g. `@info source=""diagnostic"" msg`?. @arcavaliere seems to be developing a pretty general-purpose `ModelLogger` which hopefully we can adapt for all these uses! @arcavaliere I'm more than happy to help if you need anything. MicroLogging.jl looks pretty neat! I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. TensorBoardLogger looks pretty cool! Would be awesome to have something like that one day, but I guess you'd have to use something like ncusrses...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876:350,message,messages,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876,3,['message'],['messages']
Integrability,"Hi @glwagner . Just ran into this and wanted to mention [NCTiles.jl](https://github.com/gaelforget/NCTiles.jl) which we, https://github.com/lmilechin and myself, recently released. . Not sure if `NCTiles.jl` is readily applicable to your package output but maybe it would be interesting to discuss some sort of integration. What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-536198191:311,integrat,integration,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-536198191,1,['integrat'],['integration']
Integrability,"Hi @jhdong2016, thanks for your interest in Oceananigans! . Personally I find it very difficult to help out without something that I can run and reproduce your results. Could you post your script somewhere also for making the plots. Something I can copy/paste in the REPL or just write `include(""jhdong_script.jl"")`?. It's often useful to post the version of Oceananigans you are using (and the rest of dependencies). E.g., post the output of `using Pkg; Pkg.status()`. Do I understand correctly or is it my impression that you have depth in the horizontal axis?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3560#issuecomment-2076765944:403,depend,dependencies,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3560#issuecomment-2076765944,1,['depend'],['dependencies']
Integrability,"Hi Both. Are we talking with. https://github.com/JuliaGeo. I am tempted to think we should explore Zarr interfaces (; https://zarr.readthedocs.io/en/stable/index.html ) as well as netCDF. yeesian@mit.edu who is part of https://github.com/JuliaGeo is at MIT. Chris. On Fri, Mar 22, 2019 at 9:41 AM Ali Ramadhan <notifications@github.com> wrote:; >; > Yup. It would be nice to have some good built in writers, e.g. a solid netcdf writer, but otherwise they can always write a custom writer.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub, or mute the thread.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475627506:104,interface,interfaces,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475627506,1,['interface'],['interfaces']
Integrability,"Hi Tomas,. Google gives you a $300 credit when you first sign up for Google Compute but it can't be used for GPUs anymore. See [https://cloud.google.com/free/docs/gcp-free-tier](https://cloud.google.com/free/docs/gcp-free-tier). Other options are requesting allocations on Bridges (it has V100s) or Comet (it has P100s) through XSEDE ([https://www.xsede.org/ecosystem/resources](https://www.xsede.org/ecosystem/resources)) but that might be an overkill if you just want to play around with a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/451#issuecomment-539993604:273,Bridg,Bridges,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451#issuecomment-539993604,1,['Bridg'],['Bridges']
Integrability,"Hi all,. Greg, do you know if Cat Vreugdenhi is visiting GFD this summer? It may be easy to ask her to run an example without stretched grid. That said, do we have a good sense of how important a stretched grid is for the accuracy of our LES simulations?. Raffaele. > On Jul 10, 2019, at 9:32 AM, Ali Ramadhan <notifications@github.com> wrote:; > ; > We agreed this could be a test case against which we can verify the implementation of AMD in PR #309, although the published results use a slightly modified version of AMD.; > ; > They report a number of LES runs, and since we don't have a vertically stretched grid, it might be easiest to try and reproduce the Pr = 0.7 case which they do with (Nx, Ny, Nz) = (64, 49, 64) grid points [for Ri=0 or 0.01, for Ri = 0.04 it's (64, 65, 64)]. I might suggest focusing on the Ri = 0 case as they also run a resolved DNS with (Nx, Ny, Nz) = (256, 129, 256) against which we might be able to compare (might not be possible, depending on vertical grid stretching).; > ; > Unfortunately, I don't think we can reproduce their results without a vertically stretched grid... If I understand the paper correctly, the grid is stretched according to; > ; > y_j = h*tanh(Sf*(2*(j-1)/(Ny-1))) / tanh(Sf); > so for h=1 you get grid spacings of Δy ~ 0.125 away from the wall and Δy ~ 0.0000035 adjacent to the wall. So a faithful reproduction would need 35000+ vertical levels lol.; > ; > I don't fully understand how they got their values for the vertical grid cell size adjacent to the wall ∆y_w^+, but it seems like if h = 100,000 then our values agree (they get a spacing of Δy ~ 0.35 adjacent to the wall). Either way, the ratio between the thickest and thinnest spacings is ~35,000.; > ; > Not sure if there's still a way we could compare results in this case without a vertically stretched grid...; > ; > Absolute worst case scenario, I've been working on an implementation of a vertically stretched grid (see PRs #283 and #306) but it's a work in progress and mi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-510066077:967,depend,depending,967,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-510066077,1,['depend'],['depending']
Integrability,"Hi folks. I just saw this issue. We are very glad that you're working to support interoperability btw oceananigans and xgcm! 🎉 We'd love to help however we can. Ideally you would not have to really do much here other than use CF conventions in your netCDF output and things would ""just work."" That's the beauty of standards. Unfortunately, CF conventions don't quite provide the right vocabulary to describe the curvilinear geometry of staggered grid models compactly (see https://github.com/cf-convention/discuss/issues/5). In the meantime, every modeling center seems to have their own preference for how to encode this (e.g. [comodo conventions](https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html) [now offline] used by ROMS and NEMO, [S-grid](https://github.com/sgrid/sgrid), [mosaics](https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf) from GFDL). . With xgcm, we decided to use the Comodo conventions (rather than invent yet another new convention). In retrospect, this was maybe the wrong choice, since the pycomodo project seems to have totally disappeared. 🤦 However, if you put the [right metadata](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes) in your attributes, xgcm should be able to figure out your grid. Whatever you do, please try your best to squeeze your data into existing standard file formats and metadata conventions. ; Don't invent something new. MITgcm did this with the mds data format and it has been endless headaches for our community. I don't know what JLD2 is, but it sounds like you could be going down that route... If you have any questions, please ask! I'll try to respond.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134:81,interoperab,interoperability,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134,2,"['interoperab', 'rout']","['interoperability', 'route']"
Integrability,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:156,interface,interface,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088,2,"['interface', 'wrap']","['interface', 'wrappers']"
Integrability,"Hi; I think I found another bug related to that. . The following code works fine. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), ∂x(b) / f); vz .= vz_op; ```. but it returns error if I put a plus sign. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), + ∂x(b) / f); vz .= vz_op; ```. no problem with the minus sign. Error message:. ```julia; TaskFailedException. nested task error: MethodError: no method matching getindex(::Tuple{DataType, DataType, DataType}, ::Int64, ::Int64, ::Int64); Closest candidates are:; getindex(::Tuple, ::Int64) at tuple.jl:29; getindex(::Tuple, ::Real) at tuple.jl:30; getindex(::Tuple, ::Colon) at tuple.jl:33; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812:613,message,message,613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812,1,['message'],['message']
Integrability,"Hm... I see both your points. The boundary layer is indeed pronounced in the buoyancy or buoyancy dissipation. But indeed for Ra=1e8 the boundary layer is most probably well-resolved. The boundary layer thickness, however, scales with Ra^{-1/5} or Ra^{-1/4} (depending on the flow regime)... Thus, for the Ra value in the example you are right: no modification is needed. But if one wants to take this up to higher Ra values then higher vertical resolution near the top will help. Perhaps we close this issue (as, I agree, is not really an _issue_ of the code). Or convert to discussion?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882858629:259,depend,depending,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882858629,1,['depend'],['depending']
Integrability,"Hm.... what version of Oceananigans did you try the quick_start example with? I'd bet you used a very old version, e.g., a version _before_ the breaking release [v0.90.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.90.0)?. The quick start example works on `main` for me:. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 12 seconds. 160 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [-7.51279e-18, 6.28319) regularly spaced with Δx=0.0490874; ├── Periodic y ∈ [-7.51279e-18, 6.28319) regularly spaced with Δy=0.0490874; └── Flat z. julia> model = NonhydrostaticModel(; grid, advection=WENO()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── advection scheme: WENO reconstruction order 5; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> ϵ(x, y) = 2rand() - 1; ϵ (generic function with 1 method). julia> set!(model, u=ϵ, v=ϵ). julia> simulation = Simulation(model; Δt=0.01, stop_iteration=100); Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── Next time step: 10 ms; ├── Elapsed wall time: 0 seconds; ├── Wall time per iteration: NaN days; ├── Stop time: Inf days; ├── Stop iteration : 100.0; ├── Wall time limit: Inf; ├── Callbacks: OrderedDict with 4 entries:; │ ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1); │ ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1); │ ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1); │ └─",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3551#issuecomment-2051288613:351,depend,dependency,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3551#issuecomment-2051288613,1,['depend'],['dependency']
Integrability,"Hmm yes we might need extensions to provide that functionality. Another possibility is to use plot recipes: https://docs.makie.org/stable/documentation/recipes/. That page says. > If you're a package developer, it's possible to add recipes without adding all of Makie.jl as a dependency. Instead, you can use the MakieCore package, which is a lightweight package which provides all the necessary elements to create a recipe, such as the @recipe macro, convert_arguments and convert_attribute functions, and even some basic plot type definitions. I'm not sure the stuff on `Imaginocean.jl` can be implemented with plot recipes, but if it can then perhaps that is a better approach?. Otherwise I agree that we should investigate extensions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-1629233865:276,depend,dependency,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-1629233865,1,['depend'],['dependency']
Integrability,"Hmm yes. We can implement a custom constructor. Or we can capture the additional info needed for the ""constructor"" `S` in a closure. We can also add constructors to `Krylov` with a more generic interface based on `similar` or `deepcopy` with a ""template array"". We do this for our solvers to achieve some generality even within the concept of `Field` (Field requires not only the size, but also ""locations"" on the staggered grid). https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Solvers/conjugate_gradient_solver.jl#L87-L89. I think using a closure is simpler though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436:194,interface,interface,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436,1,['interface'],['interface']
Integrability,"Hmm, the NetCDF tests are now throwing a different error. I see the problem: the size of a field depends on the topology. I'll fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591030049:97,depend,depends,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591030049,1,['depend'],['depends']
Integrability,"Hmm, well `ρg` is literally the force density exerted by the weight of the fluid. On Wikipedia, 'buoyancy' is the force induced when you displace fluid; therefore the buoyancy of a solid object is equal to . gravitational acceleration x (volume of object x density of displaced fluid - mass of the object). which gives the forcing acting on the body (positive upwards due to the sign of the terms). Here we deal in densities, so the buoyant forced defined in the same manner would essentially be . gravitational acceleration x ( reference density - density of the buoyant fluid ) . which of course is precisely `-ρ' g`, since `ρ' = ρ - ρ0`. I think that from its usage the meaning of `buoyancy_perturbation` is clear. . Something to keep in mind as we continue to discuss this topic outside this PR is that atmospheric scientists go even a step further and define 'buoyancy' as `-(ρ' - <ρ'>) g / -ρ0`, where `<>` is a horizontal average --- thus omitting the z-dependent, horizontally uniform part of the 'total' buoyancy that does not contribute to dynamics (because it is balanced by a static component of pressure). Thus using `buoyancy_perturbation` to denote a quantity which, for them, comprises even non-dynamic, irrelevant components of `-ρ' g / -ρ0` could seem a bit odd.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533129079:961,depend,dependent,961,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533129079,1,['depend'],['dependent']
Integrability,"Hmm, well it looks like we do compute arguments:. https://github.com/CliMA/Oceananigans.jl/blob/abd447980898bcbfe099d71258d4e52f3cf090f9/src/AbstractOperations/kernel_function_operation.jl#L75. But if the arguments are themselves wrapped inside a `NamedTuple` --- or any other object --- then they won't be computed. In other words `compute!(perturbation_velocities)` does not compute the elements of `perturbation_velocities`. We could add a method `compute!(tup::Tuple) = Tuple(compute!(t) for t in tup)` and also for `NamedTuple`. But I'm not sure this is the best API. Maybe it's better to require that arguments that need to be computed should be included directly as arguments. Seems like its up for debate. PS it does seem to test this correctly then we need to further evaluate . ```julia; f_perturbation = Field(f_perturbation_op); compute!(f_perturbation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1927373508:230,wrap,wrapped,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1927373508,1,['wrap'],['wrapped']
Integrability,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:636,integrat,integrate,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974,2,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,"Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose. I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415:62,depend,depend,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415,1,['depend'],['depend']
Integrability,Hmm... there's a function in `CUDA.jl` called `partial_mapreduce_grid` that might contain logic that depends on the size of the kernel (not sure): https://github.com/JuliaGPU/CUDA.jl/blob/92f1001861641cb173af49454b05c91728cbfc3d/src/mapreduce.jl#L91,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845597699:101,depend,depends,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845597699,1,['depend'],['depends']
Integrability,Hmm... we could definitely introduce a wrapper for discrete form boundary condition functions. Then we can store boundary condition dependencies in either `ContinuousBoundaryFunction` or `DiscreteBoundaryFunction`. This does seem like a good solution.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-698430081:39,wrap,wrapper,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-698430081,2,"['depend', 'wrap']","['dependencies', 'wrapper']"
Integrability,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:737,message,message,737,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537,1,['message'],['message']
Integrability,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:139,depend,depends,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['depend'],['depends']
Integrability,"Hmmm looks like it was `TEST_GROUP=integration` that went from taking ~20 minutes to ~32 minutes, enough to cause timeouts. We can live with this for now I suppose, can look into it in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/860#issuecomment-681986752:35,integrat,integration,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/860#issuecomment-681986752,1,['integrat'],['integration']
Integrability,"Hmmm might be related to how the default boundary conditions are injected since specifying the proper default BCs for top/bottom and explicit BCs for east/west seems to work:. ```julia; using Oceananigans; using Oceananigans.BoundaryConditions: NoFluxBoundaryCondition, ImpenetrableBoundaryCondition. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0),; bottom = NoFluxBoundaryCondition(),; top = NoFluxBoundaryCondition(); ). model = NonhydrostaticModel(; grid = grid,; boundary_conditions = (v=v_bcs,); ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768:65,inject,injected,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768,1,['inject'],['injected']
Integrability,"Hmmm, I don't know if many log levels will be that helpful. I guess for debug messages we'll want to have the file name and line number, but for user-facing info messages maybe we should remove the file name and line number and instead a custom log level like `DIAGNOSTIC` or `MODEL_SETUP` will be useful. I think one place that logging can hugely improve user experience is in setting up large models, especially on the GPU, where you could be waiting for several minutes while all of Julia, CUDA, and Oceananigans compiles, model is being set up, memory is allocated, etc. We know it takes time but most users will think that something is wrong if Julia is silent for 5 minutes. In this context info messages can be useful and reassure the user that Oceananigans is working properly. It's well known that progress indicators improve user experience, e.g.: https://www.nngroup.com/articles/progress-indicators/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192:78,message,messages,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192,3,['message'],['messages']
Integrability,"Hmmm, I guess the immediate issue is that `LatitudeLongitudeGrid` doesn't have a 1-location `xnodes` functions:. https://github.com/CliMA/Oceananigans.jl/blob/2e4ba6b36bf012d5dcb89ddc7160a10f774aadbe/src/Grids/latitude_longitude_grid.jl#L635-L656. But it shouldn't as x will depend on longitude and latitude. Probably most users will want output in longitude and latitude though. The bigger issue is that the `NetCDFOutputWriter` is not aware of the `LatitudeLongitudeGrid`. As this is covered by issue #2248 I'll close this issue as a duplicate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3775#issuecomment-2340897939:275,depend,depend,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775#issuecomment-2340897939,1,['depend'],['depend']
Integrability,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:190,message,message,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367,3,['message'],"['message', 'messages']"
Integrability,"Hmmm, on some level I feel like differentiating, interpolating, and integrating forcing functions seems like something the user should be doing, but I could see it being useful for collecting statistics for post-processing or analysis. If it's just a matter of switching arguments, then it sounds like a small price to pay for a potentially cool feature. I guess at some point we'll probably want to pick a convention and refactor the operators, time-stepping kernels, and user-defined functions to all match.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/390#issuecomment-527172040:68,integrat,integrating,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/390#issuecomment-527172040,1,['integrat'],['integrating']
Integrability,"Hmmm, right so if a boundary condition uses the `discrete_form=true` then it might require access to `state(model)` to fill halos, and if it `depends_on` other fields, then it needs access to them. I agree that we don't want to make invasive changes where fields depend on other fields and fields have extra properties that link to other big objects... It would make the code less modular I think. I think the current field abstraction is pretty lean so it might be nice to avoid bloating it. Would it make sense to add these dependencies in the boundary condition or `BoundaryFunction`? Then filling halos just calls the boundary condition which has immediate access to the state/fields it needs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-698403877:263,depend,depend,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-698403877,2,['depend'],"['depend', 'dependencies']"
Integrability,"Hmmm, yeah I'll close it for now as we haven't discussed it in forever. The way the `Field` abstraction seems to have evolved is that we expose `Field`s to users, but behind the scenes we have to get a little messy and use either the `OffsetArray` or the underlying `Array/CuArray` as needed. Which is fine, as long as the user interface is clean.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/163#issuecomment-525545676:328,interface,interface,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163#issuecomment-525545676,1,['interface'],['interface']
Integrability,"Hmmm, yeah so the current way we handle test dependencies (compatible with Julia 1.x but not 2.0+) doesn't seem to let us instantiate a test environment with packages required for benchmarking. We can [update the way we handle test dependencies](https://julialang.github.io/Pkg.jl/v1/creating-packages/index.html#Test-specific-dependencies-in-Julia-1.2-and-above-1) (compatible with Julia 1.2+) and define a `test/Project.toml` so then we just run with the test environment with `julia --project test` (from the repo's root dir) and we should get the packages we need for benchmarking while users won't (which is what we want I think). If this sounds like a good idea to you, I can make the change (probably should be in a separate PR). Oceananigans already requires Julia 1.3 anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/727#issuecomment-612908744:45,depend,dependencies,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727#issuecomment-612908744,3,['depend'],"['dependencies', 'dependencies-in-Julia-']"
Integrability,"How about changing . > Installing Oceananigans through the built-in Julia package manager is a good idea because Julia will take care of all dependencies and let you update Oceananigans using a single command: `] update`. to something like. ""We recommend installing `Oceananigans.jl` with the built-in Julia package manager, because this installs a stable, tagged release. `Oceananigans.jl` can be updated to the latest tagged release from the package manager by typing. ```julia; (v1.1) pkg> update Oceananigans; ```. At this time, updating `Oceananigans.jl` should be done with care, as `Oceananigans.jl` is under rapid development and breaking changes to the user API occur often."". Do we want to also move the ""Developers"" section to the end of the README? Maybe expand the scope of this PR slightly while we are looking at it?. Edit: maybe we should also provide links to the julia documentation on how to use the built-in package manager?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/396#issuecomment-530377650:141,depend,dependencies,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/396#issuecomment-530377650,1,['depend'],['dependencies']
Integrability,"How do we deal with errors of this kind in the doctests?:. ```;   | │;   | │ diff =;   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.;   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.;   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration;   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44;   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; ...; ```. i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different. I remember there was a relatively simple way to deal with this, but I can't find it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603:588,message,message,588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603,1,['message'],['message']
Integrability,"How exactly would we enforce incompressibility? Should we perform a pressure correction step? Something like. ```julia; function set!(model; enforce_incompressibility=false, kwargs... # everything else in `set!`. if enforce_incompressibility; calculate_pressure_correction!(model, 1.0); pressure_correct_velocities!(model, 1.0); end. return nothing; end; ```. (This syntax will work once #1057 is merged). The ""1.0"" is a pseudo-timestep that is technically irrelevant (but can't be `Inf` or `0`). The two above functions come from the time-stepping routine:. https://github.com/CliMA/Oceananigans.jl/blob/c35af739186434d754c70966ecc52e4cc61db5a2/src/TimeSteppers/runge_kutta_3.jl#L73-L74. I suppose this projects the user-defined velocity field onto an incompressible field, which is more or less what we want? It seems better than recomputing `w` from continuity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1027#issuecomment-710686571:549,rout,routine,549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1027#issuecomment-710686571,1,['rout'],['routine']
Integrability,"Huh, so its the difference between. https://user-images.githubusercontent.com/15271942/165942956-f73c2f7c-88dd-4c1a-9775-c209a2007894.mp4. where the hydrostatic pressure is treated _explicitly_ (via RK3 in this example) by integrating buoyancy, and. https://user-images.githubusercontent.com/15271942/165942854-8061b8fe-a254-4ed0-8f66-d6283415fd8a.mp4. where pressure is treated implicitly with an elliptic solve and fractional step (at every RK3 stage...). I tested reducing the time-step and don't see any convergence with time-step. Reducing the time-step and running 5 times as long produces. https://user-images.githubusercontent.com/15271942/165946791-6cb90b71-f361-42d9-82db-b16baaf6c3db.mp4. On `main` the same does:. https://user-images.githubusercontent.com/15271942/165952404-00e93a46-65a2-4b9b-a617-43a424f455b1.mp4. Note also these results depend on resolution (which I'm not showing). So it seems both are wrong but one is more so and it's O(1) in time. I also tested WENO5 advection (no difference) and high resolution (seems to make a difference).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950:223,integrat,integrating,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950,2,"['depend', 'integrat']","['depend', 'integrating']"
Integrability,"I agree it's silly that users are _required_ to provide meaningless numbers. Pointless suffering... There's some related discussion on #940 . We should resolve #902, #940, and this issue at the same time. I guess we need to dispatch `validate_regular_grid_size_and_extent` on the topology. Then we can correctly adjust user input depending on whether a dimension is `Flat`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1001#issuecomment-700572043:330,depend,depending,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1001#issuecomment-700572043,1,['depend'],['depending']
Integrability,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:241,depend,depends,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490,4,"['depend', 'interface']","['depends', 'interface']"
Integrability,"I agree the current state of affairs puts a lot of responsibility on the user to ensure they pass `Float32` to every constructor that requires it, which is not very _friendly_ especially to new users who aren't familiar with the code. I also agree that having a way to specify the default number type in Julia is better than using an environment variable. Besides the limitation of strings, I feel like it would stray from Oceananigans.jl's script-based interface. If you share a script with someone now, you also need to inform them to run with specific environment variables. With enough environment variables you'll want a `.env` file. Agree with @Yixiao-Zhang that with `Oceananigans.set_default_number_type(FT)` we can do some checks and throw appropriate warnings compared with `Oceananigans.settings[:default_number_type] = Float32` (assuming it's a vanilla dictionary). > Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817:454,interface,interface,454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817,1,['interface'],['interface']
Integrability,I also don't like `calc_nonlinear_κᶜᶜᶜ`. I hope we can come up with a better interface for defining LES closures in the future.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419779168:77,interface,interface,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419779168,1,['interface'],['interface']
Integrability,"I am a little perplexed, because it seemed that tests on the PR passed (except for documentation, which is mysteriously broken right now due to a dependency that's getting updated during `dev ..` in the docs build). ![image](https://user-images.githubusercontent.com/15271942/114247433-ed6df200-9949-11eb-8649-f270ee7e12c7.png). ![image](https://user-images.githubusercontent.com/15271942/114247449-f5c62d00-9949-11eb-96af-02532bde76ef.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1566#issuecomment-817010193:146,depend,dependency,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1566#issuecomment-817010193,1,['depend'],['dependency']
Integrability,"I am also doubting our regression data. For sure it is a synchronization problem, but it is difficult to understand wether it's on the data (generated long time ago) or in the current code",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427950971:57,synchroniz,synchronization,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427950971,1,['synchroniz'],['synchronization']
Integrability,"I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction. ```; Immersed Fluid; ----------- ...........; | ∘ | ∘; f c f c; k-1 k-1 k k; ```; My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The grid fitted problem as a special case where the height in the immersed cell is 0, where as in partial cells it can be anything above zero and up to the top of that cell (or within a tolerance). I hope that we can use the same functions for both, otherwise, much more confusion can arise and I am glad we are having this discussion. Thank you @jm-c for the comment. I will now change the default to 0.1, since that's what is currently used. I presume this means we don't don't want to have partial cells that are in the bottom 20% of the cell or the top 20% of the cell as well?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924:499,interface,interface,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924,1,['interface'],['interface']
Integrability,"I am glad that we are talking about this and I'm also happy to help if I can. One thing that I noticed on the docs is that we say we are using the finite volume method but then we never actually integrate the PDEs to obtain the equations in terms of the cell averaged quantities. I think this would be helpful to the user as it would point out the differences between the value at a point and the cell average of that quantity. I don't think there needs to be a lot but integrating the tracer equation first, since that's easier, and the integrating the momentum equation would add someting which at that moment I don't think is present. What do you think @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269:195,integrat,integrate,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269,3,['integrat'],"['integrate', 'integrating']"
Integrability,"I am in favor of this change but I think Jeanmichel might not be. J-M?. On Tue, Aug 27, 2019, 8:27 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Idea:; >; > - continue to use calculate_boundary_source_terms to add fluxes; > specified via Flux boundary conditions (and also via potential new; > future boundary condition types), *but*; > - use halo filling + interior source term calculation, rather than; > calculate_boundary_source_terms, to enforce Value and Gradient; > boundary conditions; >; > Advantages:; >; > - this change eliminates the need for diffusivities to be known by; > calculate_boundary_source_terms --- diffusivities are only needed if; > enforcing Flux boundary conditions via halos, or to enforce Value/; > Gradient boundary conditions via calculate_boundary_source_terms; both; > of these situations are avoided with this change;; > - nonlinear diffusivities that depend on gradients at the boundary can; > be calculated correctly for Value and Gradient boundary conditions; > - gradient information is now included in output for Value and Gradient; > boundary conditions and can be used in post-processing; > - the calculate_boundary_source_terms function remains a part of the; > algorithm for Flux boundary conditions, or more complicated boundary; > conditions (like those associated with irregular bathymetry).; >; > Previously, we were operating under the assumption that we should either; > fill halos for all inhomogeneous boundary condition types, or use; > calculate_boundary_source_terms. For some reason, we did not consider; > that our method of enforcing inhomogeneous boundary conditions could (and; > perhaps should) depend on the *type* of the boundary condition.; >; > Thoughts?; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/371?email_source=notifications&email_token=AKXUEQQKF52Q6OSJGERBYOLQGXA6XA5CNFS",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-525534795:900,depend,depend,900,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-525534795,1,['depend'],['depend']
Integrability,I am in the JLD2 camp since it has less dependencies and is easier to get working ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1261#issuecomment-740673873:40,depend,dependencies,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1261#issuecomment-740673873,1,['depend'],['dependencies']
Integrability,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:314,wrap,wrap,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906,1,['wrap'],['wrap']
Integrability,"I am open to either option, depending on which is possible at the moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2930#issuecomment-1557910267:28,depend,depending,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2930#issuecomment-1557910267,1,['depend'],['depending']
Integrability,"I am talking about changes to `Field`, which wraps around `OffsetArrays` so there is no effect on performance. We currently use `OffsetArrays`, not `Field`s, in our kernels. For the way we currently time-step this would also have no effect on GPU compatibility, because, again, we use `OffsetArrays` in our kernels, rather than `Field`s.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/457#issuecomment-542272226:45,wrap,wraps,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/457#issuecomment-542272226,1,['wrap'],['wraps']
Integrability,"I am trying to get back to the validation script and when I try accessing the data it gives me an error. Is this a known problem? @glwagner @simone-silvestri ?. ```; ┌ Info: Downloading; │ source = ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2""; │ dest = ""/u/fpoulin/.julia/scratchspaces/124859b0-ceae-595e-8997-d05f6a7a8dfe/datadeps/quarter_degree_near_global_lat_lon/tau_x-1440x600-latitude-75.jld2""; │ progress = NaN; │ time_taken = ""0.07 s""; │ time_remaining = ""NaN s""; │ average_speed = ""3.493 MiB/s""; │ downloaded = ""250.411 KiB""; │ remaining = ""∞ B""; └ total = ""∞ B""; ERROR: HTTP.Exceptions.StatusError(404, ""GET"", ""/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2"", HTTP.Messages.Response:; """"""; HTTP/1.1 404 Not Found; Server: GitHub.com; Date: Thu, 20 Jun 2024 13:36:59 GMT; Content-Type: text/html; charset=utf-8; Vary: X-PJAX, X-PJAX-Container, Turbo-Visit, Turbo-Frame, Accept-Encoding, Accept, X-Requested-With; Cache-Control: no-cache; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload; X-Frame-Options: deny; X-Content-Type-Options: nosniff; X-XSS-Protection: 0; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin; Content-Security-Policy: default-src 'none'; base-uri 'self'; child-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; connect-src 'self' uploads.github.com www.githubstatus.com collector.github.com raw.githubusercontent.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com api.githubcopilot.com objects-origin.githubusercontent.com copilot-proxy.githubusercontent.com/v1/engines/github-completion/completions *.a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:901,Message,Messages,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,1,['Message'],['Messages']
Integrability,"I applaud @vchuravy suggestion. On a different note, @fluidnumerics-joe you need to resolve the dependencies in Manifest; see. https://buildkite.com/clima/oceananigans/builds/14348#018d8bb7-22a8-4a33-9839-626ade95f3c8/18-36. I tried to do it but I don't have push rights on your fork.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935371967:96,depend,dependencies,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935371967,1,['depend'],['dependencies']
Integrability,"I changed the name of this issue; the real point here is that we can't support flow through a `Bounded` direction. If that flow is time-dependent, there are some details we need to fix regarding the pressure solve.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1156#issuecomment-1056923639:136,depend,dependent,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156#issuecomment-1056923639,1,['depend'],['dependent']
Integrability,"I checked and `interpolate(field, x, y, z)` isn't used anywhere in the source code but in a few validation experiment. It basically does the same thing, but extracts the fields location and grid. I've tried changing it to just be a wrapper for `interpolate(field, LX, LY, LZ, grid, x, y, z)` like:; ```julia; @inline interpolate(field::AbstractField{LX, LY, LZ, G, T, N}, x, y, z) where {LX, LY, LZ, G, T, N} = interpolate(field, LX(), LY(), LZ(), G, x, y, z); ```; but this fails as a dynamic funciton invocation. I also tried changing it to:; ```; @inline function interpolate(field, x, y, z); LX, LY, LZ = location(field); grid = field.grid; return interpolate(field, LX(), LY(), LZ(), grid, x, y, z); end; ```. but this errors with `Reason: unsupported call to an unknown function (call to jl_f_getfield)`, so I'm not sure its going to be straight forward or worthwhile trying to make the high level version work on GPU. Also, if we want to test interpolation, it always fails on GPU because of scalar indexing if called directly, but if wrapped in a kernel function is fine:; ```julia; @kernel function test!(field, grid, res, x, y, z); n = @index(Global); LX, LY, LZ = location(field); @inbounds res[n] = interpolate(field, Center(), Center(), Center(), grid, x[n], y[n], z[n]); end; ```; (If I put `grid = field.grid ` in the kernel function it also fails like above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689:232,wrap,wrapper,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689,2,['wrap'],"['wrapped', 'wrapper']"
Integrability,"I checked the help and indeed there is!. ```; help?> nameof; search: nameof. nameof(m::Module) -> Symbol. Get the name of a Module as a Symbol. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> nameof(Base.Broadcast); :Broadcast. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. nameof(t::DataType) -> Symbol. Get the name of a (potentially UnionAll-wrapped) DataType (without its parent module) as a symbol. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> module Foo; struct S{T}; end; end; Foo; ; julia> nameof(Foo.S{T} where T); :S. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. nameof(f::Function) -> Symbol. Get the name of a generic Function as a symbol. For anonymous functions, this is a compiler-generated name. For; explicitly-declared subtypes of Function, it is the name of the function's type. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986842606:404,wrap,wrapped,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986842606,1,['wrap'],['wrapped']
Integrability,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:504,interface,interface,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221,1,['interface'],['interface']
Integrability,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:187,depend,dependency,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343,1,['depend'],['dependency']
Integrability,I copied the whole line above in the initial message. . But to answer your question it's coming from `automatic_halo_sizing.jl`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843331768:45,message,message,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843331768,1,['message'],['message']
Integrability,I could keep cleaning things up but I think I've done enough to close #59 (and 6 other issues!). The only big feature missing is turning our `Field` struct into something we can adapt/convert to a CUDA device argument using `cudaconvert` or Adapt.jl. We can do more cleanup when we figure out how to do this. Note that tests will fail on dev/nightly builds (Julia 1.2) because something changed which broke Cassette (which GPUifyLoops depends on). Will release v0.5.0 once this is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479305069:435,depend,depends,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479305069,1,['depend'],['depends']
Integrability,I did another test from `integrate-turbulence-closures`. I just tried downgrading `GPUifyLoops` to `v0.2.1` and got the same error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482001:25,integrat,integrate-turbulence-closures,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482001,1,['integrat'],['integrate-turbulence-closures']
Integrability,"I didn't make a suggestion except the extremely Holy Principle that the default _absolutely must work_. Otherwise the code is just broken and honestly, when I encounter this in other packages I often decide not to use them. It wouldn't be unreasonable to use VectorInvariant as the default for the hydrostatic model honestly. But if we want to have a flux form default then yes it has to depend on the grid to satisfy Holy Principle 1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2400243091:388,depend,depend,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2400243091,1,['depend'],['depend']
Integrability,"I didn't quite understand what the bug in AMD was. Was it important?. (Asking because one of your commits contained a bugfix for AMD, according to the message)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1062413973:151,message,message,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1062413973,1,['message'],['message']
Integrability,"I do not mean that. I think it should be a major change. When I wrote down that sentence, I did not realize that `compat` in `Project.toml` can prevent using newer versions of dependencies with breaking changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825:176,depend,dependencies,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825,1,['depend'],['dependencies']
Integrability,"I do not really like the idea to inflate the grid inside the advection scheme though, if you want you can issue an error message",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539:121,message,message,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539,1,['message'],['message']
Integrability,I do! I'll send a message on slack.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1097521696:18,message,message,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1097521696,1,['message'],['message']
Integrability,"I don't have very much to offer, but I believe that compiler behavior / execution can differ on different machines due to difference in underlying packages and compiler dependencies, even when the julia packages are identical. If someone else has encountered the same issue then maybe we can make progress?. It'll be nice if upgrading to 1.6 (#1514) solves this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828136610:169,depend,dependencies,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828136610,1,['depend'],['dependencies']
Integrability,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:119,interface,interfaces,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724,5,['interface'],"['interface', 'interfaces']"
Integrability,"I don't know how the spherical hydrostatic model does this but I agree this would be nice to have for the rectilinear model as well. From what I recall from Sadourny (1975) you can have either energy or enstrophy conserving schemes, depending on how you do the averaging. When I played around with them I found that the enstrophy conserving scheme managed to prevent a numercial instability that can occur, but the energy conserving scheme did not. But getting either one (or both) working would be great!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873595735:233,depend,depending,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873595735,1,['depend'],['depending']
Integrability,I don't know of any fluids codes that use single precision for research. It'd be good to know if this route has been pursued successfully before devoting significant effort to it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/55#issuecomment-465616020:102,rout,route,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/55#issuecomment-465616020,1,['rout'],['route']
Integrability,"I don't know this fits here, but I was thinking about a way to have a separate repository for examples from community that doesn't affect the test running time of the main repo. . The repo could generate a wiki-like page with the examples. We could give a code template for the simulations. For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. What do you guys think? . I know this can get messy.. but it could be a nice way to avoid people reinventing the wheel while making their own simulations. With enough time, almost any experiment will have some others similar.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801:380,depend,dependencies,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801,1,['depend'],['dependencies']
Integrability,"I don't think ""child"" is used in standard way here. Usually ""child"" refers to a processes that is dependent on another process. That's not the relationship between `Distributed` and `CPU`... https://www.computerhope.com/jargon/p/parechil.htm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3716#issuecomment-2297210820:98,depend,dependent,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3716#issuecomment-2297210820,1,['depend'],['dependent']
Integrability,"I don't think I understand how this is ill-posed? It is over specified so will not produce physical results but I thought that without a radiating condition this should still not NaN straight away there should just be a lot of reflections from the boundaries?. Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. I am using a matching scheme that advects the perturbation component (defined as the boundary adjacent minus imposed velocity) out of the domain, and relaxes to the imposed velocity at different rates depending on if it is an inflow or outflow (for the v component the timescale is Inf for outflows to allow it to maximally transmit information out). I can run it with no matching scheme but it needs tiny timesteps because the noise at the boundaries becomes massive. When I use the default pressure solver it kind of works. There are some bugs, for example, there is this weird jet generation on the southern inflowing boundary. I think these would be solved with relaxing regions. . https://github.com/user-attachments/assets/a85e66e2-3da7-402a-b546-57a3860cef9c. If I run with the CG solver it NaNs ""immediately"" and is doing ~800 iterations. If I restrict the iterations it doesn't NaN as fast, but generates very high velocities in a random place:. https://github.com/user-attachments/assets/d7ea836e-f69c-4f3a-9559-c64216e95cb0. I think there is also an issue with my model that its not respecting when a boundary adjacent cell is immersed so I'll fix that and get back to you. Perhaps the ""immediate"" NaNs are actually just from the timestep not being small enough as the reflections and bathymetry interactions make some very high velocities (in my case ~40x higher than the inflows)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283:581,depend,depending,581,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283,1,['depend'],['depending']
Integrability,"I don't think it's the tests that are slow. One of the tests involves time stepping a model for 10 time steps and it prints the wall clock time taken for each time step. It's only 2-3 ms so it's executing the tests at the expected speed. I've looked into the logs and it seems to be busy building packages. It's no different than what Travis and GitLab CI do, so maybe this just takes much longer on Windows CI? If we reduce the number of build dependencies that should help then. And if we can cache the builds then that would be excellent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-468291280:445,depend,dependencies,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-468291280,1,['depend'],['dependencies']
Integrability,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:412,interface,interface,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874,2,['interface'],"['interface', 'interfaces']"
Integrability,I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112102806:39,depend,dependency,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112102806,1,['depend'],['dependency']
Integrability,"I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. ; This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`. If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else. If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033:109,rout,routines,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033,3,['rout'],['routines']
Integrability,I feel like this issue has become stale and should maybe be closed?. At least when this issue was first opened we thought (at least I thought) v1.0 would only include one model on one grid so it was easy to come up with a short checklist/roadmap to v1.0. But now with more models and grids (a great thing!) the API will probably be unstable for a long time (not a bad thing) so a v1.0 may not be close enough for a short checklist?. If people are interested in maintaining a roadmap we could go the long checklist route as @navidcy suggests: https://github.com/JuliaData/DataFrames.jl/issues/1678 and https://github.com/FluxML/Flux.jl/issues/1431 might be inspirations. I for one wouldn't mind seeing v0.100.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-887860624:514,rout,route,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-887860624,1,['rout'],['route']
Integrability,I find that the code for boundary conditions for particles cannot deal with unusually large velocity \(when $u\Delta t$ has the order of the domain size\). Fixing the related code \(Yixiao-Zhang/Oceananigans.jl@95f68a1\) enables running the script that I posted previously in this page. Do we need an additional test for such cases?. One remaining question is why the log shows that the error occurs from the pressure solver. Can we do anything to improve the accuracy of error messages?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918:478,message,messages,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918,1,['message'],['messages']
Integrability,"I found a similar problem \(see #3320\), but I am not sure whether it is related or not. I do not know whether `synchronize(device(architecture(model)))` will solve my problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1751498431:112,synchroniz,synchronize,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1751498431,1,['synchroniz'],['synchronize']
Integrability,"I get the same problem, and it looks like the boundary condition is added correctly:. ```julia; julia> model.velocities.u; 1×1×32 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×32 ImmersedBoundaryGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Value, immersed: ImmersedBoundaryCondition; └── data: 1×1×38 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:35) with eltype Float64 with indices 1:1×1:1×-2:35; └── max=-0.0857023, min=-0.972122, mean=-0.393485; ```. I think `FluxBoundaryCondition` is tested here:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/test/test_boundary_conditions_integration.jl#L231-L241. (though only for `NonhydrostaticModel`)... Might make sense to build up those boundary condition integration tests for `HydrostaticFreeSurfaceModel` and also for `ValueBoundaryCondition` and `GradientBoundaryCondition`. @simone-silvestri is this broken because we are now using ""boundary-aware"" derivatives?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317:927,integrat,integration,927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317,1,['integrat'],['integration']
Integrability,"I got it. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(x -> true)); warning: /Users/gregorywagner/.julia/packages/KernelAbstractions/MAxUm/src/cpu.jl:118:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo:; ├── immersed_boundary: GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}; ├── underlying_grid: 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── boundary conditions: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900:76,depend,dependency,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900,1,['depend'],['dependency']
Integrability,"I guess `partition` would take the place of `ranks`. I think it makes sense to delay building `connectivity` (ie we only build connectivity when we build fields and their boundary conditions) --- because we can construct connectivities if we have 1) grid and 2) the partition. But we still have to store the partition in either `grid` or `grid.architecture`, correct?. One approach could produce code like. ```julia; arch = MPIArchitecture() # note no arguments; grid = RectilinearGrid(arch, grid_kw..., partition=XPartition()); ```. internally, the constructors maybe take the form. ```julia; function RectilinearGrid(arch, size, other_grid_kw, architecture_kwargs...); arch = rebuild_arch(arch; architecture_kwargs...); # etc; end; ```. That's possibility (1). Possibility (2) is to use a wrapper for MPI jobs, perhaps completely eliminating `MPIArchitecture` altogether:. ```julia; arch = CPU(); grid = RectilinearGrid(arch, kw...); grid = MultiProcessGrid(grid, partition=XPartition()); ```. Possibilty (3) is to change all the `struct` definitions for grids so they have additional information pertinent to multi-process stuff, which is set to `nothing` when unused. The downside to (2) is that it introduces yet another level of indirection, on top of both `ImmersedBoundaryGrid` and `MultiRegionGrid`. If we wanted to do MPI-distribued, multi-region simulations in complex domains, we have 4 (!) levels of wrapping. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724:791,wrap,wrapper,791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724,2,['wrap'],"['wrapper', 'wrapping']"
Integrability,"I guess if you have a (julia) function that takes a particle time-step, given a velocity field (ie 3D array), then you can use PlanktonIndividuals.jl online with Oceananigans now, using the `Callback` Oceananigans feature that's designed for integration with other models. So maybe it already works in fact.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871:242,integrat,integration,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871,1,['integrat'],['integration']
Integrability,"I guess it does if you do `interpolate` outside a kernel. To avoid scalar operations, `interpolate` has to be wrapped in a `@kernel`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108:110,wrap,wrapped,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108,1,['wrap'],['wrapped']
Integrability,"I guess there are two questions here; one regards user interface and the other regards how we determine defaults internally. It's worth pointing out from the outset that we may have too many defaults right now; we should try to tackle that. On user interfaces, we haven't converged on a way to set parameters like ""radius of the Earth"" and ""gravitational acceleration"". One philosophy could be to never use defaults. Unfortunately that is not very friendly / convenient, but on the upside it would help users ensure that these constants are always consistent. I guess we have to decide on an approach for the user interface first; then the internal code will follow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492630341:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492630341,3,['interface'],"['interface', 'interfaces']"
Integrability,"I guess to have a continuous diffusion function that has the same features of the discrete version (with field dependency and parameters), we could implement something very similar to the `ContinuousForcing.` That would require a regularization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401764624:111,depend,dependency,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401764624,1,['depend'],['dependency']
Integrability,"I guess when we made it so auxiliary fields can be field dependencies for forcings we a) only tested on nonhydrostatic models, and b) didn't implement for functional boundary conditions. I also have no idea how this didn't cause OceanBioME models I've run on HydrostaticFreeSurface models to error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292:57,depend,dependencies,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292,1,['depend'],['dependencies']
Integrability,"I have a practical example that might demand a better interface for `calculate_diffusivities!` (or at least defining it for `ScalarDiffusivities`). I am now using quite complex formulations to calculate the viscosity for `ScalarBiharmonicDiffusivity`. Because of the staggering of the variables, the viscosity can only be calculated at `Center`s; I am using now `DiscreteDiffusionFunction`, which interpolates my formulation to the desired location in space.; This is very inefficient because I am recomputing the expensive viscosity multiple times in the same place.; It would be nice to have an option to have a precomputed diffusivity also in case of a `ScalarDiffusivity`, but provide the function to calculate the diffusivity as it is now done for `DiscreteDiffusionFunction`.; This would allow the code to be way more personalizable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342:54,interface,interface,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342,1,['interface'],['interface']
Integrability,"I have been running on the system Julia for these, I attempted to do my own install but I do not think I ended up doing much with it. I believe `gcc` is a dependency for the subsequent modules as for example when I run:; ```; module --force purge; module load ncarenv/23.10 ; module load ncarcompilers/1.0.0; ```; the last line returns ; ```; Lmod has detected the following error: These module(s) or; extension(s) exist but cannot be loaded as requested: ""ncarcompilers/1.0.0""; Try: ""module spider ncarcompilers/1.0.0"" to see how to load the module(s).; ```; which does not happen if I include `gcc`. I was also able to run my code without netcdf!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846:155,depend,dependency,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846,1,['depend'],['dependency']
Integrability,I have never tried benchmarking this. maybe the gain in performance is negligible. I guess it will depend on the number of particles and the size of the grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431:99,depend,depend,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431,1,['depend'],['depend']
Integrability,"I haven't done any scaling tests, that would be super useful!. Been meaning to clean up this PR a little bit and integrate it into the main code (right now it's completely separate) so the PR can be merged and development can continue in future PRs. Should probably also rename `DistributedModel` to `DistributedIncompressibleModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786755221:113,integrat,integrate,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786755221,1,['integrat'],['integrate']
Integrability,"I just checked the time evolution of the velocity field in this case. It seems to me that shear instability occurs when running the script on a GPU. However, the flow is steady when running the script on a CPU. Does CUDA introduce floating-point error that has x-dependence? Perhaps from the pressure solver?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559:263,depend,dependence,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559,1,['depend'],['dependence']
Integrability,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382:228,depend,dependent,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382,1,['depend'],['dependent']
Integrability,"I just noticed this:. ```julia; julia> x = range(1, stop=10, step=1.0); 1.0:1.0:10.0. julia> y = reshape(x, 10, 1, 1); 10×1×1 reshape(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 10, 1, 1) with eltype Float64:; [:, :, 1] =; 1.0; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0; 8.0; 9.0; 10.0. julia> typeof(y); Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}; ```. So the reshaped ranges do not convert to arrays / `collect` elements --- they are still ranges, with a wrapper (which means that we don't have to do anything special for GPU). I don't think there's any downside to reshape the ranges for convenience in this case. This will slightly simplify the `xnodes`, etc functions as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364:558,wrap,wrapper,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364,1,['wrap'],['wrapper']
Integrability,"I know it's documented in the code but also: https://github.com/CliMA/Oceananigans.jl/blob/bf04295910ef02ca3d4105bee801070deef99175/src/OutputReaders/field_time_series_reductions.jl#L17. Would something simple like this work?. ```julia; function reduce_4d(spatial_reduction::Function, temporal_reduction::Function, f::Function, fts::FTS4D; dims, kw...); reduced_snapshots = [; spatial_reduction(f, fts[n]; dims=filter(d -> d != 4, dims), kw...); for n in 1:length(fts.times); ]; return temporal_reduction(reduced_snapshots); end; ```. I guess we might want a similar interface to the 3D reductions but this should work for all the reductions in `field_time_series.jl`: `(:sum, :maximum, :minimum, :all, :any, :prod)`. It wouldn't work for things like `median` or `quantile` which need to act on the entire 4D array at once, but maybe these aren't _actually_ reductions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151:567,interface,interface,567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151,1,['interface'],['interface']
Integrability,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:42,message,message,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246,1,['message'],['message']
Integrability,"I looked briefly at the code but don't understand it fully. However, I didn't see a construction that I was expecting. I think we need grid constructors that take `architecture` as a positional argument:. ```julia; RectilinearGrid(arch=CPU(); keyword_arguments...) = ...; ```. Then, the `Distributed` module needs to define special grid constructors that dispatch on `architecture::MultiArchitecture`. These constructors will return only the _local_ grid for each process. This pattern will allow us to avoid having to define things like `DistributedNonhydrostaticModel`, etc. Perhaps this will allow us to achieve the pattern that you're referring to @simone-silvestri where `Distributed` has precedence over `Models`. I guess if we were to fracture the Oceananigans repo into ""finite volume specific code"" and ""physics specific code"", it certainly would be the case that the physics specific code would depend on the finite volume utilities.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690:905,depend,depend,905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690,1,['depend'],['depend']
Integrability,"I mean the new user interface for `ImmersedBoundaryCondtion`. Previously, I tried to do a simulation with heating distributed on an irregular bottom, and I found that I had to use `ImmersedBoundaryCondition(top = the_bottom_heating)` instead of `ImmersedBoundaryCondition(bottom = the_bottom_heating)` after some testing. I felt this strange and reported this behavior to Simone. Then he opened this issue, because it affects his simulations as well. I am sorry for confusing you, since you did not know Simone and I had some discussion on issue before.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782:20,interface,interface,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782,1,['interface'],['interface']
Integrability,"I mean, we could actually provide this implementation ourself with something like. ```julia; u = TimeseriesField(filepath, ""u""). u[i] # returns `Field` at save point `i`. u[i, a, b, c] # calls `getindex(file[""output/u""][string(i)], a, b, c)`; ``` . actually with `TimeseriesField` we could also automatically wrap data loaded from file into the appropriate field type as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-702105112:309,wrap,wrap,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-702105112,1,['wrap'],['wrap']
Integrability,"I missed something obvious or made a trivial mistake.I am new to Julia, Oceananigans, and computational fluid dynamics, so please forgive me if I missed something obvious or made a trivial mistake. No aspect of computational fluid dynamics is trivial or obvious! :-D I'd like to echo @navidcy for the thoughtful and well-documented issue. Your issue is numerical instability! This occurs either because the time step is too large, or because the physical problem cannot be resolved on the specified grid, which can cause energy to accumulate at the grid scale, eventually leading to blow up. This example may be exhibiting both. As @navidcy demonstrates, reducing the time-step allows for a few time-steps to be taken without blowing up. However, the scale of the physics --- a [Rayleigh-Taylor-type gravitational instability](https://en.wikipedia.org/wiki/Rayleigh%E2%80%93Taylor_instability) --- still appears to be quite small. The characteristic scale of the turbulent motions that result from your initial condition depends on the diffusivities that are prescribed. > Taking a look at my textbook, both the diffusivities look too small for the real world, especially the horizontal κh, as you mentioned. If I'm not mistaken, eddy diffusivity is much greater in magnitude than molecular diffusivity (and therefore more important), with typical vertical values of 10^-5 m^2/s, and horizontal eddy diffusivities range anywhere from 1m^2/sec to 10^4 m^2/sec. The turbulent eddy diffusivity is a property of turbulence, and thus of the physical scenario being simulated. So we can't say whether certain values are too large or too small, especially for an initial value problem like this. The numbers you've cited are typical numbers used for large-scale oceanographic problems (motions with scales of 10s of kilometers or more). However, the problem you are trying to simulate is very small scale, with a domain just 500 meters in each direction. and grid spacing down to 2 meters. In addition, its ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-731116328:1114,depend,depends,1114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-731116328,1,['depend'],['depends']
Integrability,"I moved it to Diagnostics, but it's not compiling yet because it depends on OutputWriters, which is compiled right after Diagnostics. Compiling OutputWriters before Diagnostics doesn't work also because there are some dependencies there too. I think the `define_output_variable!` part could be moved towards `OutputWriters` (since it's only used by the NetCDF writer), but the annoying thing is that I'm also using `slice_parent` in the very definition of the average, which is defined in `field_slicer.jl`. Let me know what you think, but I actually think stuff related to `FieldSlicer` could be moved to outside of `OutputWriters` since it has found other uses outside of the NetCDF output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497:65,depend,depends,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497,2,['depend'],"['dependencies', 'depends']"
Integrability,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:119,depend,dependent,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461,1,['depend'],['dependent']
Integrability,"I prefer `HorizontalDirections` to `XYDirections`. ""Horizontal"" is more meaningful when we're on a spherical shell. I understand that gravity can be rotated, but I think ""horizontal directions"" will be primarily used with models that are not rotated. The same issue plagues `XYZDirection` --- its a Cartesian / Rectilinear centric view. The situation makes even less sense on a cubed sphere, where ""x"" and ""y"" are arbitrary and pointed in different directions depending on the location on the sphere. How do others feel?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1047374594:460,depend,depending,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1047374594,1,['depend'],['depending']
Integrability,I proposed `domain_depth` to distinguish it from the already existing `depth` interface that tracks the `depth` as a function of `k` which is used in the turbulence closure module. I think `domain_depth` communicates the idea of a total static depth.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418731139:78,interface,interface,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418731139,1,['interface'],['interface']
Integrability,"I ran a few tests using the [Bickley Jet](https://github.com/CliMA/Oceananigans.jl/blob/glw-vw/grid-fitted-incompressible-model/validation/immersed_boundaries/immersed_bickley_jet.jl) with an immersed top wall from the validation script. . ### Surface Normal Velocity; We can easily look at the surface normal velocity of the immersed wall (which should be zero) with increased resolution and see that it is converging nicely, as this method should be exact except for the pressure correction, which will scale. ![Bickley_normal](https://user-images.githubusercontent.com/67593861/122986244-2e807a80-d36d-11eb-924a-074ca0ad127c.png). ### Tracer Conservation; We can also look at tracer conservation. The initial concentration is sinusoidal, so the area integrated concentration is zero over the domain initially. I've plotted both the IBM and non-IBM (lighter colors) results to see the differences. This one is on a log plot. You can see that leakage is happening in the IBM versions. It's hard to say how bad the leakage is here, and it'll probably be better to consider an initial constant concentration rather than sinusoidal to see how much leakage is occurring due to the immersed solid. ![volint_Concentration_log](https://user-images.githubusercontent.com/67593861/122986580-a058c400-d36d-11eb-9a7c-e3e8d2a7367e.png). It might be easier to see what is going on in the IBM cases without the log scaling:. ![volint_Concentration](https://user-images.githubusercontent.com/67593861/122989251-984e5380-d370-11eb-88cc-ccf4444fb331.png). ### Integrated Boundary Stress; Finally, I looked at the integrated boundary stress along the top wall. The error between the nonIBM and IBM versions at these same grid sizes are below. Unfortunately this is not getting better with increased resolution. This could be due to base state changes causing the stress to change and not necessarily something wrong with the method. It might take better refinement than 256 x 256 to really see a trend here. ![Bickley_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588:753,integrat,integrated,753,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588,1,['integrat'],['integrated']
Integrability,"I ran this using the latest version and I got no error. @Sumanshekhar17 can you please confirm the version? If the version is 0.58.2, can you please post the full code?. I got the code below from a slack message and it ran with no problems:. ```julia; using Random; using Printf; using Oceananigans; using Oceananigans.Units: minute, minutes, hour; Lz=32; Nz=32; S = 1.1 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (32, 32, 32), ; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=8e-4)); Qʰ = 200 # W m⁻², surface _heat_ flux; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; cᴾ = 3991 # J K⁻¹ s⁻¹, typical heat capacity for seawater; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m⁻¹ s⁻¹, surface _temperature_ flux; dTdz = 0.01 # K m⁻¹; T_bcs = TracerBoundaryConditions(computational_grid,; top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); u₁₀ = 10 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²; u_bcs = UVelocityBoundaryConditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:204,message,message,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['message'],['message']
Integrability,"I realized I can see from the error message that the grid is `Bounded` in all directions. I've never used this feature but I think you aren't specifying the tracked fields correctly. It needs to be something like. ```julia; # Define tracked fields as a NamedTuple; tracked_fields = (; T=tracers.T); ```. In other words, the values of the NamedTuple are themselves fields. So you have to build `tracers` before constructing the model. Something like this may work:. ```julia; tracers = (T=CenterField(grid), S=CenterField(grid)). # Define tracked fields as a NamedTuple; tracked_fields = (; T=tracers.T). model = NonhydrostaticModel(; grid, tracers, ...); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136262060:36,message,message,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136262060,1,['message'],['message']
Integrability,"I refactored the interface significantly. Now instead of using a model property `immersed_boundary`, I've introduced a new grid ""wrapper"" called `ImmersedBoundaryGrid`. This new grid wrapper replicates the behavior of the underlying or ""primary"" grid, except where functions are overridden. This allows functions like `diffusive_flux_x` to be extended without touching model time-stepping code. The main motivation for this change is to make it easy to implement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:17,interface,interface,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,3,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"I say we emit a warning for now and I'll add a comment to `offset_windowed_data` that it could be extended to support windowing and offsetting for data that doesn't cover the whole grid. Here's some thoughts for the future:. - We want to compute index intersections using ""grid indices"" rather than ""parent indices"". So more lines in `offset_windowed_data` are needed; - the ""parent indices"" corresponding to particular grid indices depend on the span of the data. `parent_index_range` is only valid for ""full"" indices. Probably we should extend `parent_index_range` to take in some information about the parent data rather than assuming it spans the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325:433,depend,depend,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325,1,['depend'],['depend']
Integrability,I see `domain_depth`. What is the proposed interface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418064001:43,interface,interface,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418064001,1,['interface'],['interface']
Integrability,"I see it like this: Tartarus is a shared system with very small limitations so it is quite difficult to prevent people from running on GPU 0 (I do not think we have the ability to implement a scheduler), so there is more possibility to incur in downtime due to users running on GPU 0. The Caltech cluster might be slower but is much more reliable because it has a professionally maintained slurm scheduler that prevents these types of problems. I tend to prefer having reliability over a modest speedup for these cases, but I am ok with other solutions. One solution would be to routinely kill the jobs on tartarus running on GPU 0 without warning, that would be possible only for people with access on tartarus though. I am ok following that route (I just killed a couple of jobs now 😅). It would be nice to find a more permanent solution though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587:579,rout,routinely,579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587,2,['rout'],"['route', 'routinely']"
Integrability,"I see that some packages have been added as test dependencies. Can you explain how to use these during the benchmarking? Are they available in the project environment?. Should we have a separate set of dependencies for benchmarking? I'm not sure if its possible to have another category of optional dependencies apart from `test`, but it might be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/727#issuecomment-612422092:49,depend,dependencies,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727#issuecomment-612422092,3,['depend'],['dependencies']
Integrability,"I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. `NetCDFOutputWriter`, `JLD2OutputWriter`, and `Checkpointer`. Or do you plan to make a new structure that handles all of them? . I agree that keeping a simple way to create `Checkpointer`s and `OutputWriter`s should be a priority, particularly in the case when the user needs to restart the simulation multiple times in an HPC, keeping in mind manageable file sizes, wall times, and chunks. Currently, this can be handle by the user creating unique output folders or changing the name of the output file for each resubmission of the simulation. Unfortunately, this makes more complex the processing of the output. I think the best solution with outputs and checkpoints will be to automatically append to the last output file from the previous simulation resubmission (currently not supported). I agree that the initialisation of the writer should not create a file, I find that quite confusing. I believe it will be simple to change by only executting the `initialize_nc_file!` and `initialize_jld2_file!` once the model is running, instead of two times, once the writers are initialised and in run time (`write_output!`). . Despite the implementation of this, I still see value in having a flag `overwrite_existing`, likely set up to `false` as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. . Regarding my changes in this PR, the function `is_output_splitted!` may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283:96,wrap,wrapper,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283,2,"['depend', 'wrap']","['depending', 'wrapper']"
Integrability,"I share here a double drake experiment that makes full use of this PR ; #### Grid setup; - latitude longitude grid from 75 S to 75 N; - 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); - 150 exponentially stretched vertical levels for a 3km deep ocean; - double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); #### Top BC: ; - temperature: restoring to reference profile (cosine shape); - salinity: prescribed latitudinally dependent surface flux; - zonal velocity: prescribed latitudinally dependent wind stress; #### Bottom BC:; - velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; #### Initial conditions; - zero velocities; - exponentially stratified temperature with SST equal to the reference temperature; - constant salinity; #### Model setup; - linear equation of state; - Richardson-based diffusivity for BL mixing ; - vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; - vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); - WENO for tracer advection (no horizontal diffusivity); - Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); #### Simulation setup; - time step of 10 minutes; - ran on 2 MPI processes with CUDA-aware MPI; - performs about 10 simulated years per day. On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). https://user-images.githubusercontent.com/33547697/219039209-e99ad100-2730-4805-bf57-c3b438f64537.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185:465,depend,dependent,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185,2,['depend'],['dependent']
Integrability,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989:127,message,message,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989,1,['message'],['message']
Integrability,I think I had the same issue for GeophysicalFlows.jl and somebody in the Julia Slack in the #documentation channel helped me out. But now my message is long deleted and I don't recall what was the issue..,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/808#issuecomment-661459847:141,message,message,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/808#issuecomment-661459847,1,['message'],['message']
Integrability,"I think I have answered my own question. If you think of the momentum equation in terms fo the stress tensor, then in vector form it is. ``; ∂ₜuᵢ - ∂ⱼ⋅σᵢⱼ= 0,; ``. where the second term is the divergence of the stress tensor. If we integrate this over the volume, and divide by the volume then we get upon using **Gauss' Divergence Theorem**. ``; ∂ₜūᵢ =1/Vfcc∭ ∂ⱼ⋅σᵢⱼ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS; ``. In the case of an idea fluid we have `σᵢⱼ=-pδᵢⱼ` and therefore our equation above becomes. ``; ∂ₜūᵢ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS = - 1/Vfcc ∬ p δᵢⱼ⋅ n̂ⱼ dS = - 1/Vfcc ∬ p n̂ᵢ dS; ``. This shows that the desired result follows from application of Gauss' Divergence Theorem on the stress tensor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916:232,integrat,integrate,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916,1,['integrat'],['integrate']
Integrability,I think I'm happy with the finite volume operators in this PR. Happy to make changes based on feedback so we have versatile and flexible operators. In the next PR I will fully integrate them with the code and make sure they are correct and performant. It will also show if I missed any operators.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773:176,integrat,integrate,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773,1,['integrat'],['integrate']
Integrability,I think `Center` is much clearer than `Cell` but I prefer `Face` over `Interface` for brevity.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-535737567:71,Interface,Interface,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-535737567,1,['Interface'],['Interface']
Integrability,"I think `base_grid` is a good name. ""underlying"" is also a little long and ""base"" helps with that. . Note we also should change the name of this abstract type if we use a different name than `underlying`:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/Grids.jl#L86-L92. Another possibility that comes to mind now is `parent_grid`, which is used throughout Julia to indicate a ""wrapped"" object:. ```julia; help?> parent; search: parent parentmodule parentindices. parent(A). Return the underlying ""parent array”. This parent array of objects of types SubArray, ReshapedArray or LinearAlgebra.Transpose is what was passed as an argument to view, reshape, transpose, etc. during object creation. If the input is not a wrapped object, return the input itself. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> A = [1 2; 3 4]; 2×2 Matrix{Int64}:; 1 2; 3 4. julia> V = view(A, 1:2, :); 2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:; 1 2; 3 4. julia> parent(V); 2×2 Matrix{Int64}:; 1 2; 3 4; ```. (And there's also `parentmodule`, etc.) Perhaps that docstring is partly inspiration for referring to things as ""underlying"" (elsewhere we also have descriptions of ""underlying data"" for fields. But I like either `parent` or `base` better than `underlying`, with maybe a preference for `parent` now that I see its fairly widespread. As a side note (issue creep...) we also don't need `AbstractRectilinearGrid`, since there's only one:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/rectilinear_grid.jl#L8. eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177:428,wrap,wrapped,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177,2,['wrap'],['wrapped']
Integrability,I think an issue is a good place to discuss interface design. I can open one if you want!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814262579:44,interface,interface,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814262579,1,['interface'],['interface']
Integrability,"I think even 1D would be ok. On the question of interpolation of velocities: to compute fluxes we need to _reconstruct_ the fields at the cell interfaces. The velocity field is _staggered_ with respect to the tracer field, such that we can trivially reconstruct the velocity field by using the cell-averaged velocity component that's centered on the location it's needed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873779209:143,interface,interfaces,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873779209,1,['interface'],['interfaces']
Integrability,"I think having `Distributed` depend on `Models` was intentional. Basically, the design is that the main code is written for single process modules; and `Distributed` simply provides some replacements for functions that are needed for distributed computations without interferring in the core algorithm. This represents a break from other code designs that weave particularities to distributed model deep into the code. What do you think about this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023:29,depend,depend,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023,1,['depend'],['depend']
Integrability,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:35,depend,dependency,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881,1,['depend'],['dependency']
Integrability,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:16,depend,depends,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873,1,['depend'],['depends']
Integrability,"I think it should be part of the `Fields` submodule. `Average` would be a wrapper around `ReducedField`. It would have similar behavior, but with the added complication that it requires evaluation to be correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-675819405:74,wrap,wrapper,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-675819405,1,['wrap'],['wrapper']
Integrability,"I think it sounds good to me! It matches what you would say in real life, e.g. ""the relaxation just depends on temperature"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/897#issuecomment-685904445:100,depend,depends,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897#issuecomment-685904445,1,['depend'],['depends']
Integrability,"I think it would be great to have these features so you can time step a model with fancy bells and whistles without an explicit loop. I have mixed feelings about the `Simulation` type because it will add an extra layer on top of `Model` that most users will have to deal with. I think we can probably integrate all of this functionality into the existing `Model` struct. Not sure what to call it, maybe `model.time_step_manager` or `model.simulation_manager` that looks like; ```julia; struct SimulationManager; Δt :: Union{Number, TimeStepWizard}; simulation_stop_time; wall_time_limit; simulation_stop_iteration; progress; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-541415364:301,integrat,integrate,301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-541415364,1,['integrat'],['integrate']
Integrability,"I think it's good to go. The only thing that doesn't quite make sense to me is why. ```julia; fill_size = fill_halo_size(field, regular_fill_function, indices, boundary_conditions, loc, grid); ```. depends on `regular_fill_function`, since. ```julia; fill_function, regular_fill_function = get_open_halo_filling_functions(loc) ; ```. and `loc` is an argument to both functions. It doesn't seem that from a purely logical point of view we need `regular_fill_function` at all here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2379279293:198,depend,depends,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2379279293,1,['depend'],['depends']
Integrability,"I think its a fine idea to merge, though it is interesting that the code will still be called `Oceananigans` :-D. I'm not sure I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:276,depend,depend,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['depend'],['depend']
Integrability,"I think maybe you were interpreting ""field dependency"" as meaning ""a dependency of `KernelComputedField`"", rather than ""a dependency that _itself_ is a field""... ? It's the latter definition that I was thinking of; that's why we call `compute!` on its elements.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426:43,depend,dependency,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426,3,['depend'],['dependency']
Integrability,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:34,Integrat,Integrated,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305,1,['Integrat'],['Integrated']
Integrability,"I think so, either that or we cannot depend on FFTW.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3708#issuecomment-2339385271:37,depend,depend,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3708#issuecomment-2339385271,1,['depend'],['depend']
Integrability,I think so. HDF5 is no longer a dependency and we can include plotting in the examples using the import pattern you use in `deepening_mixed_layer.jl`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-520783001:32,depend,dependency,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-520783001,1,['depend'],['dependency']
Integrability,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,I think that if we want to merge this we should nuke the other output writer based on NetCDF and call this one the `NetCDFOutputWriter`. I also think we should only depend on one julia-NetCDF package. What do you think?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-536176347:165,depend,depend,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-536176347,1,['depend'],['depend']
Integrability,"I think that name makes sense!. For the light attenuaiton model, I'm not sure how it would work without making it a property of the model? If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up? . I've rewritten it a little bit to make the integration a nothing operation when the user doesn't specify a model but not sure what the best solution might be here. Perhaps we could make it more generic so users can call any kind of update state operation?. But either way, happy for you to fix these issues!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335069587:319,integrat,integration,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335069587,1,['integrat'],['integration']
Integrability,"I think that, at least in theory, defining our dependency graph more explicitly (eg, optimizing ""waits"") should help us saturate the GPU. If the problem is overhead, I'm not sure what we can do?. All of the errors are of the form. ```julia; LoadError: AssertionError: length(__workgroupsize) <= length(ndrange); ```. They may all be column models that are launched with the group (1, 1, 16)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-662455799:47,depend,dependency,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-662455799,1,['depend'],['dependency']
Integrability,"I think the alternative is to build `clock` inside the constructor. In that case users can only change `clock.time` and `clock.iteration` after constructing the model, rather than passing in a custom `Clock` via this kwarg. The choice depends on what features you want to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1710#issuecomment-849802641:235,depend,depends,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1710#issuecomment-849802641,1,['depend'],['depends']
Integrability,"I think the difficult part is finding z*; this is what Huang 2005 seems to be discussing. I'm hazy on the details (maybe @hdrake can chime in) but I think the point is that while an adiabatic rearrangement into a stable density profile may exist, it may not be obtainable by a single sorting procedure due to the pressure dependence of the equation of state. Some of the subtleties of the Boussinesq approximation for seawater are discussed in http://pordlabs.ucsd.edu/wryoung/reprintPDFs/SeawaterBoussinesq.pdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841583340:322,depend,dependence,322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841583340,1,['depend'],['dependence']
Integrability,"I think the flux boundary condition implementation is correct: ; we ensure zero first and second order derivative across the boundary by mirroring the field, then we just add the flux later as a forcing. . The problem is in the `Open` boundary conditions. These just substitute the value at the interface without modifying halo nodes. This will not ensure a zero second order derivative on the face.; we have to extend the boundary condition to the halos to ensure 0 laplacian on the boundary. Two way that this can be done is either mirroring or linearly extrapolating. This will have an impact later if we support ""true"" open boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132:295,interface,interface,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132,1,['interface'],['interface']
Integrability,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:83,depend,depends,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328,3,['depend'],"['dependencies', 'depends']"
Integrability,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149:356,depend,dependencies,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149,1,['depend'],['dependencies']
Integrability,"I think the main issue here is that there is too much code, reflecting the fact that an interface for defining closures has emerged over time rather than being designed from the ground up. It could possibly benefit from a rethink. It's not as much an issue of the names of things in my opinion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1315578507:88,interface,interface,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1315578507,1,['interface'],['interface']
Integrability,"I think the main reason to use total height is that it generalizes to a ""stacked"" shallow water model (where there are N layers rather than just 1). But perhaps the choice depends on whether shallow water model is valuable mostly as a stand-alone model for physics problems or whether it's intent is more as a testbed for develping numerical methods, etc (with perhaps the eventual possibility of generalizing to N layers).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776:172,depend,depends,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776,1,['depend'],['depends']
Integrability,I think the proposed error message is more helpful and would encourage such a change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418:27,message,message,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418,1,['message'],['message']
Integrability,"I think the simulation is ready and physically/numerically correct. I ran a high-reynolds-number version of this simulation and results look like those from the original paper (even quantitatively). Here's what the v-velocity and the y-vorticity look like (in this current resolution):. https://user-images.githubusercontent.com/13205162/138630652-3c1f3180-793a-42f4-8402-8ad2a921e2d7.mp4. https://user-images.githubusercontent.com/13205162/138630663-abcc59cd-0334-4037-ae92-1ece165a3536.mp4. Now the question is what to do with this. My idea was to transform this into a docs example, but I can also leave it as a validation. If it were a docs example I think this would then teach users how to:. - use the `Buoyancy()` constructor with a specified vertical direction; - use `ConstantCoriolis`, also with a specified vertical direction (these last two are mostly useful for tilted domains I think); - Possibly also how to use NetCDF output writers, which no example does for now. A few ideas that I had for the docs example which might be controversial are. - Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES).; - Use Python/xarrray to read and plot the data. The major downside of these (especially the python one) is that it would add dependencies to the docs environment. Eager to hear some thoughts. CC: @glwagner @navidcy @francispoulin @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676:1461,depend,dependencies,1461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676,1,['depend'],['dependencies']
Integrability,"I think the size dependence has to do with how `mapreduce` works; it breaks the reduction into chunks and (10, 10, 10) might be just one chunk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1894889482:17,depend,dependence,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1894889482,1,['depend'],['dependence']
Integrability,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:179,depend,dependencies,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320,1,['depend'],['dependencies']
Integrability,"I think there are already a couple of challenges for this pull request:; 1. Implementing user-defined forcing functions without losing performance.; 2. Getting the user-defined forcing functions to work on the GPU without losing performance either. As #59 will result in a ton of refactoring, I think it might be more appropriate to address it in a different branch after #73 is resolved, so that everything (`Forcing` is already `isbitstype` but no other code depends on it) can be converted into `isbitstype`. If doing so results in large performance drops (which I think might have happened here) then it might take a while to figure out #59.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/85#issuecomment-467654884:461,depend,depends,461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/85#issuecomment-467654884,1,['depend'],['depends']
Integrability,"I think this PR Is becoming too big. I’m thinking to wrap it up here with the ConformalCubedSphere grid plus tracer halo filling, add tests and then open another one to continue on cubed sphere tasks. What do you reckon @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1483785790:53,wrap,wrap,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1483785790,1,['wrap'],['wrap']
Integrability,"I think this is a a big step forward and happy to share my two cents worth. I agree that we should keep `gravitational_acceleration` the same as before. We will need to have a bunch of `g'`. Since we have a free surface, we assume that we have air above, then `g'` of the top layer is really just `g`. That's why I would suggest having n reduced gravities for n layers. We will need n interfaces and we could also store the n heights. Sometimes it's convenient to have one or the other. For efficiency we only need one, but for convenience we might want to have both. What are people's preferences?. The more layers we have, the thinner each layer tends to be. This means that it's more likely that layer depths can vanish. If this ever happens, then a numerical instability can happen. I remember discussing with @simone-silvestri using the positive preserving property of WENO to deal with this but I also remember that a preliminary test showed that it wasn't actually ensure to be positive. Sadly, I didn't follow up. Any idea if that was fixed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717:385,interface,interfaces,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717,1,['interface'],['interfaces']
Integrability,"I think this is ready to be merged. It showcases that testing examples by rewriting them works pretty well, is easy, and should scale to work with other examples. I'll add something similar for verification experiments. I actually can't test `internal_wave.jl` without rewriting it as it depends on `PyPlot` while `deepening_mixed_layer.jl` lets you set `makeplot = false`. Might be good to leave for another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/418#issuecomment-532814994:288,depend,depends,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/418#issuecomment-532814994,1,['depend'],['depends']
Integrability,"I think to support inserting `Value` or `Gradient` directly into abstract operations would essentially entail an independent implementation from the current `AbstractOperation`, because while this is certainly feasible on the CPU, I suspect we will run into limitations on the GPU fairly quickly. I think if people are interested in direct numerical simulation in complex domains that would benefit from that kind of thing then this is a worthwhile endeavor and could even be prototyped in an independent repository (magic of Julia). Supporting correct boundary evaluation for non-immersed boundaries is straightforward via rules for filling halo regions. Thus despite the trade-offs, it makes sense to provide such a ""bonus"" feature: it's enabling for quite a few applications without a great cost (at least _yet_, because we don't have a user interface or great support for distributed computations). Support for operations across immersed boundaries is a more complex endeavor. Thus because I do not think we should regard Value / Gradient boundary conditions as a ""core"" feature (this package is oriented towards ocean modeling from large eddy simulation up to global scales --- direct numerical simulation is not our core application) the trade-off points towards not supporting this. Especially due to finite resources for software development, many of our decisions are compromises. We don't aim to be perfect, we aim to be good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690236897:845,interface,interface,845,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690236897,1,['interface'],['interface']
Integrability,"I think we can impose a little more structure that eases biogeochemical model development. One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like. ```julia; struct TracerBasedBiogeochemistry; biogeochemical_tracers; drift_advection_schemes; drift_velocities; transitions; auxiliary_fields; end; ```. and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior. Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow). I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like. ```julia; biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); ```. rather than having to use the ""discrete form"". This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285:95,rout,route,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285,3,"['interface', 'rout']","['interface', 'route']"
Integrability,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:182,interface,interface,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359,1,['interface'],['interface']
Integrability,"I think we should improve the docstring for `Distributed`:. https://github.com/CliMA/Oceananigans.jl/blob/8f55656812e4ad7968ff37fccdb3bd1974ef393b/src/DistributedComputations/distributed_architectures.jl#L174-L205. A few comments:. * Can we explain ""synchronized communication"" better? This is confusing --- I think it actually has to do with the algorithm a model uses (very far away from building the architecture). We have to explain that this concept is irrelevant unless we are using a model that has an asychronous algorithm. Or otherwise more specifically explain what this means.; * The entry for `devices` is missing a period a the end. In general more explanation of the keyword arguments that is as local to the concept of grids as possible. The docstring makes vague references to ""support for partitioning"". But this refers to models, not grids. It doesn't really make sense in this context. Also we need examples.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2265666748:250,synchroniz,synchronized,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2265666748,1,['synchroniz'],['synchronized']
Integrability,"I think we want to have users specify output with a function. . The output type should be a parameter of the output writer. . When the output type is a field, we can dispatch to a function that will write the grid associated with that field. . I started working on this on my fork, but realized it is relatively important and not a small job. It also depends on the field abstraction system, which needs some development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/91#issuecomment-468297286:351,depend,depends,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/91#issuecomment-468297286,1,['depend'],['depends']
Integrability,"I think we'll want a ""community repo"" for cases eventually. Something like https://github.com/FluxML/model-zoo if I understand the purpose of that correctly. > For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. Isn't an ordinary Julia environment enough? For the community repo I think either . 1. There is one repo-wide `Project.toml` and all examples are kept up to date or; 2. Each example has it's own `Project.toml`. As I understand the flux model zoo takes approach 1 (this is in principle better, because otherwise the examples grow stale and cease to be useful). However, that requires maintenance and substantial effort. . I think we will still want in-house examples in addition to an external community repo.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545:249,depend,dependencies,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545,1,['depend'],['dependencies']
Integrability,I think wrapping `Base.Broadcast.materialize!` in https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/Fields/broadcasting_abstract_fields.jl#L24 around `@apply_regionally` for multi region fields might do the job,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2092913101:8,wrap,wrapping,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2092913101,1,['wrap'],['wrapping']
Integrability,"I think you can define in `ImmerdsedBoundaries`; ```; return_metrics(grid::ImmersedBoundaryGrid) = return_metrics(grid.underlying_grid); ```; and that should solve the problem, because the coefficients only depend on the metrics, not on the grid itself (then maybe change some warnings); ideally we can put the `return_metrics` function in the `Grids` module, as it is not particular to `WENO` (although it is used only there at the moment)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125298630:207,depend,depend,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125298630,1,['depend'],['depend']
Integrability,"I think you have a different vision of what the ""docs"" should be perhaps. Is there maybe another solution that we can entertain? It's just important to understand the ultimate form that this object I am calling the ""documentation"" might have to take. For example check out the documentation for ECMWF's Integrated Forecast System:. https://www.ecmwf.int/en/publications/ifs-documentation. Or the NEMO ocean model:. https://zenodo.org/record/6334656#.YmNicS-B2gQ. We probably will want the docs to be citable, and may also want to submit parts of them as a paper. I'm trying to reduce the amount of work we'll have to do when the time comes around to make that transformation. I also don't want to have to erase this important work and information when we get there. We want to create knowledge in a sustainable way that can persist. So, I also think the information you want to add to the ""knowledge ecosystem"" is very useful, we just have to find the right place to put it. Maybe discussions aren't great for it either and we need another place besides Issues / Discussions / Pull requests for living knowledge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534:303,Integrat,Integrated,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534,1,['Integrat'],['Integrated']
Integrability,"I thought everything should be synchronized correctly actually. . If you are running on the GPU, the kernels run on a single stream at the moment (we still have to implement asynchronicity), so if you want to synchronize with the CPU you have to call `synchronize(device(arch))`, but that should happen automatically if you have a memory copy from device to host or vice-versa. . On the CPU, the launch is synchronized ; see KernelAbstraction.jl:; (this is the kernel launch wrapped in `@sync`; ``` ; @sync for tid in 1:Nthreads; Threads.@spawn __thread_run(tid, len, rem, obj, ndrange, iterspace, args, dynamic); end; ```; and, therefore `synchronize` does not do much; ```; synchronize(::CPU) = nothing; ```. where do you see this problem? Are you trying to look at GPU quantities from the CPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514616269:31,synchroniz,synchronized,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514616269,7,"['synchroniz', 'wrap']","['synchronize', 'synchronized', 'wrapped']"
Integrability,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:123,message,message,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783,1,['message'],['message']
Integrability,"I tried to run `benchmark_incompressible_model.jl` with advection=WENO5() and the error shown below occurred as it was benchmarking the first GPU case with grid size being 32 x 32 x 32. I'm running all benchmark cases with Float64. Many other error messages of a similar format were also outputted, but this one was the earliest one I can retrieve. My Oceananigans.jl was up to date with the latest merge #1790.; I also tried running it without specifying an advection and it ran fine. @francispoulin is experiencing the same problem. ```; Reason: unsupported use of an undefined name (use of 'pow'); Stacktrace:; [1] overdub; @ C:\Users\henry\.julia\packages\KernelAbstractions\X5hOr\src\backends\cuda.jl:264; [2] right_biased_αz₁(::Int64, ::Int64, ::Int64, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:113; [3] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:113; [4] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:187; [5] right_biased_interpolate_zᵃᵃᶠ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, ::WENO5, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:228; [6] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:228; [7] _right_biased_interpolate_zᵃᵃᶠ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, ::WENO5, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\pack",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871687335:249,message,messages,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871687335,1,['message'],['messages']
Integrability,"I tried to update Oceananigans version in ClimaOceanBiogeochemistry as:; ```; Oceananigans v0.92.0 `https://github.com/CliMA/Oceananigans.jl#glw/tuples-with-catke`; ```; Then I ran CATKE together with horizontal closure:; ```; catke = CATKEVerticalDiffusivity(); horizontal_closure = HorizontalScalarDiffusivity(ν=1e3); model = HydrostaticFreeSurfaceModel(; grid,; closure = (catke, horizontal_closure),; ...); ```; It still returns an error message:; `ERROR: type Tuple has no field κe`. Is it indicating the problem is still unresolved, or am I testing in an incorrect way?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386577814:442,message,message,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386577814,1,['message'],['message']
Integrability,I understand why `FluxBoundaryCondition`s can't be enforced with `closure=nothing` since they depend on a diffusivity. But why can't `Gradient` and `Value` BCs be enforced?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831542337:94,depend,depend,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831542337,1,['depend'],['depend']
Integrability,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:224,integrat,integrate,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407,3,['integrat'],"['integrate', 'integration']"
Integrability,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:485,integrat,integrated,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583,2,['integrat'],['integrated']
Integrability,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857:122,depend,depending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857,1,['depend'],['depending']
Integrability,"I was incorrect about the method. Sorry, I am not sure why I thought that. . >I could be wrong, but I don't think our method is IMEX Euler. It's 2nd-order Adams-Bashforth with a 'fractional step' via the operator splitting you described. The fractional step method is implicit in nature, but to my eye it seems the algorithm differs from those employed standard split implicit-explicit schemes (which do not involve operator splitting / fractional steps). Yes, the interesting thing would be to see if these methods fit into the scope of horizontal or vertical splitting of the resulting ODE system:. http://docs.juliadiffeq.org/latest/solvers/dynamical_solve.html; http://docs.juliadiffeq.org/latest/solvers/split_ode_solve.html. If they do, we can do the following:. - Setup a form where the time stepping is with an `ODEProblem`. This would give the standard methods, but not the extra things.; - Then set it up with either SplitODEProblem or PartitionedODEProblem, depending on how the system is being split, and benefit from the new methods that arise from those categories.; - Implement missing ""PDE methods"" as time stepping methods on these classes of ODEs. Anything you have or need should probably get implemented. @ali-ramadhan I'll be back next week, and we should whiteboard what you're doing for the time stepping here to understand how to characterize the underlying ODE to see what splitting abstraction it needs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549134300:969,depend,depending,969,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549134300,1,['depend'],['depending']
Integrability,"I was looking at the errors on `cpu-solver_tests` and found the message below, followed by a bunch of other errors on the lines below. Does someone know why this is failing? I can take a look at it but thought I'd check to see whether this is understood or not. ```; Vertically stretched Poisson solver [FACR, CPU, (Flat, Bounded, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/test/test_poisson_solvers.jl:272;   | Test threw exception;   | Expression: vertically_stretched_poisson_solver_correct_answer(Float64, arch, topo, 8, 8, 1:8);   | ArgumentError: length(size) must be 2.;   | Stacktrace:;   | [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:24;   | [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:24;   | [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:48;   | [4] VerticallyStretchedRectilinearGrid(::Type{T} where T; architecture::CPU, size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, zF::UnitRange{Int64}, halo::Tuple{Int64,Int64,Int64}, topology::Tuple{DataType,DataType,DataType}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/vertically_stretched_rectilinear_grid.jl:50;   | [5] vertically_stretched_poisson_solver_correct_answer(::Type{T} where T, ::CPU, ::Tuple{DataType,DataType,DataType}, ::Int64, ::Int64, ::UnitRange{Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/test/test_poisson_solvers.jl:140;   | [6] top-level scope at /storage7/buil",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819603114:64,message,message,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819603114,1,['message'],['message']
Integrability,"I went that route before, that would be prohibitive memory-wise also on moderately small grids, especially if you try to do it on 3D settings. You can sparsify the vectors if you want to alleviate it. Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I remember @sandreza had a good trick to calculate a matrix from a linear operation without having to calculate it on all the unit vectors. To sparsify the matrix you can use the utils in matrix_solver_utils.jl because, unfortunately, the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109625239:12,rout,route,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109625239,1,['rout'],['route']
Integrability,"I will let @jm-c approve this one but wanted to say I looked ti over and it looks good to me. As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would `HydrostaticCurvilinearCoriolis` be appropriate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154:192,depend,depends,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154,1,['depend'],['depends']
Integrability,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708:1467,interface,interfaces,1467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708,1,['interface'],['interfaces']
Integrability,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:98,depend,depend,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591,1,['depend'],['depend']
Integrability,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:118,Integrat,IntegrateField,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613,1,['Integrat'],['IntegrateField']
Integrability,"I would say incompressible. Essential assumption is divv=0. We can have a; non-Boussinesq incompressible model by going in to pressure coordinates.; This would be one version of a family of incompressible models. Ali also; has an incompressible version. So to me a compressible/incompressible; naming fork makes sense. On Thu, Dec 12, 2019, 9:25 AM Gregory L. Wagner <notifications@github.com>; wrote:. > If we have Compressible than Incompressible makes sense. But if we have; > QGModel, then Boussinesq makes more sense. Our choice depends on the models; > available.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/566?email_source=notifications&email_token=AKXUEQVFBB7OWDYREOYXNRTQYJCVPA5CNFSM4JZ6UGIKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGW2HZI#issuecomment-565027813>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRYWL2UJ3KNBCOZYADQYJCVPANCNFSM4JZ6UGIA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/566#issuecomment-565031859:534,depend,depends,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/566#issuecomment-565031859,1,['depend'],['depends']
Integrability,"I would suggest sticking with PAR rather than light.  PAR is very common in biogeochemistry and it is made up of specific bands of light and hence “light” and PAR aren’t exactly equivalent.  Calling it “light” could cause confusion if someone calculates PAR from the incoming solar radiation (light).; On Nov 18, 2022 at 3:07 PM +0000, Jago Strong-Wright ***@***.***>, wrote:; > @jagoosw commented on this pull request.; > In test/test_biogeochemistry.jl:; > > + wait(device(model.architecture), par_calculation); >; > +end; >; > +; >; > +biogeochemistry_parameters = (; >; > + growth_rate = 1/day,; >; > + light_limit = 3.5,; >; > + mortality_rate = 0.1/day,; >; > +; >; > + water_light_attenuation_coefficient = 0.12,; >; > + phytoplankton_light_attenuation_coefficient = 0.06,; >; > + phytoplankton_light_attenuation_exponent = 0.6,; >; > + surface_PAR = t -> 100*max(0.0, sin(t*π/(12hours))); >; > +); >; > +; >; > +biogeochemistry = SomethingBiogeochemistry(tracers = :P,; >; > + auxiliary_fields = :PAR,; >; > Makses sense, after I started I realised it was a bigger challenge than I thought it would be!; > I'll try and make these changes later.; > PAR stands for photosynthetically available radiation, perhaps it would be more clear to call it light here.; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513:1391,Message,Message,1391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513,1,['Message'],['Message']
Integrability,"I'd be on board with assuming `AbstractField` elements must be lazily evaluated with `::Field` being a special no-op case. And with renaming `Computation` to `ComputedField`. > There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. Right I was referring to the `Average` methods defined in `AbstractOperations`. > For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. Yeah I considered this as it seems like the most sensible solution but then instead of a useful error, users could end up allocating huge 3D arrays and run out of GPU memory (at which point it might be hard for them to figure out what they did wrong). > `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. Hmmm, does it make sense to rename the `Average.field` property to `Average.kernel` in line with `WindowedTimeAverage` in PR #856?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622:763,interface,interface,763,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622,1,['interface'],['interface']
Integrability,"I'll explain quickly what is happening to document it.; In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used. . This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active. The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction); let's say the advection is centered order 4 so hypothetically it requires two halo points. ; We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!). This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray. . My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971:1586,message,message,1586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971,1,['message'],['message']
Integrability,"I'm a little conflicted about this. In python the convention is to put import statements at the top of a file? So the python convention is *not* to have local import statements. Since every file is a module, this means that in python import statements are at the top of modules by convention. In julia modules can be split among many files. Thus if imports are at the top of a *file*, they are scattered within the module. One reason to put things at the top level is so that its easy to see at a glance what a package imports. It's also nice to see what methods are being extended via implication; for example if one sees `import Base: +` we can expect that `+` is redefined. However, I understand that it is not easy to connect an import statement at the top of a massive module (like ours) with where it is used among the many files that comprise the code of a module. I think having more submodules (#495, #456) is really the right solution to this problem; in that case each module is short so the issue of tracing import statements to usage within a huge module is alleviated. What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know *where* in the code the package is used?. This new convention could create issues in which functionality from a package imported in one file is used elsewhere, making it hard to trace exactly where an unfamiliar function first arrived in the namespace. Or, if two packages conflict with one another. In julia, resolving method conflicts when two packages export the same name can be tricky and the resolution depends on the order in which packages are imported.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-545594755:1733,depend,depends,1733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-545594755,1,['depend'],['depends']
Integrability,I'm closing this draft/prototype as all the useful bits from this PR have been integrated into #290.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/180#issuecomment-505432572:79,integrat,integrated,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/180#issuecomment-505432572,1,['integrat'],['integrated']
Integrability,"I'm closing this, because as discussed elsewhere a better solution is probably to change the user-interface so that only `latitude`, `radius`, and `rotation_rate` can be specified. Making this change would render this issue unimportant since the struct names would only be used internally.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/918#issuecomment-691060475:98,interface,interface,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/918#issuecomment-691060475,1,['interface'],['interface']
Integrability,"I'm finally starting to work on this issue now. I should be able to refactor all the code without changing any of the numerics. Resolving this issue will also resolve #60. I have moved the slightly separate issue of just using cell centers and cell interfaces (and explicitly stating which interface) to #146 as that will change the operators and numerics, and may be trickier to get right. I've added some goals to the original post.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475269437:249,interface,interfaces,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475269437,2,['interface'],"['interface', 'interfaces']"
Integrability,"I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):. ```julia; ERROR: LoadError: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 36)}, KernelAbstractions.NDIteration.StaticSize{(36, 1)}, typeof(Oceananigans.BoundaryConditions.gpu_fill_periodic_south_and_north_halo!)})(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, ::Tuple{Int64, Int64}, ::typeof(Oceananigans.BoundaryConditions.fill_periodic_south_and_north_halo!), ::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{Int64}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185:936,depend,dependencies,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185,1,['depend'],['dependencies']
Integrability,"I'm limited by my ignorance, but at least on the GPU it seems plausible that register allocation has to occur when the kernels are launched; ie, it cannot occur dynamically depending on runtime information. Thus branches that depend on runtime values (like what you've proposed) can't alleviate register pressure, since the compiler is forced to allocate registers for _both_ branches anyways at compile time... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/987#issuecomment-699521493:173,depend,depending,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987#issuecomment-699521493,2,['depend'],"['depend', 'depending']"
Integrability,"I'm not 100% sure but I think doing reductions over non-contiguous data might be subject to variable timings that depend on how the data is organized in memory. In an ideal world, we would benchmark these things regularly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233:114,depend,depend,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233,1,['depend'],['depend']
Integrability,"I'm not sure of the latest approaches/versions of POM and ROMS with the sigma coordinates, but the approach in our paper is similar in the sense that it is based on a general vertical coordinate change. But where ROMS and POM have a fixed distribution of points on a vertical (except for the effect of surface movement which moves points but not their relative position on the vertical), our approach allowed to move the points at any moment up or down depending on local features for example to increase resolution near the moving thermocline and differently for different horizontal positions. .As a special case you can of course have the original POM or ROMS version.; Hope it makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947:453,depend,depending,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947,1,['depend'],['depending']
Integrability,"I'm not sure that this kind of function should be defined for all closures (not all closures even have a diffusivity). If we want to have a more uniform interface, I'd focus on `AbstractScalarDiffusivity` which is specific to closures with a single scalar diffusivity. I think there is already an interface there too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686:153,interface,interface,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686,2,['interface'],['interface']
Integrability,I'm okay with the warning message that we have and closing this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-851493436:26,message,message,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-851493436,1,['message'],['message']
Integrability,"I'm only running the x64 builds so this should reduce Appveyor build times by a half to ~1 hour. Closing this issue as there's not much else we can do except remove dependencies or pay for better resources. Build cache could help but we'd have to manually update it each time package versions change, etc. and the extra maintenance isn't worth it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-500234619:165,depend,dependencies,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-500234619,1,['depend'],['dependencies']
Integrability,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:80,interface,interface,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122,1,['interface'],['interface']
Integrability,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:909,interface,interface,909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081,1,['interface'],['interface']
Integrability,"I'm sort of glad to see @glwagner is verifying the issues we first discussed last year. My 2 cents: . - Small errors in the BC eventually propagating to the whole simulation is unavoidable; this is a well mixed flow. Checking on integrated quantities, such as maintaining conserved properties or matching the expected global dissipation rate, is a more achievable and important goal. ; - Using a test case with some stronger pressure gradients along the boundary would be good as well since this induces much of the error. The circle @wenegrat suggests is the classic, but you might be able to find a more subtle case which is more relevant to your application. Perhaps turbulent flow in a wavy-wall channel? Linking the amplitude of the waves to the change in turbulent statistics seems pretty well aligned with your application (though I could be wrong).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855362669:229,integrat,integrated,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855362669,1,['integrat'],['integrated']
Integrability,"I'm still trying to figure out exactly how to go from cell value to cell-averaged value and back again. The forward approach is the quadrature scheme that we use to integrate on our cells. The backwards approach is the reconstructor. The standard choices that I've seen are to assume that the function is constant, linear and parabolic on each cell. If it's constant then the two coincide and there is nothing to worry about, but I presume this yields a lower order of accuracy. ; On top of what , we then have another choice on how to choose the flux based on the advection scheme. . Can you help me figure out what we are using as a reconstruction?. Everything else you suggest sounds good to me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864:165,integrat,integrate,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864,1,['integrat'],['integrate']
Integrability,"I'm strongly opposed to having multiple small packages. . Maybe sub-modules could be a solution. Loading `Oceananigans.Plotting` can ""dynamically"" install Plots.jl, and loading stuff from `Oceananigans.Output` will dynamically install packages depending on the output writer loaded. We just have to keep things modular and neat/tidy. If the tests are taking a while, then we could split things up into quick unit tests and more comprehensive integration tests, or we need to pay for dedicate CI resources.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501739828:244,depend,depending,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501739828,2,"['depend', 'integrat']","['depending', 'integration']"
Integrability,"I'm thinking maybe that we should not allow `BasicBiogeochemistry` to have an update state or update tracers function. This will help enforce the notion that this object is really for ""truly basic"" situations; for more advanced functioality people need to use the lower level interface (which will produce much more reusable and modular code, so is very much in our interest).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335295213:276,interface,interface,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335295213,1,['interface'],['interface']
Integrability,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:19,integrat,integration,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590,1,['integrat'],['integration']
Integrability,"I'm trying to integrate a scalar in time (the scalar itself being a volume-integrated `Field`). Pretty much what's being done here: https://github.com/tomchor/Oceanostics.jl/blob/main/test/test_budgets.jl. I can probably come up with a way to do it without auxiliary fields. I just assumed `auxiliary_fields` could also be scalars since fields is written as ""fields"" in the docs, rather than ""`Fields`"". (Although I'm not sure what you mean by a ""parameter"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482889696:14,integrat,integrate,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482889696,2,['integrat'],"['integrate', 'integrated']"
Integrability,"I'm trying to wrap my head around this (and figure out interpolation in ShallowWater) and am getting bits and pieces. It is surprising to me, a novice, that MultiaryOperations are better behaved, as I would expect that they would be more complicated. But good news that they are. If that's the case, should we rethink how BinaryOperation is put together, and maybe redo it or just use Multiary?. Sorry if this is naive but wanted to through it out there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738864365:14,wrap,wrap,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738864365,1,['wrap'],['wrap']
Integrability,"I'm wondering if it might be a bit much to put docstrings on every single `AbstractGridMetric` for this experimental feature? They aren't exported so not user-facing (I think we may end up using this internally only for things like `IntegratedField` down the line). But I can copy paste the PR comment into the docstring for \Delta z as an example. Note that `GridMetricOperation` is used internally only, it's really the instances `\Delta z`, etc that are meant to be combined in `AbstractOperations`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826007063:233,Integrat,IntegratedField,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826007063,1,['Integrat'],['IntegratedField']
Integrability,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:246,depend,depends,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814,1,['depend'],['depends']
Integrability,I've added `TracerBasedBiogeochemistry` and an example both using and not using it and they both seem to work now:; ![npd_example](https://user-images.githubusercontent.com/26657828/201384805-32bd6dfe-8838-44c8-a838-e3b841845812.png); I am slightly concerned with how I've setup the forcing for `TracerBasedBiogeochemistry` because I assume the weird stuff going on with the interpolation stuff in `ContinuousForcing` is there for a reason (and we can't use the normal continuous forcing stuff because it relies on the index of the tracer which we don't have as the model isn't finished when we setup the biogeochemical model). I'll have a go at adding an example with PAR integration to check its straightforward to add to a model later.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311916054:673,integrat,integration,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311916054,1,['integrat'],['integration']
Integrability,"I've already made sure the forcing function doesn't reference anything outside the function (reduces clarity unfortunately) and pasted the benchmarks using the script from PR #370 at the bottom. Did not try changing the function signature to `FT(grid, u, v, w, T, S, i, j, k)` as that would make implementing #25 more difficult. Also, I was kind of lazy. Adding `@inbounds` seems to help a lot. Went from being 2.1x slower to being 1.3x slower. Still a significant slowdown considering that these forcing functions aren't as computationally demanding as the rest of the right-hand-side calculation. But good enough for me right now. It can be a very powerful feature (essentially replacing the MITgcm RBCS package, for one example) so would be good to get maximum performance out of the forcing functions. But it will probably always depend on exactly how you write them. So might make sense to have guidelines on writing ""performant forcing functions"" in the documentation. ---; Attempt 1:; ```julia; @inline function Fu(grid, U, Φ, i, j, k); if k == 1; return -2*0.1/grid.Δz^2 * (U.u[i, j, 1] - 0); elseif k == grid.Nz; return -2*0.1/grid.Δz^2 * (U.u[i, j, grid.Nz] - 0); else; return 0; end; end. @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); ```; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Forcing function benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 59.9s / 0.41% 7.38GiB / 0.36% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 128×128×128 with forcing (GPU, Float64) 10 166ms 68.2% 16.6ms 13.8MiB 51.2% 1.38MiB; 128×128×128 no forcing (GPU, Float64) 10 77.4ms 31.8% 7.74ms 13.1MiB 48.8% 1.31MiB; ──────────────────────────────────────────────────────────────────────────────────────────────────; ```; ---; Attempt 2:; ```julia. @inline function Fu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208:834,depend,depend,834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208,1,['depend'],['depend']
Integrability,"I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023:106,integrat,integrate,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023,1,['integrat'],['integrate']
Integrability,"I've been trying different open boundaries and have found that making $U_b$ the mean cross boundary velocity seems to be more stable in some cases (I think when estimating it can vary rapidly when the flow switches from out to in which causes problems). From this review https://doi.org/10.1002/fld.1650181006 it seems like for the normal velocity component it is actually common to user specify $U_b$ by hand to make it stable for a particular simulation, or to make it the mean boundary velocity which they say is stable until ~30% of the flow is inflow. . The other advantage of these schemes is they don't depend on the tendencies so will be more straight forward to setup. They also suggest that just setting the gradient to zero on the boundary is fine for the other tracers/velocity components which does seem to end up with similar results. Given the illposedness of all of these solutions for the normal velocity component it seems like it might be better if we didn't commit to a particular formulation. I'm not sure what the best user interface for this might be but it might be easiest to just not call any `OpenBoundaryCondition` and instead e.g. `MeanChannelOutflowBoundaryCondition`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1976639795:610,depend,depend,610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1976639795,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"I've been wanting to clean up this interface a bit but haven't gotten to do it. ; The `grid` argument is used to compute coefficients for stretched advection; if it is not passed, we use uniform spacing coefficients. ; Some time ago, we disabled using stretched coefficients for `Centered` and `Upwind` because it seemed they would make the simulation less stable, but there was no rigorous study to check this. The grid is a kwarg to allow doing stuff like ; ```; WENO(); ```. I think the idea is to move to an interface where every element requires the grid as a positional argument so if this is the idea, we could introduce a keyword argument like `stretched_coefficients` which would make the interface clearer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529:35,interface,interface,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529,3,['interface'],['interface']
Integrability,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794:912,depend,dependant,912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794,2,['depend'],['dependant']
Integrability,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242:453,depend,dependence,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242,4,"['depend', 'integrat', 'interface']","['dependence', 'integrated', 'integrating', 'interface']"
Integrability,"I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?. For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755972885:190,depend,dependant,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755972885,1,['depend'],['dependant']
Integrability,I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C. . Does anyone working on Oceananigans have experience doing that sort of thing?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298954:30,wrap,wrap,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298954,1,['wrap'],['wrap']
Integrability,"I've played more with this now and think the way we can do this with the minimum code changes is as follows. The only other way I can see is for the boundary to store the previous timestep of the boundary adjacent points but since Fields depends on BoundaryConditions that isn't really possible. The key problem really is that previous solutions to this problem have been written in codes that store at least two time levels which we don't have. So, if we consider for now just a 1D problem with boundary point $\phi_b$ and interior points at $\phi_{b-1}$ etc. When we go to update the boundary point we have $\phi_b^n$ and $\phi_{b-1}^{n+1}$ and we want $\phi_b^{n+1}$. As per previous work we assume that the bulk speed is the same at both $b$ and $b-1$ but we don't have both the spatial and time derivatives of the $\phi$ interior at the same step so we first need to approximate the previous step as:. $\phi_{b-i}^n = \phi_{b-i}^{n+1}-\Delta t G^n_{b+1}$. We can then find the bulk velocity at timestep n as:. $U_b^n = -\frac{2\Delta x_{b-1}G^n_{b-1}}{\phi^n_b - \phi^{n+1}_{b-2} - \Delta t G^n _{b-2}}$. We then have all the information to step $\phi_b$ to:. $\phi_b^{n+1}=\phi_b^n-\frac{\Delta t}{\Delta x_b}U_b(\phi_b^n-\phi_{b-1}^{n+1} - \Delta t G^n_{b-1})$. This will require us to give the boundary condition both the tendencies and $\Delta t$, but this seems to be the easiest thing to change. I also think this is the only way we can get a physically sensible bulk speed where all of the components are calculated at the same timestep. I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a quest",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810:238,depend,depends,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810,1,['depend'],['depends']
Integrability,"I've refactored a bit more so that we can use `FieldBoundaryConditions` to construct velocity, tracer, diffusivity, pressure, and tendency boundary conditions. This is done by specifying the `field_type` required kwarg when calling `FieldBoundaryConditions`. ```julia; u_bcs = FieldBoundaryConditions(grid, field_type=:velocity); T_bcs = FieldBoundaryConditions(grid, field_type=:tracer, top=FluxBoundaryCondition(0.1)); ```. An alternative design (really a wrapper):; ```julia; VelocityFieldBoundaryConditions(grid; kwargs...) =; FieldBoundaryConditions(grid, field_type=:velocity, kwargs...); TracerFieldBoundaryConditions(grid; kwargs...) =; FieldBoundaryConditions(grid, field_type=:tracer, kwargs...); ```. This will allow us to properly set default velocity and tracer boundary conditions with a single `FieldBoundaryConditions` constructor. It will also allow us to clean up the code a bit and remove some other functions like `PressureBoundaryConditions` and `DiffusivitiesBoundaryConditions` from `solution_and_model_boundary_conditions.jl`. @glwagner Let me know what you think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/620#issuecomment-586327005:458,wrap,wrapper,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/620#issuecomment-586327005,1,['wrap'],['wrapper']
Integrability,"I've worked out where my problem is coming from. For the wall-normal velocity: first, we compute and apply the tendencies from 1:N face points, then compute the pressure correction at 1:N center points, then fill the boundary points at 1 and N+1, and apply it at 1:N face points (except the gradient is zero across the 1 face point so this doesn't do anything to the boundary. The N+1 boundary point is fine because we can just set it to anything, or time integrate something at the point since nothing else effects its value. The same is true if we prescribe a value at the 1 face point because (even though we redundantly integrate the tendencies there) it just gets reset to whatever we want. The problem is if we try to integrate something like a radiation condition there then we actually end up with $u(1, j, k) = \int (G_u + B_u) dt$ where $B_u$ is whatever integration we're trying to do at the boundary. On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that than to think of a different way todo it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695:456,integrat,integrate,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695,5,['integrat'],"['integrate', 'integration']"
Integrability,"If it's urgent, I suggest creating a new branch that merges master and whatever other branch has an important feature and depending on that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872310004:122,depend,depending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872310004,1,['depend'],['depending']
Integrability,If this will be important then we should streamline the user interface for changing to Float32. Ideally everything should take `eltype` from the grid I think without requiring tons of manual intervention.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732203856:61,interface,interface,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732203856,1,['interface'],['interface']
Integrability,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:913,rout,routines,913,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683,1,['rout'],['routines']
Integrability,"If we are committed to not using ghost cells, then I think the solution will depend on how boundary conditions are implemented. Periodic boundaries are just one of many possible cases we will encounter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/92#issuecomment-468293051:77,depend,depend,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/92#issuecomment-468293051,1,['depend'],['depend']
Integrability,"If we check after the coordinate is created, we may only need to check once (the check is the same for all user input and the message is the same: the coordinate must be increasing)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751826882:126,message,message,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751826882,1,['message'],['message']
Integrability,"If we have Compressible than Incompressible makes sense. But if we have QGModel, then Boussinesq makes more sense. Our choice depends on the models available.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/566#issuecomment-565027813:126,depend,depends,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/566#issuecomment-565027813,1,['depend'],['depends']
Integrability,"If we have a `Particle` design that looks something like. ```julia; struct Particle{P, T, R, E, D}; position :: P; properties :: T; restitution :: R; external_velocities :: E; diffusivity :: D; end; ```. With the following meaning:. * `position`: a 3-element object with the particle position (not sure what's best for GPU --- some kind of mutable struct or `Array` / `CuArray`)?; * `properties` (could use a better name): user-defined properties + model fields for simulating reactions and such. Probably need additional types / interface for these; * `restitution`: floating point number between 0 and 1 that determines particle behavior at solid walls; * `external_velocities`: a 3-tuple of settling/buoyant/other velocities to be applied to the particle in addition to the resolved + background velocity field. We can also design an abstraction / special type that computes the buoyancy of a particle with a certain temperature / salinity / buoyancy (for example); * `diffusivity` diffusion coefficient that is used to compute stochastic noise added to the particle position (requires some care to ensure the stochastic diff eq is integrated correctly. Would be nice to support both constants and functions of space-time, etc. We can start with just a few of these fields in our `Particle` type, and extend its power in future PRs if we need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713698417:530,interface,interface,530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713698417,2,"['integrat', 'interface']","['integrated', 'interface']"
Integrability,If we use `\nabla \cdot (\nu h \nabla u)` then the dissipation term is ` - \nu h | nabla u |^2`. This is accepted and has the nice property that the dissipation depends on the depth. If we use `\nabla \cdot (\nu \nabla u)` then we don't have the right units as we are evolving `h u`. . `\nabla \cdot (\nu \nabla (h u) )` does not give you a negative definite form as you would get ` - \nu \nabla u \nabla (hu)`.; P.S. How do you include latex here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090319835:161,depend,depends,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090319835,1,['depend'],['depends']
Integrability,If we're okay with merging a vertically stretched grid abstraction by itself with some tests that ensure the vertical levels are correctly computed then I think this PR is ready to be reviewed. Pressure solver and full integration will come in a future PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/543#issuecomment-572296245:219,integrat,integration,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/543#issuecomment-572296245,1,['integrat'],['integration']
Integrability,"If you want to integrate with the Julia ""progress bar"" system, you could put in something like:; ```julia; @debug ""this is a short description of my loop"" progress=iteration/length_of_loop; ```. This works in Juno, and with MicroLogging.jl in the REPL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-536805872:15,integrat,integrate,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-536805872,1,['integrat'],['integrate']
Integrability,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:515,interface,interface,515,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159,1,['interface'],['interface']
Integrability,"In some way this comes back to the fundamental question of: What is the point of KernelAbstractions CPU support. I originally intended it only for making debugging easier... But folks seem to be depending on it as a performance solution... I think it is feasible to get there, but it would require quite a bit of time and effort",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481464331:195,depend,depending,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481464331,1,['depend'],['depending']
Integrability,"In this example the sponge on the inflow probably isn't necessary, but for more complicated inflows, it probably is needed.  Probably not a bad thing to keep it in the example, but I don’t have a strong view either way. On Mar 28, 2024, at 12:01 PM, Jago Strong-Wright ***@***.***> wrote:﻿. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?. You are probably right it shouldn't be necessary here!. —Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025902925:662,Message,Message,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025902925,1,['Message'],['Message']
Integrability,"Indeed, I don't think drag is so relevant physically for this problem but it should demonstrate the interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606264607:100,interface,interface,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606264607,1,['interface'],['interface']
Integrability,"Instead of `validate_biogeochemistry`, maybe. ```julia; required_biogeochemical_tracers(::NutrientsPlanktonDetritus) = (:N, :P, :D); ```. is a better syntax. Then users don't have to write their own error messages (we'll handle that in Oceananigans). It also gives us flexibility regarding the choice between 1) automagically adding the biogeochemical tracers or 2) requiring the user to add tracers themselves. We starting to use tracers for a few important things (TKE, biogeochemistry, buoyancy models). We may also need to come up with a system for handling ""name clashes"" gracefully. For example, someone might introduce a biogeochemistry model with tracer `e`, not realizing that this would prevent them from using the biogeochemistry model with CATKE. There's a tension between simplicity and readability (which we get with short, intuitive tracer names like `e`, `T`, `S`), and catastrophic ""name clashes"" that will inevitably occur as model complexity increases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390:205,message,messages,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390,1,['message'],['messages']
Integrability,"Integer, [-1,268]:Integer, [-1,269]:Integer, [-1,270]:Integer, [-1,271]:Integer, [-1,272]:Float@double, [-1,280]:Float@double, [-1,288]:Float@double, [-1,296]:Float@double, [-1,304]:Integer, [-1,305]:Integer, [-1,306]:Integer, [-1,307]:Integer, [-1,308]:Integer, [-1,309]:Integer, [-1,310]:Integer, [-1,311]:Integer, [-1,312]:Integer, [-1,313]:Integer, [-1,314]:Integer, [-1,315]:Integer, [-1,316]:Integer, [-1,317]:Integer, [-1,318]:Integer, [-1,319]:Integer, [-1,320]:Integer, [-1,321]:Integer, [-1,322]:Integer, [-1,323]:Integer, [-1,324]:Integer, [-1,325]:Integer, [-1,326]:Integer, [-1,327]:Integer, [-1,328]:Float@double, [-1,336]:Float@double, [-1,344]:Float@double, [-1,352]:Float@double, [-1,360]:Float@double, [-1,368]:Float@double, [-1,376]:Integer, [-1,377]:Integer, [-1,378]:Integer, [-1,379]:Integer, [-1,380]:Integer, [-1,381]:Integer, [-1,382]:Integer, [-1,383]:Integer, [-1,384]:Integer, [-1,385]:Integer, [-1,386]:Integer, [-1,387]:Integer, [-1,388]:Inte...; ```. Farther down the error message says:. ```; Cannot deduce type of insertvalue ins %138 = insertvalue { { i64, i64, i64, i64, i64, i64, double, double, double, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] } }, { {} addrspace(10)*, [3 x i64] }, {} addrspace(10)* } %134, { {} addrspace(10)*, [3 x i64] } %unbox2.i.unpack286435, 1, !dbg !20 size: 32 TT: {}. Caused by:; Stacktrace:; [1] #60; @ ./tuple.jl:461; [2] afoldl; @ ./operators.jl:545; [3] filter_rec; @ ./tuple.jl:461; [4] filter; @ ./tuple.jl:464; [5] filter; @ ./tuple.jl:0; within MethodInstance for filter(::Oceananigans.Fields.var""#87#91"", ::Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Period",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140:10495,message,message,10495,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140,1,['message'],['message']
Integrability,"Interesting that this works. in the `ShallowWaterModel` we define our functions to be `(x,y,z)` because that's what I thought we had to do. But this example above suggests that in the spherical case we can define `(x,y)`. Does this mean we might be able to define functions in `ShallowWaterModel` that don't depend on `z`, or am I missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838662676:308,depend,depend,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838662676,1,['depend'],['depend']
Integrability,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:128,depend,depend,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,1,['depend'],['depend']
Integrability,"Interesting. I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:. <img width=""391"" alt=""image"" src=""https://github.com/user-attachments/assets/b1bc556f-4a82-47b3-acd8-c27e83c32591"">. Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069:332,depend,dependence,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069,1,['depend'],['dependence']
Integrability,Interesting. I noticed that there were some unnecessary test dependencies and removed those. That seems to have helped.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362562042:61,depend,dependencies,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362562042,1,['depend'],['dependencies']
Integrability,"Is it so hard to update the validation scripts too? Hopefully that should be easy and it doesn't really matter what you do first. We use the validation scripts to test the user interface. You'll be changing them no matter what, in either case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915263357:177,interface,interface,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915263357,1,['interface'],['interface']
Integrability,Is that message going to display _every_ time a model is created?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460612239:8,message,message,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460612239,1,['message'],['message']
Integrability,"Is there anything useful in the approach here. https://youtu.be/GCj4xHUGZ0g?t=2555. their message was sort of that everything was really easy. ; They used a Docker/Singularity container I think and it was a general presentation, but their example was Oceanigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724222815:90,message,message,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724222815,1,['message'],['message']
Integrability,"Is this extra simplicity in the user interface worth the extra code to maintain?. I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I also think a user can easily infer that `z` in the signature can be ignored if they just defined a grid with a `Flat` z topology, so I think the added user-friendliness is minor. (Maybe even negative since the signatures now can change based on `topology(grid)`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680:37,interface,interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680,1,['interface'],['interface']
Integrability,"Isn't that a way to obtain the reverse cumulative integration by simply adding something?; Something like `cumint[end] - cumint + cumint[1]` ; I don't remember exactly, but I think that there is a way to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343:50,integrat,integration,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343,1,['integrat'],['integration']
Integrability,"It could make sense to have a `Simulation` type for managing time stepping, including progress messages / utilities for logging output from diagnostics and maybe also plotting, eg. ```julia; simulation = Simulation(model, dt, stop_time=8day, wall_time_limit=1day, progress=ProgressMessenger(diags=diags), ...). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-539094783:95,message,messages,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-539094783,1,['message'],['messages']
Integrability,"It depends. If you are also passing `indices` to the writer, then `Field(abstract_op, data=scratch.data)` wastes a lot because it allocates a 3D array for `abstract_op`. If you want to use indices AND scratch data, you can use `Field(abstract_op; data=scrath.data, indices)`, where `indices` is the same thing you would pass to the output writer. Generally, you should only need to worry about scratch data if you have a lot of 3D output. If you have 2D output, it's unlikely that using scratch data will help much (and will significantly complicate your scripts, so I'd say best practice would be to avoid it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903:3,depend,depends,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903,1,['depend'],['depends']
Integrability,"It just helps to ensure that the discrete continuity equation (and thus discrete conservation of mass) is handled correctly. It's possible that it's not necessary (but it's the reason that the vertically integrated lateral face areas pop up in the numerics). Here are some notes:. <img width=""955"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165295054-4f3205c2-bf71-46b2-947a-b1c23241328e.png"">. <img width=""954"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165296417-38c25dde-5636-40c0-8ed3-6059f9f95740.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687:204,integrat,integrated,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687,1,['integrat'],['integrated']
Integrability,"It looks like `perturbation_norm` needs to be defined in a GPU friendly way. The error message is cutoff so I can't see where that function is defined (the clue is at the bottom of what's posted):. ```; [15] perturbation_norm(model::ShallowWaterModel{RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Fl; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678:87,message,message,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678,1,['message'],['message']
Integrability,"It looks like our problems with GM are not solved by this PR --- even when we correctly mask interior values (it might be worth testing this a second time, but I think I did this correctly). Here are results for https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/1c183f9a8df7b97f5074f18ce622b247b7b1c923, in which the stencil is rewritten to compute the ""gradient of the average"". When we do this, and use ""boundary-aware averages"", we eliminate a dependence on the boundary (ie the GM stencil is ""inward looking""). It doesn't fix the basic issue with spurious fluxes near the boundary:. https://user-images.githubusercontent.com/15271942/166609754-1c832d73-3089-48d0-89c4-a99caac344b1.mp4. Hmm... For reference, here's what happens when we revert to ""average of the gradient"" via https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/b7a67598db1fe8d5afea27cece5d35d0c20aac93:. https://user-images.githubusercontent.com/15271942/166610211-95376390-bb80-4993-8b7b-6a3cbe27bebf.mp4. My next best hypothesis is that we are seeing the precise instability that Griffies 1998 points out, and the only solution is i) horizontal diffusion or ii) the Griffies stencil. @jm-c thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953:456,depend,dependence,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953,1,['depend'],['dependence']
Integrability,"It looks like this PR fixes some issues with complex AbstractOperations, but it does not allow us to use AveragedField on the GPU. I think a possible avenue to explore could maybe be to Adapt an AveragedField by wrapping the underlying, `Adapt`ed data in `Base.Broadcast.Broadcasted`, rather than attempting to adapt `AveragedField` (with its custom `getindex`, which it the crucial part) directly for the GPU. We know that broadcasting with singleton dimensions already works on the GPU and its possible we might borrow some of that machinery. The key function we might want to get a hold of is `_broadcast_getindex`:. https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827:212,wrap,wrapping,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827,1,['wrap'],['wrapping']
Integrability,It might be a good idea to calculate our reference values for thermal expansion coefficient and haline contraction coefficient based on our reference values for temperature and salinity using TEOS-10 (or some other appropriate reference). One way to do this is via. https://github.com/TEOS-10/GSW-Python. I also think that we should nuke any of the constants that are not actively used in the code (our code is probably not an appropriate resource for determining the right heat capacity to use in a given situation).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/190#issuecomment-525539992:103,contract,contraction,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/190#issuecomment-525539992,1,['contract'],['contraction']
Integrability,"It might be possible to design an interface that uses a continuous map from a regular to stretched coordinate, rather than a generator function that specifies the location of cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775:34,interface,interface,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775,2,['interface'],"['interface', 'interfaces']"
Integrability,"It seems natural to me to have a function of 3 arguments, `x, L, N`, as those are all needed to define the grid. There are other ways of doing it I'm sure, and I am open to other options. I agree with you that given the current setup using `zF`, we do need the number of interfaces. This other option would not as we are passing functions instead. I very much like the examples you set up and think that would be very attractive from the user perspective. . Another option that I think should be included in these functions, like the two you have above, is an argument saying where the center (or something else) is in the stretched grid. It could be the left boundary, right boundary, center or anywhere else. The physics should be the guide on where to concenrate the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071:271,interface,interfaces,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071,1,['interface'],['interfaces']
Integrability,"It seems reasonable to add `architecture` to `AbstractField`. I think we actually might need this to make `AbstractOperations` work generically on distributed systems (in particular, `AbstractOperations` that depend on `Field`s or `ComputedField`s).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800549709:209,depend,depend,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800549709,1,['depend'],['depend']
Integrability,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:82,message,message,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366,1,['message'],['message']
Integrability,"It seems we have designed the solver interface (ie, the function signature to `precondition!`) to include the guess / solution at the current iteration. This does seem useful for some preconditioners, right? Eg, if the preconditioner is an asymptotic solution that depends on the current guess, this may be useful. I think. It's not necessary for the _specific_ case of the diagnoally dominant preconditioner though -- I agree with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326:37,interface,interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:499,Depend,Depending,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067,1,['Depend'],['Depending']
Integrability,It'd be easy as an intermediate step to discontinue GPU support only I suppose. Depends how much we want to simplify the code... Also this is a reason not to eliminate `LatitudeLongitudeGrid` because it seems like it will always have fewer parameters than `OrthogonalSphericalShellGrid`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3693#issuecomment-2276886031:80,Depend,Depends,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3693#issuecomment-2276886031,1,['Depend'],['Depends']
Integrability,"It'll probably need to store N arrays under the hood where N is the number of faces. Right now we use 6 faces but if you're doing cubed sphere + MPI you might end up doing 1 < N < 6 faces on each rank. Otherwise I think the abstraction should enable users to use the cubed sphere grid like they would any other grid. So things like `set!` should just work. Right now it's more about making sure the backend all works with `CubedSphereData` then a nice user interface can be built on top of it. There are some decisions to make like should `interior(::Field{..., <:CubedSphereData})` return a 4D array? But we can decide on those as they come up. It'll be nice if the output writers knew how to write `CubedSphereData` to disk, although this can come later and many users may want the fields interpolated onto a regular lat-lon grid which is a different discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1583#issuecomment-819670379:457,interface,interface,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1583#issuecomment-819670379,1,['interface'],['interface']
Integrability,It's also always preferred to use a function (which represents a user interface) rather than directly referencing a `struct` implementation (eg referencing `.name.wrapper`) that's subject to change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790:70,interface,interface,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"It's also worth noting that right now many calculations are done more than once in each timestep. For example for each component of $M_{ij}$ I'm calculating the whole strain rate tensor modulus in addition to the strain rate tensor component needed:. https://github.com/CliMA/Oceananigans.jl/blob/25cc34e6c395e210e0aecf8181919c25435d7919/src/TurbulenceClosures/turbulence_closure_implementations/scale_invariant_smagorinsky.jl#L241-L257. This is done for legibility of the code, but it may be necessary to forfeit that in favor of doing fewer calculations. (Also note that I'm using a weird way to define function names here, so lmk if you guys think I should change it.). Another thing to note that it's common to update dynamic Smagorinsky coefficients once every 5 or so time-steps only, since they can be pretty expensive. afaik this is generally done for the scale-dependent versions, which have two test filters instead of the one needed in this PR, but I wouldn't be surprised if it's occasionally necessary for the scale-invariant versions as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212664403:870,depend,dependent,870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212664403,1,['depend'],['dependent']
Integrability,"It's as @simone-silvestri said, more broadly it seems that we need to think of boundary conditions differently between `Face` fields and `Center` fields. `Face` fields have nodes on the boundary (sometimes we call those ""peripheral nodes""), so we simply impose boundary values to satisfy boundary conditions, eg for determining wall-normal velocities. `Center` fields have nodes within and outside, but not on the boundary. This is the core of the discussion @simone-silvestri and I had about tracer boundary conditions: we can choose either to set the tracer halos to produce a result when tracers are reconstructed _on_ the boundary (that's how `Value` and `Gradient` boundary conditions work -- the halos are determined by extrapolation). Or, we can set the tracer halos as if the halo region is part of some other prognostic state (which is what I envisioned `Open` should do). Finally as @simone-silvestri says the tracer halos are `0, N+1` while wall-normal velocity points _on_ the boundary are `1` and `N+1`. I think its fine to pass additional arguments to `fill_halo_regions!`, and use these for open boundary conditions. In fact, `DiscreteBoundaryCondition` and `ContinuousBoundaryCondition` appear to already be designed to accomodate additional arguments that are unused by those user interfaces (note the `args...`):. https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/discrete_boundary_function.jl#L45 . https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/continuous_boundary_function.jl#L136-L137",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075:1298,interface,interfaces,1298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075,1,['interface'],['interfaces']
Integrability,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:66,wrap,wrapped,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191,1,['wrap'],['wrapped']
Integrability,"It's because the two fields use the same data:. ```julia; u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data); ```. therefore, the problem is that we are not ""recomputing"" the dependent operands of `outputs_avg.u1` correctly. If we don't recompute the operands of `outputs_avg.u1` and `outputs_avg.v1` when we compute them, then they can be identical (and thus wrong) because they are both computed using the same array.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139144269:265,depend,dependent,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139144269,1,['depend'],['dependent']
Integrability,"It's not the geometry that allows a two-argument function, it's because the free surface in `HydrostaticFreeSurfaceModel` is a `ReducedField`. `set!` with a function now uses `FunctionField` and then broadcasting:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/set!.jl#L29-L33. and `FunctionField` at reduced locations are now called with reduced arguments:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/function_field.jl#L60-L62. where `call_func` is invoked in `getindex` for `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/function_field.jl#L64-L65. which in turn uses `node`. The length of the tuple return by `node` depends on how many locations are `Nothing`:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Grids/grid_utils.jl#L158-L168. @francispoulin what is the vertical location of fields in `ShallowWaterModel`? I think if you use `Nothing` for vertical location, you'll obtain this behavior.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838798622:794,depend,depends,794,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838798622,1,['depend'],['depends']
Integrability,"It's out of bounds because the indices of. > 1×2×10 view. are 1:1, 1:2, and 1:10. If you create a windowed `Field`, then `Field.data` is double-wrapped:. * `field.data` is an _OffsetArray_; * `parent(field.data)` is a `SubArray` (the thing that's created by `view`). Both of them have indices. `field.data` has ""global"" indices, or the indices of `field.grid`. But `field.data.parent` has ""simple"" indices, ie `1:1, 1:2, 1:10` in your case. Hopefully studying this code will help:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L271-L293. `offset_windowed_data` creates an `OffsetArray` (with global indices) around ""windowed data"", ie a `view` of the underlying array:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L217-L230. `offset_data` is here:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Grids/new_data.jl#L33-L38",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706:144,wrap,wrapped,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706,1,['wrap'],['wrapped']
Integrability,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:352,message,message,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017,2,"['depend', 'message']","['depends', 'message']"
Integrability,It's very little coding work! Most of the work is designing the interface. That's true we don't use `tracer_fields`...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1017111978:64,interface,interface,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1017111978,1,['interface'],['interface']
Integrability,It's very plausible that it depends on CUDA and also Julia version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261427135:28,depend,depends,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261427135,1,['depend'],['depends']
Integrability,"Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718:191,depend,depending,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718,2,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"Joes PR adding integration tests (which now passes and we should merge, if you can review), I think needs 12 to pass",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3607#issuecomment-2136854514:15,integrat,integration,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3607#issuecomment-2136854514,1,['integrat'],['integration']
Integrability,"Just a clue from https://github.com/jipolanco/PencilArrays.jl/issues/49:. I think it's likely we need to use some `PencilArrays` interface to set up / partition the eigenvalues, rather than attempting to manually hack together a partition. Also by the way, it looks like we might be able to use ""pencil"" decomposition with the non-hydrostatic model now too: . https://github.com/jipolanco/PencilArrays.jl/issues/42#issuecomment-1029766858. previously we could not because PencilFFTs required FFTs to be performed along dimension 1. Since we can't decompose in ""z"" (because at least right now there are vertical integrals in `NonhydrostaticModel` --- this should also be relaxed), this only left the `y` dimension for partitioning. It feels like we might be relatively straightforward to solve if we become proficient with PencilArrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302:129,interface,interface,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302,1,['interface'],['interface']
Integrability,"Just a minor comment here, default minimum fraction might be 0.2 but we more often use; a smaller value (e.g., 0.1 or smaller). On Wed, Feb 16, 2022 at 06:18:05PM -0800, Gregory L. Wagner wrote:; > > Maybe another doubt, what do we do if the ?? is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?; > ; > We don't mask the partial cells at all. We only mask cells that are fully immersed.; > ; > There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118:897,Message,Message,897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118,1,['Message'],['Message']
Integrability,"Just a quick thought: mathematically it sometimes makes sense to use boundary conditions to reduce the size of the function space a variable can live in, i.e. considering a certain field to be in the space of functions that have zero value (or zero normal derivative) at a boundary. Physically, though, I'm not sure this is so useful, since many systems have non-trivial boundary conditions, including nonlinear conditions and conditions involving multiple fields. Then the notion of a certain BC even ""belonging"" to a certain field is a little less clear... you may just have a set of fields that need to collectively satisfy a set of conditions on the boundary. E.g. thermal radiation conditions (heat flux depends nonlinearly on temperature); E.g. nontrivial stress BCs (maybe where viscosity is temperature-dependent, like ice)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260:709,depend,depends,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260,2,['depend'],"['dependent', 'depends']"
Integrability,"Just added BitInformation to the Project.toml, due to dependency on `StatsBase` and `Distributions` this also adds; ```; Updating `~/git/Oceananigans.jl/Project.toml`; [de688a37] + BitInformation v0.6.1; Updating `~/git/Oceananigans.jl/Manifest.toml`; [66dad0bd] + AliasTables v1.1.2; [de688a37] + BitInformation v0.6.1; [49dc2e85] + Calculus v0.5.1; [31c24e10] + Distributions v0.25.108; [fa6b7ba4] + DualNumbers v0.6.8; [1a297f60] + FillArrays v1.11.0; [34004b35] + HypergeometricFunctions v0.3.23; [77ba4419] + NaNMath v1.0.2; [90014a1f] + PDMats v0.11.31; [1fd47b50] + QuadGK v2.9.4; [79098fc4] + Rmath v0.7.1; [2913bbd2] + StatsBase v0.34.3; [4c63d2b9] + StatsFuns v1.3.1; [f50d1b31] + Rmath_jll v0.4.0+0; ```; also why is the Manifest.toml committed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109010873:54,depend,dependency,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109010873,1,['depend'],['dependency']
Integrability,"Just curious if DataAPI, Formatting, SortingAlgorithms, StatsBase, and UnicodePlots are required for this PR? They got added to `Manifest.toml` but no new dependencies were added to `Project.toml`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545644497:155,depend,dependencies,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545644497,1,['depend'],['dependencies']
Integrability,"Just for completeness, what do we think about `pseudomomentum`?. The issue with Stokes ""drift"" is that it implies a ""drifting"" which is not quite the right way to think about how surface waves affect the motion of fluid beneath them. In reality, average momentum (and thus any ""drifting"" that might occur) is imparted by external forces (such as the atmosphere); the averaged effect of surface waves is rather more subtle and is associated with changes to the relationship between mean momentum and vorticity (eg, vorticity feels the effect of pseudomomentum, despite that momentum does not). These concepts are confused routinely in the literature, so our community doesn't have a solid conceptual foundation on which standardized terminology is easily built. But suffice to say that in practice most people say ""Stokes drift"" but mean ""pseudomomentum"". In the context of Oceanagnians of course the prognostic variable _is_ the mean momentum (the Lagrangian-mean velocity field), thus this keyword really does control psuedomomentum with no impact on ""drifting""...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818:621,rout,routinely,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818,1,['rout'],['routinely']
Integrability,"Just for completion, I realized I posted a bug in the first message but not the code that generates it. Sorry! So below is a way to reproduce it. The error emerges because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::Vertically",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:60,message,message,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,2,"['message', 'rout']","['message', 'routine']"
Integrability,Just included it here: https://github.com/CliMA/Oceananigans.jl/pull/1193. This is my first time contributing so hopefully I followed the right protocol!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732299454:144,protocol,protocol,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732299454,1,['protocol'],['protocol']
Integrability,"Just opened a PR with this, we can discuss what's the best approach. > Would users still have to define all three for two-dimensional domains?. Ideally no. I can modify `RegularCartesianGrid` to take this into account. > I understand the benefit in terms of being explicit, but I'm worried there are a lot of use cases in which the origin of the domain is simply unimportant, and the only relevant parameter is the domain extent. The legacy constructor `RegularCartesianGrid(N, L)` can still be used in this case. > Is there any concern about confusion between specifying the domain in terms of bounding cell faces versus cell centers?. I don't think so. When specifying the domain size, you are in effect specifying the location of the first and last face. All cell centers are located strictly between the first and last cell interface. I don't think it makes sense to specify the domain via the cell centers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-541309091:828,interface,interface,828,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-541309091,1,['interface'],['interface']
Integrability,"Just some comments at this point:; * At this point, we have the HydrostaticFreeSurface model working with the split explicit free surface. It would be great to find some time later on to figure out what was going on with the implicit free surface on AMD GPUs (is the issue isolated only to that architecture??) and get this resolved.; * To get everything moved over to KernelAbstractions would constitute a rather large change, something I think @glwagner expressed an interest in avoiding. I'd vote in favor of pushing this change off for future PR's.; * I'm wrapping up a profiling report that includes MI210 and A100 GPU performance; this report will include some recommendations should we be interested in performance improvements on GPU hardware (AMD and Nvidia). This kind of work could also constitute PR's further down the road.; * The main outstanding issue seems to be that we need a platform for testing on AMD GPUs. . It appears the CliMA fork `Project.toml` and `Manifest.toml` have diverged; I'll take a look to see if I can fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147:560,wrap,wrapping,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147,1,['wrap'],['wrapping']
Integrability,"Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget. Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. Thanks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583:216,integrat,integrate,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583,1,['integrat'],['integrate']
Integrability,"Just to be clear, the point of doing this is because you want to use dispatch to write flexible array operations that are agnostic to whether the array is a 'raw' array (like an `Array` or `CuArray`), or some kind of wrapper like an `OffsetArray`. By writing `parent(a)`, you ensure correct behavior on `a` in both cases; you don't need to write new high-level functions for wrappers versus arrays because dispatch is performed at the lower level, where it belongs. With `data` we can use the same logic --- this concept is deployed extensively in PR #463.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350:217,wrap,wrapper,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350,2,['wrap'],"['wrapper', 'wrappers']"
Integrability,Just to clarify that the output was expected (z^aac is an OffsetArray that includes halo points). But I agree a warning would be nice if the length of a coordinate's interfaces does not match the requested cells + 1.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125536496:166,interface,interfaces,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125536496,1,['interface'],['interfaces']
Integrability,"Just to follow on from what @francispoulin wrote, we normally use MPI_Init() at the start and MPI_Finalize() at the end. All code that calls MPI needs to be between these statements. To your question about whether you can call MPI_Init() within MultiArch (or MultiArchitecture), I think the question is whether it would ever be useful to use an MPI routines before calling MultiArch. For example, you can't find out the local rank until you call MPI_Init(). Also, it is good practice to use both MPI_Init() and MPI_Finalize(), so if MPI_Init() is in MultiArch, it leaves the question of where MPI_Finalize() should be. This might be an argument for having them both outside of MultiArch where they are visible to the user.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1067065676:349,rout,routines,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1067065676,1,['rout'],['routines']
Integrability,"Just want to confirm some final steps with @navidcy and @glwagner here to wrap up this PR. At the moment, I believe we just need to put in a method that throws an error for `validate_free_surface` when the architecture is the AMD GPU and the free surface type is implicit free surface. I'm working on putting this in through the extensions (I believe this is the correct spot) and testing this out. Is there anything else, you want to see to get this merged into main ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1967096656:74,wrap,wrap,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1967096656,1,['wrap'],['wrap']
Integrability,Let's regularize the advection schemes in the model constructor and compute grid-dependent parts there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1164472055:81,depend,dependent,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1164472055,1,['depend'],['dependent']
Integrability,"Let's start here with documentation: a three letter superscript indicates the _location_ at which a function or object is defined. There is one letter for each direction x, y, z, in that order. And there are three locations:. * `ᶠ`: stands for ""face"" or ""interface"" with respect to a tracer cell.; * `ᶜ`: stands for ""center"" with respect to a tracer cell; * `ᵃ`: stands for ""any"", which means the operator / object is valid at either faces or interfaces. For example, the x-velocity `u` is located at `Face, Center, Center`. So the grid area (with `x`-normal) defined at `u` locations is `Axᶠᶜᶜ`. Another example is `Δyᶠᶜᵃ`, which is the _grid spacing in y_ defined at `Face, Center, Any`. Such a grid spacing arises in grids that are vertically rectilinear but horizontally-curvilinear (eg a horizontally-curvilinear that is extruded in the `z` direction). A spacing like `Δyᶠᶜᵃ(i, j, k, grid)` returns the distance from the cell center north of the `y`-node at `Face, Center, Any`, to the cell center south of the `y`-node at `Face, Center, Any`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537:255,interface,interface,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537,2,['interface'],"['interface', 'interfaces']"
Integrability,"Let's try to deal with #3238. There are some glitches with the interface that, e.g., @djlikesdjs and @siddharthabishnu have been stumbling upon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1748709615:63,interface,interface,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1748709615,1,['interface'],['interface']
Integrability,Let’s remake the data and get rid of the JLD dependence at the same time.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/322#issuecomment-517083323:45,depend,dependence,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/322#issuecomment-517083323,1,['depend'],['dependence']
Integrability,"Looking at the code for `DistributedIncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Distributed/distributed_incompressible_model.jl#L8-L36. suggests to me that it's important to include `architecture` when constructing `grid`, even for grids that are _device_ independent. Specifically, our `architecture` object combines information about the memory layout and the device that's used for computation (CPU or GPU). `RegularRectilinearGrid` is _device_ independent, but, apparently, is in practice not `architecture` in dependent (because we need to restrict ourselves to knowledge of just a ""local"" grid for local computations). One complication is that, apparently, the pressure solver requires the global grid:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Distributed/distributed_incompressible_model.jl#L40-L41. We'll have to look into that in more detail to understand what needs to be done for that, and for other solvers like the `PreconditionedConjugateGradientSolver`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-880834796:585,depend,dependent,585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-880834796,1,['depend'],['dependent']
Integrability,"Looking at this PR, I think we should make a few structural changes:; * Move `AbstractSchedule` to `Simulations`. This is where it belongs? (not `Utils`); * Make schedules a function of `Simulation`, not `model`. I don't think users really care --- it's just more logical I think this way. It's about homogenizing the Simulation/AbstractModel interface I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3015#issuecomment-1482862799:343,interface,interface,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015#issuecomment-1482862799,1,['interface'],['interface']
Integrability,"Looks good to me. My only question is about the derivation of ``wˢ``, which results from a vertical integration of the analytical functions. Currently this integral is performed under the assumption that ``wˢ`` is zero at large depths, which I clarified in the code:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L213-L215. **Is this the correct assumption here?** It effectively means that ``wˢ`` and its gradients are a maximum at the surface under a depth-decaying Stokes drift, so any horizontal convergence/divergence of Stokes drift manifests a local change in sea surface height:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L248-L250. An alternative would be to set ``wˢ`` to zero at the surface, which would cause ``wˢ`` and its horizontal gradients to reach a maximum at large depths, as the occurrences of ``ûˢ(z)`` above would become ``( ûˢ(z) - ûˢ(0) )``. Essentially, horizontal convergence/divergence would manifest as downwelling/upwelling (rather than SSH changes in the current case). I feel like this approach makes sense for LES setups, but it could cause problems for simulations of the full water column where you don't want direct Stokes drift effects deep in the ocean interior. I'm happy to go forward with this example as is, but the above would be a useful question to answer in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292:100,integrat,integration,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292,1,['integrat'],['integration']
Integrability,"Looks like KernelAbstractions.jl depends on StaticArrays.jl so it was a free dependency I suppose but good to clean up the Project.toml a bit. @navidcy Ah yeah maybe I'm a little too attached to that `weno_nth_order.jl` implementation haha. Been hoping to make it efficient so we can get fast and automatically generated WENO(n) schemes for n = 3, 5, 7, 9, ... (but it can always be fished out of git history of course).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735482050:33,depend,depends,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735482050,2,['depend'],"['dependency', 'depends']"
Integrability,"Looks like `OrderedDict` is part of [DataStructures.jl](https://github.com/JuliaCollections/DataStructures.jl) so we'd be adding a new dependency, although in this case it seems like a good idea (and it's a solid package as it used to be part of `Base`). Order is definitely important so it would be nice to have the option of iterating over diagnostics and accessing them by name if needed. It would be good to have two ways of adding diagnostics or output writers:; 1. `model.diagnostics[:havg_u] = diag` if you want to give it a name.; 2. `push!(model.diagnostics, diag)` when you don't care about giving it a name. Or when you want to `append!` a bunch of diagnostics without worrying about names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-529619838:135,depend,dependency,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-529619838,1,['depend'],['dependency']
Integrability,Looks like a good interface to me. But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?. @liuchihl will test it in our configurations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079:18,interface,interface,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079,1,['interface'],['interface']
Integrability,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:96,depend,dependency,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548,1,['depend'],['dependency']
Integrability,"Looks pretty good! A 1% violation in the BCs due to the projection seems; reasonable (as in - I would think something had gone wrong if it was 20%).; This is expected due to the issues we discussed on Zoom. While it will; certainly impact force predictions and the near wall solution slightly, the; impact should be fairly minor and might be controlled by a second BC; enforcement and projection step. The characteristics of the pressure solution within the body are; nonphysical, and so down entirely to the implementation of the pressure; solver. My guess is that the asymmetry is due to an index sweep in the; solver smearing this error ahead of itself. Is the solution outside the; body perfectly symmetric?. Gabriel D Weymouth; _______________________________________________; ""Computers are useless. They can only give you answers."" Pablo Picasso. On Fri, Dec 4, 2020 at 12:08 AM Chris Hill <notifications@github.com> wrote:. > @wenegrat <https://github.com/wenegrat> and @whitleyv; > <https://github.com/whitleyv> sounds good - is the angle dependence maybe; > due to time dependence of flow, does it move around as the flow changes?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738463407>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AADSKJZWCFPECYN4I4ZBG2DSTAR6HANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738638208:1048,depend,dependence,1048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738638208,2,['depend'],['dependence']
Integrability,"Maybe just to help you could explain the reason why `Models` should depend on `Distributed`?. In reality I think models shouldn't know anything about `architecture`. I think ideally we write architecture-agnostic code, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594129:68,depend,depend,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594129,1,['depend'],['depend']
Integrability,"Maybe the following papers might interest you. We implemented an ALE type of grid but where the regridding is wrapped into the definition of the ""vertical"" velocity (actually velocity relative to the moving grid). In this way it is very ""easy"" to keep conservation valid and if desired be close to isopycnal calculations (keeping w small). https://orbi.uliege.be/handle/2268/4295; https://orbi.uliege.be/handle/2268/8322; https://orbi.uliege.be/handle/2268/92087",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839672324:110,wrap,wrapped,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839672324,1,['wrap'],['wrapped']
Integrability,Might be able to wrap each example in a module within the temporary modified script that we use to run the test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/424#issuecomment-533777659:17,wrap,wrap,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/424#issuecomment-533777659,1,['wrap'],['wrap']
Integrability,Might make sense to include a diffusive term too? The second-order fluxes are crucial and usually mediate how boundary conditions are prescribed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874238564:98,mediat,mediate,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874238564,1,['mediat'],['mediate']
Integrability,"More generally though, we do need to design a function-based user interface for extracting grid metrics from any grid. This does not exist and it's not sustainable to access grid properties directly by writing things like `grid.Δzᵃᵃᶠ`. This method will also produce incorrect results for immersed boundaries that modify grid metrics, such as `PartialCellBottom` and a hypothetical cut-cell implemenation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722:66,interface,interface,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722,1,['interface'],['interface']
Integrability,"My feeling is that if you want to write NetCDF files through the HDF API that it will be more work, though I never tried. Regarding NetCDF.jl & NCDatasets.jl, I feel that the statements in the OP that NetCDF.jl is not being maintained and that NCDatasets.jl grew out of bugs not being fixed is are a bit of a misrepresentation. For installations and dependency reduction, hopefully the new HDF5 release, which will for the first time support cross compilation, will lead to HDF5.jl switching to BinaryBuilder, which will allow NetCDF.jl to do the same. Also with the Clang.jl improvements we can regenerate the bindings. I still hope that NetCDFand NCDatasets will be able to share more code in the future, and be mainly about exposing different user facing APIs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475809330:350,depend,dependency,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475809330,1,['depend'],['dependency']
Integrability,"My issue with changing the code (if I understand what you guys are proposing) is that it negatively impacts other aspects of the code. For example, right now this plays nice with the Coriolis parameter definition on a tilted/rotated domain. Currently we can model a domain tilt with. ```julia; buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=ĝ); coriolis = ConstantCartesianCoriolis(f=params.f₀, rotation_axis=ĝ); ```; which makes for a really seamless and simple user interface. It wouldn't be as nice if we flipped the unit vector for buoyancy in the code. Also we'd need to define another direction in addition to `ZDirection()` that would replace it as the default for the unit vector. It'd probably be something more verbose like `NegativeZDirection()` or `AntiparallelZDirection()`. (The default for `ConstantCartesianCoriolis` would still be `ZDirection()` though.). By changing `gravity_unit_vector` to `buoyancy_unit_vector` (or whatever other word we decide) we only need to change one thing and it doesn't add any verbosity to the code/interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028:487,interface,interface,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028,2,['interface'],['interface']
Integrability,"My mistake, we can remove this dependency",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2517#issuecomment-1118111898:31,depend,dependency,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517#issuecomment-1118111898,1,['depend'],['dependency']
Integrability,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:339,message,message,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645,1,['message'],['message']
Integrability,"My two cents:. > TODO list (some we might want to address before merging, some we probably should open issues about):; > ; > 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. In this PR!. > 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. Soon. > 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:447,integrat,integrating,447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333,1,['integrat'],['integrating']
Integrability,"NetCDF.jl (so does NCDatasets.jl) has some heavy dependencies like Conda, CMake, and HDF5 which must be built. Don't think there's any way around this, NetCDF output is a must.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-467101208:49,depend,dependencies,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-467101208,1,['depend'],['dependencies']
Integrability,"Never mind, I rewrote the test to act in the x,y plane with more complicated time-dependent boundary conditions at the top and bottom for u and v. It still works and doesn't require changes to the time stepping (which have been reverted). Will add this to the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518869721:82,depend,dependent,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518869721,1,['depend'],['dependent']
Integrability,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:213,integrat,integration,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720,1,['integrat'],['integration']
Integrability,"Nice! We usually use \nu for viscosity and \kappa for diffusivity --- so should we use \kappa here? You can allow it to depend on x, y, z by writing \nabla \cdot (\kappa \nabla c) without loss of generality (it's also nice to see the divergence operator show up twice I think). Thanks for putting this together...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874259919:120,depend,depend,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874259919,1,['depend'],['depend']
Integrability,"Nice, this is looking pretty good now!. I'm not sure if full or partial cells will always exhibit a form drag that prevents the two solutions from matching. But to investigate this further I think it's warranted to. 1. Check the resolution dependence of the discrepancy; 2. Try partial cells. If there's still a mismatch even with refined resolution, this is a good motivation to pursue cut cells. @simone-silvestri @siddharthabishnu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2258721763:240,depend,dependence,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2258721763,1,['depend'],['dependence']
Integrability,"No worries @jagoosw ! This is a neat application!. It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1251870804:355,rout,routine,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1251870804,1,['rout'],['routine']
Integrability,"Normalizing the different grids would definitely be good if we can do it. I would also add the grid properties. Right now there's also e.g. `grid.Δx` and `grid.Δλᶜᶜᵃ`. > After starting to use `RegularLatitudeLongitudeGrid`, I see that the defualts are quite different, you need to specify latitude, longitude, and z. I guess the main limitation is that the different grids use different coordinates (which have different names). Not sure I see a way around this besides calling `longitude` `x` and `latitude` `y` etc. > Also, there is no topology option at all. Yeah for the `RegularLatitudeLongitudeGrid` the topology depends on the `longitude` bounds. I thought it made sense to make y and z `Bounded` and only make x `Periodic` if `longitude = (-180, 180)`. So then not sure what would happen if a user passes an inconsistent `topology`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1506#issuecomment-805955833:619,depend,depends,619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1506#issuecomment-805955833,1,['depend'],['depends']
Integrability,"Note also that due to our current convention for fields and indexing, the “correct” horizontal average depends on both the field type and the boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519593629:103,depend,depends,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519593629,1,['depend'],['depends']
Integrability,Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791:38,interface,interface,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791,1,['interface'],['interface']
Integrability,"Note: this PR does not touch the algorithm. It only adds a test. Also note that the major component that is different between the CPU and GPU is the poisson solver, and the poisson solver functionality is untouched by both #241 and this PR. Because this PR does not touch the algorithm and only adds a test, we are ensured that this PR is orthogonal to the issue of fixing the GPU tests. In addition, it is unlikely that the bug fixed by #241 is related to the failure of the GPU tests. I would like this PR merged because it will be useful for integrating the turbulence closure functionality into the code, which is what I am working on now. Unless the CPU-GPU difference is associated with the diffusive terms in the solver, the integration of turbulence closures should also be orthogonal to GPU issue. So we can work on both problems at the same time without risking merge conflicts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496232282:545,integrat,integrating,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496232282,2,['integrat'],"['integrating', 'integration']"
Integrability,"OK, I think we wrap up this PR and merge it. The advection tests and what not can be another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1646559753:15,wrap,wrap,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1646559753,1,['wrap'],['wrap']
Integrability,"OK, I'll close this for now then and leave the issue open to remind us to heal the duplicate `R_Earth` that appear in Oceananigans... I like the approach that users should set their constants depending on whatever choices they like. E.g., simulating an ocean in Europe or a fish tank on the top of Everest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632033:192,depend,depending,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632033,1,['depend'],['depending']
Integrability,OK. How about we close this PR and open another on in which we:; - drop the MPICH_jll direct dependency; - add a remark in the docs for how people need to work around that for julia 1.7 + Mac M1s,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112728261:93,depend,dependency,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112728261,1,['depend'],['dependency']
Integrability,"OK. Sorry for not chiming in earlier @francispoulin, but indeed you are correct. The derivation you have for the advective terms of the tracer equation requires, e.g., u at the cell's interfaces. But we don't have those values, as you point out. In a finite volume formulation we only have the cell-averages of u around cells with centers the cell interfaces. But there is a way to reconstruct the value of u @ the interface from knowledge of the cell-averages of ū. This is usually referred as ""Reconstruction"" (section 2 of Shu 2009). I guess the best way to reconstruct u @ interface from all ū's is to take u as the cell average of ū at the particular cell? Have to think a bit on that (and wait for the coffee to kick in), but I guess this holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290:184,interface,interfaces,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290,4,['interface'],"['interface', 'interfaces']"
Integrability,"Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us here would be SMAG and PASI):. ![image](https://github.com/user-attachments/assets/5607d340-d4b4-4405-a0a6-67ed43bfd274). Some quick notes:. - Many tests are failing become I made an ad-hoc modification for now which passes the velocities to `DiffusivityFields()`. I did that because otherwise it was hard to make the model performant and simulations were taking way too long. We can (and should) review this and either come up with a better way to construct the `diffusivity_fields` or make this change separately in another PR, which will require changing the other models too.; - I'm updating the dynamic model once every 5 time steps only (this is user-defined). This is common practice for dynamic models since their cost is significantly higher than that of constant Smag or even AMD. With that practice, the dynamic model is taking about 3 times longer to run than the constant Smagorinsky. It does take significantly longer to compile (I haven't timed it). I believe there might be some optimizations still on the table though.; - I also found that the precise value of the Smag coefficient calculated via the dynamic procedure is dependent on the advection scheme, with WENO generally leading to smaller values. In hindsight, I think that's not surprising though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667:3137,depend,dependent,3137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667,1,['depend'],['dependent']
Integrability,"Oh lol, didn't even realize we already coded up a `fieldtype` function. I'll make a commit cleaning that up. It's used in a lot of places so sounds like we should redefine it to be; ```julia; fieldtype(f::Field) = typeof(u).name.wrapper; ```; and change `field_type = typeof(u).name.wrapper` to `field_type = fieldtype(u)`. For the deepening mixed layer example, sounds like we just need to test that the model setup works in which it should go in `test_models.jl`? If it's going to be time stepped, then that's either a dynamics test or a regression test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519524959:229,wrap,wrapper,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519524959,2,['wrap'],['wrapper']
Integrability,Oh no problem. I think there could even be more than one PR. First we just want to show that we can build a latitude longitude grid using OSSG. next we can test dynamics on OSSG and make sure its identical (that's a better test than just visualizing a splash). Then we can design a user interface that makes it easy to build latitdue longitude grid or any other grid on OSSG. Then we can deprecate latitude longitude grid. So there's a lot of ways to break it up. I just thought if OSSG works it'd be nice to demonstrate by running a case on lat lon grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519:287,interface,interface,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519,1,['interface'],['interface']
Integrability,"Ok @hdrake @liuchihl I have added the option to include or not the background field when computing closure fluxes. They are noit included by default. If you want to include them you need to build the `BackgroundFields` explicitly by writing something like. ```julia; background_fields = BackgroundFields(; background_closure_fluxes=true, b=B); ```. where `B` is the background buoyancy field as before. Then pass this to the model constructor instead of passing a `NamedTuple`. Let me know if this seems like a good interface and also if it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204097954:516,interface,interface,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204097954,1,['interface'],['interface']
Integrability,"Ok I have a new proposal:. Eliminate the `Buoyancy` wrapper, and instead implement a new ""optional"" wrapper called ""RotatedBuoyancy"" or something like that, which is _only_ used when buoyancy is rotated. I think this is nice because for the majority of users who don't want to rotate buoyancy, they don't have to deal with the extra layer of indirection that `Buoyancy` currently introduces. For those users who want to rotate gravity, well, they know what they are doing. This is a better API because users get out what they put in (ie the keyword `buoyancy = ...` corresponds to `model.buoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982:52,wrap,wrapper,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982,2,['wrap'],['wrapper']
Integrability,"Ok better idea. The _first_ time that time-step wizard is called as a callback, it can call into a function like `validate_CFL(model, cfl)`. . Then model developers can implement that function if they would like to warn users. Since it's called at iteration 0, the warning is prominent. Moreover, the warning can be made specific depending on the type of model and time-stepper being used, so we can be more sure that we are giving accurate and relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697334830:330,depend,depending,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697334830,1,['depend'],['depending']
Integrability,Ok two PRs that this depends on now: #3311 and #3314 . I'll mark as draft to indicate that this is on hold for a little,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1751137602:21,depend,depends,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1751137602,1,['depend'],['depends']
Integrability,"Ok you convinced me with the `print`. Better to use @navidcy's solution. On the other hand it feels a little clunky, so maybe we can define a `nameof` function which returns `string(typeof(scheme1).name.wrapper)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986811289:203,wrap,wrapper,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986811289,1,['wrap'],['wrapper']
Integrability,"Ok, I added a field `solution` to `ShallowWaterModel` and got rid of the other fields. I also added a file `src/Models/IncompressibleModels/set_incompressible_model.jl` and `src/Models/ShallowWaterModels/set_shallow_water_model.jl` in the appropriate locations with the model-specific `set!` definitions. I have also added some basic tests, and a new test group `shallow_water`. The tests can be run by typing. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; ```. I also generalized `IsotropicDiffusivity` to work for `ShallowWaterModels`. It'd be nice to generalize hyperdiffusion as well. @francispoulin take a look and let me know what you think. I think before merging we should clean up the `ShallowWaterModels` directory. We can keep the timestepper files (though these are not used, so we could also remove them...). But we should remove the scripts from the source code. I suggest we focus on putting a test suite together that builds up to integration tests; once we have a full integration test (perhaps a PR or two away) we'll be ready to write a script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-730331821:975,integrat,integration,975,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-730331821,2,['integrat'],['integration']
Integrability,"Ok, I was a bit unsure which CFL definition is the best, so I checked the 2D stability and I got a slightly better proof. ; Let's start with the discretized version of the 2D advection equation (forward euler and 2nd order centered finite volume on a staggered regular cartesian grid) ; $$\frac{c^{n+1} - c^n}{\Delta t} = u \left( \frac{c^n_i - c^n_{i-1}}{\Delta x}\right) + v \left( \frac{c^n_j - c^n_{j-1}}{\Delta y}\right)$$ ; Let's assume that c is a two-dimensional wave depending on an x wavenumber $\kappa$, a y wavenumber $\mathcal{l}$, and a time-dependent amplification factor $\xi(t)$, then; $c^n_{ij} = \xi^n \exp{(- \Im \kappa \cdot i \Delta x - \Im \mathcal{l} \cdot j \Delta y)}$. (because of overlap with the x-index $i$, I defined $\Im$ as the imaginary number $\Im = \sqrt{-1}$); Substituting this definition of $c$ and dividing through by $c^n_{ij}$ we get; $$\frac{\xi^{n+1} / \xi^n - 1}{\Delta t} = u \left(\frac{1 - \exp{(- \Im \kappa \Delta x)}}{\Delta x}\right) + v \left(\frac{1 - \exp{(- \Im \mathcal{l} \Delta y)}}{\\Delta y}\right)$$; we can make use of $\exp{\Im \theta} = \cos{\theta} + \Im \sin{\theta}$ and rewrite a bit:; $$\frac{\xi^{n+1}}{\xi^n} = 1 + \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} + \Im \sin{\kappa\Delta x}\right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} + \Im \sin{\mathcal{l} \Delta y} \right) \right]$$; Now, to ensure stability, the real part of $\xi^{n+1} / \xi^n$ should be bounded, so we have to ensure that; $$\left| \Re \left( \frac{\xi^{n+1}}{\xi^n} \right) \right| < 1$$; This yields; $$-2 < \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 0$$; The right inequality does not limit $\Delta t$, but the left does:; $$\Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 2$$; T",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511:476,depend,depending,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511,2,['depend'],"['dependent', 'depending']"
Integrability,"Ok, I'll open a PR that refactors the interface for file splitting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066:38,interface,interface,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066,1,['interface'],['interface']
Integrability,"Ok, fixed an issue dispatching on a grid with partial cells in the hydrostatic pressure integral (turns out things go very wrong if we naively integrate to find hydrostatic pressure with partial cells!) here: https://github.com/CliMA/Oceananigans.jl/pull/2306/commits/9cc91dafe140ce4d5124a4d80e8a35496e45ad7e. Things look ok now, and a resting ocean remains at rest:. <img width=""598"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/166724316-df8cd89e-aed3-4027-b0fa-60cec7ad44ac.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307:143,integrat,integrate,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307,1,['integrat'],['integrate']
Integrability,"Ok, good to know. But I think the strategy we use to distribute work should depend specifically on how much each example costs. So the optimal strategy for this code might be different than on the other PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583216547:76,depend,depend,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583216547,1,['depend'],['depend']
Integrability,"Ok, let me take a look. That synchronize should not be necessary. Also this seems weird as . https://github.com/JuliaGPU/KernelAbstractions.jl/blob/5a30f7332e5190247742fa671a01724ae2ef254a/src/cpu.jl#L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514637231:29,synchroniz,synchronize,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514637231,1,['synchroniz'],['synchronize']
Integrability,"Ok, then we need to think about the user interface. We could add a keyword argument `output_grid` to the output writer, or perhaps a positional argument as in. ```julia; JLD2OutputWriter(model, outputs, grid; kw...); ```. I think a feature that might be useful for implementing this feature is an `InterpolatedField`, which looks something like. ```julia; struct InterpolatedField; grid; data; interpoland; end. function compute!(interp::InterpolatedField); compute!(interp.interpoland); interpolate!(interp, interp.interpoland); return interp; end; ```. Then we could use this feature in `construct_output`:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_construction.jl. and maybe elsewhere. This is a chunk of work of course. I don't need it right now personally.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033135677:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033135677,1,['interface'],['interface']
Integrability,"Ok, this change doesn't work because we actually pass the `closure` and `buoyancy` to `apply_flux_bcs!`, right now:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl#L42-L43. This is for models like CATKE that have boundary conditions which depend on the closure... which extend `getbc`... https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/tke_top_boundary_condition.jl#L19-L20. So I think to make this change we also need to generalize the implementation of `DiscreteBoundaryFunction`. We would need to have a type that indicates whether or not we should somehow truncate the `args` that are passed to `fill_halo_regions!` (in that generalization, the pattern on `main` would be the special case that all the args after the first 2 are discarded). ## Nota bene. A different solution one might invent would _copy_ `model.closure` and `model.buoyancy` into CATKE's `TKETopBoundaryConditionParameters`. The reason this doesn't work is that we support _changing_ the parameters of `model.closure` after creating the model. (This is a nifty feature that makes calibration a lot more efficient.) This means that we always need to get the closure parameters from `model.closure` to be consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780:366,depend,depend,366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780,1,['depend'],['depend']
Integrability,"Okay so indeed I think this issue only happens due to poor resolution of the initial noise. I cooked up a MWE where I fixed the random seed, then used that to sprinkle 256 Gaussians (that are also horizontally periodic) throughout the domain. I did this because I wanted to have the ""same noise"", but change it from being under-resolved to well-resolved. I ran this for a few cases ranging from poorly resolved (1 to 2 grid-points per gaussian) to well-resolved (about 8 grid-points per gaussian). I'm plotting three of the animations I got in order or increasing resolution (2, 4, and 8 grid-points per gaussian):. https://user-images.githubusercontent.com/13205162/224089407-ee82f95f-1c71-4857-b69b-745ae20749f6.mp4. https://user-images.githubusercontent.com/13205162/224089438-a49d7c94-391c-4f5d-b4ac-fb658ea672c3.mp4. https://user-images.githubusercontent.com/13205162/224089523-5e485a2b-b7b4-4eb6-b793-e1123345eebc.mp4. We can clearly see that the odd behavior decreases and then finally goes away as we start resolving the initial fluctuations more and more. Some things caught my eye here though. Firstly, this is an example of the long-time solution depending on the initial conditions, which is really odd to me. Although I guess I shouldn't be so surprised, since this isn't physical turbulence, it's something else (and it's poorly resolved), but still I think it's interesting. Also as the time progresses, even in the most resolved simulation, some grid-scale noise starts to emerge (which probably has to do with the advection scheme?). However, this grid-scale noise, contrary to the _initial_ grid-scale noise, doesn't cause any trouble. I wonder why... In any case, @glwagner please feel free to convert this issue to a discussion and thanks for the help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712:1158,depend,depending,1158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712,1,['depend'],['depending']
Integrability,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310:936,message,message,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310,1,['message'],['message']
Integrability,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:507,integrat,integrate,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793,1,['integrat'],['integrate']
Integrability,"On Julia < 1.9 you need requires [which is standard practice by extension packages], if Oceananigans enforces 1.9+, it's not necessary. Wasn't sure so added both here, and you can remove the requires dependency if desired.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1755997748:200,depend,dependency,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1755997748,1,['depend'],['dependency']
Integrability,"On a different note, if a `BackgroundField` is time dependent then evaluating it at every time step makes sense. But if it's time independent, as in this case, then it's working a lot more than it should. Would it be of interest to have an option for it to not compute it at every time? I am not suggesting this be done for this problem, but thinking more in the future",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875002687:52,depend,dependent,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875002687,1,['depend'],['dependent']
Integrability,"On codecov --- the recent for the poor marks is because we basically will not test `Computation`. This makes sense as we are having trouble with CI and we also want to nuke these features. However, the NetCDFOutput writer still has some functionality that uses `Average` (which in turn has an interface to `Computation`) so I'm not sure we can get rid of them just yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-691033697:293,interface,interface,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-691033697,1,['interface'],['interface']
Integrability,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:12,interface,interface,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342,1,['interface'],['interface']
Integrability,"One remaining question is a user interface for extracting viscosities and diffusivities, especially when we have closure tuples. I think we want a function based interface. Take for example the case. ```julia; closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=1.05e-6, κ=1e-7)); ```. We could have some API functions that look like. ```julia; viscosity(model) # returns 1.05e-6 + νₑ; diffusivity(model, :b) # returns 1e-7 + κₑ; diffusivities(model) # returns a named tuple with all tracer diffusivities; ```. This could work if _all_ closures are _either_ `AbstractScalarDiffusivity` or `AbstractBiharmonicDiffusivity`. For models with heterogeneous closures we need a bit more. For example with. ```julia; closure = (HorizontalScalarBiharmonicDiffusivity(ν=1e2, κ=1e1), CATKEVerticalDiffusivity()); ```. we might have something like. ```julia; viscosity(closure[1], model); viscosity(closure[2], model); ```. which returns the viscosity associated with `closure[n]` (here, either biharmonic diffusivity or CATKE's nonlinear diffusivity). The issue is that we don't want users picking apart `model.diffusivity_fields` since this will make scripts more fragile, prone to breakage when code changes, and difficult to understand. (I also think we need to change this to `closure_fields` at some point). . Thoughts or other ideas? @navidcy @tomchor @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050:33,interface,interface,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050,2,['interface'],['interface']
Integrability,"Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088:150,message,message,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088,1,['message'],['message']
Integrability,"Or perhaps write a separate `euler_step!` that does not depend on special values of `χ`. Not sure if that would have an extra GPU cost. But even if so, it'll only be for one time-step, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046318516:56,depend,depend,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046318516,1,['depend'],['depend']
Integrability,Or we can rename the grid metric operation to `dx`? Just want to make sure we consider all options. I think in our original discussion we voted for `xspacings` in the user interface for verbosity. If that's priority 1 then I agree it motivates also replacing `Δx` with `xspacing`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468307924:172,interface,interface,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468307924,1,['interface'],['interface']
Integrability,"Other names:. * `bc.get`; * `bc.specification`; * ... ?. > Agree that CoordinateBoundaryConditions might be a weird name but yeah, maximum flexibility would be very powerful. Maybe the common use case isn't to impose each of the 30 boundary conditions one-by-one but we can just have nice helper functions/abstractions. precisely, and I like the syntax you propose. We can do lots of stuff here to make our user's lives easy. There are two issues: the backend, and the user interface. Maybe the title of this PR is confusing, because I think it's primarily about the backend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472249269:474,interface,interface,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472249269,1,['interface'],['interface']
Integrability,"Ouch! Maybe we should fix the seed. And reduce the time step to 0.1 or something so it doens't fall exactly on the bleeding edge of possibility, depending on the whims of `rand`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3538#issuecomment-2038116846:145,depend,depending,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3538#issuecomment-2038116846,1,['depend'],['depending']
Integrability,"Our finite volume numerical method does *not* enforce gradients or values of fields. The numerical method we use solves the weak form of the equations. In practice, we infer *fluxes* from the user-prescribed boundary conditions, and ensure that the volume-integrated budget for each field is locally conserved. A separate issue is the distinction between direct numerical simulation and large eddy simulation of fluids. In direct numerical simulation, all scales of motion are resolved, down to the smallest scales of motion where fields are smooth due to the action of molecular diffusion. Thus in direct numerical simulation, we expect fields to smoothly vary at the grid scale, which further implies that the volume-averaged values of fields adjacent to boundaries will be *close* to satisfying the boundary conditions. Note that the values of fields still will not be exactly equal to the boundary conditions. For example, the cell-averaged velocity field adjacent to a no-slip wall is *not* zero --- it is just small. In large eddy simulation, a possibly infinite range of scales is *unresolved* by the numerical solution, depending on the ratio between the grid scale and the Kolmogorov scale below which molecular diffusion dominates. For example, a typical oceanic boundary layer simulation might have a grid resolution of 0.5 m, whereas the Kolmogorov scale can be as small as 0.1 mm (or less, especially close to boundaries). Thus a large fraction of the flow structure is unresolved on a coarse 0.5 m grid. More importantly, there is no *physical* reason to expect that *resolved* LES fields, which should be interpreted as some ""filtered"" version of the exact solution, are smooth at the grid scale. Due to this, a ""no-flux"" or ""zero gradient"" boundary conditions does not guarantee that the gradient of a field is zero across any boundary-adjacent region. Because we do not enforce gradients or values of fields at boundaries, and because coarse LES does not guarantee smoothness of field",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/540#issuecomment-572075975:256,integrat,integrated,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/540#issuecomment-572075975,1,['integrat'],['integrated']
Integrability,"Output needs to be arbitrary. We may need to perform on-line analysis and output the result (example: turbulent dissipation rate, time-averages, slices of fields, point values, etc). We should design an additional interface for Fields. The type of the field indicates the coordinates on which the field is defined, so we should design an interface that uses that information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/93#issuecomment-468290310:214,interface,interface,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/93#issuecomment-468290310,2,['interface'],['interface']
Integrability,"PU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1994,depend,depends,1994,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['depend'],['depends']
Integrability,"Pasting the error message would be helpful for debugging this issue. One way around that should work for `VerticallyStretchedRectilinearGrid` and also curvilinear grids is to use `accurate_cell_advection_timescale`. `TimeStepWizard` accepts the `cell_advection_timescale` function as a keyword argument in its constructor. So. ```julia; using Oceananigans.Diagnostics: accurate_cell_advection_timescale. wizard = TimeStepWizard(cell_advection_timescale = accurate_cell_advection_timescale, other_kwargs...); ```. might work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-862688333:18,message,message,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-862688333,1,['message'],['message']
Integrability,"Perhaps I can chime in here to give some context. Something in the Oceananigans/KA/Enzyme/etc setup was breaking our integration test of the advection-diffusion (https://github.com/CliMA/Oceananigans.jl/pull/3480) which was blocking us for making progress for some time. Eventually Joe successfully minimized it down to this point as a minimal error (effectively just testing successful AD of Oceanigans.Utils.launch!, which was failing). We later determined the root cause of the issue to be a problem in KA (https://github.com/JuliaGPU/KernelAbstractions.jl/pull/476). The purpose of this is not to specifically act as a unit test for the individual KA issue, but to be a small unit test for Oceananigans modified launching infrastructure. That way if something else comes up as a bug in a future integration test, we can quickly find the root cause without weeks of debugging from the whole integration test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106054020:117,integrat,integration,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106054020,3,['integrat'],['integration']
Integrability,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679:167,depend,depend,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679,1,['depend'],['depend']
Integrability,"Picking up some of the discussion in #858 , we may want to adopt a more hierarchical approach to `ReducedField`s than suggested by the above comments. A more bare-bones implementation of a `ReducedField` would be. ```julia; struct ReducedField{X, Y, Z, A, G, N} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; dims :: NTuple{N, Int}; end. @propagate_inbounds getindex(r::ReducedField{Nothing, Y, Z}, i, j, k) where {Y, Z} = r.data[j, k]; @propagate_inbounds getindex(r::ReducedField{X, Nothing, Z}, i, j, k) where {X, Z} = r.data[i, k]; @propagate_inbounds getindex(r::ReducedField{X, Y, Nothing}, i, j, k) where {X, Y} = r.data[i, j]. @propagate_inbounds getindex(r::ReducedField{X, Nothing, Nothing}, i, j, k) where X = r.data[i]; @propagate_inbounds getindex(r::ReducedField{Nothing, Y, Nothing}, i, j, k) where Y = r.data[j]; @propagate_inbounds getindex(r::ReducedField{Nothing, Nothing, Z}, i, j, k) where Z = r.data[k]; ```. We can then provide further wrappers around `ReducedField` that specify the computation that generates `ReducedField.data`. We only support one of these right now (an average), so we'd only need something like `AveragedField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-674392343:971,wrap,wrappers,971,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525#issuecomment-674392343,1,['wrap'],['wrappers']
Integrability,"Playing around with an internal wave test case I think we actually need todo something more like the adaptive boundary described in section 4.1 of this paper https://doi.org/10.1016/S1463-5003(00)00013-5 as I have come across two problems: when the flow is directed out of the domain on a prescribed interface (e.g. u = cos(pi/h(z+h)) then information can't get out, and on the ""Orlanski"" side where information is travelling into the domain I am getting instability as it is just keeping the boundary value constant which by default is zero. This might present some more user interface issues as it is going to require us to set a ""known"" value on every open boundary unless we're confident that the flow will only be leaving.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155:300,interface,interface,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155,2,['interface'],['interface']
Integrability,"Please could someone rerun the failed tests, I don't think they've actually failed from what I can tell from the error messages",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2019249485:119,message,messages,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2019249485,1,['message'],['messages']
Integrability,"Posted from a slack conversation... I’ll try to clarify what we found for @francispoulin and @tomchor, if I understand correctly what was happening. I think @tomchor was. 1. Initializing a velocity field using set!(model, …); 2. Constructing a computed field ∂z_u = ComputedField(∂z(model.velocities.u)); 3. Evaluating the computed field via compute!(∂z_u); 4. Plotting ∂z_u and noticing that it’s wrong on boundaries. The reason why ∂z_u is wrong on boundaries is because the vertical derivative of u is calcaluated with a second-order difference that spans the boundary, and thus depends on “halo points” that are outside the physical domain. In Oceananigans, we use halo points to enforce Periodic, Value and Gradient boundary conditions, and will eventually use them for parallelization. If ∂z_u were calculated during a simulation, the halo points of u would be filled. However, in this case ∂z_u was evaluated before invoking run!As a result, the halo points of u were not filled, and thus ∂z_u was wrong on boundaries.; One fix for this mentioned by @alir is to fill the halo points “manually” by calling fill_halo_regions(u, CPU()) after invoking `set!`. This will work provided that u does not have function boundary conditions. If the boundary conditions of u depend on other model fields or the simulation time, this will fail. The code that fills halo regions is here: https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Models/IncompressibleModels/update_incompressible_model_state.jl#L15-L16. The “real” fix for this (a more generic solution that doesn’t require magical incantations in user scripts), however, is to fill_halo_regions! within set!. In fact, an even better solution is to call update_state!(model) at the end of set!. This way nonlinear diffusivities and hydrostatic pressure are also correct. We have also discussed projecting the velocity field onto an incompressible field within set!. We could make all these changes in one PR p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131:582,depend,depends,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131,1,['depend'],['depends']
Integrability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:633,depend,depended,633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006,1,['depend'],['depended']
Integrability,"Probably the easiest thing to do is to fork `LambertW.jl` and remove that warning. The rest seems ok, though a max iterations of 1000 seems a bit high if you want performance. It depends what you want, but as a hack you can return a NaN upon non-convergence rather than throwing a warning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904993244:179,depend,depends,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904993244,1,['depend'],['depends']
Integrability,"Profiling is a very good idea. It probably makes sense to use an integrated / application profiler (rather than simply timing functions), because WENO5 is itself composed of many small functions and we don't know which one is the bottleneck. I have never tried profiling on the GPU, but there's some info here: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/. Specifically I think we need to install NSight: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/#NVIDIA-Nsight-Systems",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956:65,integrat,integrated,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956,1,['integrat'],['integrated']
Integrability,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:37,interface,interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675,1,['interface'],['interface']
Integrability,Reading through the error message again I'm not sure its what I thought.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853:26,message,message,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853,1,['message'],['message']
Integrability,"Reductions on FieldTimeSeries are performed individually for each element by constructing two Fields and reducing one into another. Probably, the construction of the individual field is what is causing the loss in performance?; We do not necessarily need to do that, we can just wrap the data in a `ConditionalOperation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322204413:279,wrap,wrap,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322204413,1,['wrap'],['wrap']
Integrability,"Registration pull request created: [JuliaRegistries/General/10105](https://github.com/JuliaRegistries/General/pull/10105). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.24.0 -m ""<description of version>"" 2ae1cbb86f484420dd2233745a5928a00bf6f77d; git push origin v0.24.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/646#issuecomment-591214131:403,interface,interface,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/646#issuecomment-591214131,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/10259](https://github.com/JuliaRegistries/General/pull/10259). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.24.1 -m ""<description of version>"" 042f8cf12928b53b36cfa2a61a6b6a8ec7dc71bc; git push origin v0.24.1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/657#issuecomment-592714394:403,interface,interface,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/657#issuecomment-592714394,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/1174](https://github.com/JuliaRegistries/General/pull/1174). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.6.0 -m ""<description of version>"" b2a98c51816954bf7dff64f8b41c458934c95aaa; git push origin v0.6.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/265#issuecomment-498674364:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/265#issuecomment-498674364,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/1186](https://github.com/JuliaRegistries/General/pull/1186). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.6.1 -m ""<description of version>"" dcfc1bffda169aa80e246d382ad8fceae64ec658; git push origin v0.6.1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/269#issuecomment-498786993:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/269#issuecomment-498786993,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/1209](https://github.com/JuliaRegistries/General/pull/1209). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.6.2 -m ""<description of version>"" 2d9167f5aabb177be6d49208da467aabd1bece4a; git push origin v0.6.2; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/274#issuecomment-499228804:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/274#issuecomment-499228804,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/1644](https://github.com/JuliaRegistries/General/pull/1644). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.7.0 -m ""<description of version>"" 35912dd79a279c0b941cb802f6562fa9809d5ea9; git push origin v0.7.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/299#issuecomment-506907020:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/299#issuecomment-506907020,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/1672](https://github.com/JuliaRegistries/General/pull/1672). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.8.0 -m ""<description of version>"" 8fdff750ee67d41ba3e485819105e3549e774d8a; git push origin v0.8.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/305#issuecomment-507026198:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/305#issuecomment-507026198,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/2421](https://github.com/JuliaRegistries/General/pull/2421). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.9.0 -m ""<description of version>"" ccd312b9535ac93aac15abefbfdafc707d87e55a; git push origin v0.9.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/318#issuecomment-517042456:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/318#issuecomment-517042456,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/2512](https://github.com/JuliaRegistries/General/pull/2512). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.9.1 -m ""<description of version>"" a26da9c932f562241fd96d97bfcc16f3c033e72a; git push origin v0.9.1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/331#issuecomment-518220280:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/331#issuecomment-518220280,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/2551](https://github.com/JuliaRegistries/General/pull/2551). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.9.2 -m ""<description of version>"" c95160f03da7b28b0e850e69acdba7e8a809f9d0; git push origin v0.9.2; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/339#issuecomment-519114673:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/339#issuecomment-519114673,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/2589](https://github.com/JuliaRegistries/General/pull/2589). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.9.3 -m ""<description of version>"" 848edd9cc0f82638866ca200f5c1009fc82c830c; git push origin v0.9.3; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/345#issuecomment-519734487:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/345#issuecomment-519734487,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/3008](https://github.com/JuliaRegistries/General/pull/3008). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.9.4 -m ""<description of version>"" 2fea5908f58d6efae49577fb68526d0844eac7d1; git push origin v0.9.4; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/373#issuecomment-525548433:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/373#issuecomment-525548433,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/3026](https://github.com/JuliaRegistries/General/pull/3026). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.9.5 -m ""<description of version>"" ddfb32ca1b4180a25eefb38f018f37285943c381; git push origin v0.9.5; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/374#issuecomment-525735235:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/374#issuecomment-525735235,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/3054](https://github.com/JuliaRegistries/General/pull/3054). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.10.0 -m ""<description of version>"" a2b7c0e59c2f224f4fc978668cb2b85b45543981; git push origin v0.10.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/384#issuecomment-526232508:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/384#issuecomment-526232508,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/32030](https://github.com/JuliaRegistries/General/pull/32030). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if the [Julia TagBot GitHub Action](https://github.com/marketplace/actions/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.53.1 -m ""<description of version>"" 7682a3df3c65a1a7e1df2bb05d86a8ce033a91ff; git push origin v0.53.1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332:436,interface,interface,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/9559](https://github.com/JuliaRegistries/General/pull/9559). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.22.0 -m ""<description of version>"" 8352e56f5839b23d3441f6f8bd0f297f3e0b508f; git push origin v0.22.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/630#issuecomment-586704550:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/630#issuecomment-586704550,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/964](https://github.com/JuliaRegistries/General/pull/964). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.5.4 -m ""<description of version>"" f262e1879e0b3eca71ed64fdff682dd218ce1674; git push origin v0.5.4; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/235#issuecomment-495585325:399,interface,interface,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/235#issuecomment-495585325,1,['interface'],['interface']
Integrability,"Registration pull request created: [JuliaRegistries/General/9886](https://github.com/JuliaRegistries/General/pull/9886). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.23.0 -m ""<description of version>"" 7b5cc97c18c8cd7dcc7a866312630df511735189; git push origin v0.23.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/638#issuecomment-589898350:401,interface,interface,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/638#issuecomment-589898350,1,['interface'],['interface']
Integrability,"Registration pull request updated: [JuliaRegistries/General/964](https://github.com/JuliaRegistries/General/pull/964). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if [Julia TagBot](https://github.com/apps/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.5.4 -m ""<description of version>"" 1bd203648dd9070574fa08568d1b68bea4fe0590; git push origin v0.5.4; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/235#issuecomment-495586693:399,interface,interface,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/235#issuecomment-495586693,1,['interface'],['interface']
Integrability,"Right --- the core functions cannot allocate memory. Even `@views` may not be best for the final code because it allocates some memory. I would have written the `xderiv` functions, but I wasn't exactly sure how to deal with the staggered grid --- does the differentiation formula depend on whether the variable is stored at cell centers or cell faces?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437202068:280,depend,depend,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437202068,1,['depend'],['depend']
Integrability,"Right, I see. I wonder if we could use a `MovingTimeAverage` that wraps around an `OutputWriter`. I think we probably want to avoid the complexity of weaving together objects in `.diagnostics` and objects in `.output_writers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-585975293:66,wrap,wraps,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-585975293,1,['wrap'],['wraps']
Integrability,"Right, we cannot form operations with reductions. To operate on reductions, we have to wrap them in a `Field`, so that they can be computed, stored, and _then_ used via the stored result. You can write. ```julia; U = Field(Average(model.velocities.u)); U / 2; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347470713:87,wrap,wrap,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347470713,1,['wrap'],['wrap']
Integrability,"Say if we wanted to further modify the forcing function to have second derivatives so that the forcing function looks something like:. $$; (\mu_{0}\exp(z/\lambda) - m)\partial_x(\frac{\partial_y(P)}{T}); $$. where $T$ is possibly dependent on $x$ and $y$, would the code look something like this?. ```; using Oceananigans.Operators: ℑxᶜᵃᵃ, ∂xᶠᶜᶜ, ℑyᵃᶜᵃ, ∂yᶜᶠᶜ. function growing_and_grazing(i, j, k, grid, clock, fields, params) ; z = znode(Center(), Center(), Center(), i, j, k, grid); return (params.μ₀ * exp(z / params.λ) - params.m) * ℑxᶜᵃᵃ(i, j, k, grid, ∂xᶠᶜᶜ, ℑyᵃᶜᵃ(i, j, k, grid, ∂yᶜᶠᶜ, fields.P)/fields.T); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141327558:230,depend,dependent,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141327558,1,['depend'],['dependent']
Integrability,See also #1001 for an important issue about user input to `RegularCartesianGrid` when dimensions are flat. Are there other topology-dependent inputs that we need to think about?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/902#issuecomment-700572903:132,depend,dependent,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/902#issuecomment-700572903,1,['depend'],['dependent']
Integrability,"Seems that 8/10 LES regression tests pass. The `v` fails with AMD while the `w` test fails with Smagorinsky-Lilly... This is pretty consistent across Travis CI (passes on Linux, fails on Mac), Appveyor, and GitLab CI (both CPU and GPU). So it's kind of OS-specific but seems pretty robust across different hardware. But looking at the test log, the errors look fine: `Δv` and `Δw` are no larger than `~1e-13`. I'm wondering if there's a zero entry in `v` and `w` resulting in an expression like `1e-15 ≈ 1e-25`. Both `1e-15` and `1e-25` are close enough to zero for this test, but `≈` would return false. This entry could be closer or further from zero depending on OS and architecture. ```; julia> 1 ≈ 1 + 1e-10; true; julia> 1e-15 ≈ 1e-25; false; ```. Looking at how the regression data was generated, seems like it might have been good to initialize `v` with some noise. But `w=u₀` and it still fails... Rather than regenerating the regression data maybe it'll be good to change the test to check for absolute error by using the `isapprox` function and passing a non-zero `atol`. I can give this a try later this afternoon. ---. ```; Testing oceanic large eddy simulation regression [VerstappenAnisotropicMinimumDissipation, CPU]; [ Info: Δu: min=-1.14728e-13, max=1.62294e-13, mean=-1.09883e-20, absmean=2.12163e-14, std=2.76021e-14; [ Info: Δv: min=-1.5609e-13, max=1.08464e-13, mean=-2.75418e-20, absmean=2.0988e-14, std=2.72286e-14; [ Info: Δw: min=-1.80785e-13, max=1.97494e-13, mean=-1.62683e-19, absmean=3.17569e-14, std=4.27591e-14; [ Info: ΔT: min=-2.73559e-13, max=2.06057e-13, mean=-5.36897e-16, absmean=2.77339e-14, std=3.88347e-14; [ Info: ΔS: min=-1.13687e-13, max=7.81597e-14, mean=1.56125e-17, absmean=1.51424e-14, std=1.96383e-14; Ocean large eddy simulation [CPU]: Test Failed at /Users/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:69; Expression: all(Array(data((checkpointed_model.velocities).v)) .≈ Array(dat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542798712:653,depend,depending,653,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542798712,1,['depend'],['depending']
Integrability,"Shall we extend the `ShallowWaterModel` type to incorporate single- and multi-layer configs? What other properties does a multilayer shallow water type need? The reduced gravities that correspond to each interface is an obvious one... any other?. The number of layers could be a parameter of the type so we can dispatch on it in various methods. E.g.,. ```julia; mutable struct ShallowWaterModel{N, G, A<:AbstractArchitecture, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} <: AbstractModel{TS}; number_of_layers :: Int # Number of fluid layers; grid :: G # Grid of physical points on which `Model` is solved; architecture :: A # Computer `Architecture` on which `Model` is run; clock :: Clock{T} # Tracks iteration number and simulation time of `Model`; gravitational_acceleration :: GR # Gravitational acceleration; reduced_gravitational_acceleration :: RG # Reduced gravitational acceleration between for fluid interfaces; advection :: V # Advection scheme for velocities, mass and tracers; velocities :: U # Velocities in the shallow water model; coriolis :: R # Set of parameters for the background rotation rate of `Model`; forcing :: F # Container for forcing functions defined by the user; closure :: E # Diffusive 'turbulence closure' for all model fields; bathymetry :: B # Bathymetry/Topography for the model; solution :: Q # Container for transports `uh`, `vh`, and height `h`; tracers :: C # Container for tracer fields; diffusivity_fields :: K # Container for turbulent diffusivities; timestepper :: TS # Object containing timestepper fields and parameters; formulation :: FR # Either conservative or vector-invariant. function ShallowWaterModel(number_of_layers, grid, all_other_things...); arch = architecture(grid); return new{number_of_layers, typeof(G), typeof(arch), the_rest_of_parameters...}(number_of_layers, grid, arch, all_other_things...); end; end. const SingleLayerShallowWaterModel{N, G, A, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} = ShallowWaterModel{1, G, A, T, GR, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910:204,interface,interface,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910,2,['interface'],"['interface', 'interfaces']"
Integrability,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:143,integrat,integration,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089,2,['integrat'],['integration']
Integrability,Should we open an issue to discuss interfaces to stretched grids?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814216312:35,interface,interfaces,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814216312,1,['interface'],['interfaces']
Integrability,"Since the code is just a few lines, it's easy to figure out what's going on in the REPL. The top of the error message says:. ```; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35 [inlined]; ```. So let's go look at this line. It is:. https://github.com/CliMA/Oceananigans.jl/blob/f89445dcc802341d5361c2f241fe48e483dbd9ff/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L35. Ok. Does `background_fields` have the property `u`? At the REPL, using the MWE, I find:. ```julia; julia> background_fields.u; ERROR: type BackgroundFields has no field u; Stacktrace:; [1] getproperty(x::Oceananigans.Models.NonhydrostaticModels.BackgroundFields{true, @NamedTuple{…}, @NamedTuple{…}}, f::Symbol); @ Base ./Base.jl:37; [2] top-level scope; @ REPL[7]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Ok, we found the error. But where is `u`? writing `julia> background_fields.` and pressing TAB yields. ```julia; julia> background_fields.; tracers; velocities; ```. Ok, so maybe we want `background_fields.velocities.u`. Looking into the source code for background fields:. https://github.com/CliMA/Oceananigans.jl/blob/f89445dcc802341d5361c2f241fe48e483dbd9ff/src/Models/NonhydrostaticModels/background_fields.jl#L32-L38. confirms what we found, that `BackgroundFields.u` does not exist. Just to confirm, we go back to the REPL and try:. ```julia; julia> background_fields.velocities.u; ZeroField{Int64}; ```. so yes, using `velocities.u` should fix this particular bug. This is an easy fix. Just to go through the motions and get a hang for how this works, let's add the test first, and then make the fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433267716:110,message,message,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433267716,1,['message'],['message']
Integrability,"Since this is such a major change in the interface, I think we should get the docs back up again before registering 0.90 (i.e. fix https://github.com/CliMA/Oceananigans.jl/issues/3191).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1783617373:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1783617373,1,['interface'],['interface']
Integrability,"Since we don't have bitwise reproducibility, each run has random round-off errors that, if integrated into a nonlinear trajectory, can cause two solution to diverge eventually. Possibly this test case is a little too challenging (too long time integration, or too nonlinear), meaning that occasional chaotic divergence of the solution is expected?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430089012:91,integrat,integrated,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430089012,2,['integrat'],"['integrated', 'integration']"
Integrability,"Since we throw away any calculations that are entirely inside a solid, we usually don't care what happens there. I think that's why it's called `solid_interface` rather than `fluid_solid_interface`, but @simone-silvestri can confirm. I think we need a bit more information for boundary conditions right? We have to know the _direction_, eg. ```julia; using Oceananigans.AbstractOperations: flip; east_fluid_solid_interface(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. This returns `true` when our cell is not immersed, but the eastern boundary is a fluid-solid interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047168497:641,interface,interface,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047168497,1,['interface'],['interface']
Integrability,So I added a unit test showing that checks that should test its functionality. Once we get more of Oceananigans differentiated we can add some bigger integration tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531:150,integrat,integration,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531,1,['integrat'],['integration']
Integrability,So I modified this PR to support more general `AbstractTime` clocks. So now clocks work if you pass in a `DateTime` from Base.Dates (with millisecond precision) but also if you pass in a `TimeDate` from TimesDates.jl (with nanosecond precision) as they're both subtypes of `Dates.AbstractTime`. Oceananigans does not need to depend on TimesDates.jl but I added it as a test dependency so we can make sure `TimeDate` always works as I think it will be useful for LESbrary simulations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/632#issuecomment-592961331:325,depend,depend,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/632#issuecomment-592961331,2,['depend'],"['depend', 'dependency']"
Integrability,So I removed `~/.julia` and ran the instantiate before and I got the following output; ```; [45606] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Installing known registries into `~/.julia`; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.2). Unexpected behavior may occur.; └ @ /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Manifest.toml:0; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed Adapt ─────────────────────── v4.0.4; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed SentinelArrays ────────────── v1.4.5; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed Tables ────────────────────── v1.12.0; Installed FixedPointNumbers ─────────── v0.8.5; Installed GPUCompiler ───────────────── v0.26.7; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArraysCore ──────────── v1.4.3; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed StaticArrays ──────────────── v1.9.7; Installed TimerOutputs ──────────────── v0.5.24; Installed AbstractFFTs ──────────────── v1.5.0; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed OrderedCollections ────────── v1.6.3; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed LaT,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:359,depend,dependencies,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['depend'],['dependencies']
Integrability,"So I was able to isolate the issue to the `_permute_index(i, N)` function, and more specifically to the float to int conversion that it does. Something about Casette not being able to overdub a call to `Int64`?. @maleadt @vchuravy Does this error message say anything useful?. Was not able to reproduce in a minimal working example for CUDA.jl or KernelAbstractions.jl unfortunately... I'll open a PR to make this issue a priority. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; @info 1; grid = RegularCartesianGrid(topology=(Periodic, Periodic, Bounded), size=(16, 16, 16), extent=(1, 1, 1)); @info 2; model = IncompressibleModel(architecture=GPU(), grid=grid); @info 3; time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: 1; [ Info: 2; [ Info: 3; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.Cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323:247,message,message,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323,1,['message'],['message']
Integrability,"So depending on how we perceive the importance of this issue we could add docs and an example illustrating this workflow to users, as an alternative to changing the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041158015:3,depend,depending,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041158015,1,['depend'],['depending']
Integrability,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251:717,interface,interface,717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251,2,['interface'],['interface']
Integrability,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:77,synchroniz,synchronize,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808,3,['synchroniz'],"['synchronize', 'synchronizing']"
Integrability,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:144,depend,depend,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830,1,['depend'],['depend']
Integrability,"So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Can you guys give an ETA of long until the Julia 1.6 migration is complete? Looks like it's relatively close but depending on the answer I might need to change my research plans for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912:353,depend,depending,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912,1,['depend'],['depending']
Integrability,"So, I'm hitting some errors running the `baroclinic_adjustment` example with the ROCBackend. The only modification of this example script is the specification of the architecture as `GPU()`. It seems that this chokes on AMDGPU's `zeros`. I did not encounter this in the other work I was doing on Simone's branch; though the test we were using was not building with a recilinear grid. ```; $ julia --project=. ./bench/baroclinic_adjustment.jl ; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:640,interface,interface,640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,1,['interface'],['interface']
Integrability,"So, Ken and I were discussing some set of simulations that would greatly benefit from this. How hard would it be to implement this given the current state of Oceananigans?. > We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:; > http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf. Unless I'm missing something this seems trivial (some good news!). > For this to work properly, we need to modify the pressure solver to work for time-dependent inflows. This seems far from trivial. But I'm assuming this was implemented when you guys implemented cubed sphere capabilities, no?. CC @zhazorken",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934574230:529,depend,dependent,529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934574230,1,['depend'],['dependent']
Integrability,"Some good news is that more tests seem to be passing compared to the prevoius PR. . One of the messages I saw was there was a cancellation signal, see below. Lots of the tests just cancelled, and I'm not sure why. ```; Testing Oceananigans; # Received cancellation signal, interrupting; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1985730877:95,message,messages,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1985730877,1,['message'],['messages']
Integrability,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:313,wrap,wrap,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514,1,['wrap'],['wrap']
Integrability,"Something is not right again. There is a method `validate_closure`; seems like that's the place to put the error message?. My argument is just based on intuition from the method's name. This error seems part of the validation, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749:113,message,message,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749,1,['message'],['message']
Integrability,"Something we might need is a wrapper around output writers, along the lines of. ```julia; struct TimeAveragedOutputWriter{O, WTA}; output_writer :: O; windowed_time_averages :: WTA; end. function TimeAveragedOutputWriter(OutputWriterName, model, kernels; time_window, return_type=Array, output_writer_kwargs...); # construct NamedTuple of WindowedTimeAverage s; OutputWriter = eval(Symbol(OutputWriterName, :OutputWriter)); output_writer = OutputWriter(model, windowed_time_averages; output_writer_kwargs...); return TimeAveragedOutputWriter(output_writer, windowed_time_averages); end; ```. Then users will write. ```julia; U = HorizontalAverage(model.velocities.u); V = HorizontalAverage(model.velocities.v). averages_writer = TimeAveragedOutputWriter(:JLD2, model, (U=U, V=V), time_interval=1hour); ```. A WIP sketch of how we might manage ""diagnostic dependencies"" is by putting a line at the top of `run!(simulation)`:. ```julia; function run!(sim); model = sim.model; clock = model.clock. [add_dependencies!(sim, out) for out in values(sim.output_writers)]; ; # the rest of the code in run! ; ; return nothing; end; ```. where `add_dependencies!` is something like. ```julia; add_dependencies!(sim, out) = nothing. get_dependency(output) = nothing; get_dependency(output::WindowedTimeAverage) = output. function add_dependencies!(sim, writer); for output in writer.outputs; dependency = get_dependency(output); if !isnothing(dependency) && dependency !∈ sim.diagnostics.vals; push!(sim.diagnostics, dependency) ; end ; end . return nothing; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-672336901:29,wrap,wrapper,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-672336901,6,"['depend', 'wrap']","['dependencies', 'dependency', 'wrapper']"
Integrability,Sorry @navidcy I think unit tests were failing due to me removing StaticArrays but `weno_reconstruction.jl` and (`test_weno_reconstruction.jl`) still needed it. Tests should pass now 🤞 . Moving nth order WENO into a draft PR makes sense to me so I've nuked it in this PR so we can get rid of the explicit dependency on StaticArrays. @navidcy Don't think you can restart Buildkite builds right now since @glwagner and I had to be added as Buildkite users (and it's all under some CliMA account). @jakebolewski might know whether it's possible for GitHub collaborators to have some access to Buildkite?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-736950477:305,depend,dependency,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-736950477,1,['depend'],['dependency']
Integrability,"Sorry I didn't realize I didn't get the full error message:; ```; [52922] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129; Allocations: 618273 (Pool: 617476; Big: 797); GC: 1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; The versioninfo gave me the following as output:; ```; Julia Version 1.9.2; Commit e4ee485e90 (2023-07-05 09:39 UTC); Platform Info:; OS: Linux (x86_64-suse-linux); ""openSUSE Leap 15.4""; uname: Linux 5.14.21-150400.24.46-default #1 SMP PREEMPT_DYNAMIC Thu Feb 9 08:38:18 UTC 2023 (2d95137) x86_64 x86_64; CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz: ; speed user nice sys idle irq; #1-72 2600 MHz 922553194 s 727867 s 363212152 s 5414020342 s 0 s; Memory: 370.290340423584 GB (301775.56640625 MB free); Uptime: 9.37897786e6 sec; Load Avg: 13.61 25.96 27.94; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, cascadelake); Threads: 1 on 72 virtual cores; Environment:; LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:51,message,message,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['message'],['message']
Integrability,"Sorry I should have been more verbose. I meant that since the Manifest you pushed doesn't seem to work then I'm not sure I can reproduce the setup you run locally to test things. And that said, I'm not sure whether some errors you point out are because of the code or from a dependency version that is different to what I have on my side etc..",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3470#issuecomment-1937042477:275,depend,dependency,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3470#issuecomment-1937042477,1,['depend'],['dependency']
Integrability,Sorry but I don't quite understand the changes. Could you please post explain a little more? Maybe posting a couple of snipets showing how the interface changed is enough!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813428624:143,interface,interface,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813428624,1,['interface'],['interface']
Integrability,"Sorry but sometimes i must wait a long time to get gpu resources :; I created a TestOcean project with Oceananigans as dependency. I used Julia v1.4; and it works perfectly, thank you very much!. ~~~; module load julia/1.4.0 cuda; cd TestOcean; env JULIA_CUDA_USE_BINARYBUILDER=false julia --project; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; julia> using CUDA; julia> CUDA.has_cuda(); true; julia> using Oceananigans.Architectures: @hascuda; julia> @hascuda ""Hi""; ""Hi""; julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1)); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [-5.496153587253255e-18, 6.283185307179586], y ∈ [-5.496153587253255e-18, 6.283185307179586], z ∈ [-1.0, 1.7080354225002348e-17]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (100, 100, 50); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.06283185307179587, 0.06283185307179587, 0.02). julia> model = IncompressibleModel(architecture=GPU(), grid=grid); IncompressibleModel{GPU, Float64}(time = 0.000 s, iteration = 0) ; ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=100, Ny=100, Nz=50); ├── tracers: (:T, :S); ├── closure: IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}; ├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}; └── coriolis: Nothing. julia> simulation = Simulation(model, Δt=60, stop_time=3600); Simulation{IncompressibleModel{GPU, Float64}}; ├── Model clock: time = 0.000 s, iteration = 0 ; ├── Next time step (Int64): 1.000 min ; ├── Iteration interval: 1; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0.000 s, wall time limit: Inf; ├── Stop time: 1.000 hr, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with no entrie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707702037:119,depend,dependency,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707702037,1,['depend'],['dependency']
Integrability,"Sorry if I jumped the gun on the merge, I thought I saw a message deciding against pseudomomentum but can't find it anymore. To be honest I don't know much about pseudomomentum, so I can't have an informed opinion. I know you can use it when talking about nonbreaking waves, but I, personally, find that nomenclature a little obscure in this context.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778664270:58,message,message,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778664270,1,['message'],['message']
Integrability,"Sorry just approved PR #790 and merged it into master so @glwagner's suggestion should work now. @raphaelouillon Which version of Oceananigans are you currently using? You can check by typing `] status` at the Julia REPL in package mode (which you enter by pressing `]`). You might need to use/depend on the `#master` branch of Oceananigans.jl. If you're not sure how to do so, I think you just type `] add Oceananigans#master` in the Julia REPL in package mode. Let me know if you're still hitting issues!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/789#issuecomment-656942203:294,depend,depend,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789#issuecomment-656942203,1,['depend'],['depend']
Integrability,"Sorry maybe there was a miscommunication. The `output!` interface does not delay creating files until `run!`. . Delaying output initialization to `run!` does not exist. I would like to implement it, however. (In another PR.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393872882:56,interface,interface,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393872882,1,['interface'],['interface']
Integrability,"Sounds great! I've had a discussion with Greg about this before, and which method you need to implement really depends on the application. ; - The ""penalty function"" boundary was the first type proposed historically, but it is completely inappropriate for unsteady flows and will really mess up a turbulent boundary layer evolution.; - Direct forcing methods and other similar approaches go in and set the value of velocity components inside the immersed solid at each time step to satisfy the velocity boundary conditions before or after the projection step. However, you have to choose between enforcing a divergence free velocity and the BC - you can't have both without modifying the pressure Poisson equation. As long as the body isn't moving, the results tend to be fine. The pressure forces will not be time accurate and so dynamic forces will suffer. ; - For fluid structure interaction problems you really need to get those forces right and therefore must modify the pressure equation. . I've attach a write-up one of my students is working on which lays this out with a few simple examples. Section 3 reviews Immersed Boundary methods and 3.1 has a simple 1D FSI example. . [Mr M Lauber_070e4204-4db5-451e-8b61-494f2ae9eaa2_Progression_Report__9_month_pdf_7177_0.pdf](https://github.com/CliMA/Oceananigans.jl/files/5370790/Mr.M.Lauber_070e4204-4db5-451e-8b61-494f2ae9eaa2_Progression_Report__9_month_pdf_7177_0.pdf)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707656163:111,depend,depends,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707656163,1,['depend'],['depends']
Integrability,"Specifically `ifelse(a==1, n, a - 1)`. This should always be faster than `mod`. In ShallowWaterBench, we consciously choose to use OffsetArrays, to avoid any wrap around and implement ghost cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/57#issuecomment-466256607:158,wrap,wrap,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/57#issuecomment-466256607,1,['wrap'],['wrap']
Integrability,"StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub(overdub_context::Cassette.Context, overdub_arguments...) in Cassette at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:595); Stacktrace:; [1] getindex at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/AbstractOperations/binary_operations.jl:34; [2] macro expansion at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/Fields/computed_field.jl:114; [3] gpu__compute! at /glade/u/home/tomasc/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [4] overdub at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, int",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:5126,message,message,5126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['message'],['message']
Integrability,"Stuck with this error:. ```; julia> include(""test_enzyme.jl""); MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.22; MPIPreferences.jl: 0.1.11; MPICH_jll: 4.2.3+0. Library information:; libmpi: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; libmpi dlpath: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version:; MPICH Version: 4.2.3; MPICH Release date: Wed Oct 2 09:35:21 AM CDT 2024; MPICH ABI: 16:3:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --disable-doc --enable-fast=all,O3 --enable-static=no --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features:. Enzyme with CATKEVerticalDiffusivity: Error During Test at /Users/gregorywagner/Projects/Oceananigans.jl/test/test_enzyme.jl:264; Got exception outside of a @test; MethodError: no method matching getindex(::Base.RefValue{Tuple{Base.RefValue{Float64}, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:707,depend,dependency-tracking,707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['depend'],['dependency-tracking']
Integrability,"Summary of latest thoughts:. 1. Change `ParameterizedForcing` to `DiscreteForcing`.; 2. Change `SimpleForcing` to `ContinuousForcing`. Use the field name `ContinuousForcing.func` rather than `ContinuousForcing.forcing`. (This will then be consistent with `DiscreteForcing`.); 3. Change `field_in_signature` to more general a `depends_on` keyword. `ContinuousForcing` functions with dependent fields have the signature `f(x, y, z, t, field1, field2)`, where `depends_on=(:field1, :field2)`.; 4. Use assumed field locations (eg the names `u`, `v`, `w` are special and everything else is a tracer) to infer interpolating functions for the fields in `depends_on`. Move `AbstractOperations/interpolation_utils.jl` to `Operators` so they can be used in `Forcing/`.; 5. Implement a unified interface `Forcing` which permits the construction of both `ContinuousForcing` and `DiscreteForcing`.; 6. Change `ModelForcing` so that ""unwrapped"" inputs `forcing::Function` are automatically wrapped in `ContinuousForcing`. This means that unwrapped forcing functions are assumed to be functions of `x, y, z, t` (rather than a discrete forcing). Users that want to use discrete forcing must wrap their functions via `forcing = Forcing(func, discrete_form=true)`.; 7. Change the constructor for `IncompressibleModel` so that forcing functions are accepted via a `NamedTuple`, similar to boundary conditions. @ali-ramadhan thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/896#issuecomment-698312095:382,depend,dependent,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896#issuecomment-698312095,4,"['depend', 'interface', 'wrap']","['dependent', 'interface', 'wrap', 'wrapped']"
Integrability,"Sure, I ran a simple test using the MWE above without picking up a checkpoint and set:. ```julia; Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); δt = .03 # progress message interval and output saving interval; # Run a simulation; simulation = test_simulation(T1, Δt, δt, true); run!(simulation); ```; I've noticed that this strange behavior occurs when δt is smaller than or equal to 0.03, but it disappears when δt is greater than 0.03 (even at 0.031). It seems there is a cutoff value of δt below which the error emerges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870:184,message,message,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870,1,['message'],['message']
Integrability,"Sure. I'm now working on making plots of convergence and should be able to get that done today. One issue is that I have commented out a lot of stuff, which was there before. I've focused on making the one advection test and haven't integrated it into the other tests, yet. Not sure if this is a problem?. I will create a PR later today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704:233,integrat,integrated,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704,1,['integrat'],['integrated']
Integrability,"Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out if pencil decompositions are possible. ### Local topologies. The local grid topology may need",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:1093,inject,injection,1093,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['inject'],['injection']
Integrability,"TODO list (some we might want to address before merging, some we probably should open issues about):. 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. . 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:403,integrat,integrating,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979,1,['integrat'],['integrating']
Integrability,"Tbh I didn't give it as much thought as you may be implying with your message above :). But I just realized that the ShallowWater example talks about ""equations in conservative form"" and some users may have no idea what we are talking about... Let's see what @glwagner and @ali-ramadhan think on this. Perhaps with the current status of fast development it makes sense to hold on Docs for later..?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798789091:70,message,message,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798789091,1,['message'],['message']
Integrability,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:162,message,message,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962,1,['message'],['message']
Integrability,"Thank you for the written explanation! Here are my comments:. > to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to biogeochemical_transitions - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:501,interface,interface,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,1,['interface'],['interface']
Integrability,"Thank you for your response. The question is: what do *you* use to trace MPI; in Julia programs? Do you use `nsys`? If so, how?. Petr Krysl; Prof. and Vice chair for undergraduate education; Department of Structural Engineering; <https://urldefense.com/v3/__https://www.linkedin.com/company/uc-san-diego-structural-engineering-department/__;!!Mih3wA!DXYUp152SRRo03xCfQJ9NlAXovNVk-zBYRalwekzmzf2bGwdDMmY8gy9t6iQo9ok2_dvk8m987An93w0pnT_6lM$>; University of California, San Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 1:06 AM Simone Silvestri ***@***.***>; wrote:. > Using nsys it is possible to trace MPI with --trace=mpi, see:; > https://docs.nvidia.com/nsight-systems/UserGuide/index.html; > <https://urldefense.com/v3/__https://docs.nvidia.com/nsight-systems/UserGuide/index.html__;!!Mih3wA!H6UjdgIwou7PJs3BrN0sPOwBQpDzgvLSPJe4sfnC3s1yyKC4zguXAXmS7ynhe0PWPbcu93qhzzaGritvlwu8ongn$>; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396207964__;Iw!!Mih3wA!H6UjdgIwou7PJs3BrN0sPOwBQpDzgvLSPJe4sfnC3s1yyKC4zguXAXmS7ynhe0PWPbcu93qhzzaGritvl3gGBEE5$>,; > or unsubscribe; > <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWH3753SQU2FEFPUVW3Z2I6HXAVCNFSM6AAAAABPKAGA5GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGOJWGIYDOOJWGQ__;!!Mih3wA!H6UjdgIwou7PJs3BrN0sPOwBQpDzgvLSPJe4sfnC3s1yyKC4zguXAXmS7ynhe0PWPbcu93qhzzaGritvl1tQs-Dz$>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396865871:1552,Message,Message,1552,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396865871,1,['Message'],['Message']
Integrability,"Thanks @ali-ramadhan, that's helpful. It does seem that `Requires.jl` can solve this issue and satisfies @ali-ramadhan's desire for verticality as mentioned in his comment. We could perhaps isolate the output functionality into a submodule (eg, `Oceananigans.Output`) that is loaded only when `HDF5` (for example) is present. Ditto for `Oceananigans.Plotting`. I've changed the name of the issue to be more descriptive of the general issue we are discussing (heavy dependencies).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-503157682:465,depend,dependencies,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-503157682,1,['depend'],['dependencies']
Integrability,"Thanks @christophernhill ! That google link is a good read. Thanks for sending that. > When done well a PR can be a very helpful record for show what needs to be changed to achieve ""X"". When the PR is polluted with random other stuff that valuable use is lost. Fair criticism. We got a little lazy. > Related to 2. I suspect that trying to express complicated things like hybrid bc's will eventually break reducing bc to a type. Well --- I know this is just an example --- but I should point out that such a boundary condition actually *can* be specified in the code today (in two different ways). This functionality is provided by the fact that we allow a boundary condition to be specified by a user-defined function, which provide fairly wide flexibility in boundary conditions. (If hybrid BCs were popular, we could make it easier to users by designing a wrapper / API for this boundary condition --- but its important that its currently possible for a user to implement this bc if they need to.) So a hybrid BC can be specified by computing the flux associated with the given boundary condition and then using a boundary condition of the type `BoundaryCondition{Flux, Function}`. If the boundary condition involves only `Gradient`/`Value` conditions, then a second way to specify the hybrid bc is via a boundary condition of type `BoundaryCondition{Gradient, Function}`, where the gradient function computes the correct gradient across the boundary for each cell. The second choice would be preferred if knowledge of the gradients of fields across the boundary is needed (which is the case, for example, for computing LES diffusivities). . A crucial aspect of this PR is that is preserves the `calculate_boundary_source_terms!` in the algorithm --- this means that arbitrary boundary conditions that cannot be fulfilled by filling halos can still be implemented (and indeed, a `Flux` boundary condition with LES closure falls into this category). This design choice preserves code extensibility.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-529218438:859,wrap,wrapper,859,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-529218438,1,['wrap'],['wrapper']
Integrability,"Thanks @glwagner and @ali-ramadhan for your suggestions. They all sound very interesting and gives me a lot to think about. Here are my initial reactions. Given that I don't know the numerics of Oceananigans, yet, but know the physics, I can imagine myself contributing to the following pretty quickly:. 1. Shallow Water model (and maybe even a Green-Naghdi version) with several layers for fun.; 2. Layered and stratified Quasi-Geostrophic Model; 3. Hydrostatic Boussinesq Model (rigid lid first and then a free-surface). Something that I can imagine giving to good undergraduate research students would be. 4. Verticall-Implicit time-stepping for diffusion. ; 5. Profiling parallelism. If I had keen student in computer science then maybe . 6. Distributed parallelism with MPI. . I have never used GPU's before but given the efficiency of GPU's vs CPU's that you have in the docs, I am definitely going to learn. Initial thougths on 1 and 2:; I know that FourierFlows has both QG and SW, which are spectrally based. I gather that Oceananigans is Finite Volume based. If I wanted to start with either of these would you suggest I start wtih FourierFlows or ignore that?. I kind of like the idea of having a QG code that can either be FV or Spectral, depending on the users whims, but that might be difficult, depending on how compatable these two libraries are. I suppose I should start in reading the code in detail and planning out what I think needs to be done. Any suggestions are welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151:1251,depend,depending,1251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151,2,['depend'],['depending']
Integrability,"Thanks @glwagner for the help. Much appreciated. I tried to adapt it and the good news is that I don't get an error. The bad news is that I don't think the boundary conditions are being set correctly. . Below are a few ideas of things I think I need to do. Maybe you can confirm whether I understand this correctly?. - You had it set up for the sponge to depend on x but if I want the inflow and outflow to be in the south and north, respectively, then it should depend on `y`, right?; - `smoothed_step_mask` is currently only acting on the south. I pressume I need to add a similar function for the north?; - Do I need to have a sponge on `h` as well? I thought imposing this on `vh` might be enough in the case when the flow doesn't vary in the zonal direction. I imagine if I want inflow from the west only, which I do want, and the meridonal velocity depends on the zonal coordiante, then I should pick the sponge to relax to a geostrophically balanced state.; - Even though I am trying to set the inflow/outflow boundary conditions to `vh -> h` so that `v -> 1`, when I look at the final matrix, I have that `vh` is zero everywhere. This tells me that the boundary conditions are not being set. It does seem to say that `vh` does have `NormalFlow` boundary conditions so that seems like something is right. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size=(64, 64),; x=(-10, 10), y=(0, 5),; topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2); grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). damping_rate = 1/100 # relax fields on a 100 second time-scale; const y0 = 0 # center point of sponge; const dy = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((y - y0) / dy)). vh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935:355,depend,depend,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935,3,['depend'],"['depend', 'depends']"
Integrability,"Thanks @glwagner for the suggestion. Yes, I agree that would be much easier as there is no need to differentiate or integrate. Will think about that. We are specifying a `BackgroundField`, so given the fact that the buoyancy is calculated at every time step and every grid point, then having it precalculated would make more sense. . It occurs to me that if we solve for the buoyancy using array operators at the beginning, then we can specify the`BackgroundField` using arrays. Should that work? I don't know if I have seen how to specify `BackgroundField` as an array but I presume it's like how the turbulence example specifies the initial conditions in terms of an array?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874994583:116,integrat,integrate,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874994583,1,['integrat'],['integrate']
Integrability,"Thanks @glwagner. I certainly don't want to make any changes that would either slow down code or make things harder to maintain. I can't say that I know this is the right direction to go but let me try and articulate what I want to do and maybe you can suggest a direction to proceed?. The basic idea can be found by looking at `shallow_water_Bickley_jet.jl`. In this example we define a `perturbation_norm` in line 134 that computes the norm of `v`. Then in line 158 we define an output_writer to output this norm. There is nothing special about v and I might want to use use `u` as well. To do this requires two steps:. 1. Defining a new analogous function for the perturbation norm of `u`. I'm hoping we can avoid these functions completely with `using Statistics: norm` but I don't know if that's the case.; 2. In line 161 we need to list these two norms. When I tried that there was an error message, and hence what inspired this PR. I don't think this PR needs to happen and there are probably better ways of addressing points 1 and 2. Any advice?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868:897,message,message,897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868,1,['message'],['message']
Integrability,"Thanks @jagoosw and @glwagner for your thoughts on this. @glwagner, the approach to nesting is going to be highly dependent on the particular case. The nesting strategy for a simulation with mesoscale eddies passing across the boundary will be very different from the strategy to nest an LES inside a low resolution simulation. I think that this PR should provide different types of boundary conditions (the 'ingredients') and the user will need to decide how to use them for their particular case (the 'recipe' which will rely on different combinations of the 'ingredients'). Does that make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040092580:114,depend,dependent,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040092580,1,['depend'],['dependent']
Integrability,"Thanks @kburns for the suggestion. I will look at Dedalus to see what they do and learn from them. I don't think we would want to find the full spectrum unless the problem is one-dimensional, but I guess it depends on what we want it to do. Lots of potential here I'm sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731280860:207,depend,depends,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731280860,1,['depend'],['depends']
Integrability,"Thanks @maleadt! Upgrading to v5 fixed things and tests pass now. I also switched to pure GPU tests for v1.1. 1.2, 1.3, and dev. But now we're getting this error when trying to upload artifacts after testing is done:; ```; ERROR: Uploading artifacts to coordinator... too large archive id=310912043 responseStatus=413 Request Entity Too Large status=413 Request Entity Too Large token=4myNR-xV; FATAL: too large ; ERROR: Job failed: exit code 1; ```. This GitLab thread suggests increasing the ""maximum artifact size"" but maybe it's already quite large?. ---. Seems like we've increased the number of artifacts by a factor of ~2x so maybe we've just hit the limit. Is there any reason to expect that using PyPlot as a test dependency would inflate the size of the `.cov` files?. As a side note, seems excessive to upload all the artifacts from `.julia/`... Before:; ```; Uploading artifacts...; Manifest.toml: found 1 matching files ; .julia/: found 40047 matching files ; WARNING: deps/ext.jl: no matching files ; WARNING: deps/build.log: no matching files ; src/*.cov: found 15 matching files ; src/*/*.cov: found 14 matching files ; WARNING: src/*/*/*.cov: no matching files ; Uploading artifacts to coordinator... ok id=300728701 responseStatus=201 Created token=W8bqAxqn; Job succeeded; ```. Now:; ```; Uploading artifacts...; Manifest.toml: found 1 matching files ; .julia/: found 73752 matching files ; WARNING: deps/ext.jl: no matching files ; WARNING: deps/build.log: no matching files ; src/*.cov: found 15 matching files ; src/*/*.cov: found 14 matching files ; WARNING: src/*/*/*.cov: no matching files ; ERROR: Uploading artifacts to coordinator... too large archive id=310912044 responseStatus=413 Request Entity Too Large status=413 Request Entity Too Large token=mC2SF4eH; FATAL: too large ; ERROR: Job failed: exit code 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-537937846:723,depend,dependency,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-537937846,1,['depend'],['dependency']
Integrability,"Thanks @maleadt, that's very helpful!. In this PR, we haven't directly changed any kernel function signatures. However, this PR does pass more complicated objects into kernels (a wrapper around an `OffsetArray` called a ""`Field`"", rather than simply the `OffsetArray`). The primary changes in this PR are thus 1. _not_ to extract the underlying `OffsetArray` from a `Field`, and 2. writing an `adapt_structure` method for `Field`s. I suppose the translation that's performed by `adapt_structure` increases the number or arguments to the function `ptxcall_calculate_Gu__66`?. The changes made in this PR are not strictly necessary --- they are a convenience. If manually unwrapping `Field`s (the method we previously used) is necessitated by CUDA limitations, I think we can live with that. If I understand this issue correctly, we are facing a basic trade-off between (compiler?) performance and the use of convenient but complicated abstraction objects?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987:179,wrap,wrapper,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987,1,['wrap'],['wrapper']
Integrability,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:270,depend,dependency,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140,1,['depend'],['dependency']
Integrability,"Thanks @navidcy for the reply. This is helpful. This means that when we integrate the zonal momentum equation over a volume (as part of deriving the finite volume method), we get the vertical integral in the `z` derivative and hence why we get the flux at the top minus the flux at the bottom. These should be averages over each horizontal cell and we also divide by a length scale. I presume that's why the MITgcm divides by the depth of the top cell. Interesting that they seem to use a body force but it should result in the same dynamics I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-2135395047:72,integrat,integrate,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-2135395047,1,['integrat'],['integrate']
Integrability,"Thanks @qingli411. One obvious way to introduce the concept of dynamic dependencies is to break functionality out into multiple small packages (`OceananigansPlotting`, `OceananigansOutput`, etc). @vchuravy argued that this is a good philosophy for packages; perhaps even more so for a complex project like this one: we may want to keep the core as simple as possible. This would also make the tests run faster, and might make development easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501712624:71,depend,dependencies,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501712624,1,['depend'],['dependencies']
Integrability,"Thanks @simone-silvestri . I believe we found our bug!. The continuity equation (conservation of mass equation) does not change whether there is topography or not. It should always be, as follows, where `h` is the total depth:. ```; ∂ₜh + ∇⋅(h u⃗) = 0; ```. The pressure gradient, however depends only on the free surface, or if we write it in terms of the total depth we need to include the topography,. ```; ∇ η = ∇(h + b); ```. I am not sure what convention we are following, but there might be a negative in front of the `b`. . Does that make sense?. The equations you shared have some mistakes in them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128976538:289,depend,depends,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128976538,1,['depend'],['depends']
Integrability,"Thanks @simone-silvestri @glwagner! I encountered a different error on CPU recently that might be related. I ran a 3D (Bounded,Bounded,Bounded) simulation with immersed boundary on CPU. When using `FieldTimeSeries` to load the JLD2 output, I get a `BoundsError` message:. ```b = FieldTimeSeries(""moving_source_complex_topography.jld2"",""b"",grid=nothing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:262,message,message,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638,1,['message'],['message']
Integrability,"Thanks @simone-silvestri for the quick reply! I'll work on it this work and message you on slack so we can find a time that is convenient for you for us to chat, and hopefully get this moving again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1808253713:76,message,message,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1808253713,1,['message'],['message']
Integrability,"Thanks for all the clarifications, @francispoulin. Just a few thoughts:. I think regardless of what interface we end up using (allowing `x` to be a constructor, or creating a separate keyword such as `z_strecthed`) it needs to be absolutely clear what each option is gonna do. For example the name `z_stretched` doesn't tell us in any way that that corresponds to face locations. As a last option we can specify this clearly in the docstring, but ideally the keyword itself should be somewhat self-explanatory. About your comment about users not caring about what kind of stretching is used: regardless of creating convenience functions or not for stretched directions, we should always allow arbitrary stretching from the user part. That's because it's not just a matter of at which depth to make the grid tighter. Take free convection for example. Some users like to define a grid that is the finest close to the boundary and monotonically stretch from there (which I guess is what you have in mind). However, many people (and I know @glwagner is one of those) prefer simulating the whole boundary layer with one uniform resolution and only stretch the grid in the thermocline, for example. This has technical advantages such as aliasing reduction, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166:100,interface,interface,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166,1,['interface'],['interface']
Integrability,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:405,depend,dependent,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['depend'],['dependent']
Integrability,"Thanks for bringing this up, didn't realize it could be that bad. I agree it would be nice to have a barebones version of the package. Maybe we can approach this the same way we wanted to approach having ""dynamic dependencies"" for running examples that depend on Plots.jl (#195). That way, NetCDF.jl and HDF.jl only get installed and built if you decide to read/write NetCDF. I suppose this is the point of the Requires.jl package. Out of curiousity, is @qingli411's laptop running Windows? Build times on Linux and Mac (e.g. on Travis CI and GitLab CI) tends to be quite reasonable, so I'm wondering if it's a Windows thing. PS: I'm pretty sure this is also the reason why Appveyor is super slow #89.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501096708:213,depend,dependencies,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501096708,2,['depend'],"['depend', 'dependencies']"
Integrability,"Thanks for catching that! However, that's not the issue. One of the things I did (which I discussed a few messages ago) was to move `field_slicer.jl` from OutputWriter to Diagnostics, since I couldn't compile the code in the correct order for dependencies otherwise. (Plus now that FieldSlicer is used in Diagnostics, it's no longer exclusive to OutputWriters.). The test complains that it needs `short_show(fs::FieldSlicer)` in line 490 of `netcdf_output_writer.jl`: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R490. But I'm already `using` `short_show` from `Oceananigans.Diagnostics` in line 10 of the same file: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R10. This appears to work in my local set-up when testing, but somehow fails on github. Any ideas?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965:106,message,messages,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965,2,"['depend', 'message']","['dependencies', 'messages']"
Integrability,"Thanks for creating this @tomchor , I think this is a neat idea. To help me think about how this should look, could you help me find an example you want want to do this? . I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886217879:283,depend,depends,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886217879,1,['depend'],['depends']
Integrability,"Thanks for explaining why the `C` values are different, didn't realize that. Not sure where it comes from but shouldn't it be `C_roz = 4/24 = 0.167` or `C_roz = 8/24 = 0.33`?. > I'm open to changing the implementation, but I'm not sure what the best route is. Possibly we will phase out the Rozema version... ?. Not sure how much code overlaps between the two, but if both are deemed important enough to maintain, then the shared functionality can go into `amd_core.jl` or something. Although probably a bad idea to do this refactor before each AMD closure has it's own regression test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526191891:250,rout,route,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526191891,1,['rout'],['route']
Integrability,"Thanks for linking to the papers, we consulted them a while back but forgot to reference them in the documentation. Another needed change is that I incorrectly use the term geopotential. . We can definitely put them in a separate package, I'm sure someone else might find it useful. We might still need to have a separate version for ourselves that integrates with `CellField`s, pre-allocated wavenumbers, and integrates the DCT with the time stepping on the GPU. So might be better if we just spawn off a package as the core functionality of solving the poisson equation can be done in a small amount of code and doesn't need frequent updates.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469315731:349,integrat,integrates,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469315731,2,['integrat'],['integrates']
Integrability,"Thanks for opening this @raphaelouillon! Yeah it's a little confusing. So Oceananigans v0.30.0 (latest release) depends on the old packages CUDAnative.jl, CuArrays.jl, etc. but the master branch depends on CUDA.jl. With CUDA.jl the other packages are all deprecated and can't be used as all CUDA functionality comes from CUDA.jl. The older repositories like CuArrays.jl now have deprecation warnings: https://github.com/JuliaGPU/CuArrays.jl. So I guess any functionality you need from CuArrays.jl should be available through CUDA.jl. Let us know if you hit any issues with CUDA.jl though and if you need help figuring anything out. PS: I modified your post slightly to enclose the stacktrace in triple backticks (```) so it shows up with a fixed-width font (makes reading the stacktrace easier).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796#issuecomment-657833753:112,depend,depends,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796#issuecomment-657833753,2,['depend'],['depends']
Integrability,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151:517,interface,interface,517,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151,1,['interface'],['interface']
Integrability,"Thanks for sharing this @tomchor . . Do I take that to mean that if we try and run Oceananigan on an AMD GPU then very likely the code will fail because KerelAbstractions.jl (and possibily others) will fail? . It would be great to be able to run the library on any GPU but I guess a lot of this depends on KerenAbstractions, and other libraries. Do people know what other libraries we depend on that would not necessary run on AMD GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771:295,depend,depends,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771,2,['depend'],"['depend', 'depends']"
Integrability,"Thanks for the additional changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.Pk",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:250,depend,dependencies,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,4,['depend'],"['dependencies', 'dependency']"
Integrability,"Thanks for the link, I wasn't aware it there was an open PR with a proposal. Unfortunately it doesn't look like this feature will become available for a while and people have already tried to install Oceananigans and just gave up because of warnings/errors, so I'm tempted to just hack in a solution. I'm thinking of removing the dependency on all CUDA packages, and have them get added/installed at run time if the `Model` constructor is called with `arch=GPU()`. I think this should give us exactly what we want for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178#issuecomment-485397392:330,depend,dependency,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178#issuecomment-485397392,1,['depend'],['dependency']
Integrability,"Thanks for the videos @PharmCat, those simulations look pretty cool!. > So if I make model of tank and impeller can I use Oceananigans.jl for hydrodynamic simulation? this is my main question. Yes I think it is possible to simulate mixing tanks in Oceananigans, but I don't know if the simulations will be good. Oceananigans development has not focused on moving boundaries or rigid bodies. I suspect codes like ANSYS Fluent or OpenFOAM would be better for your problem, but I'm not familiar with them. Some of the impellers look pretty small so if you want to use an immersed boundary method to simulate the rigid body and walls, then you might need high resolutions with many grid points to resolve the impeller. Depending on how fast the impeller spins then your time step might need to be very small. Also, I don't know how accurate the immersed boundary method is with moving rigid bodies. You might need even smaller time steps to get good accuracy. > I just start to learn Oceananigans.jl and now i can't say this. Is it possible to use boundary for simulation mooving of rigid body in water?. From the videos I think you just want a moving boundary that describes a rotating rigid body. I think this is possible with Oceananigans but nobody has tried it. If you're interested in trying to simulate a mixing tank with Oceananigans that would be pretty cool! Please let us know if you have any questions (also feel free to open new issues) and if you post your script here we can help with debugging.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/830#issuecomment-669402349:715,Depend,Depending,715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/830#issuecomment-669402349,1,['Depend'],['Depending']
Integrability,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255:987,integrat,integration,987,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255,1,['integrat'],['integration']
Integrability,"Thanks! Strange that I'm stuck on v0.18.1 which would likely explain the error. But when I tried to update it, it won't upgrade to 0.25...almost seems like a dependency issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/679#issuecomment-595575028:158,depend,dependency,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/679#issuecomment-595575028,1,['depend'],['dependency']
Integrability,Thanks! You're right about the periodic condition and the halo region. Switching to a `8x8x8` did the trick! Although I would have thought that the interpolation routines appropriately calculated the fields at the periodic boundary. Is this expected behavior or a bug?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-770039548:162,rout,routines,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-770039548,1,['rout'],['routines']
Integrability,"Thanks!; > It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. > I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?. I suppose it might be useful to provide some functions like that to make it easier to implement. Possibly also the kernel function I put in the example gist and a wrapper like `force_nearest(particle_properties, tendency_field, particles, grid)` so there's an easy interface for people to add it to their particle dynamics function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194:317,rout,routine,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194,3,"['interface', 'rout', 'wrap']","['interface', 'routine', 'wrapper']"
Integrability,That is ironically an error in the error printer. Can you convert that to an assertion so we can see the actual error message?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710:118,message,message,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710,1,['message'],['message']
Integrability,"That region doesn't exist in the domain without IBM. The fluid region starts at z=0 in all cases, but for the IBM case, z<0 is; inside the immersed solid, while for the cases without IBM functionality; it's simply outside the domain. On Mon, Mar 21, 2022, 10:36 Francis J. Poulin ***@***.***>; wrote:. > Thanks @tomchor <https://github.com/tomchor> , and very nice.; >; > What would the difference of those two curves look like in the region; > where there is no masking? Are they identicial or just similar?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KXCYAVHO3HLQ3KWYM3VBCXRRANCNFSM5PH5P4HA>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882:825,Message,Message,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882,1,['Message'],['Message']
Integrability,"That solution looks pretty good!. As far as I can tell I think it makes sense for the ""full"" pressure field to continue smoothly into the IB, since the pressure field is somehow a solution to Poisson's equation --- even if the RHS of the Poisson equation varies rapidly close to the IB (?). Does the magnitude of the velocity error scale with the time-step, or resolution? Perhaps plotting the dependence of the error on some of those parameters can give us confidence that the method is working as expected. Should we try iterating the IB correction + pressure solve to see if it reduces the velocity error, as we hypothesized it might?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738270609:394,depend,dependence,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738270609,1,['depend'],['dependence']
Integrability,"That solution looks pretty symmetric, but you can just subtract left from; right to get a quantitative measure. If there is a persistent asymmetry; near the body, then it would be worth examining those derivative and; interpolation routines. Gabriel D Weymouth; _______________________________________________; ""Computers are useless. They can only give you answers."" Pablo Picasso. On Fri, Dec 4, 2020 at 3:34 PM Victoria Whitley <notifications@github.com>; wrote:. > Is the solution outside the body perfectly symmetric?; >; > @wenegrat <https://github.com/wenegrat> and @whitleyv; > <https://github.com/whitleyv> sounds good - is the angle dependence maybe; > due to time dependence of flow, does it move around as the flow changes?; >; > @christophernhill <https://github.com/christophernhill> This should be a; > *roughly* steady state solution for Re = 40 by the end of the simulation.; > Changes in velocity at that point are O(10^-5). Here is the velocity; > contours for the above case @weymouth <https://github.com/weymouth>.; > Angle-wise, 0 degrees was taken due east but the flow is not in that; > direction, so it should have been symmetric from [-90,90] and [90,270]. As; > @wenegrat <https://github.com/wenegrat> mentioned, the normal velocity; > may be uneven due to the interpolation and derivative calculations so near; > the boundary.; >; > [image: velocity_Re40_dx04_small]; > <https://user-images.githubusercontent.com/67593861/101181102-7ed6fb80-361a-11eb-92f1-041f0daa398e.gif>; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738849541>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AADSKJ4FSQI3H6QIOY6YVKLSTD6PJANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738864980:232,rout,routines,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738864980,3,"['depend', 'rout']","['dependence', 'routines']"
Integrability,That sounds like a better check that would generalize!. The `ComputedField` vs. `AbstractOperation` distinction could be a common enough mistake to warrant a user-friendly message.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229:172,message,message,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229,1,['message'],['message']
Integrability,"That sounds like it could be nice; can you maybe give some examples? These messages used in constructors perhaps?. So there are two issues: simulation progress statements, and logging for model construction / instantiation?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541428706:75,message,messages,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541428706,1,['message'],['messages']
Integrability,"That was my doubt...; I am not sure wether bathymetry should be added to the momentum equations (as an additional pressure term) or to the continuity equation following ; https://capture.dropbox.com/LxsRg26SQzFKu4lb. I think it depends on how you define `h`. If `h = η + Const` then you add bathymetry to the continuity. If you want to add it to the momentum then `h = η + Const + hB` (and then you add the bathymetry to the momentum because you have to subtract it from the pressure term as bathymetry does not directly influence momentum, but it is directly included in the continuity in this way). The difference is between (if `h = η + Const + hB`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=\partial_x g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=\partial_y g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x(hu)%2B\partial_y(hv)=0}"">. and (if `h = η + Const`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x((h%2Bh_B)u)%2B\partial_y((h%2Bh_B)v)=0}"">. the two formulations should be equivalent. I don't know specifically which method is better, I though including it in the continuity would avoid cancellation errors, What do you think?. for the bathymetry, it is the same one I use for the hydrostatic model, but it has a ton of grid noise in it. I think smoothing it a bit might be helpful with increasing the time step without affecting the solution too much. With @sandreza and @kburns we just implemented a spectral smoothing tool for bathymetry recently, so I though we can try it out here",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326:228,depend,depends,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326,1,['depend'],['depends']
Integrability,"That's a decent minimal example! Are you sure that the error requires `advection=WENO()` and `timestepper=:RungeKutta3`? The latter cannot be necessary since its the default (so omitting it has the same effect as including it). I find I can reproduce the error without `ImmersedBoundaryGrid` at all. About the error. The top of the message says. ```; ERROR: MethodError: no method matching cpu_fourier_tridiagonal_preconditioner_rhs!; ```. This means that the kernel function `fourier_tridiagonal_preconditioner_rhs!` is being called with the wrong arguments. For example:. ```julia; julia> f(x, y) = x + y; f (generic function with 1 method). julia> f(1); ERROR: MethodError: no method matching f(::Int64). Closest candidates are:; f(::Any, ::Any); @ Main REPL[1]:1. Stacktrace:; [1] top-level scope; @ REPL[2]:1; ```. The stacktrace shows. ```; [8] compute_preconditioner_rhs!(solver::Oceananigans.Solvers.FourierTridiagonalPoissonSolver{…}, rhs::Field{…}); @ Oceananigans.Solvers ~/.julia/packages/Oceananigans/HPOLD/src/Solvers/conjugate_gradient_poisson_solver.jl:109; ```. let's look at that line:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Solvers/conjugate_gradient_poisson_solver.jl#L109-L110. This uses the Oceananigans utility `launch!` which launches the kernel `fourier_tridiagonal_preconditioner_rhs!` with the arguments `solver.storage, tridiagonal_dir, rhs`. However, looking at the function `fourier_tridiagonal_preconditioner_rhs` a few lines above. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Solvers/conjugate_gradient_poisson_solver.jl#L93. we see that the function has 4 arguments, not 3. Hence the error. To summarize the analysis method, the key is to find the function that causes the error in the source code (`fourier_tridiagonal_preconditioner_rhs`) and then identify where it is called, and how it should be called. Here's an updated MWE from your nice one @liuchihl :. ```jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896#issuecomment-2453118576:332,message,message,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896#issuecomment-2453118576,1,['message'],['message']
Integrability,"That's a good point @glwagner - I think it's a mix of CI tests and more involved experiments. Some of these can be easily integrated in to CI since they are very cheap to run. A one level wind-driven gyre should take only a few minutes of run time to equilibrate sufficiently. Full simulations from option 3 are almost certainly too heavy for CI (unless there are plans afoot to use external resources for CI). These sort of simulations are more likely to be run occasionally and interrogated by real eyeballs. Having said that, you could setup CI to run a few time steps and compare the output with blessed output - this is what MITgcm does for its CI tests. This comes with a couple of advantages:; - the tests are useful setups for people to start using; and; - because they run regularly (for at least a few time steps) you know when the examples break. I like your idea of designing a forcing that exactly cancels the expected tendencies. It is a more rigorous test than ""is the output the same as it was when I decided it was correct?"". > Is the algorithm in Oceananigans.jl identical to some configuration of MITgcm? If so that opens the possibility to compare a solution grid-point for grid-point. This might work, but you'll need to decide how closely it should match. You definitely won't get machine precision matches - we can't even do that with different MITgcm runs. The output from MITgcm depends on the machine, the compiler, and the optimisation level.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467570923:122,integrat,integrated,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467570923,2,"['depend', 'integrat']","['depends', 'integrated']"
Integrability,"That's a good point you bring up, sounds like this will be easier once #59 is resolved. Instead of dispatching, I was actually thinking of using a macro here, e.g. `@insert_forcing` that inserts a zero if the forcing is `nothing`, a function call if the forcing is a function, and grabs a numbers from an array if it's an array. Some pseudocode:; ```julia; # Insert forcing for u-momentum equation.; macro insert_forcing_u(Fu); if Fu == nothing; return 0; else if typeof(Fu) == Function; return Meta.parse(""Fu(grid, velocities, tracers, i, j, k)""); else if typeof(Fu) <: AbstractArray; return Meta.parse(""Fu[i, j, k]""); end; end; ```; Then the time-stepping might look like; ```julia; Gu[i, j, k] = (-u∇u(...) + ... + @insert_forcing_u); ```; All the different macros can be defined in an `@eval` loop or maybe with a single `@insert_forcing` definition is it knows which forcing is being inserted so it can inject the correct `Fu"", ""Fv"", etc. in the expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470506051:908,inject,inject,908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470506051,1,['inject'],['inject']
Integrability,"That's a neat idea. We also need to checkpoint simulations rather than models, to handle cases where output is time-dependent (windowed time-averages and, in the future, time derivatives).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894:116,depend,dependent,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894,1,['depend'],['dependent']
Integrability,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985:618,integrat,integrate,618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985,3,['integrat'],['integrate']
Integrability,"The above also explains why synchronizing `mean!` doesn't help. We would need a `synchronize` at some deeper level, apparently. It is interesting that adding `sleep(0.01)` helps. 🤔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868794690:28,synchroniz,synchronizing,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868794690,2,['synchroniz'],"['synchronize', 'synchronizing']"
Integrability,"The answer for this, as per @glwagner's comments, is because that's the syntax for `KernelAbstractions`, which we use to compute GPU kernels:. From @glwagner :. The kernel is created here:; `diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize)`; and launched here:; `event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`; the diffiusivity calculations do not depend on one another, so they are all launch simultaneously. At the end, we wait for all of them to finish here:; `wait(device(arch), MultiEvent(Tuple(events)))`. Noticeably apparently we don't use `lauch!` in this case, even though apparently we should?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426:373,depend,dependencies,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426,2,['depend'],"['depend', 'dependencies']"
Integrability,"The argument `dims` indicates what dimensions to average over, where (1=x, 2=y, 3=z). So. ```julia; T_avg = AveragedField(model.tracers.T, dims=(1, 2)); ```. builds a field representing the _horizontal_ averaged of `model.tracers.T` over x and y (dimensions 1 and 2). `data` is an optional field that can be used to supply the underlying data for the `AveragedField` (useful if memory allocations are being carefully managed). `recompute_safely` is relevant only when `AveragedField` are used in other computations. In that case, the `AveragedField` will always be recomputed before computing it's dependent operation if `recompute_safely` is true. Otherwise, the `status` of `AveragedField` is checked and recompution is ""avoided"" when it seems safe to do so.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914:598,depend,dependent,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914,1,['depend'],['dependent']
Integrability,"The boundary conditions do depend on / refer to the indexing convention. A boundary condition is applied over a particular region of an array --- not a region in physical space. The boundary conditions are constructed to apply to x, y, and z. In our abstraction ""left"" means `i=1` for x and y, which makes sense. But because of the reverse convention for `z`, `k=1` is on the right for z.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488122152:27,depend,depend,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488122152,1,['depend'],['depend']
Integrability,"The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to `JLD2OutputWriter` and `NetCDFOutputWriter` in a `WindowedTimeAverage`. It does not involve any averaging. If you can explain why you think it is convoluted, perhaps we can improve it. `WindowedTimeAverage` is defined in this file: https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/windowed_time_average.jl. The key part is `accumulate_result!`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L126-L144. Can you explain why isn't this captured in our tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104:152,wrap,wrapping,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104,1,['wrap'],['wrapping']
Integrability,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:193,wrap,wrap,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187,1,['wrap'],['wrap']
Integrability,The default depends on whether the file already exists or not? Just above that... https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/netcdf_output_writer.jl#L293-L298,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1066083222:12,depend,depends,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1066083222,1,['depend'],['depends']
Integrability,The dependency on OrthogonalSphericalShellGrids here is blocking the progress (the `SplitExplicitAuxiliaryFields` type has changed in this PR). How do we deal with this? We could remove the dependency in the tests of Oceananigans and move those tests over at OrthogonalSphericalShellGrids,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2431512977:4,depend,dependency,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2431512977,2,['depend'],['dependency']
Integrability,"The difference operator doesn't use the grid metrics --- but maybe you mean the derivative / gradient operator?. Such a test would catch this issue, it's true. We could use a simple test with linear gradients. There might already be such a test, but not for all grids... ?. I think the fact that the cell spacings don't add up to the grid size could be an even worse problem because it means that integrals / budgets are not correct. But I'm not sure since the spacings at cell centers might be more important (these lines only manipulate the spacing at cell interfaces).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834:559,interface,interfaces,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834,1,['interface'],['interfaces']
Integrability,The difficulties in getting a test to fail on #1784 could mean that the issue this PR resolves is machine dependent. But I'm not sure.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-870838764:106,depend,dependent,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-870838764,1,['depend'],['dependent']
Integrability,"The difficulty with `Value` conditions is that they depend on the model / turbulence closure being used (in the simplest case, we can use the user-specification to calculate a gradient, and then infer the cross boundary flux with a diffusivity). We can implement this by implementing some standard notation for the turbulence closures (right now there is a function `viscosity`, for example, and `z_viscosity`. We need the `x` and `y` components as well). In the grid-aligned case we use halos to enforce `Value` boundary conditions, but this approach doesn't work with immersed boundaries. The `Flux` case is a bit more straightforward since it doesn't depend on the closure, but does require some reasoning about boundary normal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079:52,depend,depend,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079,2,['depend'],['depend']
Integrability,"The error comes from here:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/Distributed/distributed_fft_based_poisson_solver.jl#L65. My guess is that the eigenvalues aren't constructed properly. There's some code in the solver constructor:. https://github.com/CliMA/Oceananigans.jl/blob/aea1e043aa6f965ed599f151b6ace85f25df8cfa/src/Distributed/distributed_fft_based_poisson_solver.jl#L25-L44. which (just a guess) looks like we are trying to hack something together rather than properly using an interface defined by `PencilFFTs`. We have to read the `PencilFFTs` documentation and discover how to correctly define these arrays that are meant to be used in the above broadcasting operation. I think there is another issue about this, might be worth searching so we don't have a duplicate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630:539,interface,interface,539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630,1,['interface'],['interface']
Integrability,The error message we are gettig now does not seem to involve this PR at all. . If that is the case do we need to reset it?. ```. Downloading artifact: OpenSSL; --; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: IntelOpenMP; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: NetCDF; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenSpecFun; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: nghttp2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MbedTLS; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: Zlib; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenMPI; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkit,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:10,message,message,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['message'],['message']
Integrability,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:1041,interface,interface,1041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221,1,['interface'],['interface']
Integrability,"The issue is a little tricky. Typically we expect abstract operations to be computed during time-stepping. In that case, the halos should be correctly filled. However, @navidcy expects that abstract operations should be correct at any time and does not expect to have to call fill halo regions. Thus for `compute!` to be more generally useful to users I think we do want this behavior. The problem is that fill halo regions can be expensive eg for distributed models. Therefore to both serve expected user behavior and provide a performant interface we perhaps have to add a flag to `compute!` like `fill_halo_regions=false` so that computation for output does not trigger extra calls to fill halo regions. Note @navidcy you can also use the simpler and more transparent . ```julia; parent(model.velocities.u) .= 1; ```. or just `fill!(model.velocities.u, 1)`. I think your result would be correct then. But still if we are setting to functions then we need `set!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530:540,interface,interface,540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530,1,['interface'],['interface']
Integrability,"The issue not only happens after picking up checkpoint, it also occurs before that. For example, with the same MWE, if I set:; ```julia ; Δt = .01 # timestep (s); T1 = 6 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .03 # progress message interval and output saving interval; ```. The issue also occurs in the first run (e.g., 0-6 s):; <img width=""596"" alt=""image"" src=""https://github.com/user-attachments/assets/c4539b8b-b24d-4ba2-8a7e-a99c4d18c9a7"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259377623:268,message,message,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259377623,1,['message'],['message']
Integrability,"The issue with the power method is that its convergence depends on the _difference_ between the two largest eigenvalues, and this can be really slow. Arnoldi iteration does a lot better, and gives you multiple eigenmodes. I think it should also be easy to add since most implementations (including ArnoldiMethod.jl, it looks like) are matrix-free. Directly calculating the full spectrum might be harder -- Dedalus can do this because it forms sparse matrices for the global linear operator, but I don't think oceananigans does this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731279135:56,depend,depends,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731279135,1,['depend'],['depends']
Integrability,"The library computes the derivatives that are required to compute the tendencies, but they are not stored since that would not be very efficient. Getting some of these values but I don't know what that would look like. Also, if you are not computing this field at every time step, the cost of computing it sepratelyl might not be that high, but that of course depends on the particular problem you are dealing with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025:360,depend,depends,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025,1,['depend'],['depends']
Integrability,"The main advantage of having `DiskTimeSeries` in `Oceananigans` would be to use it in examples without depending on another package. I think the implementation of `DiskTimeSeries` is light. It also _requires_ certain features (for example, location metadata must be saved by `JLD2OutputWriter` for `DiskTimeSeries` to work). This tight coupling between `DiskTimeSeries` and `OutputWriters` could motivate including `DiskTimeSeries` in `Oceananigans.jl`. Other aspects of analyzing Oceananigans data might be more appropriate in another package. I'm not exactly sure what specific features are up for debate in this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405:103,depend,depending,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405,1,['depend'],['depending']
Integrability,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074:61,integrat,integrated,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074,2,['integrat'],['integrated']
Integrability,"The only thing we need to do to achieve this is to make a wrapper array type with new getindex that permutes indices the way we want. . We can even use a different permutation on the CPU and GPU. For loop ordering, we should write a macro that prints the loop statements. That way we can globally change the loop ordering by changing one line if we want to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541362859:58,wrap,wrapper,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541362859,1,['wrap'],['wrapper']
Integrability,"The origin of this reference heat capacity is explained around equation 3.3.3 in this document:. https://unesdoc.unesco.org/in/documentViewer.xhtml?v=2.1.196&id=p::usmarcdef_0000188170&file=/in/rest/annotationSVC/DownloadWatermarkedAttachment/attach_import_3378fdfe-50b7-4e53-8795-fafc7913dcc0%3F_%3D188170eng.pdf&locale=en&multi=true&ark=/ark:/48223/pf0000188170/PDF/188170eng.pdf#%5B%7B%22num%22%3A298%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C-93%2C846%2C0%5D. Section 2.20 in that document discusses the isobaric heat capacity. Does the ""correct"" heat capacity then depend on our interpretation of the variable `T` in `Oceananigans.jl` (and therefore on the values we choose for the thermal expansion coefficient and saline contraction coefficient)? It's all a little unclear to me. . Note also that the TEOS-10 document uses `α` for the thermal expansion coefficient. The variable `βΤ` is [sometimes used to denote the 'isothermal compressibility'](https://en.wikipedia.org/wiki/Specific_heat_capacity#Relation_between_heat_capacities).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/190#issuecomment-525582098:580,depend,depend,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/190#issuecomment-525582098,2,"['contract', 'depend']","['contraction', 'depend']"
Integrability,"The problem is that I am developing on my mac that requires an MPI downgrade to run, so I update the Manifest with julia 1.7 and that is not compatible with the CI julia. I ll revert it back. I think the viscosity can be added also here while we're at it, but also I wanted to ask how do we add bathymetry. If we add it as a pressure term in the momentum equations or as an additional advection term in the continuity equation as such. https://capture.dropbox.com/LxsRg26SQzFKu4lb. No matter what I try, the bathymetry seems to make the 1/4 degree simulation with one layer unstable (maybe I have implemented it wrong). Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248:783,integrat,integrated,783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248,1,['integrat'],['integrated']
Integrability,The reason why this test does not pass on the GPU for periodic boundary conditions in the longitudinal direction might have something to do with the synchronization of the halo filling (PR #1985 which we might want to merge soon),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060:149,synchroniz,synchronization,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060,1,['synchroniz'],['synchronization']
Integrability,"The solution is not too difficult, except for one annoying detail: if boundary conditions contain references to model fields, this means that `field.boundary_conditions` contains a circular reference. I guess we can work around this by giving boundary conditions a reference to field data, rather than the field itself. This preserves existing functionality and so its fine. We will, however, have to rewrite `VelocityFields` and `TracerFields` to a single `VelocityAndTracerFields` constructor, and perform the requisite gymnastics there. There are also challenges if users want to create `VelocityFields` and pass them to the model. I suppose we'll have to re-wrap the user-created data for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-708092162:662,wrap,wrap,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-708092162,1,['wrap'],['wrap']
Integrability,"The top of the error message on #1780 is. ```; Stacktrace:; [1] overdub; @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/In",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828:21,message,message,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828,1,['message'],['message']
Integrability,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:1092,depend,dependent,1092,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403,1,['depend'],['dependent']
Integrability,"The wizard uses `new_time_step`, which is correctly extended within `MultiRegion` ; https://github.com/CliMA/Oceananigans.jl/blob/40ac9d0efff7a0c877df652e3f9114fe53693bc2/src/MultiRegion/multi_region_models.jl#L63-L66.; I haven't extended `cell_advection_timescale` yet. Also, I haven't yet extended `interior`, because data can live on different GPUs, so `interior` should not be used if not after `reconstruct_global_field`.; Maybe I can add `cell_advection_timescale` to multi region, but then I have to extend also `cell_diffusion_timescale` and the extension of `new_time_step` has to be deleted. I ll think about the pros and the cons. ; For every function that does not work in `MultiRegion`, in the meantime, you can wrap it with `@apply_regionally` and you'll get a `MultiRegionObject` containing the local equivalent. In this case; ```; @apply_regionally new_Δt = wizard.cell_advection_timescale(model); new_Δt = minimum(new_Δt.regions); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176:725,wrap,wrap,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176,1,['wrap'],['wrap']
Integrability,"The xz and yz components of stress (called `viscous_flux_uz` and `viscous_flux_vz` in the code) are explicitly elided in the presence of an immersed boundary. For examle:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L59. where. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L45. Since we can prescribe stresses / fluxes explicitly for grid fitted schemes (in principle --- its not implemented yet) I don't think we need to worry about errors in prescribed boundary fluxes. This issue may need to be revisited for other immersed boundary methods if they make approximations there. EDIT after I wrote this I also realized that maybe I don't understand what the boundary integrated stress is here. With a viscosity of 0, shouldn't the integrated stress be zero as well? Or perhaps this is the integrated strain?. Either way I think the simplest strategy for grid fitted boundaries (and relatives like partial cells and shaved cells) is to simply ""drop in"" the relevant prescribed flux where necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499:864,integrat,integrated,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499,3,['integrat'],['integrated']
Integrability,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;   | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;   | Stacktrace:;   | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);   | @ Base ./error.jl:168;   | [2] #systemerror#62;   | @ ./error.jl:167 [inlined];   | [3] systemerror;   | @ ./error.jl:167 [inlined];   | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);   | @ Base ./iostream.jl:293;   | [5] open;   | @ ./iostream.jl:282 [inlined];   | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});   | @ Base ./io.jl:328;   | [7] open;   | @ ./io.jl:328 [inlined];   | [8] read;   | @ ./io.jl:434 [inlined];   | [9] _include(mapexpr::Function, mod::Module, _path::String);   | @ Base ./loading.jl:1166;   | [10] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [11] include(x::String);   | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;   | [12] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;   | [13] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [14] include(x::String);   | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;   | [15] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;   | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:182,depend,dependency,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134,1,['depend'],['dependency']
Integrability,"There are two packages providing high-level interfaces for reading/writing NetCDF files. I went with [NetCDF.jl](https://github.com/JuliaGeo/NetCDF.jl) as it seemed older and more mature maybe, but would be good to keep track of [NCDatasets.jl](https://github.com/Alexander-Barth/NCDatasets.jl) as it seems to use data frames instead of just arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-467008637:44,interface,interfaces,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-467008637,1,['interface'],['interfaces']
Integrability,"There is a comment about divergent initial conditions here:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/setting_initial_conditions/. A related issue is #951 . We could somehow change the behavior of `set!` to project the initial condition onto an incompressible field. For example, we might use the pressure solver. While it would be surprising that the initial condition never ends up exactly as its set by the user, it is similarly surprising to observe a large change in the velocity field after a single time step. And `set!` is intended to be used prior to time stepping. I'm not sure I agree about printing a warning based on some metric diagnosed from the velocity field passed to `set!`. However, we could print out an info message that gives the user some information about how much their velocity field was changed during the initialization process. This is related to #1013 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1027#issuecomment-704154544:758,message,message,758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1027#issuecomment-704154544,1,['message'],['message']
Integrability,"There is a fair amount of scalar iteration right now, largely I think because we have array-like objects (Fields, and friends) that lack fully-featured broadcasting capabilities. This means writing something like `a .== 2` triggers scalar iteration on the GPU because it hits Base broadcasting. We _can_ fix the problem by fleshing out broadcasting a bit so `a .== 2` works ""correctly"" / sensibly, but we haven't prioritized it (we also didn't have broadcasting at all for Field until a month or two ago). Possibly, if changing a global via `allowscalar(true)` were not available we would have been forced to address this deficiency in our Field abstraction sooner. So that could have been a good thing depending on your perspective. It did allow us to sweep some things under the hood. On the other hand I don't think we have any performance issues; scalar iteration is only used on very small arrays for testing where we are completely dominated by compile times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-864145884:703,depend,depending,703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-864145884,1,['depend'],['depending']
Integrability,"There is a nonlocal contribution in the vertical. The pressure gradient at fluid layer $j$ depends on all fluid thicknesses of that layer and **all** layers above that. Does this impose any constraint on the technical design (in terms of whether we write 3D kernels or `Nz` 2D kernels, where `Nz` the number of fluid layers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457:91,depend,depends,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457,1,['depend'],['depends']
Integrability,"There might be an issue with conditional computations but I'm not sure. For example, `ComputedField` has this `compute!` definition:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/computed_field.jl#L61-L62. I think we want something similar; eg we want the `time` argument in `KernelComputedField`:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/kernel_computed_field.jl#L76. and we want to use `compute_at!(dependency, time)` here:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/kernel_computed_field.jl#L78-L80",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769389205:512,depend,dependency,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769389205,1,['depend'],['dependency']
Integrability,"There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. The problem can be fixed by dispatching the main constructor for `Average` on `Union{Field, Computation}`. I am ok with this restriction of `Average`. However, it's worth noting that it's changes its capability. Previously, `Average` would work with anything that defines `parent` and `architecture`, including arbitrary user-defined types (this is why it works with `Computation`s, for example). With this change, it will only work with types that are specifically allowed by the constructor. Partly I think the underlying motivation for this PR could suggest we need to put a bit more effort into streamlining the user interface to `AbstractOperations` and `Computation`s. For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. We may also need to spend some more time refining the `Field` abstraction, and formalizing the connection between `Field`s and other similar objects like `Computation`s and `Average`s. In that case, we could define `Computation` as a subtype of `AbstractField`, and dispatch on `AbstractField` in the constructor for `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389:817,interface,interface,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389,2,['interface'],['interface']
Integrability,"There used to be an example of using `dynamics` to implement particles that played ""rock, paper, scissors""; ie near-neighbors were identified, and then made to interact in some way that changed particle properties. There is scope for building out a user interface for more generic particle interactions of course. I'm not convinced that this is so important that we should spoon-feed users with an interface though. In principle, `dynamics` can do everything and advanced users can write their own code. It depends on how important the uses get, and how clever we can be with an interface (so it is easy to maintain and doesn't screw things up for future development)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719:254,interface,interface,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719,4,"['depend', 'interface']","['depends', 'interface']"
Integrability,"There's a disadvantage if we need to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:449,depend,dependent,449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328,1,['depend'],['dependent']
Integrability,"There's an intriguing side benefit of this ""unified"" interface for output. It means that it is possible (though we don't have it now) for users to specify an ""output preference"" in a `Preferences.toml`, which would then determine the default behavior of `output!`. I think it also legitimately makes it easier to switching between formats.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375621948:53,interface,interface,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375621948,1,['interface'],['interface']
Integrability,"There's another limitation of the current scheme that's worth mentioning. The scheme currently precomputes the 3D diffusivity / viscosity field at cell centers, which means that a cell is ""unstable"" if _either_ vertical interface has a negative buoyancy gradient. But what we really want to do is precompute _stability_ (or the buoyancy gradient), which is more naturally located at vertical cell interfaces. This provides the tracer diffusivity directly; the momentum diffusivity can be calculated by checking the stability of two neighboring regions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746:220,interface,interface,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746,2,['interface'],"['interface', 'interfaces']"
Integrability,"There's some info in CUDA docs but it doesn't explicitly answer my question:. > For small integer powers (e.g., x2 or x3), explicit multiplication is almost certainly faster than the use of general exponentiation routines such as pow(). While compiler optimization improvements continually seek to narrow this gap, explicit multiplication (or the use of an equivalent purpose-built inline function or macro) can have a significant advantage. This advantage is increased when several powers of the same base are needed (e.g., where both x2 and x5 are calculated in close proximity), as this aids the compiler in its common sub-expression elimination (CSE) optimization. So maybe we shouldn't square at all here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593:213,rout,routines,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593,1,['rout'],['routines']
Integrability,"There's two challenges. One is refactoring `Reduction` to be more general. `cumsum!` has a diffeerent pattern, the dimensionality is not reduced for the output and it has a slightly different syntax. But I figured that stuff out here:. https://github.com/CliMA/Oceananigans.jl/pull/3590. The next challenge is to figure out how to integrate downwards rather than up; this is a little trickier I think because we may need an abstraction that reverses indices or something. There is also the metric part but that's kind of trivial, its the same thing as with `Integral` or `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956:331,integrat,integrate,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956,1,['integrat'],['integrate']
Integrability,"These are definitely cool ideas for progress statements!. I see logging as being much more general though. It should also be used when printing progress statements, but I think it's especially useful to have `@debug` messages in certain places to help with debugging. And maybe `@info` messages so the user knows what the model is doing. It could get noisy if we get carried away with them but a user staring at a blank screen for 3 minutes might not know that the GPU stuff is just compiling in the background. More responsive software feels more user-friendly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541418998:217,message,messages,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541418998,2,['message'],['messages']
Integrability,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:461,interface,interface,461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400,5,['interface'],['interface']
Integrability,"These resutls are great @whitleyv , well done! A few thoughts. First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying. Second, are there any boundary conditions imposed on the tracer at the immersed boundary? I remember there was a discussion but I don't remember the conclusion. Sorry. Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419:565,integrat,integrated,565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419,1,['integrat'],['integrated']
Integrability,"These tests aren't passing, and I have no clue why. The error is:. ```; ERROR: `Enzyme=7da242da-08ed-463a-9acd-ee780be4f1d9` depends on `ChainRulesCore=d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4`, but no such entry exists in the manifest.; ```. But I never changed anything related to that. Does anyone know what's going on?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2221669095:125,depend,depends,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2221669095,1,['depend'],['depends']
Integrability,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:387,integrat,integrated,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,2,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"This PR also includes code for the two-dimensional Leith parameterization, but it is not compiled or added to the code. Depending on when this PR is merged, that work could be added to this PR. Otherwise, it will come later. cc @navidcy @basileg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548591020:120,Depend,Depending,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548591020,1,['Depend'],['Depending']
Integrability,This branch got a little messy. Will cherry-pick on a new branch and integrate PR #291 into the script.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/292#issuecomment-506985596:69,integrat,integrate,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/292#issuecomment-506985596,1,['integrat'],['integrate']
Integrability,"This code works:. ```julia; julia> using CUDA.CUSPARSE, SparseArrays, LinearAlgebra. julia> A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0]); 3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:; 0 ⋅ 1; ⋅ 2 ⋅; ⋅ ⋅ 0. julia> B = CuSparseMatrixCSC(A); 3×3 CuSparseMatrixCSC{Int64, Int32} with 4 stored entries:; 0 ⋅ 1; ⋅ 2 ⋅; ⋅ ⋅ 0. julia> B += 1I; 3×3 CuSparseMatrixCSC{Int64, Int32} with 4 stored entries:; 1 ⋅ 1; ⋅ 3 ⋅; ⋅ ⋅ 1; ```. There's some `UniformScaling` stuff here: https://github.com/JuliaGPU/CUDA.jl/blob/06e8a4ccca62567d38a567874f82cb58517d8f01/lib/cusparse/interfaces.jl#L179. These appear to be allocating, so it still might make sense to decompose the matrix into a diagonal and off-diagonal component.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109775389:578,interface,interfaces,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109775389,1,['interface'],['interfaces']
Integrability,"This has implications in terms of code performance, if we have `set!(field)` somewhere in the code it will trigger automatically a `fill_halo_regions!` which we might not want as we are very careful to where we call `fill_halo_regions!`. There are two options then:; (1) remove all instances of `set!` in the internals and make sure to never use it; (2) implement a different interface that can be user-facing which triggers set! and fill_halo_regions! together. I would vote for (2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480334115:376,interface,interface,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480334115,1,['interface'],['interface']
Integrability,"This is a great question, though more of a Julia issue than something specific to Oceananigans! However, there is an off-chance that there is some feature we could implement to make this easier for people. Note that terminals also have line limits and its a problem for people working in the terminal too. I use the silly but practical solution of reducing my font size and re-executing code until l can see the top of the error message. However, there are probably other solutions. I wrote up a little example to experiment:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1.0); bad_callback(sim) = error(""Why did you write such a bad callback?""); simulation.callbacks[:error] = Callback(bad_callback); run!(simulation); ```. Some hunting on google returned this thread: https://discourse.julialang.org/t/redirect-output-and-error-to-a-file/58908/3. One option is to pipe to a file with the terminal utility `tee`:. ```julia; $ julia --project | tee out.txt; ```. All output generated thereafter is written to `out.txt`. I can't really see myself using this solution though. Changing the text size is easier... It looks it may also be possible to use the Julia module `StackTraces`:. https://docs.julialang.org/en/v1/manual/stacktraces/. With the above example I found. ```julia; julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, cons",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:429,message,message,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614,1,['message'],['message']
Integrability,This is a lot more sustainable than adding new properties to every output writer every time we want to support splitting a file by a different criterion. It's a decent change to the user interface. I can help if you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454:187,interface,interface,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454,1,['interface'],['interface']
Integrability,"This is an ok idea but the warning really needs to be better. It isn't clear who is ""recommending"" what; also it doesn't really make sense because the CFL depends on the time stepping method and in principle, someone can use `TimeStepWizard` with any time stepper (for example there are models external to Oceananigans that use the `Simulation`). Presumably 0.8 is some rule of thumb for RK3. Note that we envision moving `Simulation` to an external package eventually, where it could be used by other models (eg atmospheric models). Since ClimaAtmos supports all sorts of time-steppers, I'm not sure this ""recommendation"" would continue to make sense. So I'm a little skeptical about how this is put together. You could write something like ""When using 3rd order Runge-Kutta time-stepping, a time-step that produces a CFL number `cfl > sqrt(3) ≈ 1.7` is unconditionally unstable. As a rule of thumb, we recommend using time-steps that lie well within the realm of stability: for a 3rd order Runge-Kutta scheme, for example, we recommend `cfl < 0.8`. For an Adams-Bashforth scheme, which requires `cfl < XX` for stability, we recommend `cfl < 0.2`. Other time-stepping methods have different stability constraints. For more information see [a reference].""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893:155,depend,depends,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893,1,['depend'],['depends']
Integrability,This is another reason why the `Checkpointer` essentially has to depend on the `simulation` rather than just the `model`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3845#issuecomment-2414490055:65,depend,depend,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845#issuecomment-2414490055,1,['depend'],['depend']
Integrability,This is helpful - thanks Greg. It's good to have some options when unable to find the error messages during debugging!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162:92,message,messages,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162,1,['message'],['messages']
Integrability,"This is my first attempt at making a version of `cell_advection_timescale` for `ShallowWaterModel`. Note that we are dividing elements of mass flux and height, which are not defined at the same cell points, but if we are looking for estimates I wonder if this will be sufficient. I have not tested this as I'm not sure how to integrate this into the rest of the code, but I thought we could try that after we agree on what the script should look like. ```; ""Returns the time-scale for advection on a regular grid across a single grid cell ; for ShallowWaterModel.""; function cell_advection_timescale(uh, vh, h, grid); umax = maximum(abs, uh / h); vmax = maximum(abs, vh / h). Δx = grid.Δx; Δy = grid.Δy. return min(Δx/umax, Δy/vmax); end. cell_advection_timescale(model) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052:326,integrat,integrate,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052,1,['integrat'],['integrate']
Integrability,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592:23,interface,interface,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592,4,"['depend', 'interface']","['depend', 'interface', 'interfaces']"
Integrability,"This is the bathymetry that the code is currently using. Looks pretty nice. @simone-silvestri I am looking in `shallow_water_advection_operators.jl` and find something odd. Bathymetry only appears in `div_Uh` but not in `div_hUu` and `div_hUv`. I think this is reversed as the evolution equation for height doesn't care about the bathymetry, it's only the pressure term that depends on it. Do you agree?. ; ![topography](https://user-images.githubusercontent.com/8239041/168833014-c399f006-b5cb-4c30-b72c-f4b221b911c0.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128944255:375,depend,depends,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128944255,1,['depend'],['depends']
Integrability,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107,1,['interface'],['interface']
Integrability,This kind of error arises when using the environment on the branch `integrate-turbulence-closures`:. ```juliarepl; (Oceananigans) pkg> st; Project Oceananigans v0.5.4; Status `/archive1/glwagner/Projects/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v0.4.2; [c5f51814] CUDAdrv v3.0.1; [be33ccc6] CUDAnative v2.1.1; [3a865a2d] CuArrays v1.0.2; [7a1cc6ca] FFTW v0.2.4; [ba82f77b] GPUifyLoops v0.2.3; [4138dd39] JLD v0.9.1; [30363a11] NetCDF v0.7.3; [90137ffa] StaticArrays v0.10.3; [a759f4b9] TimerOutputs v0.5.0; [8ba89e20] Distributed ; [37e2e46d] LinearAlgebra ; [de0858da] Printf ; [9a3f8284] Random ; [10745b16] Statistics ; [8dfed614] Test ; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496478250:68,integrat,integrate-turbulence-closures,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496478250,1,['integrat'],['integrate-turbulence-closures']
Integrability,This looks great! I think we can re-state light integration as a field reduction with this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2100229281:48,integrat,integration,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2100229281,1,['integrat'],['integration']
Integrability,This looks super cool: I'll be happy to meet for coffee and chat in person (assuming you're both at MIT) but I am not very familiar with tools in climatology* and think @meggart @visr @evetion @mkborregaard and @juliohm will be in a better position to comment about it. *The packages in JuliaGeo have been mostly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475667907:385,interface,interface,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475667907,1,['interface'],['interface']
Integrability,"This may be beyond the point of this PR, but I feel like lots of these discussions that ultimately mostly impact user interface and experience would hugely benefit from, well, user input! . This fact, coupled with the fact that Oceananigans probably now has a decently-sized user-base, may mean that we could start using polls and directly asking users about user-interface decisions. That way we can get more hard data on what makes the code easier and clearer to most users and weight that more accurately against other aspects of the decision. Just a thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999:118,interface,interface,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999,2,['interface'],['interface']
Integrability,"This should be done already (I'm not sure why the tests keep failing, its annoying). I made the change because I seriously could not understand the code. I kept getting confused between ""compute boundary tendencies"" (which adds fluxes to the tendencies, coming in from the boundaries), and ""compute tendencies_boundaries"", which did something completely different (compute the halo dependent tendencies). So I started by changing the names so I could reason about the code without my head spinning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398224325:382,depend,dependent,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398224325,1,['depend'],['dependent']
Integrability,"This velocity field:. ```julia; uᵢ(x, y, z) = (1-tanh((x-500)/10)); ```. is compressible, because `uᵢ` depends on `x`. When we project out the compressible component (the part that depends on `x`), we are left with just `u=1`. What do we expect to happen in this case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462:103,depend,depends,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462,2,['depend'],['depends']
Integrability,"To address the first issue, here's the definition of `time_average_outputs`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L11-L16. The arguments are the specified `schedule` (which is an `AveragedTimeInterval` per the API we have designed), the `outputs` (here a `Dict`), `model`, and `field_slicer` (because we support averaging slices of fields). The first line:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L12-L13. converts the `outputs` `Dict` into a `Dict` of `WindowedTimeAverages` by wrapping each member of output in `WindowedTimeAverage`. The second part is to return the `TimeInterval` that corresponds to `AveragedTimeInterval`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L15. It'd be great to improve this functionality if we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599:662,wrap,wrapping,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599,1,['wrap'],['wrapping']
Integrability,"To answer @tomchor's question, yes, the grid is formed at the faces and that's easy enough to do when building the grid. For @ali-ramadhan questions. 1. @glwagner suggested that I try doing this in `VerticallyStretchedGrid` to see what it looks like and then we can discuss it. I'm happy to say that was very successful and now we are talking about it. I guess whether this PR is merged or not depends on how we want to proceed.; 2. Yes, I guess the question is what is the best design for the average user. Whatever we do, not everyone is going to like it but we should strive for something that is ""easy`, since that's in the description of Oceananigans. As a user I think I would simply want to specify the domain and then say I want a tighter grid around a particular point, say the left boundary, or any other point for that matter. I don't think the average user is going to care whether it's quadratic, cubic or hyperbolic, as long as you get better resolution around the point of interest. Is this something we agree on? If yes I would ideally want to user to specify the domain, where they want the clustering and then boom it happens. . @glwagner also suggeted in #1532, that it would be nice for us to put together some functions that the user can use to define grids. Specifying the array is not too difficult but I think we can make it easier by having functions to do most of the work for the user. I like @ali-ramadhan 's suggestion of having options in terms of what the input is and I will certainly need some help doing this, after we decide what we want the input to be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543:394,depend,depends,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543,1,['depend'],['depends']
Integrability,To avoid `Manifest.toml` merge conflicts should we update NCDatasets.jl (#1217) and StaticArrays.jl (#1222) in this PR as well?. I actually don't think we use StaticArrays.jl...? I used it for the `WENO{N}` implementation but it's currently commented out until it can be made efficient (also users did not like the sympy dependency).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735389432:321,depend,dependency,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735389432,1,['depend'],['dependency']
Integrability,"To be sure, I didn't know that it would fail with scalars on the GPU and I don't really know why that happens... !. Note that you can also simply output a scalar to file every time-step and do the time-integration offline. JLD2 is lightning fast so you probably won't pay for that. That's actually the simplest method, and as a bonus you get the time history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609:202,integrat,integration,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609,1,['integrat'],['integration']
Integrability,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:725,integrat,integrate,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839,2,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,"To compare the numerical solution of the Rossby-Haurwitz wave on the cubed sphere against an established benchmark, I chose the exact solution of the non-linear barotropic vorticity equation on the sphere (not the solution of the non-linear shallow water equations). This was achieved by replacing the initial phase Rλ with the time-dependent phase Rλ−νt in Equations (143)–(146) of [Williamson et al.](https://www.sciencedirect.com/science/article/pii/S0021999105800166), using the angular velocity ν given by Equation (142). The results at a resolution of 128x128 cells per panel are as follows:. - Since we prescribe the initial stream function and numerically take its derivatives to specify the initial velocities on the cubed sphere, numerical errors are present even in the initial velocities and the diagnosed initial vorticity. The vorticity error is significantly pronounced near the cubed sphere corners due to the deviation from orthogonality. For instance, in the domain's interior, the vorticity error norm is three orders of magnitude less than the vorticity norm, whereas at the corners, it is nearly the same order of magnitude.; - As the simulation progresses, the amplified error from the corners propagates into the interior as expected. After 500 time steps, the vorticity error in the interior increases from three orders of magnitude less to one order of magnitude less than the vorticity norm. I have attached panel-wise plots of the exact vorticity and the error of its numerical counterpart on the cubed sphere for the initial condition and after 500 time steps for reference. Given these circumstances, @navidcy and I are contemplating whether we should continue using the exact solution for verification in the test script or consider alternative verification methods, such as ensuring that the norm of the numerical solution of the Rossby-Haurwitz wave remains bounded within a specified range (as mentioned in the introduction to this PR). @glwagner, @simone-silvestri an",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684:333,depend,dependent,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684,1,['depend'],['dependent']
Integrability,"To do:. - Implement `mul!` for the Laplacian operator; - Implement a wrapper type for `Field` that subtypes `AbstractVector`?; - Implement `ldiv!` for the FFT-based preconditioner (after the first two are done), planning to use [`ldiv=true` with `cg`](https://jso.dev/Krylov.jl/dev/preconditioners/#Examples). This example illustrates implementing a custom operator:. https://jso.dev/Krylov.jl/dev/matrix_free/. Here is the documentation for implementing preconditioners in Krylov:. https://jso.dev/Krylov.jl/dev/preconditioners/. In Krylov, we want to remove broadcasting. . To make `Field` look like a vector we just need. ```julia; struct QuasiVector{FT, F} <: AbstractVector{FT}; field :: F; function QuasiVector(field); FT = eltype(field); F = typeof(field); return new{FT, F}(field); end; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415237451:69,wrap,wrapper,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415237451,1,['wrap'],['wrapper']
Integrability,"To fill in a few more details for @hennyg888 --- _almost all_ multithreading in Oceananigans is achieved via [`KernelAbstractions.jl`](https://github.com/JuliaGPU/KernelAbstractions.jl). Improving efficiency for Oceananigans kernels likely means contributing to `KernelAbstractions.jl` (which @vchuravy may or may not be excited about :-D). More specifically, all tendency evaluations, non-communicative / non-periodic halo fills (periodic halo filling uses Base broadcasting and thus is not parallelized), integrals (like the hydrostatic pressure integral, or vertical velocity computation in `HydrostaticFreeSurfaceModel`), evaluation of diagnostics, and broadcasting with fields all use KernelAbstractions via the Oceananigans function `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Utils/kernel_launching.jl#L71-L90. The line . ```julia; event = loop!(args...; dependencies=dependencies, kwargs...); ```. launches a kernel, using [`KernelAbstractions` syntax](https://juliagpu.github.io/KernelAbstractions.jl/stable/#Quickstart-1). `event` is a token that can be ""waited"" on if we need to. So either we can improve multithreading by changing what happens when `loop!` is called --- or, possibly, by refining the dependency tree so that we can launch more kernels simultaneously. The second optimization is probably more important for small problems. You have mostly benchmarked fairly large problems so I don't we'd see much speed for them. But I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423:921,depend,dependencies,921,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423,3,['depend'],"['dependencies', 'dependency']"
Integrability,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652:441,depend,depend,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652,1,['depend'],['depend']
Integrability,"Tthe MPI tag must be an integer. The maximum value is vendor dependent but it is quite strict. ; The smaller maximum value is [32767](https://www.intel.com/content/www/us/en/developer/articles/technical/large-mpi-tags-with-the-intel-mpi.html#:~:text=For%20the%20InfiniBand*%20support%20via,be%20queried%20in%20the%20application.). We could probably record the whole location without incurring in integer dimension issue. We cannot do ; `field_id * 100000 + loc_x * 10000 + loc_y * 1000 + loc_z * 100 + from_side * 10 + to_side` because the tag could be larger than 32767. ; However, we could combine the three locations in a dictionary; ```julia; (Center, Center, Center) -> 0; (Center, Center, Face) -> 1; (Center, Face, Center) -> 2; (Face, Center, Center) -> 3; (Face, Face, Center) -> 4; (Center, Face, Face) -> 5; (Face, Center, Face) -> 6; (Center, Center, Nothing) -> 7; (Face, Center, Nothing) -> 8; (Center, Face, Nothing) -> 9; ...; ```; If all the permutations fit into 99 values, we consume only 2 digits which would probably fit within the limits. We can also compress the `from_side` and `to_side` into only one digit because we have; ```julia; west to east -> 0; east to west -> 1; south to north -> 2; north to south -> 3; top to bottom -> 4; bottom to top -> 5; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2297127373:61,depend,dependent,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2297127373,1,['depend'],['dependent']
Integrability,Two questions:. > Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Is this one node or multiple nodes? . Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585:45,depend,dependent,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585,1,['depend'],['dependent']
Integrability,"Unfortunately it doesn't work for me:. ```julia; (base) tomas@np900:~/repos/Oceananigans.jl$ julia1.6 --project=docs/ -e 'using Pkg; Pkg.instantiate()'; (base) tomas@np900:~/repos/Oceananigans.jl$ julia1.6 --project=docs/ docs/make.jl; ERROR: LoadError: LoadError: LoadError: ArgumentError: Package SpecialFunctions [276daf66-3868-5448-9aa4-cd146d93841b] is required but does not seem to be installed:; - Run `Pkg.instantiate()` to install all recorded dependencies. Stacktrace:; [1] _require(pkg::Base.PkgId); @ Base ./loading.jl:990; [2] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [3] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [6] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compile",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:453,depend,dependencies,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['depend'],['dependencies']
Integrability,"Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298424146:136,synchroniz,synchronization,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298424146,1,['synchroniz'],['synchronization']
Integrability,"Update: we think this error arises because `CUDAnative` is not a dependency of `Oceananigans`. As a result, a `launch` function is not compiled by `GPUifyLoops`. In principle, this problem *could* be solved by adding `CUDAnative` to `Oceananigans`. However, this is not possible because `CUDAnative` and `CUDA` (which `Oceananigans` currently uses for CUDA functions / abstractions) cannot be used in the same environment due to conflicting requirements for `Adapt`. cc @sandreza @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/784#issuecomment-652686565:65,depend,dependency,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/784#issuecomment-652686565,1,['depend'],['dependency']
Integrability,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:172,depend,depending,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350,1,['depend'],['depending']
Integrability,"Using hu vs u: My reasoning was always the following: The dynamical balance of your model will depend on the practical problem and scales you will look at, hence the conclusion which (dominant) terms should be discretized ""naturally"" and ""nicely"" may vary. On the other hand, all incompressible models have the same volume conservation constraint which is most naturally discretized using hu as fundamental variables (specially on a C-grid). m2c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358:95,depend,depend,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358,1,['depend'],['depend']
Integrability,"Using this branch I get. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×1×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:245; ERROR: ArgumentError: halo must be ≤ size for coordinate y; Stacktrace:; [1] validate_halo(TX::Type, TY::Type, TZ::Type, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/input_validation.jl:87; [2] validate_rectilinear_grid_args(topology::Tuple{…}, size::Tuple{…}, halo::Tuple{…}, FT::Type, extent::Nothing, x::Tuple{…}, y::Tuple{…}, z::Tuple{…}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/rectilinear_grid.jl:292; [3] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{…}, x::Tuple{…}, y::Tuple{…}, z::Tuple{…}, halo::Tuple{…}, extent::Nothing, topology::Tuple{…}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/rectilinear_grid.jl:269; [4] with_halo(new_halo::Tuple{…}, old_grid::RectilinearGrid{…}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/rectilinear_grid.jl:389; [5] inflate_grid_halo_size(::RectilinearGrid{…}, ::WENO{…}, ::Vararg{…}); @ Oceananigans.Models.Nonhyd",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310594352:91,depend,dependency,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310594352,1,['depend'],['dependency']
Integrability,"Utlimately, Clima will need julia tools for determining seawater properties. At that time, we can direct users to those tools for determining seawater properties like `cP` that might be needed for setup calculations. Until then perhaps we do not want to encouage a dependence on `Oceananigans` for values of `cP`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/190#issuecomment-525545777:265,depend,dependence,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/190#issuecomment-525545777,1,['depend'],['dependence']
Integrability,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:293,interface,interface,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748,3,['interface'],['interface']
Integrability,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:809,depend,depend,809,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800,3,['depend'],"['depend', 'dependencies', 'dependency']"
Integrability,"Very nice work @glwagner , and thanks for making this. Lots of good stuff here. In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent. Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886072589:240,depend,dependent,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886072589,1,['depend'],['dependent']
Integrability,"Very sorry for the problems that you found but I'm glad you found them. I believe when @ali-ramadhan and I put this together we were following other examples but I definitely should have been more careful. Just so that I understand, instead of having `momentum_flux_huu, advection` and `transport_tracer_flux_x` we should have had something involving the area? I'm happy to help fix this where I can. As for computing the velocity, I hope we can fix that soon as well. I know that `ShallowWaterModel` is a bit odd as we integrate the mass transports, not the velocities, but we do use the velocity a lot. I wonder if it's worth while computing the velocities (correctly) and then storing those. That should certainly help when we add in `closure` schemes, since those should be based on the velocities, for the most part. One option would be to add `model.velocities,u` and something similar for `v`, and then access them when we need them. That has the unfortuante effect of storing 5 instead of 3 fields, so it would make things more memory intensive. I don't know if it's better to just compute the velocities everytime we need them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937:520,integrat,integrate,520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937,1,['integrat'],['integrate']
Integrability,"Very thorough write-up, thank you!. My initial reaction is that maybe something is not wrong. Intuitively I feel that TKE statistics are generally less noisy than dissipation statistics, but I agree the difference between snapshot and time average is pretty big. This is simulation dependent and I'm sure you've thought about all this though. The two should agree in the limit that the averaging window (and output interval) goes to zero? Otherwise there's a bug. I think we have pretty good time averaging tests for NetCDF with analytic solutions (https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_netcdf_output_writer.jl#L476-L570) but we don't explicitly test `NetCDFOutputWriter` + `KernelComputedField` + `AveragedTimeInterval` so there could be a bug. What does a movie of dissipation look like?. I notice the time step is `Δt = 20minutes` while the output interval is `100minutes` so at most a time average will contain 4-5 iterations worth of data. If dissipation changes rapidly (or has a period) then I can see the average being quite different from the snapshot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746:282,depend,dependent,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746,1,['depend'],['dependent']
Integrability,"Victoria, is the velocity normal to the cylinder zero? and perhaps the; tangential component too, if you are using no-slip boundary conditions. I; have a nice application of all this if you are going in 3-d. John. On Thu, Dec 3, 2020 at 2:54 PM Gregory L. Wagner <notifications@github.com>; wrote:. > That solution looks pretty good!; >; > As far as I can tell I think it makes sense for the ""full"" pressure field; > to continue smoothly into the IB, since the pressure field is somehow a; > solution to Poisson's equation --- even if the RHS of the Poisson equation; > varies rapidly close to the IB (?); >; > Does the magnitude of the velocity error scale with the time-step, or; > resolution? Perhaps plotting the dependence of the error on some of those; > parameters can give us confidence that the method is working as expected.; >; > Should we try iterating the IB correction + pressure solve to see if it; > reduces the velocity error, as we hypothesized it might?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738270609>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRQB7MCPDWK3EEILQDSS7UJBANCNFSM4SNJ4CSA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738278829:717,depend,dependence,717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738278829,1,['depend'],['dependence']
Integrability,"We can add a warning message ""note that if you used to use version blah then this now changed... etc"" and keep it there for a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455156276:21,message,message,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455156276,1,['message'],['message']
Integrability,"We can consider changing this kwarg to `directions`. I don't think we had much a conversation about it, but the two we considered originally were `direction` and `isotropy`. One motivation for using `isotropy` is to smoothly transition from ""IsotropicDiffusivity"" (with three-dimensionality implied) and ""AnisotropicDiffusivity"" (meaning, different in the horizontal and vertical directions) to a single struct. But having a clear meaning for most people is more important than that continuity. Isotropy in _one_ direction is accurate in my opinion, though I agree its the trivial case (like a ""set"" with one element) and therefore reads a little awkwardly. Diffusion can act in the ""horizontal directions"" while being horizontally-anisotropic (ie the diffusion of a vector depends on its orientation), so the meaning is a bit different. But, we can document that `ScalarDiffusivity` is isotropic in its `directions` for vectors like momentum. > To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. We can indeed use a second closure to set a vertical diffusivity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693:774,depend,depends,774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693,1,['depend'],['depends']
Integrability,"We can use an abstract type to obviate the need for ""zero functions"":. ```julia; abstract type AbstractBiogeochemistry end. struct NutrientsPlanktonDetritus{FT} <: AbstractBiogeochemistry; background_nutrients :: FT; mortality_rate :: FT; nitrification :: FT; end; ```. then with. ```julia; @inline (::AbstractBiogeochemistry)(i, j, k, grid, val_tracer_name, clock, fields) = zero(grid); ```. users don't need to define the ""netural biogeochemical forcing"" themselves. . Very Important: always use verbose names! I don't know how to enforce that within the API 😂 . I like this interface. Let's figure out if `Val{symbol}` is GPU-friendly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305830081:577,interface,interface,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305830081,1,['interface'],['interface']
Integrability,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:273,wrap,wrapper,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949,1,['wrap'],['wrapper']
Integrability,"We could do that, in fact the requests are stored in the `arch.mpi_requests` vector. The problem with using the length of that vector for inferring a `field_id` is that is not unique for different ranks. For example, a slab decomposition on a bounded domain will lead to 2 requests for the rank adjacent to boundaries (RightConnected or LeftConnected) and 4 for ranks connected on both sides. In this way, the counter is incremented globally when one field is sent, the side is inferred from the `fill_halo_side!` routine so this, combined to a location, leads to a unique tag. . What about changing the `mpi_tag` name to `active_comm_counter` and add an inverse function to extract the inputs from the tag? Then it is quite easy to inspect the tag and understand what communication we are looking at.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299104321:514,rout,routine,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299104321,1,['rout'],['routine']
Integrability,"We could implement an interface similar to `Buoyancy`, but I think this may be more easily done with `FPlane`, since `NonTraditionalFPlane` seems to be dedicated not for tilting domains, but for decomposing rotation based on latitude. We'd have something like. ```julia; θ_rad = 0.05 # radians; g̃ = (sin(θ_rad), 0, cos(θ_rad)); buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=g̃); coriolis = FPlane(f=1e-4, vertical_unit_vector=g̃); ```. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885020205:22,interface,interface,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885020205,1,['interface'],['interface']
Integrability,We could to suggest wrapping the `Reduction` in a `Field`. I'm not 100% sure the best way to inject that kind of hint; we don't own operations like `/` so I think to do that we would have to define them (and then throw an error). Hmm.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347473891:20,wrap,wrapping,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347473891,2,"['inject', 'wrap']","['inject', 'wrapping']"
Integrability,"We have always launched a kernel for flux bcs! Our method is 1) fill halos to nullify diffusive fluxes across boundaries; 2) add the specified fluxes directly to boundary cells. Step 1 requires filling halos, which we have always done for flux bcs. Previously, we used broadcasting for flux bcs, similar to what we do for periodic bcs. When the halo size was greater than 1, the intent of the broadcast operation was violated, however, because zero diffusive flux was not guaranteed for biharmonic diffusivity. This PR corrects that, allowing biharmonic diffusivities to be used in bounded domains. Some informal benchmarks suggest that a KernelAbstractions kernel can be more efficient than using GPUArrays broadcasting. KernelAbstractions kernels are also multithreaded, unlike broadcast operations. Thus I would expect speed up from this change, rather than slowdown (but likely negligible speed up). But of course benchmarking is a good idea, and if there is a problem we should open an issue. Another advantage is that we can utilize KernelAbstractions dependency feature more fully if we get to the point where we do not use broadcasting for anything. We haven't optimized our dependency structure, however. Also, there are a few puzzles to be worked out regarding periodic boundary conditions before we can convert the periodic halo filling to kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/904#issuecomment-686430220:1058,depend,dependency,1058,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/904#issuecomment-686430220,2,['depend'],['dependency']
Integrability,"We have fully implemented a hard coded drag into all of the momentum viscous fluxes. Since this implementation of the drag has different values for ""symmetric"" fluxes such as `viscous_flux_uy` and `viscous_flux_vx` that are located at the same point, the `conditional_flux_fcc` location-separated fluxes were not enough. We split these into functions such as `conditional_flux_fcc_uy` and `conditional_flux_fcc_vx`. It'll be easier to address these issues directly in the immersed `viscous_flux` once we have a separate term in the tendency equations with its own functions. . These functions then check whether the interface between solid and fluid is at the top of a cell or the bottom of a cell, applying the correctly directioned drag for that side. The way these conditionals work, the fully immersed cells that aren't on a boundary would be calculating fluxes as usual, except that all those terms are masked. So the fluxes inside the solid will remain zero. When the solid-fluid interface is at the top or right hand side of a cell, the velocities for that `(i,j,k)` location will all be within the solid. If you use them in your drag functions, it would just be zero flux. So, the drag at a top flux interface, for instance, located at `(i,j,k)` will use the velocities at `(i,j,k-1)`, and so on for the other directions. This makes them match the usual non-immersed drag BC for the 1D case as seen below. . https://user-images.githubusercontent.com/67593861/160839128-37ab95fa-f28b-43c0-8bbf-3c850ae754f2.mp4. https://user-images.githubusercontent.com/67593861/160839127-912ee3d0-75e9-4536-a494-2ec3c6c2b006.mp4. https://user-images.githubusercontent.com/67593861/160839125-bef17105-d8ac-4999-a3f0-fbbb55e8498a.mp4. @tomchor has also tested them with 3D setups, which worked as well! There's still a lot of room for streamlining and speeding up this set up, which I believe will be easier to do in the full implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667:616,interface,interface,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667,3,['interface'],['interface']
Integrability,We need https://github.com/CliMA/OrthogonalSphericalShellGrids.jl/pull/44 + a new release of OrthogonalSphericalShellGrids.jl otherwise the cyclical dependency blocks Oceananigans from bumping minor version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2436720325:149,depend,dependency,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2436720325,1,['depend'],['dependency']
Integrability,We only put the no normal gradient matching scheme in the source code which just overwrites the boundary point so this wasn't a problem. I though we weren't going to put lots of matching schemes in the source code since its not clear what is the best/correct. We could put in a simple scheme that integrates the boundary point if that would be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794:297,integrat,integrates,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794,1,['integrat'],['integrates']
Integrability,"We should have a way to mask the tracers for sure. On the other hand, in our current algorithm we do not ""use"" immersed ""halo"" nodes because we impose a no-flux condition by just setting to zero the fluxes on the immersed boundaries - opposed to actual boundaries where the ""no-flux"" condition is imposed by mirroring the values outside the boundary and explicitly calculating a flux. For this reason, we don't need to mask the tracer within the time integration. So, it is not necessary, but It is definitely a function we want to allow...; I see the confusion, what I meant is we need to remove it if it is done within the time stepping, but we leave the functionality there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180:451,integrat,integration,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180,1,['integrat'],['integration']
Integrability,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232:10,wrap,wrap,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232,1,['wrap'],['wrap']
Integrability,"We want to write. ```julia; @inline left_biased_αx₀(i, j, k, grid::AbstractGrid{FT}, ψ) where FT = C3₀ / (left_biased_βx₀(i, j, k, ψ) + FT(ε))^ƞ; ```. this will convert the floating point number `1e-6` to the appropriate precision prior to summing with the result of `left_biased_βx₀`, which in turn will compute the exponential in the appropriate precision. ultimately `left_biased_βx₀` needs to depend on `grid` to resolve #1704 so it might be smart to do that at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-873430896:397,depend,depend,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-873430896,1,['depend'],['depend']
Integrability,"We've decide that a better solution is to leave halo regions untouched when possible, rather than creating an intricate web of dependencies between different fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-716251553:127,depend,dependencies,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-716251553,1,['depend'],['dependencies']
Integrability,Well it adds a new feature. I could just bump to 0.91.6 instead but it seems quite a major feature to justify the bump in version.; Also it removes dependencies on quite some packages.; What do people think?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2269883534:148,depend,dependencies,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2269883534,1,['depend'],['dependencies']
Integrability,"Well, I agree this is a discussion worth having. Users need not add a new turbulence closure in the source code --- they can be added externally (eg in a model script) easily via multiple dispatch. We've illustrated this before, but I can't find the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:808,interface,interface,808,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,1,['interface'],['interface']
Integrability,"Well, it depends what definition of `h` you have if you include b in momentum or continuity, I agree with you that if `h` is total depth, b is found in the momentum equations. If not is found in continuity",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128978553:9,depend,depends,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128978553,1,['depend'],['depends']
Integrability,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199:761,depend,dependencies,761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199,2,"['depend', 'message']","['dependencies', 'message']"
Integrability,"Well, right now, the `Model` includes both discrete and continuous aspects of the PDE. `Model` also stores `architecture`, for example, which is unrelated to the PDE. We did consider an abstraction that represented the equation set independent from discretization. This would not be a replacement for model, but would simply be a way to organize some of the properties of model (eg buoyancy, coriolis, diffusion, etc). Yet this is a challenging abstraction to design. One issue is specification. If we try to separate the terms from their numerical implementation, we have to figure how to distinguish between ""diffusion with second-order differences"" and ""diffusion with fourth-order differences"". It's clearly possible to do this, but it's going to take some time and careful thought to implement. We've taken a more incremental approach to development the model instead, resulting in a fairly ""flat"" interface to `IncompressibleModel` that combines aspects both of the continuous equations, their discretization, and things like `architecture`, the `pressure_solver`, etc. I think flat is simple (think parameter files as the platonic ideal of a flat API); however, we still want to benefit from modularity where it's a simple change that doesn't overcomplicate the interface (hence this issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729123548:903,interface,interface,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729123548,2,['interface'],['interface']
Integrability,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:554,depend,dependence,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524,1,['depend'],['dependence']
Integrability,"Well, this is interesting. I guess when we designed the interface for `KernelComputedField` I envisioned that `field_dependencies` would be a list of `AbstractField`s (hence the name). The point is that `compute!(element)` is called on every `element` of `field_dependencies`. `u_tot` is not a field, its an `AbstractOperation`. The interesting thing is that `compute!(u_tot)` can actually do something, because `compute!` is _also_ defined for `AbstractOperations` (if `u_tot` has any `ComputedField`s in its tree, they get computed). This is a use case I didn't think of. Other objects in `field_dependencies` (like integers, floating point numbers) are ok because there's a fallback `compute!(arbitrary_object) = nothing`. However, I don't like allowing this because it makes scripts confusing to read. An integer is an ""integer dependency"" (or just a ""dependency"") --- not a ""field dependency"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594:56,interface,interface,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594,4,"['depend', 'interface']","['dependency', 'interface']"
Integrability,"Well. Reading the error message *very* closely, it looks like the failure occurs when the generator --- for some reason --- attempt to assign an Oceananigans Field at `Face, Cell, Cell` to a location expecting an Oceananigans field at `Cell, Cell, Cell`. This looks like a deep and strange issue associated with the generator function. Very odd. I think we can rewrite the code that extracts the output to use tuples rather than a dict, which might fix the issue. I'm not sure this is super important because we can never output fields directly on the GPU anyways. As stated above, however, it would be nice to fix this issue so that we can output fields directly for other purposes. I've changed the title to accurately reflect the error / bug. If this is investigated earlier it may be worthwhile raising this issue on the julia github. Something funny is happening here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-580297792:24,message,message,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-580297792,1,['message'],['message']
Integrability,"Welp, it's a minor difference at 8m resolution here:. https://user-images.githubusercontent.com/15271942/164351531-dae7cec6-de9a-43a7-a60f-29f6bbeeb060.mp4. ""new"" is this PR. The results are expected though I think: when we put the diffusivity at cell interfaces (holding everything else the same / all parameters constant), the mixing rate is slightly reduced. @navidcy @simone-silvestri @adelinehillier shall we merge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829:252,interface,interfaces,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829,1,['interface'],['interfaces']
Integrability,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:24,interface,interface,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276,1,['interface'],['interface']
Integrability,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917:23,rout,route,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917,1,['rout'],['route']
Integrability,"What if `nu` varies? Do we write this. ```; h⁻¹ ∇ ⋅ (ν h ∇u); ```. ?. this could be implemented using the existing closures:. 1. Add a property `velocities = (u = uh / h, v = vh / h)` (the abstract operations, no data) to `ShallowWaterModel`; 2. Support only `HorizontalScalarDiffusivity` and `HorizontalScalarBiharmonicDiffusivity` (explicitly forbid other closures in the constructor); 3. Then in the constructor, rewrite the closures with. ```julia; if closure isa HorizontalScalarDiffusivity; ν = closure.ν; thickness_weighted_ν = h * ν # Works when `ν` is a number, field, or function of (x, y, z); thickness_weighted_closure = HorizontalScalarDiffusivity(ν = thickness_weighted_ν); end; ```. The same sort of logic applies to tracers diffusivities and also for biharmonic viscosity / diffusivities. 4. Write the kernel functions as. ```julia; 1 / h[i, j, k] * ∂ⱼ_τ₁ⱼ(i, j, k, grid, closure, diffusivities, velocities, tracers, clock, nothing); ```. (the `nothing` is `buoyancy` in our 3D models). I think that should work. The only case that won't work is diffusivities that are functions of `(x, y, z, t)`. But in fact this could be supported too by wrapping function `ν` in `FunctionField` with the model `clock` in the model constructor when `ν_effective` is calculated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833:1157,wrap,wrapping,1157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833,1,['wrap'],['wrapping']
Integrability,"What parallelism strategy makes sense? One particle per thread? Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Presumably `TimeSeries` makes sense for simple diagnosed particle ""properties"" and is the place to start. Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design, especially because our time stepping is not very abstracted yet. If we are integrated with DifferentialEquations this job might get a bit easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547069123:412,depend,depend,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547069123,2,"['depend', 'integrat']","['depend', 'integrated']"
Integrability,What was the code? We can improve the error message,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2313485356:44,message,message,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2313485356,1,['message'],['message']
Integrability,"What's the point of wrapping it in `Forcing`?. I think a cleaner syntax is . ```julia; u_forcing = FieldTimeSeries{}(...); model = NonhydrostaticModel(; grid, forcing = (; u = u_forcing)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3760#issuecomment-2329663112:20,wrap,wrapping,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3760#issuecomment-2329663112,1,['wrap'],['wrapping']
Integrability,"When I exit the REPL I get a very long error message ending:; <summary>; <details>; ```; WARNING: Error while freeing DeviceBuffer(568 bytes at 0x0000000320000400):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemFreeAsync; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #free#2; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:97 [inlined]; [5] free; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:92 [inlined]; [6] #actual_free#976; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:77 [inlined]; [7] actual_free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:74 [inlined]; [8] #_free#998; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:492 [inlined]; [9] _free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:479 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:464 [inlined]; [11] macro expansion; @ ./timing.jl:393 [inlined]; [12] #free#997; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:463 [inlined]; [13] free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:452 [inlined]; [14] (::CUDA.var""#1004#1005""{CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, CUDA.CuStream})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:130; [15] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; WARNING: Error while freeing DeviceBuffer(560 bytes at 0x0000000320000000):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:45,message,message,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129,1,['message'],['message']
Integrability,"When I set the halo to be `halo=(3,3)` I get the following error message since it wants `halo=(3,3,0)`. This seems slightly less than idea. Should we make it so that either are acceptable?. ```; [2021/05/18 12:08:59.339] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grid; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614:65,message,message,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614,1,['message'],['message']
Integrability,When the `Oceananigans` github page is opened it might present this helpful message:. ![image](https://user-images.githubusercontent.com/15271942/136055771-2191957e-eced-4696-9362-03aac3e10722.png). Copy/pastable commands:. ```; git branch -m master main; git fetch origin; git branch -u origin/main main; git remote set-head origin -a; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1446#issuecomment-934522905:76,message,message,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1446#issuecomment-934522905,1,['message'],['message']
Integrability,"While bathymetry is not a priority at the moment, there may be simple, non-invasive methods (from an algorithms standpoint) like the one described in the slack message pasted by @ali-ramadhan for modeling non-rectangular domains. . Probably the main challenge is not implementing the method (which could take a few days), but verifying and validating the implementation (more likely a few weeks of work at minimum). A collaboration with others who are knowledgeable in Julia and can participate in debugging and validation is probably the best chance for having this feature implemented any time soon, given the time constraints of the main developers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644:160,message,message,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644,1,['message'],['message']
Integrability,"While using `main` indeed I can reproduce the error above... ```Julia; navidcy:Oceananigans.jl/ |main ✓|$ julia-1.10 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.10.0 (2023-12-25); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; └ @ ~/Oceananigans.jl/Manifest.toml:0; ┌ Warning: The project dependencies or compat requirements have changed since the manifest was last resolved.; │ It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.; └ @ Pkg.API ~/julia-1.10/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:1800; Precompiling Oceananigans; 1 dependency successfully precompiled in 21 seconds. 143 already precompiled.; [ Info: Oceananigans will use 48 threads. julia> grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Ce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:432,depend,dependencies,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,3,['depend'],"['dependencies', 'dependency']"
Integrability,"Why does `BoundaryConditions` need to depend on `Distributed`? I think `Distributed` needs to _extend_ `fill_halo_regions!`. For this, `Distributed` must come _after_ `BoundaryConditions`. I also think that `Distributed` needs to come after `Field`; and `Field` depends on `BoundaryConditions`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489:38,depend,depend,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489,2,['depend'],"['depend', 'depends']"
Integrability,"Wow, awesome work!. Here are a few thoughts/comments:. > * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid"". :+1: much clearer. > * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:775,interface,interfaces,775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,1,['interface'],['interfaces']
Integrability,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1303,depend,depends,1303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['depend'],['depends']
Integrability,"Yea agree that it might be considered an ""abuse of abstraction"" to define `end` to mean ""the grid point corresponding to the physical edge of the domain"". That's what @sandreza expected, however? #UsersComeFirst . Maybe what we need is a section in the docs about working with underlying discrete data structures that includes a practical discussion about halos and the staggered grid, with examples. And we'll recommend using continuous interfaces as much as possible to avoid mistakes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691067868:438,interface,interfaces,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691067868,1,['interface'],['interfaces']
Integrability,"Yeah I think we definitely want `cpu` and `gpu`, then `examples` would be a good third one for now. Plots.jl would be the big dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/195#issuecomment-485529302:126,depend,dependency,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195#issuecomment-485529302,1,['depend'],['dependency']
Integrability,Yeah definitely agree the two should have a consistent interface. I'm also in favour of a single `filepath` keyword argument that encompasses both `filename` and `dir`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-684825114:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-684825114,1,['interface'],['interface']
Integrability,Yeah not the most informative error but it does something! I usually just expect a slower simulation due to float conversions. Checking types would be great! I don't even think there's a test that sets up a `Float32` model and just checks that it's fully `Float32` all the way down. I've also mostly stuck to `Float64` simulations but I am interested in whether `Float32` can work nicely out of the box. Sounds like it'll probably be quite case-dependent...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785#issuecomment-2369729862:445,depend,dependent,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785#issuecomment-2369729862,1,['depend'],['dependent']
Integrability,Yeah pretty sure I fixed this in the (increasingly stale) `ar/integrate-vs-grid` branch but should double check what I did there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/667#issuecomment-595013489:62,integrat,integrate-vs-grid,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/667#issuecomment-595013489,1,['integrat'],['integrate-vs-grid']
Integrability,"Yeah the idea is that if the docker build passes, then the image contains a working version of Oceananigans. So anyone can download the image and spin up containers running Oceananigans, and it will work out of the box without having to worry about having the right version of Julia, the right dependencies, build issues, etc. Might only be used by people already familiar with Docker, but another nice use case is if we're spinning up large ensembles of simulations we can just download the docker image instead of having every instance download/install/build Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/316#issuecomment-516915995:294,depend,dependencies,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316#issuecomment-516915995,1,['depend'],['dependencies']
Integrability,Yeah the output writing might get complicated as it could depend on the grid and boundary conditions and #86. . Will also be more complicated when data is spread across multiple cores or GPUs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/92#issuecomment-468295104:58,depend,depend,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/92#issuecomment-468295104,1,['depend'],['depend']
Integrability,"Yeah the plot is from v0.5.x or something lol. Not sure if CPU -> GPU speedups are as relevant anymore? Well, maybe a lot of people are still on CPUs. The speedup can be much larger with WENO, but it's all very CPU and GPU dependent. I've seen ~8x and ~2000x speedups for the same benchmark. Also not sure if there are any good metrics to quantify performance. But @simone-silvestri's scaling plots would probably be great to include?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272351495:223,depend,dependent,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272351495,1,['depend'],['dependent']
Integrability,"Yeah the problem with `ifelse` is that it actually calculates both branches. I thought it was faster on the GPU as well, but it depends on the use case. We've been using explicit `if` statements in the z-operators for a long time and it was still decently fast with millions of if statements per time step so I don't think using it in an AMD kernel will be bad. We should still run `benchmark_turbulence_closures.jl` before and after of course.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/335#issuecomment-519092641:128,depend,depends,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/335#issuecomment-519092641,1,['depend'],['depends']
Integrability,"Yeah, I guess that would work too!. It does have to just be one kernel per point I think because the modified value depends on all of the other tracer values.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719178763:116,depend,depends,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719178763,1,['depend'],['depends']
Integrability,"Yeah, live-plotting was always a bit of a suspect strategy in general. I think adding an output writer is a great idea. . Would be pretty neat also to have the ability to export snapshots from the interior of a running `Simulation`, somehow (basically, more descriptive simulation logging) --- some kind of callback function? In theory I suppose such a function could be integrated with `progress`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/676#issuecomment-595422486:371,integrat,integrated,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/676#issuecomment-595422486,1,['integrat'],['integrated']
Integrability,"Yep. the inputs `Ax, Ay, Az, C, D` are used to construct the matrix that solves; ```; Axᵢ₊₁ xᵢ₊₁ + Axᵢ xᵢ₋₁ + Ayⱼ₊₁ xⱼ₊₁ + Ayⱼ xⱼ₋₁ + Azₖ₊₁ xₖ₊₁ + Azₖ xⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) xᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) xᵢⱼₖ = b; ```; with periodic or zero-flux boundary condition depending on the topology of the grid (i.e. bounded topology -> zero flux BC, periodic topology -> periodic BC). If you need a matrix to solve the discretized Poisson equation at `ᶜᶜᶜ`:; ```; Ax = zeros(N...); Ay = zeros(N...); Az = zeros(N...); C = zeros(grid, N...); D = zeros(grid, N...); for i = 1:grid.Nx, j = 1:grid.Ny, k = 1:grid.Nz; Ax[i, j, k] = Δzᵃᵃᶜ(i, j, k, grid) * Δyᶠᶜᵃ(i, j, k, grid) / Δxᶠᶜᵃ(i, j, k, grid); Ay[i, j, k] = Δzᵃᵃᶜ(i, j, k, grid) * Δxᶜᶠᵃ(i, j, k, grid) / Δyᶜᶠᵃ(i, j, k, grid); Az[i, j, k] = Δxᶜᶜᵃ(i, j, k, grid) * Δyᶜᶜᵃ(i, j, k, grid) / Δzᵃᵃᶠ(i, j, k, grid); end; reduced_dim = (false, false, false); matrix_constructors, diagonal, problem_size = matrix_from_coefficients(arch, grid, (Ax, Ay, Az, C, D), reduced_dim); matrix = arch_sparse_matrix(arch, matrix_constructors); ```; Take care that, with these coefficients, the RHS will have to be multiplied by the volume. (otherwise you can always divide the coefficients by the volume before constructing the matrix)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1106118069:297,depend,depending,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1106118069,1,['depend'],['depending']
Integrability,"Yes !. On Thu, Apr 28, 2022 at 06:33:13AM -0700, Gregory L. Wagner wrote:; > @christophernhill does MITgcm have a divergence viscosity feature?; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112209787; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112313591:363,Message,Message,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112313591,1,['Message'],['Message']
Integrability,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:563,integrat,integration,563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970,1,['integrat'],['integration']
Integrability,"Yes, I can use `AbstractArray{FT}`, but it should represent a vector (whatever format he has).; For common array types, it always leads to an `AbstractVector`, so I never found the need to remove it.; I was always hesitant to relax this constraint because the type of `b` is used for allocating the ""vectors"" in the workspace of a Krylov method.; If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415718444:481,message,message,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415718444,1,['message'],['message']
Integrability,"Yes, except that we don't allocate memory for vorticity at all; we compute it on the fly. The prognostic fields are velocity components and tracers. For hydrostatic, w is diagnostic and free surface is prognostic. For nonhydrostatic, w is prognostic. The diagnostic fields include pressure, w if hydrostatic, and any diagnostics fields associated with the closure. We will also have a user interface for closure prognoetic fields at some point too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502:390,interface,interface,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502,1,['interface'],['interface']
Integrability,"Yes, it would be good to test that it converges quadratically as expected. If it's an expensive test that requires large solves we can throw it into a set of integration tests (#139) that runs less frequently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/227#issuecomment-495018342:158,integrat,integration,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227#issuecomment-495018342,1,['integrat'],['integration']
Integrability,"Yes, sorry. It only pertains to the netcdf outputwriter. Currently, we need the users to write `close(outputwriter)` at the end of their scripts to close open netcdf files. I am hoping to integrate that with `run_simulation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/650#issuecomment-592267256:188,integrat,integrate,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/650#issuecomment-592267256,1,['integrat'],['integrate']
Integrability,"Yes, that is the page that I saw.  I got there by searching the docs, not using the index.; On Sep 19, 2023 at 4:41 PM +0100, Gregory L. Wagner ***@***.***>, wrote:; > Hmm, yes I think that is an orphan page in the docs with no link...; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725927502:362,Message,Message,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725927502,1,['Message'],['Message']
Integrability,"Yes, this should work.  If it doesn’t work on kelp, you can try it on proteus or oceanus.; On Jun 20, 2024 at 10:41 PM +0100, Jago Strong-Wright ***@***.***>, wrote:; > The distributed regression tests are still failing but I'm not sure how to go about getting them to work because I can't work out how to run mpi locally, is it possible to do e.g. mpiexec -n 4 ... locally just on a single machine?; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181609099:526,Message,Message,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181609099,1,['Message'],['Message']
Integrability,"Yesterday, @ali-ramadhan and I discussed a new idea for improving the abstraction of equations. The idea is to abstract a `RightHandSide` consisting of a tuple of `Flux`es and `VolumeTerm`s or `SourceTerm`s. Each `Flux` or `VolumeTerm` type would define a `getindex` method, and carry around the references needed to execute that `getindex` method on CPU or GPU. This would greatly simplify the time-stepping routines, which currently involve long function signatures. There'd be no need for 'unpacking', because each term in the equation would perform unpacking upon instantiation. It would also probably be easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them referen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:409,rout,routines,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['rout'],['routines']
Integrability,"You are also right, the data was generated on the CPU so it should be synchronized correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1428721649:70,synchroniz,synchronized,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1428721649,1,['synchroniz'],['synchronized']
Integrability,You are saying that you’d expect to have estimates of the velocity values at the interfaces rather than their cell-averaged values (centered around the interfaces)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416:81,interface,interfaces,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416,2,['interface'],['interfaces']
Integrability,"You can also define a function `stop_if_nan(simulation)` that returns `true` if a NaN is detected, and then add this function to a simulation's stop criteria via `push!(simulation.stop_criteria, stop_if_nan)`. A few ways to do the same thing, which is why resolving #1138 would be nice for users. . Sorry if I implied that #1138 had to be resolved first. The problem right now is there are _too many_ ways to stop a simulation, which makes the user interface confusing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733258279:449,interface,interface,449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733258279,1,['interface'],['interface']
Integrability,"You can design convenience for the abstract operation too if you don’t care whether the user explicitly creates scratch space. For convenience for large numbers of computations with shared scratch space, I suggest a wrapper similar to FieldOutputs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/653#issuecomment-592706072:216,wrap,wrapper,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/653#issuecomment-592706072,1,['wrap'],['wrapper']
Integrability,"You can start by allowing the coefficient to be an array as in AMD:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L143. Then with a callback you can implement any model, including dynamic Smagorinsky. So this provides unlimited flexibility in developing a new closure. I think its possible you will find that its more efficient to precompute (eg in a callback) the coefficient rather than compute it on the fly with a function, especially because the computation of the different filters is a bit non-local, eg you have to average over a few grid points, which could involve relatively expensive memory fetches. A function-based interface could be nice too, but note that they are relatively complicated. Do we expect a lot of users to experiment with custom coefficient functions? @tomchor if this feature is just for you to experiment with dynamic Smagorinsky implementations then I think experimenting in the source code is an even quicker and easier option than designing a function-based interface... @simone-silvestri and @xkykai have talked about dynamic Smagorinsky too but I think their main conclusion is that it is not a gimme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674:764,interface,interface,764,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674,2,['interface'],['interface']
Integrability,"You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence. Does `AnisotropicMinimumDissipation` work? Or other closures?. I'm wondering if the problem is the use of a `BinaryOperation` for the diffusivities with `SmagorinskyLilly`:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L214. It might be possible to avoid using that `BinaryOperation` by instead extending the three diffusivity getter functions:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L87-L89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597:165,integrat,integrated,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597,1,['integrat'],['integrated']
Integrability,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056:496,depend,depends,496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056,1,['depend'],['depends']
Integrability,You should be able to load any NetCDF file using xarray and it gives you a nice and powerful interface for analyzing and manipulating the data. Probably not the best example as it's a little old and messy (I've started using Makie more often) but here's one example: https://github.com/CliMA/LESbrary.jl/blob/3595ff2e1db6d5e6898b6ea84335fdb9dbd23b15/src/make_lesbrary_plots.py,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432:93,interface,interface,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432,1,['interface'],['interface']
Integrability,"You start with a very unstable stratification so you set up Rayleigh-Taylor instability. The reason you get inf temp is because simulation blows up. If I reduce the time-step I can integrate up to the final time of `t=80sec` that you chose, but if you need to integrate further probably you need to reduce the time-step further or add a time-step wizard... I enhanced your script a bit with a log message to keep track of the CFL... I also added RK3 time-step. I also reduced the resolution to 128^3 so I can experiment as my laptop cannot casually run 256^3 simulations :) . ```Julia; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(128, 128, 128), y=(-500, 500), x=(-500, 500), z=(-500, 0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3), timestepper = :RungeKutta3,; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1)). @inline thermoc(x, y, z) = 16-12*tanh((z+250)/10)+rand(Float64); @inline sal(x, y, z) = 16+12*tanh((z+250)/10)+rand(Float64); set!(model1, u=-0.05, v=0, T=thermoc, S=sal). using Oceananigans.Diagnostics: AdvectiveCFL. CFL = AdvectiveCFL(wizard). start_time = time_ns(). progress(sim) = @printf(""i: % 6d, sim time: % 10s, wall time: % 10s, Δt: % 10s, CFL: %.2e\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - start_time)),; prettytime(sim.Δt),; CFL(sim.model)). simulation = Simulation(model1, Δt=2., stop_time=80second, iteration_interval=4, progress=progress). function init_save_some_metadata!(file, model); file[""author""] = ""oofs""; return nothing; end. simulation.output_writers[:tracers] = JLD2OutputWriter(model1, model1.tracers,; prefix = ""Temp Data"",; schedule = TimeInterv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730997277:181,integrat,integrate,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730997277,3,"['integrat', 'message']","['integrate', 'message']"
Integrability,You will need to add `CUDAKernels` as a dependency,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811480162:40,depend,dependency,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811480162,1,['depend'],['dependency']
Integrability,"[`Relaxation`](https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L24-L73) applies to more than just sponge layers --- it's a convenience wrapper for a forcing function that ""relaxes"" a field to some `target` at a specified `rate`, limited to a region outside a `mask` function. `Relaxation` is actually a special type of callable `ContinuousForcing`:. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L81-L82. The snippet shows that `mask` is callable with the signature `x, y, z` and target is callable with the signature `x, y, z, t`. Any appropriate `mask` and `target` will work. Also, we've provided a parameterized convenience type for a Gaussian `mask`. So, sponge layers are simply one application of `Relaxation`. @tomchor, perhaps what you're saying is that a Gaussian is not appropriate for a sponge layer `mask`, since one might want a function with a sharper cutoff (subject to @navidcy's caveats). I think this is a valid criticism --- it might make sense to add more appropriate parameterized types (using tanh's, etc?) This could be added in a PR that also updates the documentation and provides a better example for implementing a sponge layers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410:201,wrap,wrapper,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410,1,['wrap'],['wrapper']
Integrability,"`@sprintf` / `@printf` formatters allow right-padding with the syntax `% 123s`, where `123` is the number of spaces. for example:. ```julia; julia> a = ""hi""; ""hi"". julia> b = ""bye""; ""bye"". julia> c = ""yeah sure""; ""yeah sure"". julia> @printf(""a: % 12s\nb: % 12s\nc: % 12s"", a, b, c); a: hi; b: bye; c: yeah sure; ```. Other points:. * The plot looks great!; * I would suggest just merging this plot and working on new advection schemes in another PR.; * You can let a validation script depend on `Polynomials` without adding `Polynomials` to the Oceananigans `Project.toml`. There's a few other validation scripts that depend on random packages that are not a part of Oceananigans.; * This PR also adds a bunch of new examples that are variants on the Bickley jet. Probably not intended?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839084343:485,depend,depend,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839084343,2,['depend'],['depend']
Integrability,"`@stdlib/Serialization`; [1a1011a3] SharedArrays `@stdlib/SharedArrays`; [6462fe0b] Sockets `@stdlib/Sockets`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [4607b0f0] SuiteSparse `@stdlib/SuiteSparse`; [fa267f1f] TOML `@stdlib/TOML`; [a4e569a6] Tar `@stdlib/Tar`; [8dfed614] Test `@stdlib/Test`; [cf7118a7] UUIDs `@stdlib/UUIDs`; [4ec0a83e] Unicode `@stdlib/Unicode`; [e66e0078] CompilerSupportLibraries_jll `@stdlib/CompilerSupportLibraries_jll`; [deac9b47] LibCURL_jll `@stdlib/LibCURL_jll`; [29816b5a] LibSSH2_jll `@stdlib/LibSSH2_jll`; [c8ffd9c3] MbedTLS_jll `@stdlib/MbedTLS_jll`; [14a3606d] MozillaCACerts_jll `@stdlib/MozillaCACerts_jll`; [05823500] OpenLibm_jll `@stdlib/OpenLibm_jll`; [efcefdf7] PCRE2_jll `@stdlib/PCRE2_jll`; [83775a58] Zlib_jll `@stdlib/Zlib_jll`; [8e850ede] nghttp2_jll `@stdlib/nghttp2_jll`; [3f19e933] p7zip_jll `@stdlib/p7zip_jll`; Precompiling project...; ✗ RecipesPipeline; ✗ Plots; 0 dependencies successfully precompiled in 7 seconds (205 already precompiled); 2 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages; Testing Running tests...; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads; [2023/02/21 06:36:13.652] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.673] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.728] WARN Over-writing reg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:10337,depend,dependencies,10337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,2,['depend'],['dependencies']
Integrability,"`KernelAbstraction.synchronize(device(arch))` would be the same as the previous `wait(device(arch), event)` where the error would be thrown",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514588771:19,synchroniz,synchronize,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514588771,1,['synchroniz'],['synchronize']
Integrability,"`NetCDF_jll <400.900` works for me. Adding the following lines to `Project.toml` of `Oceananigans` or the environment for running `Oceananigans` should work, but it seems not the best practice since it adds a stale dependency. . ```toml; [deps]; NetCDF_jll = ""7243133f-43d8-5620-bbf4-c2c921802cf3"". [compat]; NetCDF_jll = ""<400.900""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2356961241:215,depend,dependency,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2356961241,1,['depend'],['dependency']
Integrability,"```; Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question. Stacktrace:; [1] error(s::String); @ Base .\error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:116; [5] getindex(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:48; [6] scalar_getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:34 [inlined]; [7] _getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:17 [inlined]; [8] getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:15 [inlined]; [9] getindex; @ C:\Users\ADMIN\.julia\packages\OffsetArrays\rMTtC\src\OffsetArrays.jl:422 [inlined]; [10] getindex; @ C:\Users\ADMIN\.julia\packages\Oceananigans\E4XVr\src\Fields\field.jl:540 [inlined]; [11] rescale!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, @NamedTuple{u::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Fl... (repeats 1 time); [12] top-level scope; @ In[10]:9; ```. This is an error message I am getting from my code. Please share your comments on how to resolve this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299:1902,message,message,1902,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299,1,['message'],['message']
Integrability,"```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.Operators; using GLMakie. # A bit of code...; @inline f²(i, j, k, grid, f, args...) = @inbounds f(i, j, k, grid, args...)^2. @inline function Riᶜᶜᶜ(i, j, k, grid, U, b); N² = ℑzᵃᵃᶜ(i, j, k, grid, ∂zᶜᶜᶠ, b); S²u = ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u); S²v = ℑyzᵃᶜᶜ(i, j, k, grid, f², ∂zᶜᶠᶠ, U.v); S² = S²u + S²v; return ifelse(S² == 0, zero(eltype(grid)), N² / S²); end. grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()); velocities = fake_model.velocities; tracers = fake_model.tracers. # Pacanowski-Philander implementation; #; # The following implements the Packanowski-Philander model for shear-modulated mixing; # with parameters:; ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. # In Packanowski-Philander both the viscosity and diffusivity; # depend on the Richardson number:; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(velocities, tracers.b)); Ri = Field(Ri_op). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). @show ν # it's an operation... closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). # For `closure` to work correctly, the Ri must be defined as an ""auxiliary field"" of the model.; # Fields in model.auxiliary_fields are updated every time-stepper stage.; model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer(), auxiliary_fields = (; Ri)); model.velocities = velocities; model.tracers = tracers. # Initial condition with Ri ≈ 0.01; step(x, c, w) = 1/2 * (1 + tanh((x - c) / w)) # smooth step function. N² = 1e-4; bᵢ(x, y, z) = N² * z. S² = 1e-2; Δu = 4 # m; uᵢ(x, y, z) = Δu * sqrt(S²) * step(z, -grid.Lz/2, Δu). set!(model, u=uᵢ, b=bᵢ). simulation = Simulation(model, Δt=1minute, stop_time=1day). # Alternative to writing output.; fields ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967:2375,depend,depend,2375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967,1,['depend'],['depend']
Integrability,"```julia; using Random, Printf; using Oceananigans, Oceananigans.Utils. Nx = 25 # Number of grid points in x and y; Nz = 50 # Number of grid points in z; Δz = 4.0 # Grid spacing in x, y, z (meters); Qᵀ = 1e-5 # Temperature flux at surface; ∂T∂z = 0.005 # Initial vertical temperature gradient; f = 1e-4 # Coriolis parameter; α = 2e-4 # Thermal expansion coefficient; β = 8e-4 # Haline contraction coefficient. grid = RegularCartesianGrid(size=(Nx, Nx, Nz), extent=(Δz*Nx, Δz*Nx, Δz*Nz)); T_bcs = TracerBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵀ), bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ). ## Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. ## Temperature initial condition: a stable density tradient with random noise superposed.; T₀(x, y, z) = 20 + ∂T∂z * z + ∂T∂z * model.grid.Lz * 1e-6 * Ξ(z). set!(model, T=T₀); ```; That's the setup I'm using now. Should we start from this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629369389:385,contract,contraction,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629369389,1,['contract'],['contraction']
Integrability,`auxiliary_fields` are fields that are meant to be used in forcing functions. That's related to why you're getting the error --- `Forcing.field_dependencies` can include auxiliary fields. A callback is a good way to integrate something and will not change your tendency kernel functions.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482922692:216,integrat,integrate,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482922692,1,['integrat'],['integrate']
Integrability,`gravitational_acceleration` will always be a Number... We might have to have a derived `g'` for every interface.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2954#issuecomment-1452910338:103,interface,interface,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2954#issuecomment-1452910338,1,['interface'],['interface']
Integrability,"`on_architecture` for a model seems to be a little complicated because of FFTs that depend on very different plans for GPU and CPU. I am leaning towards leaving `on_architecture` only for some basics building blocks (fields, grids, some solvers) and not allow `on_architecture` for models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1973863577:84,depend,depend,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1973863577,1,['depend'],['depend']
Integrability,"`src/Fields/show_fields.jl` was. ```; import Oceananigans: short_show. location_str(::Type{Face}) = ""Face""; location_str(::Type{Center}) = ""Center""; location_str(::Type{Nothing}) = ""⋅"". function show_size(field); Nx, Ny, Nz = size(field); return ""$Nx×$Ny×$Nz""; end. show_location(X, Y, Z) = ""($(location_str(X)), $(location_str(Y)), $(location_str(Z)))"". show_location(field::AbstractField{X, Y, Z}) where {X, Y, Z} = show_location(X, Y, Z). short_show(m::Missing) = ""$m"". short_show(field::AbstractField) = string(show_size(field), "" "", typeof(field).name.wrapper, "" located at "", show_location(field)); short_show(field::AveragedField) = string(show_size(field), "" "", ""AveragedField over dims=$(field.dims) located at "", show_location(field), "" of "", short_show(field.operand)); short_show(field::ComputedField) = string(show_size(field), "" "", ""ComputedField located at "", show_location(field), "" of "", short_show(field.operand)). Base.show(io::IO, field::AbstractField{X, Y, Z, A}) where {X, Y, Z, A} =; print(io, ""$(short_show(field))\n"",; ""├── architecture: $A\n"",; ""└── grid: $(short_show(field.grid))""). function Base.show(io::IO, field::Field); print(io, ""$(short_show(field))"", '\n',; ""├── data: "", summary(field.data), '\n',; ""├── grid: $(short_show(field.grid))"", '\n',; ""└── boundary conditions: $(short_show(field.boundary_conditions))""). return nothing; end. show_status(::Nothing) = ""nothing""; show_status(status) = ""time=$(status.time)"". function Base.show(io::IO, field::AveragedField); print(io, ""$(short_show(field))"", '\n',; ""├── data: "", summary(field.data), '\n',; ""├── grid: $(short_show(field.grid))"", '\n',; ""├── dims: $(field.dims)"", '\n',; ""├── operand: $(short_show(field.operand))"", '\n',; ""└── status: "", show_status(field.status)). return nothing; end. function Base.show(io::IO, field::ComputedField); print(io, ""$(short_show(field))"", '\n',; ""├── data: "", summary(field.data), '\n',; ""├── grid: $(short_show(field.grid))"", '\n',; ""├── operand: $(short_show(field.opera",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1986#issuecomment-921618400:557,wrap,wrapper,557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1986#issuecomment-921618400,1,['wrap'],['wrapper']
Integrability,`w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions. We could think to change the dependencies to all fields instead of only the prognostic ones,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979:95,depend,dependency,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979,2,['depend'],"['dependencies', 'dependency']"
Integrability,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:146,integrat,integrating,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618,2,"['depend', 'integrat']","['depend', 'integrating']"
Integrability,a 20-year integration of the quarter degree simulation (in `validation/near_global_lat_lon/near_global_quarter_degree.jl`) using the following as a free surface:. ```; Δt = 10minutes # probably we can go to 10min or 15min?; CFL = 0.7. wave_speed = sqrt(g_Earth * grid.Lz); Δg = 1 / sqrt(1 / min_Δx(grid)^2 + 1 / min_Δy(grid)^2). @show substeps = Int(ceil(2 * Δt / (CFL / wave_speed * Δg))). free_surface = SplitExplicitFreeSurface(; substeps); ```. https://user-images.githubusercontent.com/33547697/217328677-9c737e8d-140b-4a9f-92b9-d42f5d364a3d.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1421225576:10,integrat,integration,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1421225576,1,['integrat'],['integration']
Integrability,"ably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1.data, field2.data, field1.operand, field2.operand); end; ```. and the kernel. ```julia; @kernel function _compute_two!(data1, data2, operand1, operand2); i, j, k = @index(Global, NTuple); @inbounds data1[i, j, k] = operand1[i, j, k]; @inbounds data2[i, j, k] = operand2[i, j, k]; end; ```. There should also be a way to generalize to the nth case using some `ntuple` magic. (Note that we tried this with tracer kernels previously without obtaining any speed up, but overlapping `ComputedField`s could be a more promising application of this technique.). # Using `mapreduce` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1907,depend,depend,1907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['depend'],['depend']
Integrability,"agree with Greg. I would prefer we get w by stepping forward for w because; then there are no concerns about rigid lids etc. We ended up using; continuity because the elliptic inversion was missing a div.v/delt source; term. When that problem got fixed I believe integrating forward for w works; just fine. Ali, can you confirm?. On Wed, Aug 7, 2019 at 8:16 AM Gregory L. Wagner <notifications@github.com>; wrote:. > We originally did the recompilation of w from continuity partly because we; > thought this may prevent an accumulation of error that could otherwise; > occur, and partly because @sandreza <https://github.com/sandreza>; > convinced us this was more correct. But I would argue that because we; > haven't done model verification we aren't sure whether this is correct or; > not.; >; > Another issue, or annoyance, with recomputing w from continuity is that it; > is only valid in the case of rigid lids on top and bottom.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/336?email_source=notifications&email_token=AKXUEQUD4TCBCCFDIMAPNC3QDK4KXA5CNFSM4IJ2G5UKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD3YGJQY#issuecomment-519070915>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQPFPDDHQ2JSNTPR3TQDK4KXANCNFSM4IJ2G5UA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-519073694:263,integrat,integrating,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-519073694,1,['integrat'],['integrating']
Integrability,"an Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 6:38 AM Simone Silvestri ***@***.***>; wrote:. > Yep, we used nsys because our primary objective is to trace GPU execution.; > I think it will work also on CPU programs.; > There is nothing really specific about profiling julia with nsys, provided; > that MPI is correctly configured (i.e. your script works with MPI already).; > An example of a batch script that traces MPI calls is; >; > #!/bin/bash; > #SBATCH -N 2; > #SBATCH --ntasks-per-node=4; > #SBATCH --cpus-per-task=16; > #SBATCH --mem=500GB; > #SBATCH --time 24:00:00; > #SBATCH --gres=gpus:4; >; > cat > launch.sh << EoF_s; > #! /bin/sh; > export CUDA_VISIBLE_DEVICES=0,1,2,3; > exec \$*; > EoF_s; > chmod +x launch.sh; >; > srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl; >; > Here, nsys will produce one report per processor. You can use mpirun or; > mpiexec instead of srun.; > If you want to insert NVTX annotations inside the code you need to add the; > environment variable (ref; > <https://urldefense.com/v3/__https://github.com/JuliaGPU/NVTX.jl__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6C7RIjP6$>; > ); >; > export JULIA_NVTX_CALLBACKS=gc; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396961670__;Iw!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6H5RkVsz$>,; > or unsubscribe; > <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWEQFWMJVYNAYQ7WX4LZ2KFD3AVCNFSM6AAAAABPKAGA5GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGOJWHE3DCNRXGA__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6OcpZ5Rs$>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719:2334,Message,Message,2334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719,1,['Message'],['Message']
Integrability,"ananigans.Fields: _set!; ./Models/ShallowWaterModels/set_shallow_water_model.jl:import Oceananigans.Fields: set!; ./Models/ShallowWaterModels/set_shallow_water_model.jl:function set!(model::ShallowWaterModel; kwargs...); ./Models/ShallowWaterModels/set_shallow_water_model.jl: _set!(ϕ, value); ./Models/ShallowWaterModels/shallow_water_model.jl: set!(bathymetry_field, bathymetry); ./Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl: set!(η, reshape(storage, solver.problem_size...)); ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:import Oceananigans.TimeSteppers: reset!; ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:function reset!(sefs::SplitExplicitFreeSurface); ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl: @apply_regionally set!(free_surface.η, free_surface.state.η̅); ./Models/HydrostaticFreeSurfaceModels/distributed_split_explicit_free_surface.jl:""""""Integrate z at locations `location` and set! `height`` with the result""""""; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:using Oceananigans.Fields: _set!; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:import Oceananigans.Fields: set!; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl: set!(model; kwargs...); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:`set!(ϕ::AbstractField, data)` function exists.; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:set!(model, u=u₀, v=v₀, T=T₀); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:function set!(model::HydrostaticFreeSurfaceModel; kwargs...); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl: @apply_regionally _set!(ϕ, value); ./Models/Models.jl:import Oceananigans.TimeSteppers: reset!; ./Models/Models.jl:function reset!(model::AbstractModel); ./MultiRegion/multi_region_field.jl:im",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021:3985,Integrat,Integrate,3985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021,1,['Integrat'],['Integrate']
Integrability,any slight dependency update results in most GPU tests failing... :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2873#issuecomment-1399622770:11,depend,dependency,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2873#issuecomment-1399622770,1,['depend'],['dependency']
Integrability,"ary conditions (on the domain, not even considering immersed boundary conditions yet). My expectation was that the `GradientBoundaryCondition` would be applied to whichever tracer fields are passed along to the tendency functions:; > ; > ```; > - ∇_dot_qᶜ(i, j, k, grid, closure, diffusivities, val_tracer_index, closure_c, clock, model_fields, buoyancy); > - immersed_∇_dot_qᶜ(i, j, k, grid, closure_c, c_immersed_bc, closure, diffusivities, val_tracer_index, clock, model_fields); > ```; > ; > which in our case should be the sum of the perturbation and background tracer fields. Instead, it seems that our solutions are behaving as though the `GradientBoundaryCondition` is only being applied to the perturbation fluxes at the boundaries. Indeed, when we remove the background field from the gradient values passed to `GradientBoundaryCondition`, we get the behavior we are looking for. `GradientBoundaryCondition` isn't applied to the fields at all. The tracer gradient across the boundary is the quantity we need in order to compute fluxes across boundaries. Therefore when the immersed boundary flux is computed, we call. https://github.com/CliMA/Oceananigans.jl/blob/738d1724e5128502efe5579dd210fc17aacb9089/src/ImmersedBoundaries/immersed_boundary_condition.jl#L100-L101. Contrast this with the routine for `ValueBoundaryCondition` which is a bit more involved:. https://github.com/CliMA/Oceananigans.jl/blob/738d1724e5128502efe5579dd210fc17aacb9089/src/ImmersedBoundaries/immersed_boundary_condition.jl#L103-L107. These gradients are then used to compute the flux, for example. https://github.com/CliMA/Oceananigans.jl/blob/738d1724e5128502efe5579dd210fc17aacb9089/src/ImmersedBoundaries/immersed_boundary_condition.jl#L117-L122. > Instead, it seems that our solutions are behaving as though the GradientBoundaryCondition is only being applied to the perturbation fluxes at the boundaries. I don't know exactly what it means for a gradient to be applied to the field. Can you please clarify?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207696563:1729,rout,routine,1729,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207696563,1,['rout'],['routine']
Integrability,as mentioned on slack here's @jlk9 's Enzyme integration test PR https://github.com/CliMA/Oceananigans.jl/pull/3480. We should check that the tuple doesn't also break that (or try to find the correct mutually happy solution like maybe vararg type),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944736039:45,integrat,integration,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944736039,1,['integrat'],['integration']
Integrability,"atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:285; [2] macro expansion at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1395,synchroniz,synchronize,1395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronize']
Integrability,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1342,integrat,integrated,1342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939,2,['integrat'],['integrated']
Integrability,"ation); ./Models/NonhydrostaticModels/set_nonhydrostatic_model.jl:import Oceananigans.Fields: set!; ./Models/NonhydrostaticModels/set_nonhydrostatic_model.jl: set!(model; kwargs...); ./Models/NonhydrostaticModels/set_nonhydrostatic_model.jl:function set!(model::NonhydrostaticModel; enforce_incompressibility=true, kwargs...); ./Models/ShallowWaterModels/set_shallow_water_model.jl:import Oceananigans.Fields: set!; ./Models/ShallowWaterModels/set_shallow_water_model.jl:function set!(model::ShallowWaterModel; kwargs...); ./Models/ShallowWaterModels/shallow_water_model.jl: set!(bathymetry_field, bathymetry); ./Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl: set!(η, reshape(storage, solver.problem_size...)); ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl: @apply_regionally set!(free_surface.η, free_surface.state.η̅); ./Models/HydrostaticFreeSurfaceModels/distributed_split_explicit_free_surface.jl:""""""Integrate z at locations `location` and set! `height`` with the result""""""; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:import Oceananigans.Fields: set!; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl: set!(model; kwargs...); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:function set!(model::HydrostaticFreeSurfaceModel; kwargs...); ./MultiRegion/multi_region_field.jl:import Oceananigans.Fields: set!, compute!, compute_at!, validate_field_data, validate_boundary_conditions; ./Oceananigans.jl: interior, set!, compute!, regrid!, location,; ./OutputReaders/field_time_series.jl:import Oceananigans.Fields: Field, set!, interior, indices; ./OutputReaders/field_time_series.jl: set!(time_series, path, name); ./OutputReaders/field_time_series.jl:##### set!; ./OutputReaders/field_time_series.jl:function set!(time_series::InMemoryFieldTimeSeries, path::String, name::String); ./OutputReaders/field_time_series.jl: set!(time_series[n], field_n); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021:9595,Integrat,Integrate,9595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021,1,['Integrat'],['Integrate']
Integrability,"bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=10.0, max_change=1.1, max_Δt=1minute,cell_advection_timescale = accurate_cell_advection_timescale). start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=wizard, stop_time=40minutes, iteration_interval=10,; progress=progress_message); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586:2970,message,message,2970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586,1,['message'],['message']
Integrability,before it was 52 or 56min... so perhaps it helped slightly but also sometimes depending on how many thing tartarus is doing at the moment you can have some variability in times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163:78,depend,depending,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163,1,['depend'],['depending']
Integrability,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1688,integrat,integrated,1688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678,2,['integrat'],['integrated']
Integrability,"boundary_source_terms to add fluxes; > specified via Flux boundary conditions (and also via potential new; > future boundary condition types), *but*; > - use halo filling + interior source term calculation, rather than; > calculate_boundary_source_terms, to enforce Value and Gradient; > boundary conditions; >; > Advantages:; >; > - this change eliminates the need for diffusivities to be known by; > calculate_boundary_source_terms --- diffusivities are only needed if; > enforcing Flux boundary conditions via halos, or to enforce Value/; > Gradient boundary conditions via calculate_boundary_source_terms; both; > of these situations are avoided with this change;; > - nonlinear diffusivities that depend on gradients at the boundary can; > be calculated correctly for Value and Gradient boundary conditions; > - gradient information is now included in output for Value and Gradient; > boundary conditions and can be used in post-processing; > - the calculate_boundary_source_terms function remains a part of the; > algorithm for Flux boundary conditions, or more complicated boundary; > conditions (like those associated with irregular bathymetry).; >; > Previously, we were operating under the assumption that we should either; > fill halos for all inhomogeneous boundary condition types, or use; > calculate_boundary_source_terms. For some reason, we did not consider; > that our method of enforcing inhomogeneous boundary conditions could (and; > perhaps should) depend on the *type* of the boundary condition.; >; > Thoughts?; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/371?email_source=notifications&email_token=AKXUEQQKF52Q6OSJGERBYOLQGXA6XA5CNFSM4IQTDLRKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HHZJBGA>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQVH4CCJNLTZKN24KZLQGXA6XANCNFSM4IQTDLRA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-525534795:1669,depend,depend,1669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-525534795,1,['depend'],['depend']
Integrability,"but, @tomchor, I'd be definitely more than happy if you'd made these changes since they are trivial and need not be discussed or what not ;). (just saying in response to your protocol concerns..!). thanks for reviewing!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882149988:175,protocol,protocol,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882149988,1,['protocol'],['protocol']
Integrability,"c,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:298; [12] macro expansion at /home/alir/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:109 [inlined]; [13] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!)})(::CUDA.CuArray{Complex{Float64},3}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/alir/.julia/packages/KernelAbstractions/xslEz/src/backends/cuda.jl:172; [14] launch!(::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol, ::typeof(Oceananigans.Solvers.calculate_pressure_right_hand_side!), ::CUDA.CuArray{Complex{Float64},3}, ::Vararg{Any,N} where N; dependencies::KernelAbstractions.CudaEvent, include_right_boundaries::Bool, location::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /home/alir/Oceananigans.jl/src/Utils/kernel_launching.jl:80; [15] solve_for_pressure!(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuAr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323:10311,depend,dependencies,10311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323,1,['depend'],['dependencies']
Integrability,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041:2089,integrat,integration,2089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041,3,['integrat'],['integration']
Integrability,"ce, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!)})(::Field{Center, Center, Face, GPU, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuArray{Float32, 3}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, Float32, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}}}}}, ::Vararg{Any, N} where N; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /g/data/v45/nc3020/.julia/packages/CUDAKernels/8wtKq/src/CUDAKernels.jl:194; [11] calculate_interior_tendency_contributions!(tendencies::NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, GPU, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuArray{Float32, 3}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, Float32, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:20630,depend,dependencies,20630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['depend'],['dependencies']
Integrability,"cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1643,depend,dependency,1643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['depend'],['dependency']
Integrability,"ch aren't integrated yet).; >; > I can see reasons for having a separate repository for examples and; > tutorials if there are enough of them, but I don't see e.g. the output; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequently for a while).; >; > I also don't have to git clone a bunch of repositories just to work on a; > simple example.; >; > But this is getting off-topic.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/284?email_source=notifications&email_token=AA27DYA55SSJKHXQBFUSJDLP2OVODA5CNFSM4HXEYRJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2Z",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:1533,depend,depend,1533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,1,['depend'],['depend']
Integrability,"cision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Fields._regrid!), ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; dependencies::Nothing, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /g/data/v45/nc3020/Oceananigans.jl/src/Utils/kernel_launching.jl:95; [16] launch!; @ /g/data/v45/nc3020/Oceananigans.jl/src/Utils/kernel_launching.jl:79 [inlined]; [17] regrid!(a::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:12303,depend,dependencies,12303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['depend'],['dependencies']
Integrability,"ck?. Same! Runs again no complaining :). ```julia; julia> using Oceananigans. julia> grid; 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Bounded y ∈ [0.0, 2.0] regularly spaced with Δy=2.0; └── Flat z. julia> model = HydrostaticFreeSurfaceModel(grid=grid, free_surface = ImplicitFreeSurface()); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> simulation = Simulation(model, Δt=1.0, stop_iteration=2); Simulation{typename(HydrostaticFreeSurfaceModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1 second; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 2.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (198.852 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.013 minutes).; [ Info: Simulation is stopping. Model iteration 2 has hit or exceeded simulation stop iteration 2.; ```. > Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). yeah!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166:4005,message,message,4005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166,1,['message'],['message']
Integrability,closing this as we are moving fwd with a compat entry that will render this message useless.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3182#issuecomment-1637677967:76,message,message,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182#issuecomment-1637677967,1,['message'],['message']
Integrability,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1547,depend,depends,1547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,1,['depend'],['depends']
Integrability,"d to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter information from a type's string?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:1936,wrap,wrapper,1936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328,1,['wrap'],['wrapper']
Integrability,de/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/bin:/glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/bin:/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/bin:/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/bin:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/bin:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/bin:/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/oclfpga/bin:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin/intel64:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin:/glade/u/apps/casper/23.10/opt/wrappers/bin:/glade/u/apps/casper/23.10/opt/utils/bin:/glade/u/home/knudsenl/.local/bin:/usr/lib/mit/bin:/opt/pbs/bin:/glade/u/apps/casper/23.10/opt/view/bin:/usr/local/bin:/usr/bin:/sbin:/bin:/glade/u/apps/casper/23.10/spack/opt/spack/llvm/14.0.6/gcc/7.5.0/arf7/bin; NCAR_LDFLAGS_INTEL_ONEAPI_COMPILERS = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/lib; MODULESHOME = /glade/u/apps/casper/23.10/spack/opt/spack/lmod/8.7.24/gcc/7.5.0/m4jx/lmod/lmod; PKG_CONFIG_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:14262,wrap,wrappers,14262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['wrap'],['wrappers']
Integrability,"did you use the test environment or Oceananigans's enviroment? On Tartarus, branch main in the test environment does this. ```; Precompiling project...; 1 dependency successfully precompiled in 38 seconds. 218 already precompiled.; Testing Running tests...; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [2023/02/14 16:22:39.804] INFO Running shallow water regression tests...; [2023/02/14 16:22:40.097] INFO Testing shallow water Bickley jet simulation regression [GPU, VectorInvariantFormulation]; [2023/02/14 16:23:08.854] WARN Inflating model grid halo size to (4, 4, 0) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point. -@-> /home/ssilvest/stable_oceananigans/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:233; [2023/02/14 16:24:01.792] INFO Initializing simulation...; [2023/02/14 16:24:08.481] INFO ... simulation initialization complete (6.689 seconds); [2023/02/14 16:24:08.481] INFO Executing initial time step...; [2023/02/14 16:24:43.227] INFO ... initial time step complete (34.746 seconds).; [2023/02/14 16:24:43.387] INFO Simulation is stopping after running for 41.593 seconds.; [2023/02/14 16:24:43.387] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:24:48.950] INFO Δu: min=-1.671992e-04, max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:155,depend,dependency,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,1,['depend'],['dependency']
Integrability,"ditions.gpu__fill_bottom_and_top_halo!)})(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Utils/kernel_launching.jl:95; [7] fill_bottom_and_top_halo!(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ::Symbol, ::Tuple{Int64, Int64}, ::Tuple{Face, Center, Center}, ::GPU, ::CUDAKernels.CudaEvent, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261:2535,depend,dependencies,2535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261,1,['depend'],['dependencies']
Integrability,"drostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1245,depend,depend,1245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['depend'],['depend']
Integrability,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:1281,integrat,integrate,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,1,['integrat'],['integrate']
Integrability,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1671,depend,depend,1671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,1,['depend'],['depend']
Integrability,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1523,depend,depend,1523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,5,['depend'],"['depend', 'dependent', 'depends']"
Integrability,"e.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils ~/OC.jl/src/Utils/kernel_launching.jl:103; [15] calculate_interior_tendency_contributions!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Col",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:14775,depend,dependencies,14775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['depend'],['dependencies']
Integrability,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1526,depend,dependency,1526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,4,['depend'],"['dependencies', 'dependency']"
Integrability,"eananigans.Utils; using Oceananigans.Diagnostics: AdvectiveCFL. grid = RegularCartesianGrid(size=(128, 1, 128),; x = (-64, 64),; y = (0, 1),; z = (-64, 64),; topology = (Periodic, Periodic, Bounded)). model = IncompressibleModel(grid = grid,; architecture = CPU(),; advection = UpwindBiasedThirdOrder(),; timestepper = :RungeKutta3,; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = IsotropicDiffusivity(ν=1e-2, κ=1e-2)). # Initial condition for Rayleigh-Taylor instability; #; # Rayleigh-Taylor instability occurs when dense fluid accelerates; # into lighter fluid below due to gravitational forces.; #; # The growth rate of Rayleigh-Taylor instability is; #; # γ = √(k * Δb); #; # where k is the wavenumber of the unstable mode and Δb is the jump from ; # light to dense fluid (I've defined buoyancy such that Δb = - g * Δρ, where g ; # is gravitational acceleration and Δρ is the density jump). The growth rate is faster ; # for smaller modes, which means the smallest scale of the motions that develop depend; # either on the viscous scale, or, in a numerical simulation, the grid scale.; #; # The rate at which energy is removed at the grid scale is roughly. @show γ_diffusion = model.closure.κ.b / grid.Δx^2. # We choose the buoyancy jump so that the growth rate at the grid scale; # is (hopefully) affected significantly by molecular viscosity and diffusion; # (but one large enough to allow the simulation to run in a reasonable amount; # of time). The grid-scale wavenumber is . k = grid.Nx * 2π / grid.Lx. # And our target growth rate is. γ_growth = 100 * γ_diffusion. # which yields a buoyancy jump; Δb = γ_growth^2 / k. # We also choose the width of the buoyancy jump to be. d = 2 * grid.Δz # a bit above the grid scale. # Initial condition: unstable buoyancy gradient + noise; unstable_buoyancy(x, y, z) = - Δb * tanh(z / d) * (1 + 1e-2 * Δb * randn()). set!(model, b = unstable_buoyancy). wizard = TimeStepWizard(cfl=1.0, Δt=0.2, max_Δt=1.0, max_change=1.1). CFL = AdvectiveCFL(wi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-731141248:1403,depend,depend,1403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-731141248,1,['depend'],['depend']
Integrability,"ecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels ~/.julia/packages/CUDAKernels/3IKLV/src/CUDAKernels.jl:283; [14] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Models.NonhydrostaticModels.calculate_Gu!), ::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:12822,depend,dependencies,12822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['depend'],['dependencies']
Integrability,"ed between CFM and DFM results, with the deviation being below 10%. which suggests that _accuracy_ may not be an important factor in deciding which method to use. But the next sentence is. > Considering the nature of capturing the discontinuity at the fluid-solid interface, DFM might offer a more accurate result, which however requires more follow-up simulations to give a solid investigation. which is difficult to interpret. I suppose all they can say is that their results are similar to one another, but they cannot say which one is more accurate (and perhaps it doesn't matter which method is more accurate in their case, if both methods return similar results). That said, I think time-step considerations are really important, and seem like a good reason to choose DFM over CFM. . Balaras (2004)'s pressure equation is. <img width=""868"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/95799302-36f2c280-0cc2-11eb-9342-a2b47a1cfdfa.png"">. where, crucially, `Ω` is the _computational_ domain (irrespective of the immersed boundary). So following Balaras (2004) would mean _not_ modifying the pressure solver? That's good news!. Does it make sense to first implement an algorithm that assumes the boundary coincides with the grid?. I am not super worried about the algorithmic changes require to implement a DFM immersed boundary. I think we can isolate the immersed boundary implementation from the rest of the code and interface with the time-stepping routines with a single function call that calculates the discrete forcing and applies a correction to the velocity field. Using multiple dispatch, this change to the algorithm will have no cost to simulations that don't use immersed boundaries. The main challenge I think is figuring out abstractions that make it easy to create immersed boundaries and assign boundary conditions (@ali-ramadhan and my job to figure this out) --- and we'd have this challenge for any immersed boundary implementation, whether CFM or DFM.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707401128:2400,interface,interface,2400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707401128,2,"['interface', 'rout']","['interface', 'routines']"
Integrability,"el clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). return simulation; end. function next_actuation_time(sch::AveragedTimeInterval); t₀ = sch.first_actuation_time; N = sch.actuations; T = sch.interval; return t₀ + (N + 1) * T; end. if isfile(""timeavg.nc""); rm(""timeavg.nc""); println(""File 'timeavg.nc' was successfully removed.""); else; println(""File 'timeavg.nc' does not exist.""); end; # run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s). δt = .01 # progress message interval and output saving interval; # Run a simulation that saves data to a checkpoint. simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; # N = iteration(simulation); # checkpoint = ""test_iteration$N.jld2""; # simulation = test_simulation(T2, Δt, δt, false); # run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); # Plots.savefig(""ln.png""); ln; close(ds); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:2947,message,message,2947,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['message'],['message']
Integrability,"en the current state of Oceananigans?. I think it will take at least a few weeks of dedicated work by someone familiar with Oceananigans and Julia. The algorithms are more or less known, so the challenges are mainly in software development. A significant chunk of the work is developing and running validation experiments. > ; > > We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:; > > http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf; > ; > Unless I'm missing something this seems trivial (some good news!). I believe we'll need to insert a mass correction step into our algorithm (perhaps after fill halo regions in update state?) and how to decide when we need it. I think we'll need it both for non-zero inflow conditions (so `Open` boundaries with conditions other than `nothing` / 0`) and outflow conditions like Orlanski. > ; > > For this to work properly, we need to modify the pressure solver to work for time-dependent inflows; > ; > This seems far from trivial. But I'm assuming this was implemented when you guys implemented cubed sphere capabilities, no?. We only support hydrostatic cubed sphere simulations, so we did not implement an algorithm for accurate non-hydrostatic pressure solves with time-dependent boundary conditions when implementing the cubed sphere. The algorithm is known (I have a sketch, though some effort should be devoted to writing it up in the documentation); we only need to design a useful software abstraction. The main issue is that the right hand side of the pressure Poisson equation depends on the _time-derivative_ of the wall-normal velocity. This means that we need to store the wall-normal velocity at a prior time-step. We can probably redesign the implementation of the `Open` boundary condition for this purpose, and add code to `solve_for_pressure!` that adds these contributions when necessary: ; https://github.com/CliMA/Oceananigans.jl/blob/73",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920:1155,depend,dependent,1155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920,1,['depend'],['dependent']
Integrability,"es and nonlinear; > diffusivities depend on the velocity and tracer fields, in general. We; > currently handle this only during time-stepping --- there is no guarantee,; > for example, that the diffusivities or ghost cell values are consistent; > with the velocity field if the velocity field is set by the function set!; > (in fact, the diffusivities are *always* inconsistent with the current; > velocity field due to the fact that they are calculated *prior* to taking; > a time-step). If we want to guarantee such a consistency, we can develop; > the concept of a model ""state"" and apply it to both ocean and atmospheric; > models (eg a function update_state!(model), or something similar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:1437,wrap,wraps,1437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['wrap'],['wraps']
Integrability,"ess, should be the same for 1D, 2D, and 3D. So in the 2D turbulence example the domain is decomposed in y since that's the only decomposition currently supported. > Also (again correct me if I'm missing something) from my talks with you guys about this it seems that the primary goal of MPI-distributed parallelism is to run multi-GPU simulations, since GPUs have a relatively low memory limit. In this case, I think the way to use MPI is very different from the traditional multi-CPU runs. That is, I think the important capabilities when distributing a simulation across a few GPUs are different from the important capabilities when distributing it across hundreds of CPU cores. Yeah for sure. If you can only decompose in y and you want to run on hundreds of CPU ranks then each rank gets a very thin domain, almost a slice. The surface-to-volume ratio of each rank is high which means lots of communication overhead. If you're running a huge simulation on a moderate number of GPUs then each rank gets a pretty thick slice so the surface-to-volume ratio is smaller, leading to less communication overhead. Definitely agree that it's probably not a huge deal for now. > In principle I completely agree with this. In principle communicating with another sub-domain is treated exactly the same as you treat BCs, right? Which is to fill the halo region accordingly. The only difference being that the proper way to fill it now depends on other processes, instead of depending on the user definitions of the BCs. ; >; > This is also true when a subdomain is, say, `Periodic` on the left and communicating on the right. Both the left and right halo regions have to filled using information outside of that particular subdomain. So I think treating that subdomain direction as `Bounded` is appropriate!. Thanks for the thoughts! I think using `Bounded` makes a lot of sense for the reasons you mentioned. Also would be good to avoid adding a new non-physical topology to do with halo communication haha.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786128856:1813,depend,depends,1813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786128856,2,['depend'],"['depending', 'depends']"
Integrability,"ever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light of this, it might make sense to not do (2). That way we'd leave `ZDirection` in `Grids`, and define `VerticalFormulation`, `HorizontalFormulation` and `ThreeDimenionalFormulation` in `TurbulenceClosures`. Since these latter aren't ""directions"" anymore, there wouldn't be an overlap with `ZDirection` (which literally indicates only a direction). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:1963,interface,interface,1963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915,2,['interface'],['interface']
Integrability,"ey can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact multiple model components at the same time. This has cropped up in `HydrostaticFreeSurfaceModel` where `gravitational_acceleration` can be specified separately in the buoyancy model and the free surface model. Dealing with global physical parameters is the purpose of the [`CLIMAParameters`](https://github.com/CliMA/CLIMAParameters.jl) package so we may need to brainstorm about how to use that package in this context...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:1625,wrap,wrapper,1625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['wrap'],['wrapper']
Integrability,"field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model), pd.units); end; ```. with this design, the user can pass a list of `PrintableDiagnostics` to `ProgressPrinter`, which are then evaluated and the results turned into a string via the function `pretty_diagnostic`. As for option 1 of using a logging package, perhaps it could be nice to use some logging functionality that's configurable with global variables (?) rather than manually creating a `ProgressPrinter` that does ""brute force"" printing as I have described above. However I think that it would require some customization of existing logging packages, since the typical `info` or `debug` settings are not sufficient for the purposes of logging simulation output (right?) Instead, we would need more options, and it'd be nice to obtain the ability to also print the output of diagnostics / monitoring functions, as we do in the example script. And I think doing it this way might involve adding some lines to our time stepping loop. Perhaps @ali-ramadhan has more to say. Another thing we have talked about is somehow having the ability to live-update messages in the terminal (rather than printing a stream of message). This would be nice because it could dramatically reduce the text-noise that a stream of messages invokes, allowing the user to much more easily read and interpret the output of a simulation progress (in addition to creating the possibility for nice pseudo-animations via `UnicodePlots.jl`). I'm not 100% sure how to do this; one places to start could be https://github.com/ronisbr/TextUserInterfaces.jl. Any work on any of these ideas could be useful! I'd be happy to Skype to talk more and clarify any questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:4000,message,messages,4000,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,3,['message'],"['message', 'messages']"
Integrability,"field?. For the functionality proposed here I would advocate for using the existing `ComputedField` and creating a new abstract operation type called `Interpolation`:. ```julia; struct Interpolation{G1, G2, P} <: AbstractOperation; grid :: G1; parent :: P; parent_grid :: G2; end; ```. then we have something like. ```julia; c_interpolation = Interpolation(c, new_grid); c_interpolation[i, j, k]; ```. To prepare such a field for output you might write. ```julia; new_c = ComputedField(Interpolation(c, new_grid)); ```. This will work out of the box with `ComputedField` and output writers. We'll need to take care regarding output writers and the possibility of writing to various grids. I believe we have baked in the assumption that the ""grid"" appropriate for output is the one associated with `model` in both output writers. . The functionality proposed where the interpolation object is callable with `(x, y, z)` is a bit different I think. I think that object doesn't need to be associated with a new grid at all. It's just a generic interpolation object. I think that's not a terrible idea to provide --- I think we are essentially overloading the `interpolate` function provided by `Interpolations.jl` with a custom, speedy method?. A related feature is to provide `set!` function for fields on different grids. In other words:. ```julia; coarse_c = CellField(CPU(), coarse_grid); fine_c = CellField(CPU(), fine_grid). set!(fine_c, interesting_data); set!(coarse_c, fine_c); ```. This is similar to interpolation, but I think for such a `set!` method we actually want to ensure that the global budget is respected... ? Thus we want to use integration to `set!` one field to another, rather than interpolation.... ?. This kind of functionality is implemented in `OceanTurb` for the 1D case:. https://github.com/glwagner/OceanTurb.jl/blob/b0d21cddaaf9aa625146108b5ec96a2a544a2f9f/src/fields.jl#L280-L299. Agree that if we have functions for interpolation we can use them for particle advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/975#issuecomment-699044595:2246,integrat,integration,2246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/975#issuecomment-699044595,1,['integrat'],['integration']
Integrability,"g to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper support for systems of coupled nonlinear boundary conditions, etc). It's a good discussion to have regardless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772:1051,interface,interface,1051,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772,5,['interface'],"['interface', 'interfaces']"
Integrability,"ggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1912,depend,depends,1912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,1,['depend'],['depends']
Integrability,"great Ryan - hope we can collaborate on this. There is a growing group of; people using and developing oceananigans and it would be good to link in; with xgcm. John. On Wed, Feb 10, 2021 at 5:03 PM Ryan Abernathey <notifications@github.com>; wrote:. > Hi folks. I just saw this issue. We are very glad that you're working to; > support interoperability btw oceananigans and xgcm! 🎉 We'd love to help; > however we can.; >; > Ideally you would not have to really do much here other than use CF; > conventions in your netCDF output and things would ""just work."" That's the; > beauty of standards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:336,interoperab,interoperability,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535,1,['interoperab'],['interoperability']
Integrability,"gularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ),typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}},Tuple{typeof(identity),typeof(identity),typeof(identity),typeof(Oceananigans.Operators.ℑxyᶜᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/glwagner/.julia/packages/CUDA/YeS8q/src/compiler/execution.jl:297; [11] macro expansion at /home/glwagner/.julia/packages/CUDA/YeS8q/src/compiler/execution.jl:109 [inlined]; [12] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},typeof(Oceananigans.Fields.gpu__compute!)})(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/glwagner/.julia/packages/KernelAbstractions/jAutM/src/backends/cuda.jl:185; [13] compute!(::ComputedField{Cell,Cell,Cell; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738834053:29866,depend,dependencies,29866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738834053,1,['depend'],['dependencies']
Integrability,"hat `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1447,depend,depends,1447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['depend'],['depends']
Integrability,"he current design. A ""boundary condition"" is a flux, gradient, or value of a field (`u`, `v`, `w`, `T`, `S`) at the end (`left`, `right`) in a given direction (`x`, `y`, `z`). ### Pros. * Generality: any boundary condition can be specified; * Similarity to the mathematics: this design corresponds to how boundary conditions are specified in PDEs; * Extensibility: the design accommodates changes in *types* of boundary conditions or changes in dimensionality. (Adding new solution variables requires code modification, but that is true throughout the code). ### Concerns. * It's more complicated than allowing only 3-4 possibilities to users; as @johncmarshall54 says:. > It's not obvious to me what a field boundary condition is, vs a coordinate boundary condition.; Fundamentally we are applying boundary conditions to u, v, w, T, and S fields, and that's it. It all seems a bit too complicated. * The hierarchical dependence of this design on parameterized types creates a lot of possibilities for different boundary conditions to be specified, and this is a concern for performance (@ali-ramadhan). * We aren't sure what to call the function (currently `bc.calc`) whose purpose is to return the value of the boundary condition (either the field value, flux, gradient, or whatever) at a given grid point and simulation time. ### Other miscellaneous thoughts. * This PR implements a backend / abstraction system for specifying boundary conditions. For users we can add as much sugar on top as we want. * As we have discussed, the way we implement boundary conditions is intimately connected to the way that we specify equations. This can be seen in the current code (though it is commented out) in that [the lines that specify a no-slip condition depend on the ""vertical viscosity""](https://github.com/climate-machine/Oceananigans.jl/blob/7fb355d77df98e37a80b3e796291fa2856d3e1ce/src/time_steppers.jl#L293). Adding other diffusive terms (hyperdiffusivity, Leith diffusivity, various turbulent diffu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026:1027,depend,dependence,1027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026,1,['depend'],['dependence']
Integrability,"he face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:1237,depend,dependent,1237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,1,['depend'],['dependent']
Integrability,"here's an; > unresolved or partially-resolved turbulent boundary layer (rather than; > prescribing a particular value or gradient). That said, I think if we are; > able to specify the gradients of a field across a boundary it will likely; > be straightforward to extend that implementation to specifying fluxes.; >; > The paper; >; > ""Moving from momentum transfer to heat transfer – A comparative study of; > an advanced Graetz-Nusselt problem using immersed boundary methods""; > <https://www.sciencedirect.com/science/article/pii/S0009250918306250> by; > Lu et al. (2019); >; > may also be relevant. Their conclusion is a bit confusing. They state; >; > In all simulations, excellent agreement are reached between CFM and DFM; > results, with the deviation being below 10%.; >; > which suggests that *accuracy* may not be an important factor in deciding; > which method to use. But the next sentence is; >; > Considering the nature of capturing the discontinuity at the fluid-solid; > interface, DFM might offer a more accurate result, which however requires; > more follow-up simulations to give a solid investigation.; >; > which is difficult to interpret. I suppose all they can say is that their; > results are similar to one another, but they cannot say which one is more; > accurate (and perhaps it doesn't matter which method is more accurate in; > their case, if both methods return similar results).; >; > That said, I think time-step considerations are really important, and seem; > like a good reason to choose DFM over CFM.; >; > Balaras (2004)'s pressure equation is; >; > [image: image]; > <https://user-images.githubusercontent.com/15271942/95799302-36f2c280-0cc2-11eb-9342-a2b47a1cfdfa.png>; >; > where, crucially, Ω is the *computational* domain (irrespective of the; > immersed boundary). So following Balaras (2004) would mean *not*; > modifying the pressure solver? That's good news!; >; > Does it make sense to first implement an algorithm that assumes the; > boundary coincide",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707404766:1436,interface,interface,1436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707404766,1,['interface'],['interface']
Integrability,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588:215,wrap,wrapped,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588,1,['wrap'],['wrapped']
Integrability,"https://github.com/MikeInnes/Requires.jl ?. On Fri, Jun 14, 2019 at 10:47 AM Ali Ramadhan <notifications@github.com>; wrote:. > I'm strongly opposed to having multiple small packages.; >; > Why is that, given the benefits?; >; > Mainly I think we can get all the same benefits by maintaining a single; > unified and tidy repository with sub-modules. I don't see Oceananigans as a; > complex project yet, we're barely at 2,500 lines of code (minus turbulence; > closure operators which aren't integrated yet).; >; > I can see reasons for having a separate repository for examples and; > tutorials if there are enough of them, but I don't see e.g. the output; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:492,integrat,integrated,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,1,['integrat'],['integrated']
Integrability,"https://github.com/meggart/ZarrNative.jl. On Fri, Mar 22, 2019 at 9:48 AM Chris Hill <cnh@mit.edu> wrote:; >; > Hi Both; >; > Are we talking with; >; > https://github.com/JuliaGeo; >; > I am tempted to think we should explore Zarr interfaces (; > https://zarr.readthedocs.io/en/stable/index.html ) as well as netCDF.; >; > yeesian@mit.edu who is part of https://github.com/JuliaGeo is at MIT; >; > Chris; >; >; > On Fri, Mar 22, 2019 at 9:41 AM Ali Ramadhan <notifications@github.com> wrote:; > >; > > Yup. It would be nice to have some good built in writers, e.g. a solid netcdf writer, but otherwise they can always write a custom writer.; > >; > > —; > > You are receiving this because you were mentioned.; > > Reply to this email directly, view it on GitHub, or mute the thread.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475627935:231,interface,interfaces,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475627935,1,['interface'],['interfaces']
Integrability,"ich is kind of similar to #73 #85. I suppose we can interpret every term in the momentum equation as an ""arbitrary function"". The design I've been using is to define a type that represents part of the governing equation to make the equation modular and changeable by the user. Definitely suggest alternative designs if good alternatives come to mind. > Is a closure always meant to replace the viscous dissipation (𝜈∇²u) operators? Will Smag/AMD replace the Laplacian diffusion operators (e.g. κ∇²T) as well?. I am proposing that we consider using this conceptual model for a ""closure"". Perhaps a better name than ""closure"" is `Dissipation`... ? All of the turbulent closures we are considering introduce a ""turbulent"" viscosity and diffusivity which is typically much larger than the molecular value. Thus a ""molecular"" isotropic diffusivity can be interpreted as the limiting case of a turbulent closure. The reason it might be good design is because turbulent closures can modify boundary conditions (which depend on viscosity/diffusivity), and because we may want to use common implicit time-stepping methods for the turbulent diffusivity in addition to a ""molecular"" diffusivity. > Out of curiousity, can these closures be framed as ODEProblems using DifferentialEquations.jl?. A subgrid turbulent kinetic energy variable in a typical turbulence closure obeys a three-dimensional PDE and is advected, diffused, dissipated, and interacts with terms in the momentum and tracer equation via nonlinear terms. It is a first-class solution variable similar to the velocity field or active tracers. See equation 12 in [Moeng 1984](https://journals.ametsoc.org/doi/pdf/10.1175/1520-0469%281984%29041%3C2052%3AALESMF%3E2.0.CO%3B2). > Sounds like #115 (and #59 (comment)) should be resolved before this closure abstraction is merged in?. I think it makes sense to resolve #107, #115, and #59 before implementing anything; especially #59 because this affects the function signature we use for the closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222089:1123,depend,depend,1123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222089,1,['depend'],['depend']
Integrability,"ies the maximum number of workers connected to in parallel at a host. Defaults to 10. • shell: specifies the type of shell to which ssh connects on the workers.; • shell=:posix: a POSIX-compatible Unix/Linux shell (sh, ksh, bash, dash, zsh, etc.). The default.; • shell=:csh: a Unix C shell (csh, tcsh).; • shell=:wincmd: Microsoft Windows cmd.exe. • dir: specifies the working directory on the workers. Defaults to the host's current directory (as found by pwd()). • enable_threaded_blas: if true then BLAS will run on multiple threads in added processes. Default is false. • exename: name of the julia executable. Defaults to ""$(Sys.BINDIR)/julia"" or ""$(Sys.BINDIR)/julia-debug"" as the case may be. It is; recommended that a common Julia version is used on all remote machines because serialization and code distribution might fail; otherwise. • exeflags: additional flags passed to the worker processes. • topology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4065,message,message,4065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['message'],['message']
Integrability,"ilities. For example, we might have just doubly periodic in (x, y) plus flux in z on all fields, or singly-periodic in x and flux in (y, z) on all fields. Agree that `CoordinateBoundaryConditions` might be a weird name but yeah, maximum flexibility would be very powerful. Maybe the common use case isn't to impose each of the 30 boundary conditions one-by-one but we can just have nice helper functions/abstractions like; ```julia; model.boundary conditions += HorizontallyPeriodic(); ```. > @ali-ramadhan do you mean with regards to performance? I'm not sure. With multiple dispatch being core to julia it seems this scenario is not uncommon (30+ may not be very large). I'm still pretty new to Julia so yeah don't know if that will be an issue, especially on the GPU. Only way to find out is to try and benchmark! Maybe you're right and 30+ isn't a lot. @vchuravy any idea on whether 30+ parameterized types for a struct is too many? Would this hurt performance on the GPU?. > The function calc does not actually impose a boundary condition --- the imposition of boundary condition depends on, for example, the viscosity and diffusivity, and is a property of the equation (or turbulent closure) being implemented. Again for example, the K-Profile-Parameterization includes a modification of how a flux boundary condition is implemented. In other words, the ""specification of flux"" is separate from the ""imposition of a boundary condition"". The former is determined by the user. The latter is determined by the model/governing equation. I see. So if no parameterizations are being used, are the boundary conditions actually being _imposed_ then? Even with KPP, isn't the boundary condition still being _imposed_ only to later be modified by KPP?. I still feel like `bc.calc()` feels obscure, I'm not sure why a boundary condition should have to calculated. Perhaps it's just semantics but it would be nice to see boundary conditions be _imposed_ in the code and see something like `bc.impose(...)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472241993:1211,depend,depends,1211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472241993,1,['depend'],['depends']
Integrability,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2318,interface,interface,2318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['interface'],['interface']
Integrability,"in dimensionality. (Adding new solution variables requires code modification, but that is true throughout the code). ### Concerns. * It's more complicated than allowing only 3-4 possibilities to users; as @johncmarshall54 says:. > It's not obvious to me what a field boundary condition is, vs a coordinate boundary condition.; Fundamentally we are applying boundary conditions to u, v, w, T, and S fields, and that's it. It all seems a bit too complicated. * The hierarchical dependence of this design on parameterized types creates a lot of possibilities for different boundary conditions to be specified, and this is a concern for performance (@ali-ramadhan). * We aren't sure what to call the function (currently `bc.calc`) whose purpose is to return the value of the boundary condition (either the field value, flux, gradient, or whatever) at a given grid point and simulation time. ### Other miscellaneous thoughts. * This PR implements a backend / abstraction system for specifying boundary conditions. For users we can add as much sugar on top as we want. * As we have discussed, the way we implement boundary conditions is intimately connected to the way that we specify equations. This can be seen in the current code (though it is commented out) in that [the lines that specify a no-slip condition depend on the ""vertical viscosity""](https://github.com/climate-machine/Oceananigans.jl/blob/7fb355d77df98e37a80b3e796291fa2856d3e1ce/src/time_steppers.jl#L293). Adding other diffusive terms (hyperdiffusivity, Leith diffusivity, various turbulent diffusivity parameterizations/closures) can affect how the boundary condition is implemented. We are not ready to develop an equation abstraction system yet, but we must keep in mind the difference between *implementing* a boundary condition in the context of a set of equations, and *specifying* a boundary condition. This PR attempts to solve the latter problem. . * It would be nice to know how MITgcm implements different boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026:1859,depend,depend,1859,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026,1,['depend'],['depend']
Integrability,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:2094,interface,interface,2094,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['interface'],['interface']
Integrability,"in/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. </div></div><div class=""JobLogComponent__Footer pt2"" style=""box-sizing: border-box; display: flex; padding-top: 10px; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:6074,wrap,wrappers,6074,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['wrap'],['wrappers']
Integrability,"in` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to red",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:1052,wrap,wrapped,1052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041,1,['wrap'],['wrapped']
Integrability,"ind the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1226,interface,interface,1226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,1,['interface'],['interface']
Integrability,"ions on #1241 (and proposed as a solution there). Specifically, abstraction operations that failed to compile due to a recursive call to `identity` now compile, because we use different identity functions. The compiler doesn't complain and compiles these objects. This includes operators like `u - v + w` as demonstrated in my example. This hack doesn't allow us to execute arbitrarily complex abstract operations on the GPU. I don't think we can guarantee execution of arbitrary code in general. In this case, there are other issues that compiler might encounter that are not related to recursive calls to `identity`. We identified two additional issues on https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:1742,wrap,wrapper,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,1,['wrap'],['wrapper']
Integrability,"isn't an issue for the pressure solver, right? (Based on the fact that you got a 2D turbulence example going.) . If that's the case, then this limitation might be okay for now, as it would only affect cases we're you'd want to parallelize in `x` for efficiency purposes but you could still get away with running your set-up in a less-than-optimal configuration, no? I think this would be similar to the old limitation of being able to run `(Bounded, Periodic, Bounded)` domains only in CPUs. This was not optimal but if you wanted to circumvent this you could easily do so by rotating your domain to make it `(Periodic, Bounded, Bounded)` which _could_ be run on GPUs. Also (again correct me if I'm missing something) from my talks with you guys about this it seems that the primary goal of MPI-distributed parallelism is to run multi-GPU simulations, since GPUs have a relatively low memory limit. In this case, I think the way to use MPI is very different from the traditional multi-CPU runs. That is, I think the important capabilities when distributing a simulation across a few GPUs are different from the important capabilities when distributing it across hundreds of CPU cores. > I guess if we consider communication as a boundary conditions, then it makes sense to use Bounded in any case where halo communication is required. Then there is no need for extra topologies. In principle I completely agree with this. In principle communicating with another sub-domain is treated exactly the same as you treat BCs, right? Which is to fill the halo region accordingly. The only difference being that the proper way to fill it now depends on other processes, instead of depending on the user definitions of the BCs. . This is also true when a subdomain is, say, `Periodic` on the left and communicating on the right. Both the left and right halo regions have to filled using information outside of that particular subdomain. So I think treating that subdomain direction as `Bounded` is appropriate!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-785220748:2338,depend,depends,2338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-785220748,2,['depend'],"['depending', 'depends']"
Integrability,"ive this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple model types it makes more sense and would simplify the `Model` type by moving out output writers and diagnostics. I still think we don't need a new type and can simply define a new function like; ```julia; run_model!(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); ```; which just needs `time_step!` to be defined. > Nice work with the test cases @ali-ramadhan! No objections to merging from me, but I think we should have a discussion (in person or in a separate issue) about ways to separate aspects of the model that make it an atmosphere vs. an ocean model from things that make it a compressible vs. incompressible model. Thanks! Hmmm, that's a good point that currently the `IncompressibleModel` is really more of an `OceanModel` as evidence by the `surface_waves` functionality and the `SeawaterBuoyancy` default",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:2278,wrap,wraps,2278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['wrap'],['wraps']
Integrability,"l/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:406 [inlined]; │ [11] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:410 [inlined]; │ [12] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:419 [inlined]; │ [13] macro expansion; │ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1615,synchroniz,synchronization,1615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronization']
Integrability,"lDiffusivities/catke_vertical_diffusivity.jl:285; [2] macro expansion at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:406 [inlined]; │ [11] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:410 [inlined",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1509,synchroniz,synchronization,1509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronization']
Integrability,"las.so: symbol cublasLt_for_cublas_DDD version libcublasLt.so.11 not defined in file libcublasLt.so.11 with link time reference; ```. and. ```; Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_models.jl:197; Test threw exception; Expression: time_step_hydrostatic_model_works(grid; free_surface); CUBLASError: the GPU program failed to execute (code 13, CUBLAS_STATUS_EXECUTION_FAILED); Stacktrace:; [1] throw_api_error(res::CUDA.CUBLAS.cublasStatus_t); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:11; [2] macro expansion; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:24 [inlined]; [3] cublasDnrm2_v2(handle::Ptr{CUDA.CUBLAS.cublasContext}, n::Int64, x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, incx::Int64, result::Base.RefValue{Float64}); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/utils/call.jl:26; [4] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:168 [inlined]; [5] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:173 [inlined]; [6] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:108 [inlined]; [7] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:107 [inlined]; [8] cg_iterator!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Pl::Oceananigans.Solvers.SparseInversePreconditioner{CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}}; abstol::Float64, reltol::Float64, maxiter::Int64, statevars::IterativeSolvers.CGStateVariables{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, initially_zero::Bool); @ IterativeSolvers ~/.julia-10861/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [9] cg!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abstol::Float64, reltol::Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526:1241,wrap,wrappers,1241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526,1,['wrap'],['wrappers']
